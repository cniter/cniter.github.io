<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>矩阵的应用之图像仿射变换 | Shaun&#39;s Space</title><link rel="icon" href="/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fork-awesome/1.1.5/css/fork-awesome.min.css" integrity="sha256-P64qV9gULPHiZTdrS1nM59toStkgjM0dsf5mK/UwBV4=" crossorigin="anonymous"><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha256-ZvOgfh+ptkpoa2Y4HkRY28ir89u/+VRyDE7sB7hEEcI=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js" integrity="sha256-EPrkNjGEmCWyazb3A/Epj+W7Qm2pB9vnfXw+X6LImPM=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/gitalk/1.6.2/gitalk.min.css" integrity="sha512-rx3CPzDhA62PgmbTqj/Z/FHBR9/CrMcHtuylW9I75in7eONhEBFpcFmfjCTKwn9sFyKY1Nwbl0hM7QMbk/I3bg==" crossorigin="anonymous"><script src="//cdnjs.cloudflare.com/ajax/libs/gitalk/1.6.2/gitalk.min.js" integrity="sha512-rdP841RJYVS0QrnTWV27dz7sJL/bhNTdOlXSy5uI+chevnZyFVmtN+zq+w6njz4wMWKu9yFVTUWHTqIbUq/6Vw==" crossorigin="anonymous"></script><link rel="stylesheet" href="/css/style.css"><style>body{cursor:url(/img/cursor/normal.cur),auto}#navbar-toggler--btn,.highlight-wrap[data-lang]::before,a,button{cursor:url(/img/cursor/link.cur),auto}</style><script>const bdshareURL = "/plugins/baidushare/";</script></head><body><!--[if lt IE 9]>
        <link rel="stylesheet" href="/css/ie9.css">
        <div class="alert alert-danger topframe" role="alert">
            嘿，朋友！您的浏览器已<strong>过期</strong>，不建议继续食用。
            <a target="_blank" class="alert-link" href="http://browsehappy.com">这里</a> 有些新玩意儿，何不试试？
        </div>
    <![endif]--><header id="header"><nav id="navbar" class="navbar navbar-expand-md"><div class="container"><h1 id="site-title"><a href="/" class="navbar-brand"><img src="/img/favicon.png"> <span>Shaun&#39;s Space</span></a></h1><button id="navbar-toggler--btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar"><span><i class="fa fa-list-ul" aria-hidden="true"></i></span></button><div class="collapse navbar-collapse" id="collapsibleNavbar"><ul class="navbar-nav"><li class="nav-item"><a class="nav-link" href="/" title="首页" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-home"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives" title="所有文章" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-archive"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories" title="全部分类" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-folder"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags" title="全部标签" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-tags"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about" title="关于本站" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-user"></i> 关于</a></li></ul></div></div></nav></header><div class="container"><div class="row"><aside id="left-col" class="col-md-1"></aside><main class="col-lg-8 col-sm-12"><article id="post-矩阵的应用之图像仿射变换" class="article div-border"><header class="article-header"><span class="article-date article-title--post"><i class="fa fa-calendar" aria-hidden="true"></i> <a href="/posts/e124baa1.html"><time datetime="2018-01-20T13:21:16.000Z">2018-01-20</time></a></span><section class="article-title article-title--post"><a href="/posts/e124baa1.html">矩阵的应用之图像仿射变换</a></section><div class="article-label"><div class="article-category label"><i class="fa fa-book" aria-hidden="true"></i> <a class="color4 article-category-link" href="/categories/Image-Graphic/">Image&Graphic</a></div><div class="article-tag label"><i class="fa fa-bookmark" aria-hidden="true"></i> <a class="color4 article-tag-link" href="/tags/algorithm/">algorithm</a><a class="color4 article-tag-link" href="/tags/matlab/">matlab</a><a class="color4 article-tag-link" href="/tags/opencv/">opencv</a></div></div></header><section class="article-content"><h2 id="前言">前言</h2><p>　　好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，Shaun 这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。</p><a id="more"></a><h2 id="预备篇">预备篇</h2><p>　　首先需要了解的是图像中坐标系和数学课本中常用的坐标系略有不同，图像中坐标系是以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴；而数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴。所以由图像中坐标 <span class="math inline">\((x,y)\)</span> 转数学课本中常见的坐标 <span class="math inline">\((x&#39;,y&#39;)\)</span> 的公式为 $x’ = x - C/2; y’ = -y + R/2; $ 其中 <span class="math inline">\(C\)</span> 表示原图像总列数，即原图像宽度，<span class="math inline">\(R\)</span> 表示原图像总行数，即原图像高度。</p><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="346px" height="160px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="62" x2="125" y2="62" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="75" y1="100" x2="75" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="126" y="56" fill="blue">X 轴</text><text x="75" y="20" fill="blue">Y 轴</text><line x1="210" y1="25" x2="310" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="210" y1="25" x2="210" y2="100" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="310" y="42" fill="blue">X 轴</text><text x="215" y="110" fill="blue">Y 轴</text><text x="40" y="150" fill="blue">数学坐标系</text><text x="240" y="150" fill="blue">图像坐标系</text></svg></div><p>　　<font color="#FA8072"><strong>※注：</strong>值得注意的是因为 MATLAB 和 OpenCV 的像素索引坐标形式为 <strong><em>(行坐标，列坐标)</em></strong> ，所以若以本文这样定的图像坐标，则图像中坐标 <span class="math inline">\((x,y)\)</span> 对应的像素值为 <span class="math inline">\(f(y,x)\)</span>。</font></p><h2 id="变换篇">变换篇</h2><p>据 OpenCV 文档所说：</p><blockquote><ol type="1"><li><p>一个任意的仿射变换都能表示为 <em>乘以一个矩阵</em> (线性变换) 接着再 <em>加上一个向量</em> (平移).</p></li><li><p>综上所述, 我们能够用仿射变换来表示:</p><ol type="1"><li>旋转 (线性变换)</li><li>平移 (向量加)</li><li>缩放操作 (线性变换)</li></ol><p>你现在可以知道, 事实上, 仿射变换代表的是两幅图之间的 <strong>关系</strong> .</p></li><li><p>我们通常使用 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/a832b76c4f4a4ec13ac1b557da4fed6006e64d00.png" alt="2 3"> 矩阵来表示仿射变换.</p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/c3fdaa7031379552454b333ff916cd1987107b5c.png" alt="A = -begin{bmatrix} a_{00} &amp; a_{01} \ a_{10} &amp; a_{11} -end{bmatrix}_{2 2} B = \begin{bmatrix} b_{00} \ b_{10} \end{bmatrix}_{2 1} M = -begin{bmatrix} A &amp; B -end{bmatrix} =-begin{bmatrix} a_{00} &amp; a_{01} &amp; b_{00} \ a_{10} &amp; a_{11} &amp; b_{10}-end{bmatrix}_{2 3}">　　</p><p>考虑到我们要使用矩阵 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"> 和 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B"> 对二维向量 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/22671b2dfac15c46b634f068e4ccd644551abd8a.png" alt="X = \begin-{bmatrix}x \ y\end-{bmatrix}"> 做变换, 所以也能表示为下列形式:</p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/7b0b4b830b85f222266aa9c8fc76e1a7ce998c42.png" alt="T = A \begin-{bmatrix}x \ y\end-{bmatrix} + B"> or <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/f44f98e19b4ee0613633b70414a47259846b2d27.png" alt="T = M ^{T}"></p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/3295a3e90f963d7a35c1cd910b9258cd92761a8f.png" alt="T=\begin-{bmatrix}a_{00}x + a_{01}y + b_{00} \ a_{10}x + a_{11}y + b_{10}\end-{bmatrix}">　　</p></li></ol></blockquote><p>而在冈萨雷斯的《数字图像处理_第三版》里有：</p><blockquote><p>最常用的空间坐标变换之一是仿射变换，其一般形式如下： <span class="math display">\[ \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \textbf{T} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \begin{bmatrix} t_{11} &amp; t_{12} &amp; 0 \\ t_{21} &amp; t_{22} &amp; 0 \\ t_{31} &amp; t_{32} &amp; 1 \end{bmatrix} \]</span> 其中 <span class="math inline">\((v,w)\)</span> 为原坐标，<span class="math inline">\((x,y)\)</span> 为变换后的坐标，可根据变换矩阵 <span class="math inline">\(\textbf{T}\)</span> 中的元素选择的值，对一组坐标点做尺度、旋转、平移或偏移变换。一些常见的变换矩阵及作用如下表：</p><table><colgroup><col style="width:16%"><col style="width:41%"><col style="width:41%"></colgroup><thead><tr class="header"><th style="text-align:center">变换名称</th><th style="text-align:center">仿射变换矩阵<span class="math inline">\(\textbf{T}\)</span></th><th style="text-align:center">坐标公式</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><strong>恒等变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v , \\ y=w \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>尺度变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vc_x , \\ y=wc_y \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>旋转变换</strong>（以逆时针为正）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} cos(\theta) &amp; sin(\theta) &amp; 0 \\ -sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vcos(\theta)-wsin(\theta) , \\ y=vsin(\theta)+wcos(\theta) \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>旋转变换</strong>（以顺时针为正）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vcos(\theta)+wsin(\theta) , \\ y=-vsin(\theta)+wcos(\theta) \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>平移变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v+t_x , \\ y=w+t_y \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>偏移变换</strong>（水平）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_h &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v+ws_h , \\ y=w \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>偏移变换</strong>（垂直）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; s_v &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v , \\ y=vs_v+w \end{cases}\)</span></td></tr></tbody></table><p>仿射变换的实现由两种方式：一种是 <strong><em>前向映射（Forward Mapping）</em></strong>：直接采用利用原图像坐标 <span class="math inline">\((v,w)\)</span> 通过 <span class="math inline">\(\begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}\)</span> 得到变换后的坐标 <span class="math inline">\((x,y)\)</span>，使用前向映射会导致一些问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的花纹状）；更好的一种方式是采用 <strong><em>反向映射（Inverse Mapping）</em></strong>：扫描输出图像的位置 <span class="math inline">\((x,y)\)</span>，通过 <span class="math inline">\(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)</span>（其中 <span class="math inline">\(\textbf{T}^{-1}\)</span> 为 <span class="math inline">\(\textbf{T}\)</span> 的逆矩阵）计算输入图像对应的位置 <span class="math inline">\((v,w)\)</span>，通过插值方法决定输出图像该位置的灰度值。</p></blockquote><p>　　<strong>本文这里采取冈萨雷斯的《数字图像处理_第三版》的变换矩阵方式</strong>，毕竟所学的矩阵论也是将变换矩阵放在后面作为第二个因子。虽然仿射变换都有现成的 API 可以调用，而且速度一般要比自己写的要快，但是知其然终究也要知其所以然。</p><p>　　<strong>下面就以旋转变换为例了</strong>，因为尺度变换和平移变换只需要相应的缩放图像即可，而旋转变换不仅需要更改图像大小，还要确定旋转中心，而旋转中心一般以图像中心为标准。</p><h3 id="旋转变换">旋转变换</h3><p>　　旋转变换首先需要确定旋转中心，若以图像左上角为旋转中心，则只需要像做尺度变换和平移变换那样通过 <span class="math inline">\(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)</span> 做普通的变换即可。而以图像中心为旋转中心，首先需要做坐标变换，将以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴的图像坐标系转换为以图像中心为原点，水平向右为 X 轴，垂直向下为 Y 轴的数学坐标系；再做正常的旋转变换；随后再将数学坐标系转换为图像坐标系，所以图像中心为旋转中心的旋转变换总共需要做三次变换。这里就以图像中心为旋转中心为例，由于有三次变换，所以应该有三个变换矩阵相乘，设 图像坐标系==》数学坐标系的变换矩阵为 T1，旋转变换矩阵为 T2，数学坐标系==》图像坐标系的变换矩阵为 T3，设顺时针旋转角度为 <span class="math inline">\(\theta\)</span> ，原图像宽度为 <span class="math inline">\(C\)</span>，高度为 <span class="math inline">\(R\)</span>，旋转后图像宽度为 <span class="math inline">\(W\)</span>，高度为 <span class="math inline">\(H\)</span>，则： <span class="math display">\[ T1=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ -0.5C &amp; 0.5R &amp; 1 \end{bmatrix}　　 T2=\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}　　 T3=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0.5W &amp; 0.5H &amp; 1 \end{bmatrix} \]</span> 则旋转变换最终形式为：<span class="math inline">\(\begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}=\begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix}T1*T2*T3\)</span>。</p><p><strong><em>※BTW：</em></strong>旋转变换中，旋转后图像宽度 <span class="math inline">\(W\)</span>，高度 <span class="math inline">\(H\)</span> 与 原图像宽度 <span class="math inline">\(C\)</span>，高度 <span class="math inline">\(R\)</span> 的关系为： <span class="math display">\[ \begin{cases} H = |R*cos(\theta)| + |C*sin(\theta)| , \\ W = |C*cos(\theta)| + |R*sin(\theta)| \end{cases} \]</span></p><h2 id="插值篇">插值篇</h2><p>　　因为经过采用<strong>反向映射</strong><font color="#00f"><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></font>方式的仿射变换之后，得到的原图像坐标 <span class="math inline">\((v,w)\)</span> 往往不是整数值，所以无法知道其对应的像素值 <span class="math inline">\(f(w,v)\)</span>，这时需要采取插值的方式近似估计该坐标位置的像素值。</p><p>　　常用的插值方法有最近邻插值（nearest neighbor interpolation）、双线性插值（bilinear interpolation）和双三次插值（bicubic interpolation），其中双三次插值在保持图像细节方面最好，但花费时间也最多，PS 中的消除锯齿和羽化效果好像就采用了双三次插值。</p><p>　　最近邻插值只考虑相邻最近的像素，双线性插值考虑相邻的 4 个像素点，双三次插值则考虑相邻的 16 个像素点。</p><h3 id="最近邻插值">最近邻插值</h3><p>　　最近邻插值最简单，将变换后图像的坐标 <span class="math inline">\((x,y)\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)\)</span> ，直接对 <span class="math inline">\((v,w)\)</span> 进行四舍五入得到相应的整数坐标 <span class="math inline">\((⌊v+0.5⌋,⌊w+0.5⌋)\)</span><font color="#00f"><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></font>，用该整数坐标的像素值近似估计 <span class="math inline">\((v,w)\)</span> 的像素值，令 <span class="math inline">\(f(y,x)=f(⌊w+0.5⌋,⌊v+0.5⌋)\)</span> ，从而得到变换后图像每个像素点的像素值。</p><h3 id="双线性插值">双线性插值</h3><p>　　双线性插值是线性插值方法的一种扩展，它是 X 和 Y 两个方向上线性插值的组合。</p><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="270px" height="230px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="25" x2="225" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="25" y1="25" x2="25" y2="200" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="230" y="42" fill="blue">X 轴</text><text x="30" y="210" fill="blue">Y 轴</text><circle cx="60" cy="60" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="160" cy="60" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="160" cy="160" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="60" cy="160" r="3" stroke="black" stroke-width="1" fill="red"/><text x="36" y="70" fill="blue">P1</text><text x="170" y="70" fill="blue">P2</text><text x="170" y="170" fill="blue">P3</text><text x="36" y="170" fill="blue">P4</text><circle cx="100" cy="60" r="3" stroke="black" stroke-width="1" fill="blue"/><circle cx="100" cy="160" r="3" stroke="black" stroke-width="1" fill="blue"/><text x="110" y="70" fill="blue">Z1</text><text x="110" y="170" fill="blue">Z2</text><circle cx="100" cy="100" r="3" stroke="black" stroke-width="1" fill="green"/><text x="110" y="110" fill="blue">P(v,w)</text><line x1="100" y1="25" x2="100" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="100" x2="100" y2="100" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="60" y1="25" x2="60" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="160" y1="25" x2="160" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="60" x2="160" y2="60" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="160" x2="160" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/></svg></div><p>如上图，设变换后图像的坐标 <span class="math inline">\((x,y)\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)\)</span> ，即点 <span class="math inline">\(P\)</span> 正好处于四个像素点 <span class="math inline">\(P1(v_0, w_0)\)</span>、<span class="math inline">\(P2(v_0+1, w_0)\)</span>、<span class="math inline">\(P3(v_0+1, w_0+1)\)</span>、<span class="math inline">\(P4(v_0, w_0+1)\)</span> 的中间，其中 <span class="math inline">\(v_0=⌊v⌋\)</span>，<span class="math inline">\(w_0=⌊w⌋\)</span> ，点 <span class="math inline">\(P\)</span> 对应的像素值为 <span class="math inline">\(f(P)\)</span> 因为双线性插值即在 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 两个方向进行线性插值，首先计算 <span class="math inline">\(X\)</span> 方向的插值： <span class="math display">\[ \begin{cases} \frac{f(P2)-f(P1)}{P2.x-P1.x}=\frac{f(Z1)-f(P1)}{Z1.x-P1.x} , \\ \frac{f(P3)-f(P4)}{P3.x-P4.x}=\frac{f(Z2)-f(P4)}{Z2.x-P4.x} \end{cases} \]</span> 即： <span class="math display">\[ \begin{cases} f(Z1)=\frac{Z1.x-P1.x}{P2.x-P1.x}f(P2)+\frac{P2.x-Z1.x}{P2.x-P1.x}f(P1) =(v-v_0)f(P2)+(v_0+1-v)f(P1), \\ f(Z2)=\frac{Z2.x-P4.x}{P3.x-P4.x}f(P3)+\frac{P3.x-Z2.x}{P3.x-P4.x}f(P4) =(v-v_0)f(P3)+(v_0+1-v)f(P4) \end{cases}\tag{1} \]</span> 然后计算 <span class="math inline">\(Y\)</span> 方向的插值： <span class="math display">\[ \begin{equation} \frac{f(Z2)-f(Z1)}{Z2.y-Z1.y}=\frac{f(P)-f(Z1)}{P.y-Z1.y} \end{equation} \]</span> 即： <span class="math display">\[ \begin{equation} f(P)=\frac{P.y-Z1.y}{Z2.y-Z1.y}f(Z2)+\frac{Z2.y-P.y}{Z2.y-Z1.y}f(Z1) =(w-w_0)f(Z2)+(w_0+1-w)f(Z1) \end{equation}\tag{2} \]</span> 结合式（1）和式（2）可得： <span class="math display">\[ \begin{equation} f(P)=(v_0+1-v)(w_0+1-w)f(P1)+(v-v_0)(w_0+1-w)f(P2)+(v-v_0)(w-w_0)f(P3)+(v_0+1-v)(w-w_0)f(P4) \end{equation} \]</span> 用矩阵形式可表示为： <span class="math display">\[ f(P)=\begin{bmatrix} v_0+1-v &amp; v-v_0 \end{bmatrix} \begin{bmatrix} f(P1) &amp; f(P4) \\ f(P2) &amp; f(P3) \end{bmatrix} \begin{bmatrix} (w_0+1-w) \\ (w-w_0) \end{bmatrix} \]</span> 即： <span class="math display">\[ f(y,x)=f(w,v)=\begin{bmatrix} ⌊v⌋+1-v &amp; v-⌊v⌋ \end{bmatrix} \begin{bmatrix} f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) \\ f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) \end{bmatrix} \begin{bmatrix} (⌊w⌋+1-w) \\ (w-⌊w⌋) \end{bmatrix} \]</span></p><h3 id="双三次插值">双三次插值</h3><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="270px" height="230px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="25" x2="225" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="25" y1="25" x2="25" y2="200" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="230" y="42" fill="blue">X 轴</text><text x="30" y="210" fill="blue">Y 轴</text><line x1="55" y1="25" x2="55" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="85" y1="25" x2="85" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="115" y1="25" x2="115" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="145" y1="25" x2="145" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="175" y1="25" x2="175" y2="176" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="55" x2="175" y2="55" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="85" x2="175" y2="85" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="115" x2="175" y2="115" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="145" x2="175" y2="145" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="175" x2="176" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><circle cx="55" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><text x="77" y="85" fill="blue">P11</text><circle cx="100" cy="100" r="3" stroke="black" stroke-width="1" fill="green"/><text x="110" y="110" fill="blue">P(v,w)</text></svg></div><p>　　如上图，双三次插值需要考虑相邻16个像素（4×4），用双三次插值重采样的图像更平滑并且更能保留图像细节，在这三种插值算法中，双三次插值效果最好，但处理速度最慢。同样设变换后图像的坐标 <span class="math inline">\((x,y)​\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)​\)</span> ，与其左上角相邻最近的 点P11 坐标则为 <span class="math inline">\((⌊v⌋,⌊w⌋)​\)</span> ，该插值方法需要选取一个合适的插值基函数，参照维基百科 <strong>Bicubic interpolation</strong> 的一般为： <span class="math display">\[ W(x) = \begin{cases} (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{for } |x| \leq 1, \\ a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{for } 1 &lt; |x| &lt; 2, \\ 0 &amp; \text{otherwise}, \end{cases} \]</span> 其中 <span class="math inline">\(a\)</span> 一般取 -0.5 、-0.75 或 -1；则：<span class="math inline">\(f(y,x)=f(w,v)=A*B*C\)</span> ，其中： <span class="math display">\[ A=\begin{bmatrix} W( v-(⌊v⌋-1) ) &amp; W(v-⌊v⌋) &amp; W( (⌊v⌋+1)-v ) &amp; W( (⌊v⌋+2)-v ) \end{bmatrix} \\ B=\begin{bmatrix} f(⌊w⌋-1,⌊v⌋-1) &amp; f(⌊w⌋,⌊v⌋-1) &amp; f(⌊w⌋+1,⌊v⌋-1) &amp; f(⌊w⌋+2,⌊v⌋-1) \\ f(⌊w⌋-1,⌊v⌋) &amp; f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) &amp; f(⌊w⌋+2,⌊v⌋) \\ f(⌊w⌋-1,⌊v⌋+1) &amp; f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) &amp; f(⌊w⌋+2,⌊v⌋+1) \\ f(⌊w⌋-1,⌊v⌋+2) &amp; f(⌊w⌋,⌊v⌋+2) &amp; f(⌊w⌋+1,⌊v⌋+2) &amp; f(⌊w⌋+2,⌊v⌋+2) \end{bmatrix} \\ C=\begin{bmatrix} W( w-(⌊w⌋-1) ) \\ W(w-⌊w⌋) \\ W( (⌊w⌋+1)-w ) \\ W( (⌊w⌋+2)-w ) \end{bmatrix} \]</span></p><p>即： <span class="math display">\[ f(y,x)=f(w,v)= \sum\limits_{row=-1}^2\sum\limits_{col=-1}^2f(⌊w⌋+row,⌊v⌋+col)W(row-(w-⌊w⌋))W(col-(v-⌊v⌋)) \]</span> <strong>另附：</strong>网上也有人中间那个矩阵 <span class="math inline">\(B\)</span> 是本文中间矩阵 <span class="math inline">\(B\)</span> 的转置，经过下文实践，感觉效果差不多，但从理论上来说，应该本文这样写才是对的吧🤔。</p><h2 id="实践篇">实践篇</h2><p>　　本次实践采用 Matlab R2016b，具体 matlab 实现代码为：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="MATLAB"><figure class="highlight hljs matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">clc;clear;close all;</div><div class="line"></div><div class="line">img = imread(<span class="string">'lena_gray.jpg'</span>); <span class="comment">% 读取图像</span></div><div class="line">[R, C] = <span class="built_in">size</span>(img); <span class="comment">% 获取图像大小</span></div><div class="line"></div><div class="line">theta = <span class="number">45</span> * <span class="built_in">pi</span> / <span class="number">180.0</span>; <span class="comment">% 旋转角度</span></div><div class="line">H = <span class="built_in">ceil</span>(<span class="built_in">abs</span>(R*<span class="built_in">cos</span>(theta)) + <span class="built_in">abs</span>(C*<span class="built_in">sin</span>(theta)));    <span class="comment">% 变换后图像的高度</span></div><div class="line">W = <span class="built_in">ceil</span>(<span class="built_in">abs</span>(C*<span class="built_in">cos</span>(theta)) + <span class="built_in">abs</span>(R*<span class="built_in">sin</span>(theta)));    <span class="comment">% 变换后图像的宽度</span></div><div class="line">res = <span class="built_in">zeros</span>(H, W);   <span class="comment">% 构造结果矩阵。每个像素点默认初始化为0（黑色）</span></div><div class="line"></div><div class="line">T1 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>; <span class="number">-0.5</span>*C <span class="number">0.5</span>*R <span class="number">1</span>];   <span class="comment">% 将原图像坐标映射到数学笛卡尔坐标</span></div><div class="line">T2 = [cos(theta) -sin(theta) <span class="number">0</span>; sin(theta) cos(theta) <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];    <span class="comment">% 数学笛卡尔坐标下顺时针旋转的变换矩阵</span></div><div class="line">T3 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>; <span class="number">0.5</span>*W <span class="number">0.5</span>*H <span class="number">1</span>];    <span class="comment">% 将数学笛卡尔坐标映射到旋转后的图像坐标</span></div><div class="line">T = T1*T2*T3;</div><div class="line">inv_T = inv(T);    <span class="comment">% 求逆矩阵</span></div><div class="line"><span class="comment">% inv_T = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; -0.5*W*cos(theta)-0.5*H*sin(theta)+0.5*C 0.5*W*sin(theta)-0.5*H*cos(theta)+0.5*R 1];</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> y = <span class="number">1</span> : H   <span class="comment">% 变换后图像的纵坐标，行，高</span></div><div class="line">    <span class="keyword">for</span> x = <span class="number">1</span> : W   <span class="comment">% 变换后图像的横坐标，列，宽</span></div><div class="line">        original_coordinate = [x y <span class="number">1</span>] * inv_T; <span class="comment">% 矩阵乘法</span></div><div class="line">        v = original_coordinate(<span class="number">1</span>);    <span class="comment">% 原图像的横坐标，列，宽</span></div><div class="line">        w = original_coordinate(<span class="number">2</span>);    <span class="comment">% 原图像的纵坐标，行，高</span></div><div class="line">        <span class="comment">% 变换后的位置判断是否越界</span></div><div class="line">        <span class="keyword">if</span> v&gt;=<span class="number">1</span> &amp;&amp; w&gt;=<span class="number">1</span> &amp;&amp; v&lt;=C &amp;&amp; w&lt;=R</div><div class="line">            res(y, x) = img(<span class="built_in">round</span>(w), <span class="built_in">round</span>(v));  <span class="comment">% 用原图像对应坐标的像素值填充变换后的图像（最邻近插值）</span></div><div class="line">            </div><div class="line">            <span class="comment">% ------------- 双线性插值（bilinear interpolation）-----------------</span></div><div class="line">            left = <span class="built_in">floor</span>(v); right = <span class="built_in">ceil</span>(v); top = <span class="built_in">floor</span>(w); bottom = <span class="built_in">ceil</span>(w);</div><div class="line">            dC = v-left;   <span class="comment">% 列偏差</span></div><div class="line">            dR = w-top;    <span class="comment">% 行偏差</span></div><div class="line">            res(y, x) = (<span class="number">1</span>-dC)*(<span class="number">1</span>-dR)*img(top, left) + dC*(<span class="number">1</span>-dR)*img(top,right) + (<span class="number">1</span>-dC)*dR*img(bottom, left) + dC*dR*img(bottom, right); </div><div class="line">            </div><div class="line">            <span class="comment">% ------------- 双三次插值（bicubic interpolation） -------------------------</span></div><div class="line">        <span class="keyword">if</span> left&gt;=<span class="number">2</span> &amp;&amp; top&gt;=<span class="number">2</span> &amp;&amp; left&lt;=(C<span class="number">-2</span>) &amp;&amp; top&lt;=(R<span class="number">-2</span>)</div><div class="line">            img = double(img);</div><div class="line">            MA = [bicubic(<span class="number">1</span>+dC) bicubic(dC) bicubic(<span class="number">1</span>-dC) bicubic(<span class="number">2</span>-dC)];</div><div class="line">            MB = [img(top<span class="number">-1</span>,left<span class="number">-1</span>) img(top,left<span class="number">-1</span>) img(top+<span class="number">1</span>,left<span class="number">-1</span>) img(top+<span class="number">2</span>,left<span class="number">-1</span>);</div><div class="line">                 img(top<span class="number">-1</span>,left) img(top,left) img(top+<span class="number">1</span>,left) img(top+<span class="number">2</span>,left);</div><div class="line">                 img(top<span class="number">-1</span>,left+<span class="number">1</span>) img(top,left+<span class="number">1</span>) img(top+<span class="number">1</span>,left+<span class="number">1</span>) img(top+<span class="number">2</span>,left+<span class="number">1</span>);</div><div class="line">                 img(top<span class="number">-1</span>,left+<span class="number">2</span>) img(top,left+<span class="number">2</span>) img(top+<span class="number">1</span>,left+<span class="number">2</span>) img(top+<span class="number">2</span>,left+<span class="number">2</span>)];</div><div class="line">            <span class="comment">% MB = MB';    % 求转置矩阵</span></div><div class="line">            MC = [bicubic(<span class="number">1</span>+dR); bicubic(dR); bicubic(<span class="number">1</span>-dR); bicubic(<span class="number">2</span>-dR)];</div><div class="line">            res(y, x) = MA*MB*MC;</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>;</div><div class="line"></div><div class="line">figure, imshow(uint8(res)); <span class="comment">% 显示图像</span></div></pre></td></tr></table></figure></div><p>BiCubic 基函数 Matlab 代码为：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="MATLAB"><figure class="highlight hljs matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">W</span> = <span class="title">bicubic</span><span class="params">(x)</span></span></div><div class="line"><span class="comment">%bicubic 双三次插值基函数</span></div><div class="line">a = <span class="number">-1</span>; <span class="comment">% 默认取a为-1</span></div><div class="line">x1 = <span class="built_in">abs</span>(x);</div><div class="line">x2 = x1*x1;</div><div class="line">x3 = x1*x2; </div><div class="line"></div><div class="line"><span class="keyword">if</span> x1 &lt;= <span class="number">1</span></div><div class="line">   W = <span class="number">1</span> - (a+<span class="number">3</span>)*x2 + (a+<span class="number">2</span>)*x3;</div><div class="line"><span class="keyword">elseif</span> x1&gt;<span class="number">1</span> &amp;&amp; x1&lt;=<span class="number">2</span></div><div class="line">   W = <span class="number">-4</span>*a + <span class="number">8</span>*a*x1 - <span class="number">5</span>*a*x2 + a*x3;</div><div class="line"><span class="keyword">else</span> </div><div class="line">   W = <span class="number">0</span>;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></div><p>　　旋转变换中感觉插值的作用没体现出来，以肉眼来看感觉三种插值方法的效果差不多，可能是 Shaun 选取的示例不好，为了体现插值效果，应该采用尺度变换（缩放变换）的。以上代码改为尺度变换也简单，自定义图像缩放后的宽高，以两倍为例，<code>H = R * 2; W = C * 2;</code>，再将旋转变换矩阵改为尺度变换矩阵，尺度变换矩阵中 <span class="math inline">\(c_x=W/C；c_y=H/R\)</span>。</p><p>为了便于理解，Shaun 对代码就不进行优化了（其实是你懒吧 _(:з」∠)_）。</p><h2 id="后记">后记</h2><p>　　本文算是数字图像处理中最基础的知识了，但 Shaun 在写时还是查阅了大量相关的资料，有些地方理解的还不是很透彻，行文思路有点混乱 ╮(╯▽╰)╭。本来是不想使用图片的，但本文不用图片很难理解清楚，又为了不使用外部图，最后只得参考 <a href="http://www.runoob.com/svg/svg-tutorial.html" target="_blank" rel="external">SVG 教程</a> 和 <a href="https://www.w3cplus.com/svg/svg-markers.html" target="_blank" rel="external">如何创建SVG箭头和polymarker——<code>marker</code>元素</a> 采用 SVG 绘制相应图片了。等有时间再把用 OpenCV 实现的 C++ 代码也贴上吧。最后再感叹一下 Matlab 确实是做科研的好工具（°Д°）Ъ，<del>吐槽一下 <em>MathJax</em> 排版好痛苦啊，太多需要转义符<code>\</code>的地方了吧。</del>，搞错了 Σ(ﾟдﾟ;)，这主要和 markdown 渲染有关，hexo 默认的 markdown 渲染插件 hexo-renderer-marked 太普通了，有些东西根本没办法渲染或者渲染有问题 （╯‵□′）╯︵┴─┴，Shaun 最后决定使用 hexo-renderer-pandoc 插件渲染 markdown，这样就完美了 (๑•̀ㅂ•́)و✧ 。</p><p>　　至于具体怎么使用 hexo-renderer-pandoc 替换默认的渲染器可参考：<a href="https://www.v2ex.com/t/410080" target="_blank" rel="external">如何禁止 hexo 在 html 代码里插入&lt;br&gt;标签?</a>。具体如下：</p><blockquote><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="BASH"><figure class="highlight hljs bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 1、安装 Pandoc，可以不顺带安装 MiKTex</span></div><div class="line"><span class="comment"># 2、卸载默认渲染器</span></div><div class="line">npm uninstall hexo-renderer-marked --save</div><div class="line"><span class="comment"># 3、安装 hexo-renderer-pandoc</span></div><div class="line">npm install hexo-renderer-pandoc --save</div></pre></td></tr></table></figure></div></blockquote><h2 id="附录">附录</h2><p>　　挖的坑总是要填的，呐，这就是用 OpenCV 实现的旋转变换，实现语言为 C++ ：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI       3.14159265358979323846</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">bicubic</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// bicubic 双三次插值基函数</span></div><div class="line">	<span class="keyword">int</span> a = <span class="number">-1</span>;	<span class="comment">// 默认取a为 - 1</span></div><div class="line">	<span class="keyword">double</span> x1 = <span class="built_in">fabs</span>(x);</div><div class="line">	<span class="keyword">double</span> x2 = x1*x1;</div><div class="line">	<span class="keyword">double</span> x3 = x1*x2;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (x1 &lt;= <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span> - (a + <span class="number">3</span>)*x2 + (a + <span class="number">2</span>)*x3;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x1 &gt; <span class="number">1</span> &amp;&amp; x1 &lt;= <span class="number">2</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-4</span> * a + <span class="number">8</span> * a*x1 - <span class="number">5</span> * a*x2 + a*x3;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat img = cv::imread(<span class="string">"../Data/lena_gray.jpg"</span>, <span class="number">0</span>);	<span class="comment">// 以灰度模式读取图片</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> R = img.rows;	<span class="comment">// 获取原图像高度</span></div><div class="line">	<span class="keyword">int</span> C = img.cols;	<span class="comment">// 获取原图像宽度</span></div><div class="line"></div><div class="line">	<span class="keyword">double</span> theta = <span class="number">45</span> * M_PI / <span class="number">180.0</span>;	<span class="comment">// 旋转角度</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> H = <span class="built_in">ceil</span>(<span class="built_in">fabs</span>(R*<span class="built_in">cos</span>(theta)) + <span class="built_in">fabs</span>(C*<span class="built_in">sin</span>(theta)));	<span class="comment">// 变换后图像的高度</span></div><div class="line">	<span class="keyword">int</span> W = <span class="built_in">ceil</span>(<span class="built_in">fabs</span>(C*<span class="built_in">cos</span>(theta)) + <span class="built_in">fabs</span>(R*<span class="built_in">sin</span>(theta)));	<span class="comment">// 变换后图像的宽度</span></div><div class="line"></div><div class="line">	cv::Mat res = cv::Mat::zeros(H, W, CV_8UC1);	<span class="comment">// 构造结果矩阵。每个像素点默认初始化为0（黑色）	</span></div><div class="line"></div><div class="line">	cv::Mat T1 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-0.5</span>*C, <span class="number">0.5</span>*R, <span class="number">1</span>);	<span class="comment">// 将原图像坐标映射到数学笛卡尔坐标</span></div><div class="line">	cv::Mat T2 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">cos</span>(theta), -<span class="built_in">sin</span>(theta), <span class="number">0</span>, <span class="built_in">sin</span>(theta), <span class="built_in">cos</span>(theta), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 数学笛卡尔坐标下顺时针旋转的变换矩阵</span></div><div class="line">	<span class="keyword">double</span> t3[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0.5</span>*W, <span class="number">0.5</span>*H, <span class="number">1</span> &#125; &#125;;	<span class="comment">// 将数学笛卡尔坐标映射到旋转后的图像坐标</span></div><div class="line">	cv::Mat T3 = cv::Mat(<span class="number">3</span>, <span class="number">3</span>, CV_64FC1, t3);</div><div class="line">	cv::Mat T = T1*T2*T3;</div><div class="line">	cv::Mat inv_T = T.inv();	<span class="comment">// 求逆矩阵</span></div><div class="line">	<span class="comment">//cv::Mat inv_T = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, -0.5*W*cos(theta) - 0.5*H*sin(theta) + 0.5*C, 0.5*W*sin(theta) - 0.5*H*cos(theta) + 0.5*R, 1);</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; H; y++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; W; x++)</div><div class="line">		&#123;</div><div class="line">			cv::Mat point = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; x, y, <span class="number">1</span>);</div><div class="line">			cv::Mat original_coordinate = point * inv_T;	<span class="comment">// 矩阵乘法</span></div><div class="line">			<span class="keyword">double</span> v = original_coordinate.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);	<span class="comment">// 原图像的横坐标，列，宽</span></div><div class="line">			<span class="keyword">double</span> w = original_coordinate.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 原图像的纵坐标，行，高</span></div><div class="line"></div><div class="line">			<span class="comment">// 变换后的位置判断是否越界</span></div><div class="line">			<span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; w &gt;= <span class="number">0</span> &amp;&amp; v &lt;= C - <span class="number">1</span> &amp;&amp; w &lt;= R - <span class="number">1</span>)</div><div class="line">			&#123;</div><div class="line">				res.at&lt;uchar&gt;(y, x) = img.at&lt;uchar&gt;(round(w), round(v));	<span class="comment">// 用原图像对应坐标的像素值填充变换后的图像（最邻近插值）</span></div><div class="line">				</div><div class="line">				<span class="comment">// ------------ - 双线性插值（bilinear interpolation）---------------- -</span></div><div class="line">				<span class="keyword">int</span> left = <span class="built_in">floor</span>(v), right = <span class="built_in">ceil</span>(v), top = <span class="built_in">floor</span>(w), bottom = <span class="built_in">ceil</span>(w);</div><div class="line">				<span class="keyword">double</span> dC = v - left;	<span class="comment">// 列偏差</span></div><div class="line">				<span class="keyword">double</span> dR = w - top;	<span class="comment">// 行偏差</span></div><div class="line">				res.at&lt;uchar&gt;(y, x) = (<span class="number">1</span> - dC)*(<span class="number">1</span> - dR)*img.at&lt;uchar&gt;(top, left) + dC*(<span class="number">1</span> - dR)*img.at&lt;uchar&gt;(top, right) + (<span class="number">1</span> - dC)*dR*img.at&lt;uchar&gt;(bottom, left) + dC*dR*img.at&lt;uchar&gt;(bottom, right);</div><div class="line">			</div><div class="line">				<span class="comment">// ------------ - 双三次插值（bicubic interpolation）------------------------ -</span></div><div class="line">				<span class="keyword">if</span> (left &gt;= <span class="number">1</span> &amp;&amp; top &gt;= <span class="number">1</span> &amp;&amp; left &lt;= (C - <span class="number">3</span>) &amp;&amp; top &lt;= (R - <span class="number">3</span>))</div><div class="line">				&#123;</div><div class="line">					cv::Mat MA = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; bicubic(<span class="number">1</span> + dC), bicubic(dC), bicubic(<span class="number">1</span> - dC), bicubic(<span class="number">2</span> - dC));</div><div class="line">					cv::Mat MB = img(cv::Rect(left - <span class="number">1</span>, top - <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>));	<span class="comment">// 提取当前相邻区域16个像素点做插值</span></div><div class="line">					MB.convertTo(MB, CV_64FC1);	<span class="comment">// 变换为浮点型数据</span></div><div class="line">					MB = MB.t();	<span class="comment">// 求转置矩阵</span></div><div class="line">					cv::Mat MC = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">1</span>) &lt;&lt; bicubic(<span class="number">1</span> + dR), bicubic(dR), bicubic(<span class="number">1</span> - dR), bicubic(<span class="number">2</span> - dR));</div><div class="line">					cv::Mat result = MA*MB*MC;</div><div class="line">					res.at&lt;uchar&gt;(y, x) = <span class="keyword">static_cast</span>&lt;uchar&gt;(result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cv::imshow(<span class="string">"result"</span>, res);	<span class="comment">// 显示变换后图像</span></div><div class="line">	cv::waitKey(<span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></div><p>　　以上 C++ 代码在 VS2013 下能完美运行，不管是用 OpenCV-2.4.11 还是 OpenCV-3.2.0。其实完全理解的话，不管用什么工具都能实现，只是看哪个工具方便一点而已，就这个而言，感觉 Matlab 要方便很多，Shaun 就不继续挖 Python 的坑了，毕竟如果要用 Python 实现其实还是用 OpenCV，只是用 OpenCV Python 版的接口而已。</p><h2 id="参考资料">参考资料</h2><p>[１] <a href="https://wenku.baidu.com/view/e94cfa2d336c1eb91a375dab.html" target="_blank" rel="external">第4章 图像几何变换</a></p><p>[２] <a href="http://blog.csdn.net/lkj345/article/details/50555870" target="_blank" rel="external">图像旋转原理及实现</a></p><p>[３] <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/warp_affine/warp_affine.html#warp-affine" target="_blank" rel="external">仿射变换</a>（<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" class="uri" target="_blank" rel="external">http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html</a>）</p><p>[４] <a href="http://blog.csdn.net/augusdi/article/details/9028365" target="_blank" rel="external">图像处理常用插值方法总结</a></p><p>[５] <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation" target="_blank" rel="external"><strong>Wikipedia Bilinear interpolation</strong></a></p><p>[６] <a href="http://blog.csdn.net/xjz18298268521/article/details/51220576" target="_blank" rel="external">双线性插值算法的详细总结</a></p><p>[７] <a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="external"><strong>Wikipedia Bicubic interpolation</strong></a></p><p>[８] <a href="https://wenku.baidu.com/view/34dea625192e45361166f504.html?qq-pf-to=pcqq.c2c" target="_blank" rel="external">双三次插值(bicubic interpolation)原理及MATLAB源码实现</a></p><p>[９] <a href="https://dailc.github.io/2017/11/01/imageprocess_bicubicinterpolation.html" target="_blank" rel="external">图像缩放】双立方（三次）卷积插值</a>（<a href="https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95" class="uri" target="_blank" rel="external">https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95</a>）</p><section class="footnotes"><hr><ol><li id="fn1"><p><font color="#FA8072">为啥不说前向映射呢？这是因为若原图像坐标 <span class="math inline">\((v,w)\)</span> 通过前向映射方式得到变换后图像的坐标 <span class="math inline">\((x,y)\)</span> ，而且这个坐标为小数的话，一般采用四舍五入的方式得到变换后图像对应的整数坐标 <span class="math inline">\((⌊x+0.5⌋,⌊y+0.5⌋)\)</span>，令 <span class="math inline">\(f(⌊y+0.5⌋,⌊x+0.5⌋)=f(w,v)\)</span> 。</font><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p><font color="#FA8072"><span class="math inline">\(⌊x⌋\)</span> 表示向下取整，称为 Floor，指的是小于或等于 <span class="math inline">\(x\)</span> 的最大整数；<span class="math inline">\(⌈x⌉\)</span> 表示向上取整，称为 Ceil，指的是大于或等于 <span class="math inline">\(x\)</span> 的最小整数，<span class="math inline">\(eg：⌊5.6⌋ = 5，⌊-5.6⌋ = -6；⌈5.6⌉ = 6，⌈-5.6⌉ = -5。\)</span></font><a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section></section></article><div class="copyright"><p><span>本文标题：</span> <a href="/posts/e124baa1.html">矩阵的应用之图像仿射变换</a></p><p><span>文章作者：</span> <a href="/" title="访问 Shaun 的个人博客" data-toggle="tooltip">Shaun</a></p><p><span>发布时间：</span> 2018年01月20日 - 21时21分</p><p><span>最后更新：</span> 2020年08月22日 - 00时00分</p><p><span>原始链接：</span> <a class="post-url" href="/posts/e124baa1.html" title="矩阵的应用之图像仿射变换" data-toggle="tooltip">http://cniter.github.io/posts/e124baa1.html </a><span class="copy-path" data-clipboard-text="原文: http://cniter.github.io/posts/e124baa1.html　　作者: Shaun" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span></p><p><span>许可协议：</span> <i class="fa fa-creative-commons"></i> <a rel="license" href="//creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)" target="_blank" data-toggle="tooltip">"署名-非商业性使用-相同方式共享 4.0 国际" </a>转载请保留原文链接及作者。</p></div><nav id="article-nav"><a href="/posts/7cebf0ee.html" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">&lt;</strong><div class="article-nav-title">&nbsp; 17年走了，18年来了</div></a><a href="/posts/aef52be2.html" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">本人常用小工具安利 &nbsp;</div><strong class="article-nav-caption">&gt;</strong></a></nav><div class="bdsharebuttonbox"><a href="#" class="fx fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-files-o bds_copy" data-cmd="copy" title="复制网址" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享" data-toggle="tooltip"></a></div><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"矩阵的应用之图像仿射变换 | Shaun's Space",bdMini:"2",bdMiniList:!1,bdPic:"",bdStyle:"2",bdSize:"24"},share:{}},document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="/plugins/baidushare/static/api/js/share.js"+"?v=89860593.js?cdnversion="+~(-new Date/36e5)</script><div id="comments" class="div-border"><div id="gitalk-container"></div><script type="text/javascript">const gitalk = new Gitalk({
            clientID: '76d001d82d863f78c669',
            clientSecret: '7d58a8616d460c3fa945cf04ddaa5f07ff1db458',
            id: window.location.pathname,
            repo: 'cniter.github.io',
            owner: 'cniter',
            admin: 'cniter',
            // facebook-like distraction free mode
            distractionFreeMode: true
        });

        gitalk.render('gitalk-container')</script></div><script>let articleToc = '<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预备篇"><span class="toc-number">2.</span> <span class="toc-text">预备篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变换篇"><span class="toc-number">3.</span> <span class="toc-text">变换篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#旋转变换"><span class="toc-number">3.1.</span> <span class="toc-text">旋转变换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插值篇"><span class="toc-number">4.</span> <span class="toc-text">插值篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#最近邻插值"><span class="toc-number">4.1.</span> <span class="toc-text">最近邻插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双线性插值"><span class="toc-number">4.2.</span> <span class="toc-text">双线性插值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#双三次插值"><span class="toc-number">4.3.</span> <span class="toc-text">双三次插值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实践篇"><span class="toc-number">5.</span> <span class="toc-text">实践篇</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-number">6.</span> <span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#附录"><span class="toc-number">7.</span> <span class="toc-text">附录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考资料"><span class="toc-number">8.</span> <span class="toc-text">参考资料</span></a></li></ol>';
    $(window).on('load', function () {
        $('.toc-title').text("文章目录");
        $('.post-list').replaceWith(articleToc);

        // ============= 使目录可折叠 ================
        // -------------添加小图标--------------
        var $itemHasChild = $("#toc .toc-item:has(> .toc-child)");
        var $titleHasChild = $itemHasChild.children(".toc-link");
        $itemHasChild.prepend("<i class='fa fa-caret-down'></i><i class='fa fa-caret-right'></i>");
        var $iconToFold = $(".toc-item > .fa-caret-down");
        var $iconToExpand = $(".toc-item > .fa-caret-right");
        $iconToExpand.addClass("hide");
        // --------------点击小图标--------------
        var clickIcon = function () {
            $("#toc .toc-item > i").click(function () {
                $(this).siblings(".toc-child").slideToggle(100);
                $(this).toggleClass("hide");
                $(this).siblings("i").toggleClass("hide");
            })
        }()
        // 默认展开目录，所以隐藏掉表示“目录已展开”的图标（向下的小三角）
        var $iconToFold = $(".toc-item > .fa-caret-down");
        $iconToExpand.addClass("hide");
        // ------------点击大标题-----------------
        var clickTitle = function () {
            $titleHasChild.dblclick(function () {
                $(this).siblings(".toc-child").hide(100);
                $(this).siblings("i").toggleClass("hide");
            })
            // After dblclick enent
            $titleHasChild.click(function () {
                var $curentTocChild = $(this).siblings(".toc-child");
                if ($curentTocChild.is(":hidden")) {
                    $curentTocChild.show(100);
                    $(this).siblings("i").toggleClass("hide");
                }
            })
        }()
        // ---------点击总标题-----------------
        var clickTocTitle = function () {
            var $iconToExpand = $(".toc-item > .fa-caret-right");
            var $iconToFold = $(".toc-item > .fa-caret-down");
            var $subToc = $titleHasChild.next(".toc-child");
            var $tocTitle = $("#toc .toc-title");
            // 当包含多级目录时再执行
            if ($titleHasChild.length) {
                $tocTitle.addClass("clickable");
                $tocTitle.click(function () {
                    if ($subToc.is(":hidden")) {
                        $subToc.show(150);
                        $iconToExpand.removeClass("hide");
                        $iconToFold.addClass("hide");
                    } else {
                        $subToc.hide(100);
                        $iconToExpand.addClass("hide");
                        $iconToFold.removeClass("hide");
                    }
                })
            }
        }()
    });</script></main><div id="site-tool"><div class="scroll"><a href="#header"><i class="fa fa-arrow-up"></i></a> <a href="#footer"><i class="fa fa-arrow-down"></i></a></div><div></div></div><aside id="right-col" class="col-lg-3 col-sm-12"><div id="sidebar-sticky--bottom"></div><div id="sidebar"><header class="author-info div-border"><a href="/"><img class="header-avatar" src="/img/avatar.jpg"></a><h1 class="header-author"><a href="/" title="Hi Mate" data-toggle="tooltip">Shaun</a></h1><p class="header-slogan">求知！ 视界！ 未来！ ↖(^ω^)↗</p><div class="social-info"><a class="social-icon" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" title="envelope" data-toggle="tooltip"><i class="fa fa-envelope" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="https://github.com/cniter" title="github" data-toggle="tooltip"><i class="fa fa-github" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="/atom.xml" title="rss" data-toggle="tooltip"><i class="fa fa-rss" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12" title="qq" data-toggle="tooltip"><i class="fa fa-qq" aria-hidden="true"></i></a></div></header><div class="search div-border" title="搜索" data-toggle="tooltip"><form id="search-form"><input type="text" id="local-search--input" name="q" results="0" placeholder=" Search..." autocomplete="off" autocorrect="off"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search--result"></div><p class="no-result">No results found</p></div><div id="tagcloud" class="tagcanvas div-border" title="标签" data-toggle="tooltip"><canvas width="200" height="200" id="tagcloud-canvas"><p>Anything in here will be replaced on browsers that support the canvas element</p><ul><li><a href="/tags/algorithm/" data-weight="6">algorithm</a></li><li><a href="/tags/android/" data-weight="2">android</a></li><li><a href="/tags/bigdata/" data-weight="2">bigdata</a></li><li><a href="/tags/c-cpp/" data-weight="6">c/cpp</a></li><li><a href="/tags/clustering/" data-weight="1">clustering</a></li><li><a href="/tags/container/" data-weight="1">container</a></li><li><a href="/tags/css/" data-weight="1">css</a></li><li><a href="/tags/cv/" data-weight="5">cv</a></li><li><a href="/tags/devtool/" data-weight="1">devtool</a></li><li><a href="/tags/ffmpeg/" data-weight="1">ffmpeg</a></li><li><a href="/tags/geomesa/" data-weight="1">geomesa</a></li><li><a href="/tags/geometry/" data-weight="3">geometry</a></li><li><a href="/tags/gfw/" data-weight="1">gfw</a></li><li><a href="/tags/git/" data-weight="0">git</a></li><li><a href="/tags/github/" data-weight="1">github</a></li><li><a href="/tags/gl/" data-weight="1">gl</a></li><li><a href="/tags/hexo/" data-weight="8">hexo</a></li><li><a href="/tags/integration/" data-weight="1">integration</a></li><li><a href="/tags/java/" data-weight="2">java</a></li><li><a href="/tags/language/" data-weight="2">language</a></li><li><a href="/tags/latex/" data-weight="0">latex</a></li><li><a href="/tags/mapbox/" data-weight="1">mapbox</a></li><li><a href="/tags/markdown/" data-weight="1">markdown</a></li><li><a href="/tags/matlab/" data-weight="2">matlab</a></li><li><a href="/tags/network/" data-weight="1">network</a></li><li><a href="/tags/note/" data-weight="5">note</a></li><li><a href="/tags/numerical/" data-weight="1">numerical</a></li><li><a href="/tags/opencv/" data-weight="11">opencv</a></li><li><a href="/tags/opendrive/" data-weight="1">opendrive</a></li><li><a href="/tags/opengl/" data-weight="1">opengl</a></li><li><a href="/tags/python/" data-weight="1">python</a></li><li><a href="/tags/qt/" data-weight="2">qt</a></li><li><a href="/tags/record/" data-weight="9">record</a></li><li><a href="/tags/search/" data-weight="1">search</a></li><li><a href="/tags/segmentation/" data-weight="2">segmentation</a></li><li><a href="/tags/tensorflow/" data-weight="1">tensorflow</a></li><li><a href="/tags/thought/" data-weight="3">thought</a></li><li><a href="/tags/unix-like/" data-weight="2">unix-like</a></li><li><a href="/tags/vscode/" data-weight="1">vscode</a></li></ul></canvas><script src="/plugins/TagCanvas/jquery.tagcanvas.min.js" type="text/javascript"></script><script type="text/javascript">$(document).ready(function(){$("#tagcloud-canvas").tagcanvas({initial:[.1,-.1],activeCursor:'url("/img/cursor/link.cur"), auto',reverse:!0,depth:.75,weight:!0,weightFrom:"data-weight",weightMode:"both",weightSizeMin:15,weightSizeMax:50})||$("#tagcloud").hide()})</script></div><div class="friends div-border" title="友链" data-toggle="tooltip"><a target="_blank" class="friends-link" href="https://cniter.github.io">Shaun&#39;s Space</a></div><div class="revolvermaps div-border" title="访客" data-toggle="tooltip"><script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;m=7&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=49" defer></script></div></div><div class="toc-card"><div class="toc-card--head"><i class="fa fa-angle-up" aria-hidden="true"></i></div><div id="toc" class="toc-card--content"><strong class="toc-title">文章列表</strong><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/8d3d87a2.html">Scala 学习小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/489fa7b3.html">时空查询之ECQL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9978824c.html">GeoMesa踩坑指北</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3692cd6.html">IDEA使用Docker环境开发调试</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/af5e9ace.html">大数据环境搭建笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ae780057.html">设计模式浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/eee1c041.html">积分计算</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a5661762.html">Geometry增量更新</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e225d8fd.html">Mapbox显示GeoServer地图</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3d8ab974.html">Docker使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6694a214.html">空间中三角形与三角形相交</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5315fcfd.html">计算几何基础</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b7d79231.html">OpenDrive解析小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/39a3c99e.html">一张纹理做天空盒</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a250bb21.html">Windows Terminal 尝鲜小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ae5f9dce.html">读大学</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cf97ba7c.html">2019，既是结束又是开始</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ff29de94.html">快速判断三角形与长方体相交</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70a807da.html">网页菜单纯 css 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/abe58f8c.html">个人游记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/26d437be.html">hexo-theme-chi主题更新小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3578e309.html">［译］为什么深度学习没有取代传统的计算机视觉</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/37b89a23.html">再也不见，18年</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ac4679b5.html">hexo-theme-chi主题开发小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/64889158.html">Matlab和OpenCV混合编程小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be7949e4.html">Android实践小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fc1165b7.html">C++数组中的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cafdd60d.html">Android开发环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/27a4c8b6.html">Windows实用技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6315717b.html">FFmpeg提取与合并命令使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fd823bf9.html">解决VSCode使用Cmder作为默认终端问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fddd1e17.html">图割算法之NCuts浅见</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c42ff8d4.html">图割算法之Graph Cuts浅见</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b93d943b.html">C++中static用法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8fb9f004.html">斐波那契数列的三种写法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/982ff584.html">搜索技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7cebf0ee.html">17年走了，18年来了</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e124baa1.html">矩阵的应用之图像仿射变换</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aef52be2.html">本人常用小工具安利</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/376168c6.html">解决无法打开某个网页问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5f54aa2c.html">PyQt5使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/82d3b275.html">TensorFlow Object Detection API使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2a3d46b0.html">C语言中整型提升问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dece8eba.html">TXT数据转OpenCV中的Mat数据</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e8b35736.html">OpenCV中滑动条和鼠标事件响应操作的使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b6fb6109.html">利用回调函数计算函数运行时间</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df943c4f.html">论如何科学的上网</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b1e9411b.html">Hexo的SPFK主题修改小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/22c3daf1.html">解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/509ee93b.html">解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3bc0decc.html">Hexo添加各种小部件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fd0f8195.html">OpenCV中显著性检测算法的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/35132cb7.html">OpenCV中Selective Search算法的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/170c76cc.html">别了，漆黑的象牙塔</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c3f26b1.html">Win10以树形结构显示文件目录结构</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/68065b99.html">ACGN作品个人印象简评</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4f6225b7.html">Hexo添加站内本地搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/302a6244.html">用OpenCV显示OpenGL图形</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7df528b4.html">Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17017530.html">MyThoughts</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7d5bc07b.html">解决写上篇文档“Hexo+GitHub搭建个人博客”遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d7965b48.html">Hexo+GitHub搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4a17b156.html">Hello World</a></li></ul></div></div></aside></div></div><span id="cursor-trail"></span> <span class="click-halo"></span><footer id="footer" class="text-center"><div class="copyright-info">&copy; 2017 - 2021 <a href="/">Shaun</a></div><span class="site-visitor"><i class="fa fa-user-o" aria-hidden="true"></i> <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> &nbsp;|&nbsp; <i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> &nbsp;|&nbsp; <i class="fa fa-hand-o-up" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span><div class="site-info"><a href="http://hexo.io/" target="_blank">Hexo </a>theme <a href="https://github.com/cniter/hexo-theme-chi" target="_blank">Chi </a>by <a href="https://github.com/cniter" target="_blank">Shaun</a></div></footer><script type="text/javascript" async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" integrity="sha256-WUED7NFzpsmHtLO7bswSz4JSfkhE+cD4ncKeOznwFSY=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }

        , TeX: {
            extensions: ["extpfeil.js"]
        }
    });
    
    MathJax.Hub.Queue(function() {
        let all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';                 
        }       
    });</script><script type="text/javascript">// 监听搜索结果是否发生变化
    const MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;  // Firefox和Chrome早期版本中带有前缀
    const config = { attributes: true, childList: true, characterData: true }; // 配置观察选项
    let target = document.querySelector('#local-search--result');
    let $local_search_result = $("#local-search--result");
    let $no_result = $(".no-result");
    let observer = new MutationObserver(function (mutations) {  // 创建观察者对象
        mutations.forEach(function (mutation) {
            // console.log(mutation.type);
            if (!$local_search_result.text() && $local_search_result.html() != '') {    // 无搜索结果
                $no_result.show(200);
            } else {
                $no_result.hide();
            }
        });
    });
    

    // 激活搜索框时才搜索
    let inputArea = document.querySelector("#local-search--input");
    let getSearchFile = function () {
        // 调用搜索函数
        let search_path = "search.xml";
        if (search_path.length == 0) {
            search_path = "search.xml";
        }
        let path = "/" + search_path;
        searchFunc(path, 'local-search--input', 'local-search--result');
        observer.observe(target, config);   // 传入目标节点和观察选项
    }
    inputArea.onfocus = function () { getSearchFile() }

    // 搜索重置
    let $resetButton = $("#search-form .fa-times");
    let $resultArea = $("#local-search--result");
    inputArea.oninput = function () { $resetButton.show(); }
    let resetSearch = function () {
        $resultArea.html("");
        document.querySelector("#search-form").reset();
        $resetButton.hide();
        $no_result.hide();
        observer.disconnect();  // 停止观察
    }

    // 屏蔽回车
    inputArea.onkeydown = function (event) { if (event.keyCode == 13) return false }

    // 搜索函数
    let searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                let datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                let $input = document.getElementById(search_id);
                let $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    let str = '<ul class=\"search-result--list\">';
                    let keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        let isMatch = true;
                        let content_index = [];
                        let data_title = data.title.trim().toLowerCase();
                        let data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        let data_url = data.url;
                        let index_title = -1;
                        let index_content = -1;
                        let first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title != '' && data_content != '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i == 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='/" + data_url + "' class='search-result--title' target='_blank'>" + "> " + data_title + "</a>";
                            let content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out characters
                                let start = first_occur - 6;
                                let end = first_occur + 6;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start == 0) {
                                    end = 10;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                let match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    let regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                })
                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                        }
                    })
                    $resultContent.innerHTML = str;
                })
            }
        })
    }</script><script type="module" src="/js/main.js"></script><script>$(document).ready(function() {
            $("del").attr("title","你知道的太多了ヾ(▼ﾍ▼；) (#｀皿´メ)");
            $('.toc-card').width($('#right-col').width());  // 使目录栏与右侧栏宽度一致            
            
            // 添加脚注提示
            $('a.footnote-ref').each(function (index, elem) {
                let post_id = $(this).parents('article').attr('id');
                let fn_href = $(this).attr('href');
                elem.setAttribute('data-toggle', 'tooltip');
                elem.setAttribute('data-html', 'true');
                elem.setAttribute('title', $("#" + post_id + " " + fn_href).html());
            });
        });
        $(window).on('load', function () {
            $('#sidebar-sticky--bottom').height($('#right-col').height() - $('#sidebar').height() - $('#footer').height());  // 完全填充#right-col高度
        });
        $(function () { $("[data-toggle='tooltip']").tooltip(); });</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"Tia/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/Tia/Tia.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":0,"vOffset":-76},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body></html>