<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="Google S2 Geometry 浅解 - Shaun&#39;s Space"><meta name="keywords" content="geometry"><meta property="og:type" content="article"><meta property="og:site_name" content="Shaun&#39;s Space"><title>Google S2 Geometry 浅解 - Shaun&#39;s Space</title><link rel="icon" href="/img/favicon.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fork-awesome/1.1.5/css/fork-awesome.min.css" integrity="sha256-P64qV9gULPHiZTdrS1nM59toStkgjM0dsf5mK/UwBV4=" crossorigin="anonymous"><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha256-ZvOgfh+ptkpoa2Y4HkRY28ir89u/+VRyDE7sB7hEEcI=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js" integrity="sha256-EPrkNjGEmCWyazb3A/Epj+W7Qm2pB9vnfXw+X6LImPM=" crossorigin="anonymous"></script><script src="//cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" integrity="sha256-FiZwavyI2V6+EXO1U+xzLG3IKldpiTFf3153ea9zikQ=" crossorigin="anonymous"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"><style>body{cursor:url(/img/cursor/normal.cur),auto}#navbar-toggler--btn,.code-copy,.copy-path,a,button{cursor:url(/img/cursor/link.cur),auto}#site-bg{position:fixed;left:0;top:0;width:100%;height:100%;z-index:-1;background-image:url(/img/site-bg/bg-1.jpg);background-repeat:no-repeat;background-size:100% 100%;opacity:.2;transition:background-image 3s}</style><script>const bdshareURL="/plugins/baidushare/"</script><script async type="text/javascript" src="/js/live2d/autoload.js"></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Shaun's Space" type="application/atom+xml">
</head><body><!--[if lt IE 9]>
        <link rel="stylesheet" href="/css/ie9.css">
        <div class="alert alert-danger topframe" role="alert">
            嘿，朋友！您的浏览器已<strong>过期</strong>，不建议继续食用。
            <a target="_blank" class="alert-link" href="http://browsehappy.com">这里</a> 有些新玩意儿，何不试试？
        </div>
    <![endif]--><header id="header"><nav id="navbar" class="navbar navbar-expand-md"><div class="container"><h1 id="site-title"><a href="/" class="navbar-brand"><img src="/img/favicon.png"> <span>Shaun&#39;s Space</span></a></h1><button id="navbar-toggler--btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#collapsibleNavbar"><span><i class="fa fa-list-ul" aria-hidden="true"></i></span></button><div class="collapse navbar-collapse" id="collapsibleNavbar"><ul class="navbar-nav"><li class="nav-item"><a class="nav-link" href="/" title="首页" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-home"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives" title="所有文章" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-archive"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories" title="全部分类" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-folder"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags" title="全部标签" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-tags"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about" title="关于本站" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-user"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/guide" title="Treasure Guide" data-toggle="tooltip" data-placement="bottom"><i class="nav-icon fa fa-university"></i> 导航</a></li></ul></div></div></nav></header><div class="container"><div class="row"><aside id="left-col" class="col-md-1"></aside><main class="col-lg-8 col-sm-12"><article id="post-Google-S2-Geometry-浅解" class="article div-border"><header class="article-header"><span class="article-date article-title--post"><i class="fa fa-calendar" aria-hidden="true"></i> <a href="/posts/720275bd.html"><time datetime="2021-09-19T08:21:58.000Z">2021-09-19</time></a></span><section class="article-title article-title--post"><a href="/posts/720275bd.html">Google S2 Geometry 浅解</a></section><div class="article-label"><div class="article-category label"><i class="fa fa-book" aria-hidden="true"></i> <a class="color2 article-category-link" href="/categories/Mathematics/">Mathematics</a></div><div class="article-tag label"><i class="fa fa-bookmark" aria-hidden="true"></i> <a class="color4 article-tag-none-link" href="/tags/geometry/" rel="tag">geometry</a></div></div></header><section class="article-content"><h2 id="前言">前言</h2><p>　　Google S2 Geometry（以下简称 S2） 是 Google 发明的基于单位球的一种地图投影和空间索引算法，该算法可快速进行覆盖以及邻域计算。更多详见 <a target="_blank" rel="noopener" href="https://s2geometry.io/">S2Geometry</a>，<a target="_blank" rel="noopener" href="https://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/">Google’s S2, geometry on the sphere, cells and Hilbert curve</a>，<a target="_blank" rel="noopener" href="https://halfrost.com/go_s2_regioncoverer/">halfrost 的空间索引系列文章</a>。虽然使用 S2 已有一年的时间，但确实没有比较系统的看过其源码，这次借着这段空闲时间，将 Shaun 常用的功能系统的看看其具体实现，下文将结合 S2 的 C++，Java，Go 的版本一起看，由于 Java 和 Go 的都算是 C++ 的衍生版，所以以 C++ 为主，捎带写写这三种语言实现上的一些区别，Java 版本时隔 10 年更新了 2.0 版本，喜大普奔。</p><span id="more"></span><h2 id="坐标篇">坐标篇</h2><figure><img src="https://s2geometry.io/devguide/img/s2cell_global.jpg" alt="s2 projection"><figcaption aria-hidden="true">s2 projection</figcaption></figure><p>　　S2 的投影方式可简单想象为一个单位球外接一个立方体，从球心发出一条射线得到球面上的点到立方体上 6 个面的投影，即将球面投影为立方体，当然中间为了使面积分布更为均匀，还做了些其他坐标变换。</p><h3 id="s2latlng-坐标">S2LatLng 坐标</h3><p>　　首先是经纬度坐标，默认用弧度（Radians）构造，取值范围为经度 [-π，+π]，纬度 [-π/2，+π/2]，当然也可使用 S1Angle 将角度（Degrees）转成弧度来构造。</p><h3 id="s2point-坐标">S2Point 坐标</h3><p>　　然后球面笛卡尔坐标，这是个三维坐标，由 S2LatLng 到 S2Point 相当于将单位球的极坐标表示法转换为笛卡尔坐标表示法，具体公式为 <span class="math inline">\(x=\cos(lat)cos(lng);　y=cos(lat)sin(lng);　z=sin(lat)\)</span>。</p><h3 id="faceuv-坐标">FaceUV 坐标</h3><p>　　这个坐标并没实际的类与其对应，face 指的是立方体的面，值域为 [0,5]，而 uv 坐标是指面上的点，值域为 [-1,1]。首先需要知道 S2Point 会投影到哪个面上，可以知道 S2 的笛卡尔坐标 X 轴正向指向 0 面，Y 轴正向指向 1 面，Z 轴正向指向 2 面，X 轴负向指向 3 面，Y 轴负向指向 4 面，Z 轴负向指向 5 面，所以 S2Point xyz 哪个分量的绝对值最大，就会投影到哪个轴指向的面，若该分量为正值，则取正向指的面，若该分量为负值，则取负向指的面。至于 uv 的计算方式就是直线与平面的交点了，之前的一篇「计算几何基础」中写过，但这里的平面和直线都比较特殊，所以有快速算法，就直接贴 Go 的代码吧：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="GO"><div class="code-copy"></div><figure class="highlight hljs go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validFaceXYZToUV given a valid face for the given point r (meaning that</span></span><br><span class="line"><span class="comment">// dot product of r with the face normal is positive), returns</span></span><br><span class="line"><span class="comment">// the corresponding u and v values, which may lie outside the range [-1,1].</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validFaceXYZToUV</span><span class="params">(face <span class="keyword">int</span>, r r3.Vector)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> face &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">return</span> r.Y / r.X, r.Z / r.X</span><br><span class="line">	<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> -r.X / r.Y, r.Z / r.Y</span><br><span class="line">	<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> -r.X / r.Z, -r.Y / r.Z</span><br><span class="line">	<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">		<span class="keyword">return</span> r.Z / r.X, r.Y / r.X</span><br><span class="line">	<span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">		<span class="keyword">return</span> r.Z / r.Y, -r.X / r.Y</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> -r.Y / r.Z, -r.X / r.Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这里需要注意的是 S2Point xyz 三分量构成的向量与平面法向量的点积必须是正数时 uv 才算正确有效，Go 在计算时没做校验，C++ 和 Java 都有校验，使用时需要注意。</p><h3 id="facest-坐标">FaceST 坐标</h3><p>　　之所以引入 ST 坐标是因为同样的球面面积映射到 UV 坐标面积大小不一，大小差距比较大（离坐标轴越近越小，越远越大），所以再做一次 ST 变换，将面积大的变小，小的变大，使面积更均匀，利于后面在立方体面上取均匀格网（cell）时，每个 cell 对应球面面积差距不大。S2 的 ST 变换有三种：1、线性变换，基本没做任何变形，只是简单将 ST 坐标的值域变换为 [0, 1]，cell 对应面积最大与最小比大约为 5.2；2、二次变换，一种非线性变换，能起到使 ST 空间面积更均匀的作用，cell 对应面积最大与最小比大约为 2.1；3、正切变换，同样能使 ST 空间面积更均匀，且 cell 对应面积最大与最小比大约为 1.4，不过其计算速度相较于二次变换要慢 3 倍，所以 S2 权衡考虑，最终采用了二次变换作为默认的 UV 到 ST 之间的变换。二次变换公式为：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="JAVA"><div class="code-copy"></div><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stToUV</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">4</span> * s * s - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">1</span> - <span class="number">4</span> * (<span class="number">1</span> - s) * (<span class="number">1</span> - s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">uvToST</span><span class="params">(<span class="keyword">double</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * Math.sqrt(<span class="number">1</span> + <span class="number">3</span> * u);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - <span class="number">0.5</span> * Math.sqrt(<span class="number">1</span> - <span class="number">3</span> * u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="faceij-坐标">FaceIJ 坐标</h3><p>　　IJ 坐标是离散化后的 ST 坐标，将 ST 空间的平面划分为 <span class="math inline">\(2^{30}×2^{30}\)</span> 个网格，取网格所在的横纵坐标得到 IJ 坐标，所以由 ST 到 IJ 坐标的变换就比较简单了：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="JAVA"><div class="code-copy"></div><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stToIj</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Math.max(</span><br><span class="line">    <span class="number">0</span>, Math.min(<span class="number">1073741824</span> - <span class="number">1</span>, (<span class="keyword">int</span>) Math.round(<span class="number">1073741824</span> * s - <span class="number">0.5</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="s2cellid">S2CellId</h3><p>　　这个 id 其实是个一维坐标，而是利用希尔伯特空间填充曲线将 IJ 坐标从二维变换为一维，该 id 用一个 64 位整型表示，高 3 位用来表示 face（0~5），后面 61 位来保存不同的 level（0~30） 对应的希尔伯特曲线位置，每增加一个 level 增加两位，后面紧跟一个 1，最后的位数都补 0。<em>注：Java 版本的 id 是有符号 64 位整型，而 C++ 和 Go 的是无符号 64 位整型，所以在跨语言传递 id 的时候，在南极洲所属的最后一个面（即 face = 5）需要小心处理。</em></p><h4 id="hilbertcurve">HilbertCurve</h4><figure><img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/Hilbert_curve_production_rules%21.svg" alt="hilbert_curve_subdivision_rules"><figcaption aria-hidden="true">hilbert_curve_subdivision_rules</figcaption></figure><figure><img src="https://upload.wikimedia.org/wikipedia/commons/3/35/Hilbert_curve_3_Orient%21.svg" alt="hilbert_curve"><figcaption aria-hidden="true">hilbert_curve</figcaption></figure><p>　　上面两张图很明了的展示了希尔伯特曲线的构造过程，该曲线的构造基本元素由 ABCD 4 种“U”形构成，而 BCD 又可由 A 依次逆时针旋转 90 度得到，所以也可以认为只有一种“U”形，每个 U 占 4 个格子，以特定方式进行 1 分 4 得到下一阶曲线形状。</p><p>每个 U 坐标与希尔伯特位置（用二进制表示）对应关系如下：</p><ul><li>A：<code>00 -&gt; (0,0); 01 -&gt; (0,1); 10 -&gt; (1,1); 11 -&gt; (1,0);</code></li><li>B：<code>00 -&gt; (1,1); 01 -&gt; (0,1); 10 -&gt; (0,0); 11 -&gt; (1,0);</code></li><li>C：<code>00 -&gt; (1,1); 01 -&gt; (1,0); 10 -&gt; (0,0); 11 -&gt; (0,1);</code></li><li>D：<code>00 -&gt; (0,0); 01 -&gt; (1,0); 10 -&gt; (1,1); 11 -&gt; (0,1);</code></li></ul><p>每个 U 一分四对应关系如下：</p><ul><li>A：<code>D -&gt; A -&gt; A -&gt; B</code></li><li>B：<code>C -&gt; B -&gt; B -&gt; A</code></li><li>C：<code>B -&gt; C -&gt; C -&gt; D</code></li><li>D：<code>A -&gt; D -&gt; D -&gt; C</code></li></ul><p>　　根据以上两个对应关系就能找到右手坐标系任意阶数的希尔伯特位置及坐标对应关系。以初始 1 阶曲线 A 为例，占据四个格子，然后进行一分四操作，四个格子分成 16 个格子，A 分为 DAAB 四个“U”形，连接起来即为 2 阶曲线，位置与坐标对应关系为（都用二进制表示）：</p><p><code>0000 -&gt; (00, 00); 0001 -&gt; (01, 00); 0010 -&gt; (01, 01); 0011 -&gt; (00, 01)</code>；</p><p><code>0100 -&gt; (00, 10); 0101 -&gt; (00, 11); 0110 -&gt; (01, 11); 0111 -&gt; (01, 10)</code>；</p><p><code>1000 -&gt; (10, 10); 1001 -&gt; (10, 11); 1010 -&gt; (11, 11); 1011 -&gt; (11, 10)</code>；</p><p><code>1100 -&gt; (11, 01); 1101 -&gt; (10, 01); 1110 -&gt; (10, 00); 1111 -&gt; (11, 00)</code>；</p><p>　　从二进制中很容易看出随着阶数的增加，位置与坐标的对应关系：每增加一阶，位置往后增加两位，坐标分量各增加一位，位置增加的两位根据一分四对应关系拼接，坐标各分量增加的一位需先找到一分四对应关系，再找对应位置与坐标对应关系，将得到的坐标分量对应拼接。以一阶的 <code>01 -&gt; (0,1)</code> 到二阶的 <code>0110 -&gt; (01, 11)</code> 为例，首先根据 01 得到当前所属一阶第二块，查找一分四对应关系知道，下一阶这块还是 A，根据 0110 后两位 10 可知这块属于 A 的第三个位置，查找坐标得到是 <code>(1,1)</code>，结合一阶的 <code>(0,1)</code>，对应分量拼接得到坐标 <code>(01,11)</code>，即 <code>(1, 3)</code>，同理可根据第二阶的坐标反查第二阶的位置。有了这些关系，就能生成希尔伯特曲线了，下面就看看 S2 是怎么生成 id 的。</p><h4 id="s2id">S2Id</h4><p>　　首先 S2 中用了两个二维数组分别保存位置到坐标以及坐标到位置的对应的关系：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kIJtoPos[orientation][ij] -&gt; pos</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kIJtoPos[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">// (0,0) (0,1) (1,0) (1,1)</span></span><br><span class="line">  &#123;     <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>  &#125;,  <span class="comment">// canonical order</span></span><br><span class="line">  &#123;     <span class="number">0</span>,    <span class="number">3</span>,    <span class="number">1</span>,    <span class="number">2</span>  &#125;,  <span class="comment">// axes swapped</span></span><br><span class="line">  &#123;     <span class="number">2</span>,    <span class="number">3</span>,    <span class="number">1</span>,    <span class="number">0</span>  &#125;,  <span class="comment">// bits inverted</span></span><br><span class="line">  &#123;     <span class="number">2</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">0</span>  &#125;,  <span class="comment">// swapped &amp; inverted</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kPosToIJ[orientation][pos] -&gt; ij</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPosToIJ[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">// 0  1  2  3</span></span><br><span class="line">  &#123;  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span> &#125;,    <span class="comment">// canonical order:    (0,0), (0,1), (1,1), (1,0)</span></span><br><span class="line">  &#123;  <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;,    <span class="comment">// axes swapped:       (0,0), (1,0), (1,1), (0,1)</span></span><br><span class="line">  &#123;  <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,    <span class="comment">// bits inverted:      (1,1), (1,0), (0,0), (0,1)</span></span><br><span class="line">  &#123;  <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,    <span class="comment">// swapped &amp; inverted: (1,1), (0,1), (0,0), (1,0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kPosToOrientation[pos] -&gt; orientation_modifier</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPosToOrientation[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></div><p>　　方向 0（canonical order）相当于上文中 A，方向 1（axes swapped）相当于上文中 D，方向 2（bits inverted）相当于上文中 C，方向 3（swapped &amp; inverted）相当于上文中 B，kPosToOrientation 代表 S2 中方向 0 一分四的对应关系，而 方向 1，2，3 的对应关系可由该值推出，计算公式为 <code>orientation ^ kPosToOrientation</code>，eg：<code>1 -&gt; 1^kPosToOrientation=[0, 1, 1, 2]; 3 -&gt; 3^kPosToOrientation=[2, 3, 3, 0]</code>，与上文中一分四对应关系一致。</p><p>　　随后 S2 初始化了一个 4 阶希尔伯特曲线位置与坐标的对应关系查找表，见 C++ 版的 <code>MaybeInit()</code> 方法，</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ij = (i &lt;&lt; <span class="number">4</span>) + j;</span><br><span class="line">lookup_pos[(ij &lt;&lt; <span class="number">2</span>) + orig_orientation] = (pos &lt;&lt; <span class="number">2</span>) + orientation;</span><br><span class="line">lookup_ij[(pos &lt;&lt; <span class="number">2</span>) + orig_orientation] = (ij &lt;&lt; <span class="number">2</span>) + orientation;</span><br></pre></td></tr></table></figure></div><p>　　orig_orientation 代表 4 个初始方向，orientation 代表该位置或坐标下一阶一分四的方向，数组中每个元素是 16 位数，2 个字节，一个四阶希尔伯特曲线是 <span class="math inline">\(2^4×2^4=256\)</span> 个位置，一个初始方向对应一个四阶希尔伯特曲线，所以一个查找表共占内存 <span class="math inline">\(2×256×4=2048=2KB\)</span>，正好一级缓存能放下，再大的话，一级缓存可能放不下，反而会降低查找速度。这两个查找表就相当于 4 个超“U”形的位置与坐标对应关系，同时一分四对应关系保持不变，以超“U”作为基本元素做下一阶希尔伯特曲线，每增加一阶位置往后增加 8 位，IJ 坐标各往后增加 4 位，如此，以更快的速度迭代到 S2 想要的 30 阶希尔伯特曲线。C++ 的这份代码就很精妙了：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">S2CellId <span class="title">S2CellId::FromFaceIJ</span><span class="params">(<span class="keyword">int</span> face, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化超“U”形查找表</span></span><br><span class="line">  <span class="built_in">MaybeInit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// face 向左移 60 位</span></span><br><span class="line">  uint64 n = absl::implicit_cast&lt;uint64&gt;(face) &lt;&lt; (kPosBits - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定每个面的初始“U”形方向，使每个面都保持相同的右手坐标系，6 个面生成的希尔伯特曲线可以依次相连</span></span><br><span class="line">  uint64 bits = (face &amp; kSwapMask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于超“U”形得到 30 阶希尔伯特曲线 IJ 坐标对应位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BITS(k) do &#123; \</span></span><br><span class="line"><span class="meta">    const int mask = (1 &lt;&lt; kLookupBits) - 1; \</span></span><br><span class="line"><span class="meta">    bits += ((i &gt;&gt; (k * kLookupBits)) &amp; mask) &lt;&lt; (kLookupBits + 2); \</span></span><br><span class="line"><span class="meta">    bits += ((j &gt;&gt; (k * kLookupBits)) &amp; mask) &lt;&lt; 2; \</span></span><br><span class="line"><span class="meta">    bits = lookup_pos[bits]; \</span></span><br><span class="line"><span class="meta">    n |= (bits &gt;&gt; 2) &lt;&lt; (k * 2 * kLookupBits); \</span></span><br><span class="line"><span class="meta">    bits &amp;= (kSwapMask | kInvertMask); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// IJ 只有 30 位，7 这个调用只会导致位置移 4 位，后续调用都移 8 位，得到 4 + 8 * 7 = 60 位</span></span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">7</span>); </span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GET_BITS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整个 n 向右移一位，再以 1 结尾</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S2CellId</span>(n * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再来看看根据 id 反算 IJ 坐标：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S2CellId::ToFaceIJOrientation</span><span class="params">(<span class="keyword">int</span>* pi, <span class="keyword">int</span>* pj, <span class="keyword">int</span>* orientation)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 与上面一样</span></span><br><span class="line">  <span class="built_in">MaybeInit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="keyword">this</span>-&gt;<span class="built_in">face</span>();</span><br><span class="line">  <span class="keyword">int</span> bits = (face &amp; kSwapMask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反算 IJ 坐标，k == 7 时，取希尔伯特曲线位置高 4 位，IJ 各前 2 位，其余依次取位置 8 位， IJ 各 4 位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BITS(k) do &#123; \</span></span><br><span class="line"><span class="meta">    const int nbits = (k == 7) ? (kMaxLevel - 7 * kLookupBits) : kLookupBits; \</span></span><br><span class="line"><span class="meta">    bits += (static_cast<span class="meta-string">&lt;int&gt;</span>(id_ &gt;&gt; (k * 2 * kLookupBits + 1)) \</span></span><br><span class="line"><span class="meta">             &amp; ((1 &lt;&lt; (2 * nbits)) - 1)) &lt;&lt; 2; \</span></span><br><span class="line"><span class="meta">    bits = lookup_ij[bits]; \</span></span><br><span class="line"><span class="meta">    i += (bits &gt;&gt; (kLookupBits + 2)) &lt;&lt; (k * kLookupBits); \</span></span><br><span class="line"><span class="meta">    j += ((bits &gt;&gt; 2) &amp; ((1 &lt;&lt; kLookupBits) - 1)) &lt;&lt; (k * kLookupBits); \</span></span><br><span class="line"><span class="meta">    bits &amp;= (kSwapMask | kInvertMask); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">7</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GET_BITS</span></span><br><span class="line"></span><br><span class="line">  *pi = i;</span><br><span class="line">  *pj = j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orientation != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">S2_DCHECK_EQ</span>(<span class="number">0</span>, kPosToOrientation[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">S2_DCHECK_EQ</span>(kSwapMask, kPosToOrientation[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 0x1111111111111111ULL may be better?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lsb</span>() &amp; <span class="number">0x1111111111111110</span>ULL) &#123;</span><br><span class="line">      bits ^= kSwapMask;</span><br><span class="line">    &#125;</span><br><span class="line">    *orientation = bits;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> face;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这里的 orientation 实际是指当前位置的方向，即其周围必有 3 个位置与其方向相同，最后一行注释 Shaun 之所以认为应该是 0x1111111111111111ULL，是因为第 30 阶希尔伯特曲线位置（leaf cell）按理说同样需要做异或操作得到方向，不过整个 S2 库都没有需要用到 leaf cell 的方向，所以这就倒无关紧要了。之所以需要做异或操作，是因为 bits 是该位置下一阶一分四的方向，而对于同一个希尔伯特曲线位置，奇数阶与奇数阶下一阶一分四方向相同，偶数阶与偶数阶下一阶一分四方向相同，lsb() 表示二进制 id 从右往左数第一个 1 所代表的数， 所以有 0x1111111111111110ULL 这一魔术数，而异或操作正好能将下一阶一分四方向调整为当前阶方向。</p><p>　　如此 S2 的坐标以及 id 的生成以及反算就很明了了，下面就是 S2 如何使用 id 做计算了。</p><hr><h3 id="facesiti-坐标">FaceSiTi 坐标</h3><p>　　这个是 S2 内部计算使用的坐标，一般用来计算 cell 的中心坐标，以及根据当前 s 和 t 坐标的精度（小数点后几位）判断对应的级别（level）。由于 S2 本身并不显式存储 ST 坐标（有存 UV 坐标），所以 ST 坐标只能计算出来，每个 cell 的中心点同样如此。计算公式为 <span class="math inline">\(Si=s*2^{31};Ti=t*2^{31}\)</span>。至于为啥是 <span class="math inline">\(2^{31}\)</span>，是因为该坐标是用来描述从 0~ 31 阶希尔伯特曲线网格的中心坐标，0 阶中心以 <span class="math inline">\(1/2^1\)</span> 递增，1 阶中心以 <span class="math inline">\(1/2^2\)</span> 递增，2 阶中心以 <span class="math inline">\(1/2^3\)</span> 递增，……，30 阶中心以 <span class="math inline">\(1/2^{31}\)</span> 递增。S2 计算 id 对应的格子中心坐标，首先就会计算 SiTi 坐标，再将 SiTi 转成 ST 坐标。</p><h2 id="算法篇">算法篇</h2><h3 id="邻域算法">邻域算法</h3><p>　　S2 计算邻域，最关键的是计算不同面相邻的 leaf cell id，即：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">S2CellId <span class="title">S2CellId::FromFaceIJWrap</span><span class="params">(<span class="keyword">int</span> face, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制 IJ 最大最小取值为 -1~2^30, 刚好能超出 IJ 正常表示范围 0~2^30-1</span></span><br><span class="line">  i = <span class="built_in">max</span>(<span class="number">-1</span>, <span class="built_in">min</span>(kMaxSize, i));</span><br><span class="line">  j = <span class="built_in">max</span>(<span class="number">-1</span>, <span class="built_in">min</span>(kMaxSize, j));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> kScale = <span class="number">1.0</span> / kMaxSize;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> kLimit = <span class="number">1.0</span> + DBL_EPSILON;</span><br><span class="line">  <span class="built_in">S2_DCHECK_EQ</span>(<span class="number">0</span>, kMaxSize % <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// IJ -&gt; SiTi -&gt; ST -&gt; UV</span></span><br><span class="line">  <span class="keyword">double</span> u = <span class="built_in">max</span>(-kLimit, <span class="built_in">min</span>(kLimit, kScale * (<span class="number">2</span> * (i - kMaxSize / <span class="number">2</span>) + <span class="number">1</span>)));</span><br><span class="line">  <span class="keyword">double</span> v = <span class="built_in">max</span>(-kLimit, <span class="built_in">min</span>(kLimit, kScale * (<span class="number">2</span> * (j - kMaxSize / <span class="number">2</span>) + <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">  face = S2::<span class="built_in">XYZtoFaceUV</span>(S2::<span class="built_in">FaceUVtoXYZ</span>(face, u, v), &amp;u, &amp;v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FromFaceIJ</span>(face, S2::<span class="built_in">STtoIJ</span>(<span class="number">0.5</span>*(u+<span class="number">1</span>)), S2::<span class="built_in">STtoIJ</span>(<span class="number">0.5</span>*(v+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这个算法主要用来计算超出范围（0~2^30-1）的 IJ 对应的 id，核心思想是先将 FaceIJ 转为 XYZ，再使用 XYZ 反算得到正常的 FaceIJ，进而得到正常的 id。中间 IJ -&gt; UV 中坐标实际经过了 3 步，对于 leaf cell，IJ -&gt; SiTi 的公式为 <span class="math inline">\(Si=2×I+1\)</span>，而对于 ST -&gt; UV，这里没有采用二次变换，就是线性变换 <span class="math inline">\(u=2*s-1\)</span>，官方注释上说明用哪个变换效果都一样，所以采用最简单的就行。</p><h4 id="边邻域">边邻域</h4><p>　　边邻域代码很简单，也很好理解：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::GetEdgeNeighbors</span><span class="params">(S2CellId neighbors[<span class="number">4</span>])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="keyword">this</span>-&gt;<span class="built_in">level</span>();</span><br><span class="line">  <span class="comment">// 计算当前 level 一行或一列对应多少个 30 级的 cell（leaf cell） 2^(30-level)</span></span><br><span class="line">  <span class="keyword">int</span> size = <span class="built_in">GetSizeIJ</span>(level);</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Edges 0, 1, 2, 3 are in the down, right, up, left directions.</span></span><br><span class="line">  neighbors[<span class="number">0</span>] = <span class="built_in">FromFaceIJSame</span>(face, i, j - size, j - size &gt;= <span class="number">0</span>)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">1</span>] = <span class="built_in">FromFaceIJSame</span>(face, i + size, j, i + size &lt; kMaxSize)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">2</span>] = <span class="built_in">FromFaceIJSame</span>(face, i, j + size, j + size &lt; kMaxSize)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">3</span>] = <span class="built_in">FromFaceIJSame</span>(face, i - size, j, i - size &gt;= <span class="number">0</span>)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　分别计算当前 IJ 坐标下右上左坐标对应 id，FromFaceIJSame 表示若邻域在相同面，则走 FromFaceIJ，否则走 FromFaceIJWrap，由于这两个函数得到都是 leaf cell，要上升到指定 level，需要用到 parent 方法，即将希尔伯特曲线位置去掉右 <span class="math inline">\(2*(30-level)\)</span> 位，再组合成新的 id，位运算也很有意思：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64 <span class="title">lsb_for_level</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uint64&#123;<span class="number">1</span>&#125; &lt;&lt; (<span class="number">2</span> * (kMaxLevel - level));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> S2CellId <span class="title">S2CellId::parent</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  uint64 new_lsb = <span class="built_in">lsb_for_level</span>(level);</span><br><span class="line">  <span class="comment">// 取反加一实际是取负数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S2CellId</span>((id_ &amp; (~new_lsb + <span class="number">1</span>)) | new_lsb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="点邻域">点邻域</h4><p>　　S2 的点邻域并不是指常规意义上 4 个顶点相邻左上右上右下左下的 id，而是一种比较特殊的相邻关系，以直角坐标系 (0,0),(0,1),(1,1),(1,0) 为例，(0,0) 的点邻域为 (0,0),(0,-1),(-1,-1),(-1,0)，(0,1) 的点邻域为 (0,1),(0,2),(-1,2),(-1,1)，(1,1) 的点邻域为 (1,1),(1,2),(2,2),(2,1)，(1,0) 的点邻域为 (1,0),(1,-1),(2,-1),(2,0)。具体代码如下：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::AppendVertexNeighbors</span><span class="params">(<span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     vector&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// level &lt; this-&gt;level()</span></span><br><span class="line">  <span class="built_in">S2_DCHECK_LT</span>(level, <span class="keyword">this</span>-&gt;<span class="built_in">level</span>());</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 IJ 落在 level 对应 cell 的哪个方位？（左下左上右上右下，对应上文的(0,0),(0,1),(1,1),(1,0)坐标）</span></span><br><span class="line">  <span class="keyword">int</span> halfsize = <span class="built_in">GetSizeIJ</span>(level + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> size = halfsize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">bool</span> isame, jsame;</span><br><span class="line">  <span class="keyword">int</span> ioffset, joffset;</span><br><span class="line">  <span class="keyword">if</span> (i &amp; halfsize) &#123;</span><br><span class="line">    ioffset = size;</span><br><span class="line">    isame = (i + size) &lt; kMaxSize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ioffset = -size;</span><br><span class="line">    isame = (i - size) &gt;= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &amp; halfsize) &#123;</span><br><span class="line">    joffset = size;</span><br><span class="line">    jsame = (j + size) &lt; kMaxSize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    joffset = -size;</span><br><span class="line">    jsame = (j - size) &gt;= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">parent</span>(level));</span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + ioffset, j, isame).<span class="built_in">parent</span>(level));</span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i, j + joffset, jsame).<span class="built_in">parent</span>(level));</span><br><span class="line">  <span class="comment">// 则邻域的 IJ 与当前 cell 都不在同一个面，则说明只有三个点邻域</span></span><br><span class="line">  <span class="keyword">if</span> (isame || jsame) &#123;</span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + ioffset, j + joffset,</span><br><span class="line">                                     isame &amp;&amp; jsame).<span class="built_in">parent</span>(level));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　上面的代码算是比较清晰了，3 个点邻域的情况一般出现在当前 id 位于立方体 6 个面的角落，<em>该方法的参数 level 必须比当前 id 的 level 要小</em>。</p><h4 id="全邻域">全邻域</h4><p>　　所谓全邻域，即为当前 id 对应 cell 周围一圈 cell 对应的 id，若周围一圈 cell 的 level 与 当前 id 的 level 一样，则所求即为正常的 9 邻域。具体代码如下：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="C++"><div class="code-copy"></div><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::AppendAllNeighbors</span><span class="params">(<span class="keyword">int</span> nbr_level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  vector&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// nbr_level &gt;= level</span></span><br><span class="line">  <span class="built_in">S2_DCHECK_GE</span>(nbr_level, <span class="built_in">level</span>());</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先归一 IJ 坐标，将 IJ 坐标调整为当前 cell 左下角 leaf cell 的坐标</span></span><br><span class="line">  <span class="keyword">int</span> size = <span class="built_in">GetSizeIJ</span>();</span><br><span class="line">  i &amp;= -size;</span><br><span class="line">  j &amp;= -size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nbr_size = <span class="built_in">GetSizeIJ</span>(nbr_level);</span><br><span class="line">  <span class="built_in">S2_DCHECK_LE</span>(nbr_size, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = -nbr_size; ; k += nbr_size) &#123;</span><br><span class="line">    <span class="keyword">bool</span> same_face;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      same_face = (j + k &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= size) &#123;</span><br><span class="line">      same_face = (j + k &lt; kMaxSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      same_face = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 生成外包围圈下上两边的 id, 顺序为从左往右</span></span><br><span class="line">      output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + k, j - nbr_size,</span><br><span class="line">                                       j - size &gt;= <span class="number">0</span>).<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">      output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + k, j + size,</span><br><span class="line">                                       j + size &lt; kMaxSize).<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成外包围圈左右两边以及四个边角的 id, 顺序为从下往上</span></span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i - nbr_size, j + k,</span><br><span class="line">                                     same_face &amp;&amp; i - size &gt;= <span class="number">0</span>)</span><br><span class="line">                      .<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + size, j + k,</span><br><span class="line">                                     same_face &amp;&amp; i + size &lt; kMaxSize)</span><br><span class="line">                      .<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= size) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　知道这个函数的作用，再看代码就很明了了，<em>这个方法的参数 nbr_level 必须大于或等于当前 id 的 level</em>，因为一旦外包围圈的 cell 面积比当前 cell 还大，就无法得到正确的外包围圈。</p><h3 id="覆盖算法">覆盖算法</h3><p>　　S2 的覆盖，是指给定一块区域，能用多少 id 对应的 cell 完全覆盖该区域（GetCovering），当然也有尽量覆盖的算法（GetInteriorCovering），下面主要解析 GetCovering，因为 GetInteriorCovering 也差不多，就是覆盖策略略有不同。</p><p>GetCovering 的区域入参是 S2Region，比较典型的 S2Region 有以下几种：</p><ul><li>S2Cell：S2 id 对应的网格，会保存左下右上两个 UV 坐标，也是覆盖算法使用的基本元素；</li><li>S2CellUnion：多个 S2Cell 集合体，GetCovering 的返回值；</li><li>S2LatLngRect：经纬度矩形区域；</li><li>S2Cap：球帽区域，类比于二维圆的圆弧，球帽的构造比较奇怪，球帽的中心 S2Point 是需要，但另一个变量不是球帽的圆弧角，而是半个圆弧角（S2 代码库对应的 S1Angle 弧度，90 度代表半球，180 度代表全球）所对应弦长的平方，最大值为 4，之所以采用弦长的平方作为默认构造，是因为这就是 3 维中距离，在进行距离比较的场景时会更方便，比如测试是否包含一个 S2Point，计算覆盖多边形时，就不用再比较角度，毕竟角度计算代价比较大；</li><li>S2Loop：多边形的基本组成元素，第一个点与最后一个点隐式连接，逆时针代表封闭，顺时针代表开孔取外围区域，不允许自相交；</li><li>S2Polygon：非常正常的复杂多边形，由多个 S2Loop 构成，S2Loop 之间不能相交；</li><li>S2Polyline：一条折线，同样不能自相交；</li><li>还有些其它不常用的：S2R2Rect（S2Point 矩形区域），S2RegionIntersection（集合相交区域），S2RegionUnion（集合合并区域），……等。</li></ul><p>　　S2 覆盖算法的本质是一种启发式算法，先取满足当前条件最基本的元素，再依照条件进行迭代优化，所以该算法得到的只是一个近似最优解。GetCovering 需要依次满足以下条件：</p><ol type="1"><li>生成的 S2Cell level 不能比指定的 minLevel 小；（必须满足）</li><li>生成的 S2Cell 的个数不能比指定的 maxCells 多；（可以满足，当满足 1 时，数目已经 maxCells 多，迭代停止）</li><li>生成的 S2Cell level 不能比指定的 maxLevel 大；（必须满足）</li></ol><p>　　以上 3 个条件对应 GetCovering 的其他三个参数，当然还有一个参数是 levelModel，表示从 minLevel 向下分到 maxLevel 时，是 1 分 4，还是 1 分 16，还是 1 分 64，对应一次升 1 阶曲线，还是一次升 2 阶，或是一次升 3 阶。下面就来具体看看 GetCovering 的算法流程（代码就不贴了，太多了）：</p><ol type="1"><li>首先获取候选种子 S2Cell。先构造一个临时覆盖器，设置 maxCells 为 4，minLevel 为 0，以快速得到初始覆盖结果，做法为：先得到覆盖输入区域的 S2Cap，再用 S2CellUnion 覆盖该 S2Cap，根据 S2Cap 圆弧度计算 S2Cell 的 level，若最终 level &lt; 0，则说明 S2Cap 非常大，需要取 6 个面对应的 S2Cell，否则只需要取 S2Cap 中心点对应 S2Cell 的 level 级的点邻域 4 个 S2Cell 作为初始候选 S2Cell。</li><li>然后标准化候选种子。第一步，如果候选 S2Cell level 比 maxLevel 大或者候选 S2Cell 的 level 不符合 levelModel，则调整候选 S2Cell 的 level，用指定父级 S2Cell 来代替；第二步，归一化候选 S2Cell，先对 S2Cell 按 id 排序，去除被包含的 id，以及对 id 剪枝（若连续 4 个 S2Cell 共有同一个 parent，则用 parent 代替这 4 个 S2Cell）；第三步，反归一化候选 S2Cell，若候选 S2Cell level 比 minLevel 小或不满足 levelModel，则需要将 S2Cell 分裂，用指定级别的孩子来取代该 S2Cell；第四步，检查是否满足全部条件，若满足，则标准化完成，若不满足，则看候选 S2Cell 的数目是否足够多，若足够多，则需要迭代进行 GetCovering，这样会极大降低算法性能，若不是很多，则迭代合并相同祖先的两个 S2Cell（当然祖先的 level 不能比 minLevel 小），最后再次检查所有候选 S2Cell 是否达到标准化要求，并调整 S2Cell level。</li><li>构造优先级队列。将符合条件（与入参区域相交）的候选 S2Cell 放进一个优先级队列中，优先级会依次根据三个参数进行判断，1、S2Cell 的大小（level 越大，S2Cell 越小），越大的优先级越高；2、入参区域与候选 S2Cell 孩子相交（这里的相交是指相交但不完全包含）的个数，越少优先级越高；3、入参区域完全包含候选 S2Cell 孩子和与无法再细分的孩子的个数，同样是越少优先级越高。在构造这个优先级队列的同时，会输出一些候选 S2Cell 作为覆盖算法的正式结果，这些 S2Cell 满足任意以下条件：1、被入参区域完全覆盖；2、与入参区域相交但不可再细分；3、入参区域包含或相交全部孩子。如此留在优先级队列中的，就都是些与入参区域边界相交的 S2Cell，这些就是真正的候选 S2Cell。</li><li>最后，处理优先级队列中的 S2Cell。处理方式也比较简单粗暴，继续细分并入队，满足上面3个出队条件的任意一个，即可出队作为正式结果，当然，若分到后面可能正式的 S2Cell 太多，甚至超过 maxCells，这时不再细分强行出队作为正式结果。最后，再对正式结果做一次标准化处理，即进行第 2 步，得到最终的覆盖结果。</li></ol><p>　　以上就是 S2 覆盖算法的大致流程，更加细节的东西，还是得看代码，文字有些不是很好描述，代码里面计算候选 S2Cell 的优先级就很有意思。</p><hr><p>　　当然 S2 中还有很多其他算法（凸包，相交，距离），这里就不做太多介绍了，Shaun 平常用的最多的就是覆盖算法，之前一直没有细看，就简单用用 api，同时为了对一块大的 S2Cell 做多线程处理，需要了解 S2Cell 一分四的方向，经过这次对 S2 的了解，发现之前的用法存在一些问题，可见调包侠同样需要对包有一定的了解才能调好包 ╮(╯▽╰)╭。</p><h2 id="后记">后记</h2><p>　　正如许多经典的算法一样，看完之后总有种我上我也行的感觉，但实际完全不行，S2 全程看下来有些地方确实比较晦涩，而且这一连串的想法也很精妙（单位球立方体投影，ST 空间面积优化，64 位 id 生成等），Shaun 或许能有部分想法，但这么多奇思妙想组合起来，就完全不行。</p><h2 id="附录">附录</h2><h3 id="hilbertcurve-绘制">HilbertCurve 绘制</h3><p>　　在网上随便找了三种实现方式，并用 threejs 简单绘制了一下：</p><div class="highlight-wrap" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false" data-lang="TYPESCRIPT"><div class="code-copy"></div><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HilbertCurve</span> </span>&#123;</span><br><span class="line">    order = <span class="number">3</span>; <span class="comment">// 阶数</span></span><br><span class="line">    size = <span class="number">1</span> &lt;&lt; <span class="built_in">this</span>.order; <span class="comment">// 行列数</span></span><br><span class="line">    totalSize = <span class="built_in">this</span>.size * <span class="built_in">this</span>.size; <span class="comment">// 总网格数，希尔伯特长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://www.youtube.com/watch?v=dSK-MW-zuAc</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path = [];</span><br><span class="line">        <span class="keyword">let</span> origOrientation = [</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        ]; <span class="comment">// 倒 U 形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.totalSize; i++) &#123;</span><br><span class="line">            path.push(hilbertToXY(i, <span class="built_in">this</span>.order));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbertToXY</span>(<span class="params">i: <span class="built_in">number</span>, order: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index = i &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">let</span> curCoord = origOrientation[index].slice();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> ord = <span class="number">1</span>; ord &lt; order; ord++) &#123;</span><br><span class="line">                i = i &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">                index = i &amp; <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">let</span> delta = <span class="number">1</span> &lt;&lt; ord;</span><br><span class="line">                <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 顺时针旋转 90°</span></span><br><span class="line">                    <span class="keyword">let</span> tmp = curCoord[<span class="number">0</span>];</span><br><span class="line">                    curCoord[<span class="number">0</span>] = curCoord[<span class="number">1</span>];</span><br><span class="line">                    curCoord[<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">1</span>) &#123;</span><br><span class="line">                    curCoord[<span class="number">1</span>] += delta;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">2</span>) &#123;</span><br><span class="line">                    curCoord[<span class="number">0</span>] += delta;</span><br><span class="line">                    curCoord[<span class="number">1</span>] += delta;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 逆时针旋转 90°</span></span><br><span class="line">                    <span class="keyword">let</span> tmp = delta - <span class="number">1</span> - curCoord[<span class="number">0</span>];</span><br><span class="line">                    curCoord[<span class="number">0</span>] = delta - <span class="number">1</span> - curCoord[<span class="number">1</span>];</span><br><span class="line">                    curCoord[<span class="number">1</span>] = tmp;</span><br><span class="line">                    curCoord[<span class="number">0</span>] += delta;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> curCoord;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hacker&#x27;s Delight</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path: <span class="built_in">number</span>[][] = [];</span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>,</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="number">0</span>; <span class="comment">// along the curve</span></span><br><span class="line"></span><br><span class="line">        step(<span class="number">0</span>);</span><br><span class="line">        hilbert(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">this</span>.order);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">dir: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (dir &amp; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    x += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    y += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    x -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    y -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path[s] = [x, y];</span><br><span class="line"></span><br><span class="line">            s += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbert</span>(<span class="params">dir: <span class="built_in">number</span>, rot: <span class="built_in">number</span>, order: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (order === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            dir += rot;</span><br><span class="line">            hilbert(dir, -rot, order - <span class="number">1</span>);</span><br><span class="line">            step(dir);</span><br><span class="line"></span><br><span class="line">            dir -= rot;</span><br><span class="line">            hilbert(dir, rot, order - <span class="number">1</span>);</span><br><span class="line">            step(dir);</span><br><span class="line"></span><br><span class="line">            hilbert(dir, rot, order - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            dir -= rot;</span><br><span class="line">            step(dir);</span><br><span class="line">            hilbert(dir, -rot, order - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.wikipedia.org/wiki/Hilbert_curve</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path: <span class="built_in">number</span>[][] = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (let i = 0; i &lt; this.totalSize; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     path.push(hilbertToXY(this.size, i));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; <span class="built_in">this</span>.size; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="built_in">this</span>.size; x++) &#123;</span><br><span class="line">                path[xyToHilbert(<span class="built_in">this</span>.size, x, y)] = [x, y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">rot</span>(<span class="params">N: <span class="built_in">number</span>, rx: <span class="built_in">number</span>, ry: <span class="built_in">number</span>, xy: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ry === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rx === <span class="number">1</span>) &#123;</span><br><span class="line">                    xy[<span class="number">0</span>] = N - <span class="number">1</span> - xy[<span class="number">0</span>];</span><br><span class="line">                    xy[<span class="number">1</span>] = N - <span class="number">1</span> - xy[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> t = xy[<span class="number">0</span>];</span><br><span class="line">                xy[<span class="number">0</span>] = xy[<span class="number">1</span>];</span><br><span class="line">                xy[<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbertToXY</span>(<span class="params">N: <span class="built_in">number</span>, h: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> t = h;</span><br><span class="line">            <span class="keyword">let</span> xy = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> s = <span class="number">1</span>; s &lt; N; s *= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> rx = <span class="number">1</span> &amp; (t / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">let</span> ry = <span class="number">1</span> &amp; (t ^ rx);</span><br><span class="line">                rot(s, rx, ry, xy);</span><br><span class="line">                xy[<span class="number">0</span>] += s * rx;</span><br><span class="line">                xy[<span class="number">1</span>] += s * ry;</span><br><span class="line">                t /= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> xy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">xyToHilbert</span>(<span class="params">N: <span class="built_in">number</span>, x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> xy = [x, y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> s = N / <span class="number">2</span>; s &gt; <span class="number">0</span>; s /= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> rx = (xy[<span class="number">0</span>] &amp; s) &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">let</span> ry = (xy[<span class="number">1</span>] &amp; s) &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                h += s * s * ((<span class="number">3</span> * rx) ^ ry);</span><br><span class="line">                rot(N, rx, ry, xy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> lineGeometry = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line">        <span class="built_in">this</span>.getPath_V3().forEach(<span class="function">(<span class="params">vertice</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> vecot = <span class="keyword">new</span> THREE.Vector3().fromArray(vertice);</span><br><span class="line">            vecot.setZ(<span class="number">0</span>);</span><br><span class="line">            lineGeometry.vertices.push(vecot);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> lineMaterial = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ffff</span>, <span class="attr">linewidth</span>: <span class="number">1</span> &#125;);</span><br><span class="line">        <span class="keyword">let</span> line = <span class="keyword">new</span> THREE.Line(lineGeometry, lineMaterial);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></section></article><div class="copyright"><p><span>本文标题：</span> <a href="/posts/720275bd.html">Google S2 Geometry 浅解</a></p><p><span>文章作者：</span> <a href="/" title="访问 Shaun 的个人博客" data-toggle="tooltip">Shaun</a></p><p><span>发布时间：</span> 2021年09月19日 - 16时21分</p><p><span>最后更新：</span> 2021年12月18日 - 19时54分</p><p><span>原始链接：</span> <a class="post-url" href="/posts/720275bd.html" title="Google S2 Geometry 浅解" data-toggle="tooltip">http://cniter.github.io/posts/720275bd.html </a><span class="copy-path" data-clipboard-text="原文: http://cniter.github.io/posts/720275bd.html　　作者: Shaun" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span></p><p><span>许可协议：</span> <i class="fa fa-creative-commons"></i> <a rel="license noopener" target="_blank" href="//creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)" target="_blank" data-toggle="tooltip">"署名-非商业性使用-相同方式共享 4.0 国际" </a>转载请保留原文链接及作者。</p></div><nav id="article-nav"><a href="/posts/9c9b4035.html" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">&lt;</strong><div class="article-nav-title">&nbsp; Scala 多线程编程小结</div></a><a href="/posts/55e674ff.html" id="article-nav-older" class="article-nav-link-wrap"><div class="article-nav-title">K8S 应用开发指北 &nbsp;</div><strong class="article-nav-caption">&gt;</strong></a></nav><div class="bdsharebuttonbox"><a href="#" class="fx fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-weixin bds_weixin" data-cmd="weixin" title="分享到微信" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-qq bds_sqq" data-cmd="sqq" title="分享到QQ好友" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-facebook-official bds_fbook" data-cmd="fbook" title="分享到Facebook" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-twitter bds_twi" data-cmd="twi" title="分享到Twitter" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-linkedin bds_linkedin" data-cmd="linkedin" title="分享到linkedin" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-files-o bds_copy" data-cmd="copy" title="复制网址" data-toggle="tooltip"></a> <a href="#" class="fx fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享" data-toggle="tooltip"></a></div><script>with(window._bd_share_config={common:{bdSnsKey:{},bdText:"Google S2 Geometry 浅解 | Shaun's Space",bdMini:"2",bdMiniList:!1,bdPic:"",bdStyle:"2",bdSize:"24"},share:{}},document)(getElementsByTagName("head")[0]||body).appendChild(createElement("script")).src="/plugins/baidushare/static/api/js/share.js"+"?v=89860593.js?cdnversion="+~(-new Date/36e5)</script><div id="comments" class="div-border"><script src="https://giscus.app/client.js" data-repo="cniter/cniter.github.io" data-repo-id="MDEwOlJlcG9zaXRvcnkxMTQ0NjAxMDc=" data-category="Announcements" data-category-id="DIC_kwDOBtKFy84CkXvq" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="https://cniter.github.io/css/giscus-chi.css" data-lang="zh-CN" data-loading="lazy" crossorigin="anonymous" async></script></div><script>let articleToc='<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">坐标篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#s2latlng-%E5%9D%90%E6%A0%87"><span class="toc-number">2.1.</span> <span class="toc-text">S2LatLng 坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#s2point-%E5%9D%90%E6%A0%87"><span class="toc-number">2.2.</span> <span class="toc-text">S2Point 坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#faceuv-%E5%9D%90%E6%A0%87"><span class="toc-number">2.3.</span> <span class="toc-text">FaceUV 坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#facest-%E5%9D%90%E6%A0%87"><span class="toc-number">2.4.</span> <span class="toc-text">FaceST 坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#faceij-%E5%9D%90%E6%A0%87"><span class="toc-number">2.5.</span> <span class="toc-text">FaceIJ 坐标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#s2cellid"><span class="toc-number">2.6.</span> <span class="toc-text">S2CellId</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hilbertcurve"><span class="toc-number">2.6.1.</span> <span class="toc-text">HilbertCurve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#s2id"><span class="toc-number">2.6.2.</span> <span class="toc-text">S2Id</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#facesiti-%E5%9D%90%E6%A0%87"><span class="toc-number">2.7.</span> <span class="toc-text">FaceSiTi 坐标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">算法篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E5%9F%9F%E7%AE%97%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">邻域算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E9%82%BB%E5%9F%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">边邻域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%82%B9%E9%82%BB%E5%9F%9F"><span class="toc-number">3.1.2.</span> <span class="toc-text">点邻域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E9%82%BB%E5%9F%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">全邻域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">覆盖算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E8%AE%B0"><span class="toc-number">4.</span> <span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95"><span class="toc-number">5.</span> <span class="toc-text">附录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hilbertcurve-%E7%BB%98%E5%88%B6"><span class="toc-number">5.1.</span> <span class="toc-text">HilbertCurve 绘制</span></a></li></ol></li></ol>';$(window).on("load",(function(){$(".toc-title").text("文章目录"),$(".post-list").replaceWith(articleToc);var s=$("#toc .toc-item:has(> .toc-child)"),c=s.children(".toc-link");s.prepend("<i class='fa fa-caret-down'></i><i class='fa fa-caret-right'></i>");$(".toc-item > .fa-caret-down");var l=$(".toc-item > .fa-caret-right");l.addClass("hide");$("#toc .toc-item > i").click((function(){$(this).siblings(".toc-child").slideToggle(100),$(this).toggleClass("hide"),$(this).siblings("i").toggleClass("hide")})),$(".toc-item > .fa-caret-down");l.addClass("hide");c.dblclick((function(){$(this).siblings(".toc-child").hide(100),$(this).siblings("i").toggleClass("hide")})),c.click((function(){var s=$(this).siblings(".toc-child");s.is(":hidden")&&(s.show(100),$(this).siblings("i").toggleClass("hide"))})),function(){var s=$(".toc-item > .fa-caret-right"),l=$(".toc-item > .fa-caret-down"),a=c.next(".toc-child"),t=$("#toc .toc-title");c.length&&(t.addClass("clickable"),t.click((function(){a.is(":hidden")?(a.show(150),s.removeClass("hide"),l.addClass("hide")):(a.hide(100),s.addClass("hide"),l.removeClass("hide"))})))}()}))</script></main><div id="site-tool"><div class="scroll"><a href="#header"><i class="fa fa-arrow-up"></i></a> <a href="#footer"><i class="fa fa-arrow-down"></i></a></div><div></div></div><aside id="right-col" class="col-lg-3 col-sm-12"><div id="sidebar-sticky--bottom"></div><div id="sidebar"><header class="author-info div-border"><a href="/"><img class="header-avatar" src="/img/avatar.jpg"></a><h1 class="header-author"><a href="/" title="Hi Mate" data-toggle="tooltip">Shaun</a></h1><p class="header-slogan">求知！ 视界！ 未来！ ↖(^ω^)↗</p><div class="social-info"><a class="social-icon" target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" title="envelope" data-toggle="tooltip"><i class="fa fa-envelope" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="https://github.com/cniter" title="github" data-toggle="tooltip"><i class="fa fa-github" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="/atom.xml" title="rss" data-toggle="tooltip"><i class="fa fa-rss" aria-hidden="true"></i> </a><a class="social-icon" target="_blank" href="http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12" title="qq" data-toggle="tooltip"><i class="fa fa-qq" aria-hidden="true"></i></a></div></header><div class="search div-border" title="搜索" data-toggle="tooltip"><form id="search-form"><input type="text" id="local-search--input" name="q" results="0" placeholder=" Search..." autocomplete="off" autocorrect="off"> <i class="fa fa-times" onclick="resetSearch()"></i></form><div id="local-search--result"></div><p class="no-result">No results found</p></div><div id="tagcloud" class="tagcanvas div-border" title="标签" data-toggle="tooltip"><canvas width="200" height="200" id="tagcloud-canvas"><p>Anything in here will be replaced on browsers that support the canvas element</p><ul><li><a href="/tags/algorithm/" data-weight="8">algorithm</a></li><li><a href="/tags/android/" data-weight="2">android</a></li><li><a href="/tags/bigdata/" data-weight="2">bigdata</a></li><li><a href="/tags/c-cpp/" data-weight="6">c/cpp</a></li><li><a href="/tags/clustering/" data-weight="1">clustering</a></li><li><a href="/tags/container/" data-weight="1">container</a></li><li><a href="/tags/css/" data-weight="1">css</a></li><li><a href="/tags/cv/" data-weight="5">cv</a></li><li><a href="/tags/devtool/" data-weight="1">devtool</a></li><li><a href="/tags/ffmpeg/" data-weight="1">ffmpeg</a></li><li><a href="/tags/geomesa/" data-weight="1">geomesa</a></li><li><a href="/tags/geometry/" data-weight="4">geometry</a></li><li><a href="/tags/gfw/" data-weight="1">gfw</a></li><li><a href="/tags/github/" data-weight="1">github</a></li><li><a href="/tags/gl/" data-weight="1">gl</a></li><li><a href="/tags/golang/" data-weight="2">golang</a></li><li><a href="/tags/hexo/" data-weight="8">hexo</a></li><li><a href="/tags/http/" data-weight="1">http</a></li><li><a href="/tags/integration/" data-weight="1">integration</a></li><li><a href="/tags/java/" data-weight="2">java</a></li><li><a href="/tags/k8s/" data-weight="1">k8s</a></li><li><a href="/tags/language/" data-weight="3">language</a></li><li><a href="/tags/latex/" data-weight="1">latex</a></li><li><a href="/tags/mapbox/" data-weight="1">mapbox</a></li><li><a href="/tags/markdown/" data-weight="1">markdown</a></li><li><a href="/tags/matlab/" data-weight="2">matlab</a></li><li><a href="/tags/network/" data-weight="1">network</a></li><li><a href="/tags/note/" data-weight="7">note</a></li><li><a href="/tags/numerical/" data-weight="1">numerical</a></li><li><a href="/tags/opencv/" data-weight="11">opencv</a></li><li><a href="/tags/opendrive/" data-weight="1">opendrive</a></li><li><a href="/tags/opengl/" data-weight="1">opengl</a></li><li><a href="/tags/python/" data-weight="1">python</a></li><li><a href="/tags/qt/" data-weight="2">qt</a></li><li><a href="/tags/record/" data-weight="14">record</a></li><li><a href="/tags/search/" data-weight="1">search</a></li><li><a href="/tags/segmentation/" data-weight="2">segmentation</a></li><li><a href="/tags/tensorflow/" data-weight="1">tensorflow</a></li><li><a href="/tags/thought/" data-weight="3">thought</a></li><li><a href="/tags/unix-like/" data-weight="3">unix-like</a></li><li><a href="/tags/vscode/" data-weight="1">vscode</a></li></ul></canvas><script src="/plugins/TagCanvas/jquery.tagcanvas.min.js" type="text/javascript"></script><script type="text/javascript">$(document).ready((function(){$("#tagcloud-canvas").tagcanvas({initial:[.1,-.1],activeCursor:'url("/img/cursor/link.cur"), auto',reverse:!0,depth:.75,weight:!0,weightFrom:"data-weight",weightMode:"both",weightSizeMin:15,weightSizeMax:50})||$("#tagcloud").hide()}))</script></div><div class="friends div-border" title="友链" data-toggle="tooltip"><a target="_blank" class="friends-link" href="https://cniter.github.io">Shaun&#39;s Space</a></div><div class="revolvermaps div-border" title="访客" data-toggle="tooltip"><script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;m=7&amp;c=ff0000&amp;cr1=ffffff&amp;f=arial&amp;l=49" defer></script></div></div><div class="toc-card"><div class="toc-card--head"><i class="fa fa-angle-up" aria-hidden="true"></i></div><div id="toc" class="toc-card--content"><strong class="toc-title">文章列表</strong><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/36b343ff.html">HTTP 超时浅见</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6be57d7f.html">关于中学的学习方法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/619020f7.html">VNSWRR 算法浅解</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2eb69b33.html">记一次资源不释放的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dbbe01e5.html">社畜三年，风雨兼程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8e1d1e1d.html">2021 年小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4b1f50ff.html">M1 个人配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9c9b4035.html">Scala 多线程编程小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/720275bd.html">Google S2 Geometry 浅解</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/55e674ff.html">K8S 应用开发指北</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/81321445.html">OpenGL坐标系统与渲染管线</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8d3d87a2.html">Scala 学习小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/28416d7c.html">2020年小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b59e3e7b.html">Linux服务器运维文档</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/489fa7b3.html">时空查询之ECQL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9978824c.html">GeoMesa踩坑指北</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3692cd6.html">IDEA使用Docker环境开发调试</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/af5e9ace.html">大数据环境搭建笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ae780057.html">设计模式浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/eee1c041.html">积分计算</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a5661762.html">Geometry增量更新</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e225d8fd.html">Mapbox显示GeoServer地图</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3d8ab974.html">Docker使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6694a214.html">空间中三角形与三角形相交</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5315fcfd.html">计算几何基础</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b7d79231.html">OpenDrive解析小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/39a3c99e.html">一张纹理做天空盒</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a250bb21.html">Windows Terminal 尝鲜小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ae5f9dce.html">读大学</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cf97ba7c.html">2019，既是结束又是开始</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ff29de94.html">快速判断三角形与长方体相交</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70a807da.html">网页菜单纯 css 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/abe58f8c.html">个人游记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/26d437be.html">hexo-theme-chi主题更新小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3578e309.html">［译］为什么深度学习没有取代传统的计算机视觉</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/37b89a23.html">再也不见，18年</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ac4679b5.html">hexo-theme-chi主题开发小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/64889158.html">Matlab和OpenCV混合编程小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be7949e4.html">Android实践小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fc1165b7.html">C++数组中的坑</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cafdd60d.html">Android开发环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/27a4c8b6.html">Windows实用技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6315717b.html">FFmpeg提取与合并命令使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fd823bf9.html">解决VSCode使用Cmder作为默认终端问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fddd1e17.html">图割算法之NCuts浅见</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c42ff8d4.html">图割算法之Graph Cuts浅见</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b93d943b.html">C++中static用法小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8fb9f004.html">斐波那契数列的三种写法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bcdf334e.html">LaTex语法指北</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/982ff584.html">搜索技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7cebf0ee.html">17年走了，18年来了</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e124baa1.html">矩阵的应用之图像仿射变换</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aef52be2.html">本人常用小工具安利</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/376168c6.html">解决无法打开某个网页问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5f54aa2c.html">PyQt5使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/82d3b275.html">TensorFlow Object Detection API使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2a3d46b0.html">C语言中整型提升问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dece8eba.html">TXT数据转OpenCV中的Mat数据</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e8b35736.html">OpenCV中滑动条和鼠标事件响应操作的使用小结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b6fb6109.html">利用回调函数计算函数运行时间</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df943c4f.html">论如何科学的上网</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b1e9411b.html">Hexo的SPFK主题修改小记</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/22c3daf1.html">解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/509ee93b.html">解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3bc0decc.html">Hexo添加各种小部件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fd0f8195.html">OpenCV中显著性检测算法的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/35132cb7.html">OpenCV中Selective Search算法的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/170c76cc.html">别了，漆黑的象牙塔</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c3f26b1.html">Win10以树形结构显示文件目录结构</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/68065b99.html">ACGN作品个人印象简评</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4f6225b7.html">Hexo添加站内本地搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/302a6244.html">用OpenCV显示OpenGL图形</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7df528b4.html">Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17017530.html">MyThoughts</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7d5bc07b.html">解决写上篇文档“Hexo+GitHub搭建个人博客”遇到的问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d7965b48.html">Hexo+GitHub搭建个人博客</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4a17b156.html">Hello World</a></li></ul></div></div></aside></div></div><span id="cursor-trail"></span> <span class="click-halo"></span><footer id="footer" class="text-center"><div class="copyright-info">&copy; 2017 - 2024 <a href="/">Shaun</a></div><span class="site-visitor"><i class="fa fa-user-o" aria-hidden="true"></i> <span id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></span> &nbsp;|&nbsp; <i class="fa fa-eye" aria-hidden="true"></i> <span id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i></span> &nbsp;|&nbsp; <i class="fa fa-hand-o-up" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span></span><div class="site-info"><a href="http://hexo.io/" target="_blank">Hexo </a>theme <a href="https://github.com/cniter/hexo-theme-chi" target="_blank">Chi </a>by <a href="https://github.com/cniter" target="_blank">Shaun</a></div></footer><script type="text/javascript" async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML" integrity="sha256-WUED7NFzpsmHtLO7bswSz4JSfkhE+cD4ncKeOznwFSY=" crossorigin="anonymous"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }

        , TeX: {
            extensions: ["extpfeil.js"]
        }
    });
    
    MathJax.Hub.Queue(function() {
        let all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';                 
        }       
    });</script><script type="text/javascript">const MutationObserver=window.MutationObserver||window.WebKitMutationObserver||window.MozMutationObserver,config={attributes:!0,childList:!0,characterData:!0};let target=document.querySelector("#local-search--result"),$local_search_result=$("#local-search--result"),$no_result=$(".no-result"),observer=new MutationObserver((function(e){e.forEach((function(e){$local_search_result.text()||""==$local_search_result.html()?$no_result.hide():$no_result.show(200)}))})),inputArea=document.querySelector("#local-search--input"),getSearchFile=function(){let e="search.xml";0==e.length&&(e="search.xml"),searchFunc("/"+e,"local-search--input","local-search--result"),observer.observe(target,config)};inputArea.onfocus=function(){getSearchFile()};let $resetButton=$("#search-form .fa-times"),$resultArea=$("#local-search--result");inputArea.oninput=function(){$resetButton.show()};let resetSearch=function(){$resultArea.html(""),document.querySelector("#search-form").reset(),$resetButton.hide(),$no_result.hide(),observer.disconnect()};inputArea.onkeydown=function(e){if(13==e.keyCode)return!1};let searchFunc=function(e,t,r){"use strict";$.ajax({url:e,dataType:"xml",success:function(e){let n=$("entry",e).map((function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}})).get(),l=document.getElementById(t),s=document.getElementById(r);l.addEventListener("input",(function(){let e='<ul class="search-result--list">',t=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length<=0||(n.forEach((function(r){let n=!0,l=r.title.trim().toLowerCase(),s=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),c=r.url,o=-1,a=-1,u=-1;if(""!=l&&""!=s&&t.forEach((function(e,t){o=l.indexOf(e),a=s.indexOf(e),o<0&&a<0?n=!1:(a<0&&(a=0),0==t&&(u=a))})),n){e+="<li><a href='"+c+"' class='search-result--title' target='_blank'>> "+l+"</a>";let n=r.content.trim().replace(/<[^>]+>/g,"");if(u>=0){let r=u-6,l=u+6;r<0&&(r=0),0==r&&(l=10),l>n.length&&(l=n.length);let s=n.substr(r,l);t.forEach((function(e){let t=new RegExp(e,"gi");s=s.replace(t,'<em class="search-keyword">'+e+"</em>")})),e+='<p class="search-result">'+s+"...</p>"}}})),s.innerHTML=e)}))}})}</script><script>function loadScript(e,t){let a=document.createElement("script");a.type="text/javascript",a.async=!0,a.readyState?a.onreadystatechange=function(){"loaded"!=a.readyState&&"complete"!=a.readyState||(a.onreadystatechange=null,t())}:a.onload=function(){t()},a.src=e,document.getElementsByTagName("body")[0].appendChild(a)}</script><script type="module" src="/js/main.js"></script><script>$(document).ready((function(){$("del").attr("title","你知道的太多了ヾ(▼ﾍ▼；) (#｀皿´メ)"),$(".toc-card").width($("#right-col").width()),$("a.footnote-ref").each((function(t,e){let i=$(this).parents("article").attr("id"),o=$(this).attr("href");e.setAttribute("data-toggle","tooltip"),e.setAttribute("data-html","true"),e.setAttribute("title",$("#"+i+" "+o).html())})),setInterval(()=>{$("#site-bg").fadeTo(1e3,.1,()=>{$("#site-bg").css("background-image",'url("/img/site-bg/bg-'+Math.floor(8*Math.random())+'.jpg")')}),$("#site-bg").fadeTo(2e3,.2)},3e4),siteBgElem=document.getElementById("site-bg"),siteBgElem&&siteBgElem.clientWidth>0&&siteBgElem.clientHeight>0&&loadScript("/js/widget/canvas-nest.js",()=>{new CanvasNest(siteBgElem,{opacity:1,pointColor:"255,255,0",color:"255,255,0",count:30})})})),$(window).on("load",(function(){$("#sidebar-sticky--bottom").height($("#right-col").height()-$("#sidebar").height()-$("#footer").height())})),$((function(){$("[data-toggle='tooltip']").tooltip()}))</script></body></html>