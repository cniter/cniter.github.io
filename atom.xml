<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shaun&#39;s Space</title>
  
  <subtitle>求知！ 视界！ 未来！ ↖(^ω^)↗</subtitle>
  <link href="http://cniter.github.io/atom.xml" rel="self"/>
  
  <link href="http://cniter.github.io/"/>
  <updated>2022-02-20T10:00:20.129Z</updated>
  <id>http://cniter.github.io/</id>
  
  <author>
    <name>Shaun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021 年小结</title>
    <link href="http://cniter.github.io/posts/8e1d1e1d.html"/>
    <id>http://cniter.github.io/posts/8e1d1e1d.html</id>
    <published>2022-02-20T01:46:12.000Z</published>
    <updated>2022-02-20T10:00:20.129Z</updated>
    
    <content type="html"><![CDATA[<p>　　纵观宇宙史，生物史，人之一生，不过沧海一粟，弹指灰飞，若有重来，何必重来。人生一字，莫过于拼，为私欲者有之，为利他者有之，为后代者有之，为权利者有之，为名声者有之，为理想者有之，。。。不拼之人，难存于世，众生皆苦，苦中作乐。　　——鲁迅没说过文集</p><span id="more"></span><h2 id="前言">前言</h2><p>　　21 年，工作上第一阶段的目标算是提前半年完成了，非常感谢前领导的赏识，至于生活上第一阶段的目标感觉还是遥遥无期。</p><h2 id="工作篇">工作篇</h2><p>　　21 年，同样一直在学习，感觉全年都在用新事物完成工作，从学习 Scala，Go 到 OSS，K8S，再到熟悉 macOS，Vim。用这些新学的东西从 0 到 1 完成了一个半项目，一个项目是地图切片系统，将 GIS 数据以 S2 网格的形式进行重新分组管理，这个系统算是优化到了 Shaun 能优化的极致，内存和性能之间达成的 trade-off，单机版可以最大程度的利用多核 CPU，集群版同样可以充分发挥多台机器的作用，这个项目算是 Shaun 花大力气做的第二个项目了，同样的满意与自豪，希望能继续发光发热。至于那半个项目，只能说是开了个头，算是 shp 数据的版本管理系统，支持正常的 CRUD，空间查询以及分析能力，初步的属性和几何信息版本管理，这个项目没有做完，算是留下了一点小遗憾。不过 22 年再回过头去看，继续做下去的话，会碰到很多难点，有些问题，对 21 年的 Shaun 来说可能是无解的，甚至可能是导致项目做不下去的关键问题。</p><p>　　21 年，人生中第一次跳槽，要说原因，可能也就是想换个环境，接触不同的人，当然也有一部分钱的原因，更重要的还是想出来看看，看看其他的一些流程方案，加快自己的成长速度，正如 Shaun 在学生时代说的，换个环境能使人成长的更快。确实，跳槽了之后能明显感觉到自己做事的一些变化，每个环境对人的要求是不一样的，不谈孰高孰低，只是不同的方面而已，综合这些方面，才能更好的应对后续碰到的一些困难以及有更好的发展前途。</p><p>　　21 年，工作上最大的收获不是做了多少项目，学了多少新技术，更不是跳槽涨了多少薪，而是跳槽后心态和做事方面的一些转变。以前虽然嘴上说着社畜社畜，但总还是一种学生心态，年轻气盛（年轻人不气盛还叫年轻人吗 ๑乛◡乛๑ ），做事钻牛角尖，只想尽最大的努力做好一件事，一心多用就比较烦躁，有时也大手大脚的，还好是 toB 的行业，有足够的时间来打磨和优化，也是真的感谢前领导的赏识和放任。跳槽之后，感觉自己做事的心态一下就放开了。在新公司，学到了一个新词语——确定性。</p><p>　　向上管理又同时不唯上，却是不简单，保障确定性就是一种比较好的做法，所谓的确定性就是能够完全把控一件自己负责的事。确定性，说到底也就是数据，有些什么事，分别是什么，分别有多少，工作量多少，计划排期，现在的进度，剩余情况，预期情况，风险情况，牵扯的上下游安排，碰到的问题与困难，可能的解决方案。并不是说一定要有阶段性的成果才算确定性，每次汇报，都能把上面这些问题说清楚，也是一种确定性，能够确定这些东西也是自己能力的一种体现。领导关心的也是这些数据，向上负责，同时也是对工作负责，对自己负责。</p><h2 id="生活篇">生活篇</h2><p>　　对目前的 Shaun 来说，生活和工作基本没啥区别，工作在 Coding，生活有时也会 Coding，唯一的区别在于，工作是为了生存，生活是为了兴趣。生活算是工作之余的放松，所以关于生活能写的确实不多。</p><p>　　21 年，虽然疫情还在持续，但常年待在租房里还是有一些出去玩的冲动，遂去了一趟西湖，人确实很多，风景也没有让人耳目一新的感觉，有点名不副实了，还没有旁边的龙井村好玩，杭州的交通也是一场不太美好的出行体验。出去玩，主要是为了散心，这个目的算是达到了。</p><p>　　21 年，本来想去一趟黄山的，但由于自己懒得动，还是没去成，这不得不说是一种遗憾了，换了个城市，再想提起勇气去，就不知道是猴年马月了。换城市这件事，Shaun 也认真思考过，代价确实比较大，或许将来有一天，Shaun 会因为这个决定后悔，当然也或许不会，Shaun 一贯的认知就是有钱在哪都舒服，没钱在哪都难受，最终还是 follow my heart，决定趁着年轻，多出去看看，毅然决然的走出过去两年多舒适的工作和生活环境，来到这个陌生的环境重新开始，这件事，算是为平淡的生活增加了些许起伏。</p><p>　　刚来到新城市，虽然觉得一切都比较新鲜，但还是被新城市恶劣的天气环境给搞的很不爽，不过还算运气不错，只看了一家就找到了 Shaun 还算满意的房子，新城市的房租确实要高一些，而且中介费居然要一个月的房租，这着实是有些高。新城市的防疫政策对底层打工人没有丁点儿人文关怀，部分小区的看门大爷是真大爷，就像菜鸟程序员写的低级 robot，逻辑写的死死的。防疫软件也是垃圾中的战斗机，纳税人的血汗钱也不知道有多少进了个人口袋。</p><p>　　理财方面也开始接触一些更专业的知识，国内金融从业资格考试主要有四个：证券从业资格考试，基金从业资格考试，银行从业资格考试，期货从业资格考试，都有对应的统编教材，并不是说要一定通过这几个考试，而是可以从这几门考试中，对国内金融市场有一定的认识，不是完全的小白（<em>真要参加考试的话可以看看这个 <a href="https://www.zhihu.com/question/27618901/answer/269242670">证券资格证考试要准备多久？</a> ，刷题的话就找个 app 就行，<strong>刷题学习法</strong> 😅</em>），一般看完前两个从业资格的备考资料就差不多了，有个基础的认识，后期的交易策略或计划就只能根据个人的情况慢慢摸索了。至于 21 年的理财成果就不是很好了，把 20 年赚的又亏回去了，主要是出于 20 年的乐观心态，觉得互联网还能再涨点，就一直没卖，没想到 21 年的国家政策对互联网这么不友好，想要挣钱，还是得跟着政策走 ¯\_(ツ)_/¯。</p><h2 id="总结">总结</h2><p>　　前路漫漫，不问对错，不求利弊。每个公司做事的风格是不一样的，这种差异性才是需要学习的地方，也是能让人快速成长的基础。年纪越大，越觉得人生若只如初见是一种奢侈。独行备艰难，莫忘守初心。</p><div style="text-align:center; font-family: Allura, Consolas, Helvetica, Tahoma, Arial, Microsoft YaHei, 微软雅黑, SimSun, 宋体, Heiti, 黑体, sans-serif; font-size:1.3em; color:#4094c3; font-weight:700; margin:.5em auto;">21 年获得技能：<strong><em>学无止境</em></strong><br />21 年获得成就：<strong><em>重新开始</em></strong></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　纵观宇宙史，生物史，人之一生，不过沧海一粟，弹指灰飞，若有重来，何必重来。人生一字，莫过于拼，为私欲者有之，为利他者有之，为后代者有之，为权利者有之，为名声者有之，为理想者有之，。。。不拼之人，难存于世，众生皆苦，苦中作乐。　　——鲁迅没说过文集&lt;/p&gt;</summary>
    
    
    
    <category term="Life" scheme="http://cniter.github.io/categories/Life/"/>
    
    
    <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>M1 个人配置</title>
    <link href="http://cniter.github.io/posts/4b1f50ff.html"/>
    <id>http://cniter.github.io/posts/4b1f50ff.html</id>
    <published>2022-02-06T02:21:28.000Z</published>
    <updated>2022-02-20T10:00:20.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　记录一下 Shaun 个人的 Mac 装机配置。</p><span id="more"></span><h2 id="iterm2">iTerm2</h2><p>　　下载安装 <a href="https://iterm2.com/">iTerm2</a>，默认 shell 就是 zsh，所以不需要安装。</p><p>　　安装 <a href="https://github.com/ohmyzsh/ohmyzsh#basic-installation">Oh My Zsh</a>，github 上的命令在国内可能无法顺利执行，先 clone 下来，手动执行 <code>sh tools/install.sh</code>。</p><p>　　安装 <a href="https://github.com/romkatv/powerlevel10k/#oh-my-zsh">Powerlevel10k</a> 之前，先安装 <a href="https://www.nerdfonts.com/font-downloads">nerd font 字体</a>，Shaun 个人还是比价喜欢 Fira Code 字体，所以就选择下载 Fira Code Nerd Font 字体，只需要安装 <code>Fira Code Retina Nerd Font Complete.ttf</code> 即可。设置 iTerm2 字体为 FiraCode Nerd Font。</p><p>　　随后开始安装 Powerlevel10k，安装完之后重启 iTerm2，会有 Powerlevel10k 的配置提问，依次回答（有推荐按推荐）完成即可配置好 Powerlevel10k，若后续想修改配置，可直接编辑 <code>~/.p10k.zsh</code> 文件或使用 <code>p10k configure</code> 命令重新回答配置提问。最后在 zsh 的配置文件 <code>~/.zshrc</code> 中设置 <code>ZSH_THEME=powerlevel10k/powerlevel10k</code>。</p><p>　　推荐安装 zsh 插件 <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a> 和 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a>，在执行完</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></div><p>后修改 ~/.zshrc 的 plugins 值，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plugins=( </span><br><span class="line">    git</span><br><span class="line">    zsh-syntax-highlighting</span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    # other plugins...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div><h2 id="vscode">VSCode</h2><p>　　VSCode 同样需要设置终端字体为 <code>FiraCode Nerd Font</code>，在终端中进入 Downloads 目录执行 <code>mv Visual\ Studio\ Code.app /Applications</code> 命令，将 VSCode 放进 应用程序 中，再执行 sudo ln -s "/Applications/Visual Studio Code.app/Contents/Resources/app/bin/code" /usr/local/bin/code，之后可在终端使用命令（<code>code .</code>）直接打开 VSCode。</p><h2 id="homebrew">Homebrew</h2><p>　　直接执行：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install.sh)&quot;</span><br><span class="line"></span><br><span class="line">echo &#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27; &gt;&gt; ~/.zprofile</span><br><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure></div><p>安装完成后先检查目录 <code>/opt/homebrew/Library/Taps/homebrew/homebrew-cask</code> 是否存在，若不存在，则执行：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /opt/homebrew/Library/Taps/homebrew/</span><br><span class="line">git clone https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure></div><p>　　最后设置中科大源：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles/bottles&#x27; &gt;&gt; ~/.zprofile</span><br><span class="line">source ~/.zprofile</span><br></pre></td></tr></table></figure></div><h2 id="aria2">Aria2</h2><p>　　直接使用命令 <code>brew install aria2</code> 安装，生成配置文件：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br><span class="line">mkdir .aria2</span><br><span class="line">cd .aria2</span><br><span class="line">touch aria2.conf</span><br></pre></td></tr></table></figure></div><p>　　打开 Finder，通过 Shift+Cmd+G 进入路径：~/.aria2/，编辑文件 <code>aria2.conf</code>，添加以下内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#用户名</span><br><span class="line">#rpc-user=user</span><br><span class="line">#密码</span><br><span class="line">#rpc-passwd=passwd</span><br><span class="line">#上面的认证方式不建议使用,建议使用下面的token方式</span><br><span class="line">#设置加密的密钥</span><br><span class="line">#rpc-secret=token</span><br><span class="line">#允许rpc</span><br><span class="line">enable-rpc=true</span><br><span class="line">#允许所有来源, web界面跨域权限需要</span><br><span class="line">rpc-allow-origin-all=true</span><br><span class="line">#允许外部访问，false的话只监听本地端口</span><br><span class="line">rpc-listen-all=true</span><br><span class="line">#RPC端口, 仅当默认端口被占用时修改</span><br><span class="line">#rpc-listen-port=6800</span><br><span class="line">#最大同时下载数(任务数), 路由建议值: 3</span><br><span class="line">max-concurrent-downloads=5</span><br><span class="line">#断点续传</span><br><span class="line">continue=true</span><br><span class="line">#同服务器连接数</span><br><span class="line">max-connection-per-server=5</span><br><span class="line">#最小文件分片大小, 下载线程数上限取决于能分出多少片, 对于小文件重要</span><br><span class="line">min-split-size=10M</span><br><span class="line">#单文件最大线程数, 路由建议值: 5</span><br><span class="line">split=10</span><br><span class="line">#下载速度限制</span><br><span class="line">max-overall-download-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-download-limit=0</span><br><span class="line">#上传速度限制</span><br><span class="line">max-overall-upload-limit=0</span><br><span class="line">#单文件速度限制</span><br><span class="line">max-upload-limit=0</span><br><span class="line">#断开速度过慢的连接</span><br><span class="line">#lowest-speed-limit=0</span><br><span class="line">#验证用，需要1.16.1之后的release版本</span><br><span class="line">#referer=*</span><br><span class="line">#文件保存路径, 默认为当前启动位置</span><br><span class="line">dir=/Users/yuanxu/Downloads</span><br><span class="line">#文件缓存, 使用内置的文件缓存, 如果你不相信Linux内核文件缓存和磁盘内置缓存时使用, 需要1.16及以上版本</span><br><span class="line">#disk-cache=0</span><br><span class="line">#另一种Linux文件缓存方式, 使用前确保您使用的内核支持此选项, 需要1.15及以上版本(?)</span><br><span class="line">#enable-mmap=true</span><br><span class="line">#文件预分配, 能有效降低文件碎片, 提高磁盘性能. 缺点是预分配时间较长</span><br><span class="line">#所需时间 none &lt; falloc ? trunc &lt;&lt; prealloc, falloc和trunc需要文件系统和内核支持</span><br><span class="line">file-allocation=prealloc</span><br><span class="line">bt-tracker=udp://tracker.opentrackr.org:1337/announce,udp://open.tracker.cl:1337/announce,udp://9.rarbg.com:2810/announce,udp://tracker.openbittorrent.com:6969/announce,udp://exodus.desync.com:6969/announce,udp://www.torrent.eu.org:451/announce,udp://vibe.sleepyinternetfun.xyz:1738/announce,udp://tracker1.bt.moack.co.kr:80/announce,udp://tracker.zerobytes.xyz:1337/announce,udp://tracker.torrent.eu.org:451/announce,udp://tracker.theoks.net:6969/announce,udp://tracker.srv00.com:6969/announce,udp://tracker.pomf.se:80/announce,udp://tracker.ololosh.space:6969/announce,udp://tracker.monitorit4.me:6969/announce,udp://tracker.moeking.me:6969/announce,udp://tracker.lelux.fi:6969/announce,udp://tracker.leech.ie:1337/announce,udp://tracker.jordan.im:6969/announce,udp://tracker.blacksparrowmedia.net:6969/announce</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>最后的 bt-tracker 可以从 <a href="https://github.com/ngosang/trackerslist">trackerslist</a> 获取，只用最好的 20 个即可（trackers_best (20 trackers) =&gt; <a href="https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt">link</a> / <a href="https://ngosang.github.io/trackerslist/trackers_best.txt">mirror</a> / <a href="https://cdn.jsdelivr.net/gh/ngosang/trackerslist@master/trackers_best.txt">mirror 2</a>）。</p><p>　　接着启动 aria2：<code>aria2c --conf-path="/Users/xxx/.aria2/aria2.conf" -D</code> （xxx 为电脑用户名），在 ~/.zshrc 中加入</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alias start-aria2=&#x27;aria2c --conf-path=&quot;/Users/xxx/.aria2/aria2.conf&quot; -D&#x27;</span><br><span class="line">start-aria2</span><br></pre></td></tr></table></figure></div><p>将 start-aria2c 作为启动 aria2 的命令别名，顺便开机自启。</p><p>　　最后从 <a href="http://aria2.baisheng999.com/">Aria2中文网</a> 安装 Chrome 插件，打开 aria2 的 WebUI 界面。</p><h2 id="expect">expect</h2><p>　　经常需要使用 ssh 远程登陆堡垒机再到远程服务器，输密码选机器都很麻烦，可以用 expect 写些脚本，自动填充密码和机器，一键直接进到远程服务器。首先安装 expect：<code>brew install expect</code>。在 /usr/local/bin 目录中新建脚本：<code>sudo vi mysl.sh</code>，填充相应内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/expect -f</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> USER [用户名]</span><br><span class="line"><span class="built_in">set</span> PWD [密码]</span><br><span class="line"><span class="built_in">set</span> TERMSERVIP [堡垒机服务器ip]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全部的远程服务器（[remote_server_name] 需要修改为对应的服务器名</span></span><br><span class="line"><span class="built_in">set</span> RS1 [remote_server_name]</span><br><span class="line"><span class="built_in">set</span> RS2 [remote_server_name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># help 命令，查看所有需要登录的远程服务器</span></span><br><span class="line"><span class="keyword">if</span> &#123;[lindex <span class="variable">$argv</span> 0] == <span class="string">&quot;help&quot;</span>&#125; &#123;</span><br><span class="line">    puts <span class="string">&quot;1: <span class="variable">$RS1</span> [说明]&quot;</span></span><br><span class="line">    puts <span class="string">&quot;2: <span class="variable">$RS2</span> [说明]&quot;</span></span><br><span class="line">    send <span class="string">&quot;exit\r&quot;</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#  ===== 脚本正文 =====</span></span><br><span class="line"><span class="comment"># 默认登陆远程服务器1</span></span><br><span class="line"><span class="built_in">set</span> RS <span class="variable">$RS1</span></span><br><span class="line"><span class="built_in">set</span> timeout 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入命令 1，则登陆第一台服务器</span></span><br><span class="line"><span class="keyword">if</span> &#123;[lindex <span class="variable">$argv</span> 0] == <span class="string">&quot;1&quot;</span>&#125; &#123;</span><br><span class="line">    <span class="built_in">set</span> RS <span class="variable">$RS1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> &#123;[lindex <span class="variable">$argv</span> 0] == <span class="string">&quot;2&quot;</span>&#125; &#123;</span><br><span class="line">    <span class="built_in">set</span> RS <span class="variable">$RS2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spawn ssh <span class="variable">$&#123;USER&#125;</span>@<span class="variable">$&#123;TERMSERVIP&#125;</span> -p 22</span><br><span class="line">expect &#123;</span><br><span class="line">    <span class="string">&quot;yes/no&quot;</span> &#123; send <span class="string">&quot;yes\r&quot;</span>; exp_continue; &#125;</span><br><span class="line">    <span class="string">&quot;*assword*&quot;</span> &#123; send <span class="string">&quot;<span class="variable">$PWD</span>\n&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择几号跳板机</span></span><br><span class="line">expect <span class="string">&quot;*num*&quot;</span> &#123; send <span class="string">&quot;0\n&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆远程服务器</span></span><br><span class="line">expect <span class="string">&quot;<span class="variable">$&#123;USER&#125;</span>@&quot;</span> &#123; send <span class="string">&quot;ssh <span class="variable">$RS</span>\n&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 expect（保持在远程服务器终端</span></span><br><span class="line">interact</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出 expect（回到本地终端</span></span><br><span class="line"><span class="comment"># expect eof  </span></span><br></pre></td></tr></table></figure></div><p>为新建的脚本增加可执行权限：<code>sudo chmod 777 mysl.sh</code>，之后可直接使用 <code>mysl.sh 1</code> 登录到对应的远程服务器。</p><h2 id="lrzsz">lrzsz</h2><p>　　与 FTP 和 NFS 相比，使用 lrzsz 与远程 linux 服务器做文件上传和下载是最简单的，在 iTerm2 中使用 <code>rz</code> 和 <code>sz</code> 命令进行上传和下载文件需要一定的配置。<strong><em>※注</em></strong>： <em>使用 expect 自动登录的远程环境可能无法使用 sz rz 命令</em>。</p><p>　　首先安装 lrzsz：<code>brew install lrzsz</code>。再跳转目录：<code>cd /usr/local/bin</code>，新建文件：<code>sudo vi iterm2-recv-zmodem.sh</code>，添加内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose folder with prompt &quot;Choose a folder to place received files in&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/bin/rz -E -e -b</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Sent \-\&gt; $FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></div><p>再新建文件：<code>sudo vi iterm2-send-zmodem.sh</code>，添加内容：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># Author: Matt Mastracci (matthew@mastracci.com)</span></span><br><span class="line"><span class="comment"># AppleScript from http://stackoverflow.com/questions/4309087/cancel-button-on-osascript-in-a-bash-script</span></span><br><span class="line"><span class="comment"># licensed under cc-wiki with attribution required </span></span><br><span class="line"><span class="comment"># Remainder of script public domain</span></span><br><span class="line"></span><br><span class="line">osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to version&#x27;</span> &gt; /dev/null 2&gt;&amp;1 &amp;&amp; NAME=iTerm2 || NAME=iTerm</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$NAME</span> = <span class="string">&quot;iTerm&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    FILE=`osascript -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to activate&#x27;</span> -e <span class="string">&#x27;tell application &quot;iTerm2&quot; to set thefile to choose file with prompt &quot;Choose a file to send&quot;&#x27;</span> -e <span class="string">&quot;do shell script (\&quot;echo \&quot;&amp;(quoted form of POSIX path of thefile as Unicode text)&amp;\&quot;\&quot;)&quot;</span>`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$FILE</span> = <span class="string">&quot;&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> Cancelled.</span><br><span class="line">    <span class="comment"># Send ZModem cancel</span></span><br><span class="line">    <span class="built_in">echo</span> -e \\x18\\x18\\x18\\x18\\x18</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Cancelled transfer</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    /usr/<span class="built_in">local</span>/bin/sz <span class="string">&quot;<span class="variable">$FILE</span>&quot;</span> -e -b</span><br><span class="line">    sleep 1</span><br><span class="line">    <span class="built_in">echo</span></span><br><span class="line">    <span class="built_in">echo</span> \<span class="comment"># Received $FILE</span></span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure></div><p>　　为新建的两文件添加可执行权限：<code>sudo chmod 777 iterm2-*</code>。之后添加 rz sz 命令的软连接：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/homebrew/bin/rz /usr/local/bin/rz</span><br><span class="line">sudo ln -s /opt/homebrew/bin/sz /usr/local/bin/sz</span><br></pre></td></tr></table></figure></div><p>　　最后配置 iTerm2，选择 Preference... -&gt; Profiles -&gt; Default -&gt; Advanced -&gt; Edit （in Triggers），添加下载触发器：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Regular expression 中填写</span></span><br><span class="line">rz waiting to receive.\*\*B0100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Action 选择</span></span><br><span class="line">Run Silent Coprocess...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Parameters 中填写</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/iterm2-send-zmodem.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Instant 不勾选</span></span><br><span class="line"><span class="comment"># 5. Enabled 勾选</span></span><br></pre></td></tr></table></figure></div><p>再添加上传触发器：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Regular expression 中填写</span></span><br><span class="line">\*\*B00000000000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. Action 选择</span></span><br><span class="line">Run Silent Coprocess...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. Parameters 中填写</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/iterm2-recv-zmodem.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. Instant 不勾选</span></span><br><span class="line"><span class="comment"># 5. Enabled 勾选</span></span><br></pre></td></tr></table></figure></div><p>　　至此 M1 中 iTerm2 rz sz 命令配置完成。</p><h2 id="参考资料">参考资料</h2><p><a href="https://suixinblog.cn/2019/09/beautify-terminal.html">iTerm2 + zsh + Oh My Zsh + Powerlevel10k 打造 Mac 下最强终端</a></p><p><a href="https://zhuanlan.zhihu.com/p/341831809">M1芯片Mac上Homebrew安装教程</a></p><p><a href="https://www.jianshu.com/p/6f344a1fd2e8">Mac M1 iTerm2 配置rz sz 上传下载文件</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　记录一下 Shaun 个人的 Mac 装机配置。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://cniter.github.io/categories/Share/"/>
    
    
    <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>Scala 多线程编程小结</title>
    <link href="http://cniter.github.io/posts/9c9b4035.html"/>
    <id>http://cniter.github.io/posts/9c9b4035.html</id>
    <published>2021-10-10T01:56:42.000Z</published>
    <updated>2021-12-18T11:54:13.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　多线程的执行方式有两种：并发（Concurrent）和并行（Parallel），简单来说，并发就是两个线程轮流在一个 CPU 核上执行，而并行则是两个线程分别在两个 CPU 核上运行。一般而言，程序员无法直接控制线程是并发执行还是并行执行，线程的执行一般由操作系统直接控制，当然程序运行时也可以做简单调度。所以对于一般程序员来说，只需要熟练使用相关语言的多线程编程库即可，至于是并发执行还是并行执行，可能并不是那么重要，只要能达到预期效果就行。</p><span id="more"></span><p>　　Shaun 目前接触的 Scala 原生多线程编程语法就两个：Future 和 Parallel Collections。其中 Future 用的的最多，并且 Parallel Collections 语法非常简单，所以主要介绍 Future，附带提一下 Parallel Collections。</p><h2 id="executioncontext-篇">ExecutionContext 篇</h2><p>　　ExecutionContext 是 Future 的执行上下文，相当于是 Java 的线程池，Java 的线程池主要有以下两类：</p><ul><li>ThreadPool：所有线程共用一个任务队列，当线程空闲时，从队列中取一个任务执行。</li><li>ForkJoinPool：每个线程各有一个任务队列，当线程空闲时，从其他线程的任务队列中取一批任务放进自己的队列中执行。</li></ul><p>　　对于少量任务，这两个池子没啥区别，只是 ThreadPool 在某些情况下会死锁，比如在一个并行度为 2 （最多两个线程）的 ThreadPool 中执行两个线程，两个线程又分别提交一个子任务，并等到子任务执行完才退出，这时会触发相互等待的死锁条件，因为没有多余的空闲线程来执行子任务，而 ForkJoinPool 中每个线程产生的子任务会放在自己的任务队列中，ForkJoinPool 可以在线程耗尽时额外创建线程，也可以挂起当前任务，执行子任务，从而防止死锁。对于大量任务，ForkJoinPool 中的空闲线程会从其他线程的任务队列中一批一批的取任务执行，所以一般会更快，当然若各个任务执行时间比较均衡，则 ThreadPool 会更快。</p><p>　　根据线程池创建的参数不同，Executors 中提供了 5 种线程池：newSingleThreadExecutor（单线程线程池，可保证任务执行顺序），newFixedThreadPool（固定大小线程池，限制并行度），newCachedThreadPool（无限大小线程池，任务执行时间小采用），newScheduledThreadPool（同样无限大小，用来处理延时或定时任务），newWorkStealingPool（ForkJoinPool 线程池）。前四种都属于 ThreadPool，根据阿里的 Java 的编程规范，不推荐直接使用 Executors 创建线程池，不过对于计算密集型任务，一般使用 newFixedThreadPool 或 newWorkStealingPool 即可，线程数设置当前 CPU 数即可（Runtime.getRuntime.availableProcessors()），多了反而增加线程上下文切换次数，对CPU 的利用率不增反减。</p><p>　　Scala 提供了一个默认的 ExecutionContext：<code>scala.concurrent.ExecutionContext.Implicits.global</code>，其本质也是一个 ForkJoinPool，并行度默认设置为当前可用 CPU 数，当然也会根据需要（比如当前全部线程被阻塞）额外创建更多线程。一般做计算密集型任务就用默认线程池即可，特殊情况也可以自己创建 <code>ExecutionContext.fromExecutor(Executors.newFixedThreadPool(8))</code>，下面的代码就可以创建一个同步阻塞的 ExecutionContext：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> currentThreadExecutionContext = <span class="type">ExecutionContext</span>.fromExecutor(</span><br><span class="line">  <span class="keyword">new</span> <span class="type">Executor</span> &#123;</span><br><span class="line">    <span class="comment">// Do not do this!</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span></span>(runnable: <span class="type">Runnable</span>) &#123; runnable.run() &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>原因是 <code>runnable.run()</code> 并不会新开一个线程，而是直接在主线程上执行，和调用普通函数一样。</p><h2 id="future-篇">Future 篇</h2><p>　　先上一个简单的 Future 并发编程 Demo：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////import scala.concurrent.ExecutionContext.Implicits.global</span></span><br><span class="line"><span class="comment">//val pool = Executors.newFixedThreadPool(Runtime.getRuntime.availableProcessors())</span></span><br><span class="line"><span class="keyword">val</span> pool = <span class="type">Executors</span>.newWorkStealingPool()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ec = <span class="type">ExecutionContext</span>.fromExecutorService(pool)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> futures = <span class="type">Array</span>.range(<span class="number">0</span>, <span class="number">10000</span>).map(i =&gt; <span class="type">Future</span> &#123;</span><br><span class="line">  println(i)</span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">  i</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> futureSequence = <span class="type">Future</span>.sequence(futures)</span><br><span class="line">futureSequence.onComplete(&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(results) =&gt; &#123;</span><br><span class="line">    println(results.mkString(<span class="string">&quot;Array(&quot;</span>, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;)&quot;</span>))</span><br><span class="line">    println(<span class="string">s&quot;Success&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ec.shutdown()</span><br><span class="line">    pool.shutdownNow()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; println(<span class="string">s&quot;Error processing future operations, error = <span class="subst">$&#123;e.getMessage&#125;</span>&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="type">Await</span>.result(futureSequence, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br></pre></td></tr></table></figure></div><p>　　如果计算机 CPU 核数为 8 核，则程序运行成功后将会从 VisualVM 中看到有 8 个线程数在运行，控制台中会每次打印 8 条记录，最后打印出完整数组。</p><p>　　onComplete 是 Future 的回调函数，可对 Success 和 Failure 分别处理，Await 是为了阻塞主线程，当 futureSequence 执行完成后，才继续执行下面的任务。当然，主线程的阻塞也可以使用 Java 中的 CountDownLatch 来实现，只需要在每个 Future 执行完成后调用一次 countDown() 即可，或者直接在 onComplete 的回调函数中调用一次也行。（<em>题外话：CountDownLatch 和 Golang 中的 sync.WaitGroup 感觉区别不大</em>）。</p><p>　　如果不想让程序并发执行，则将 <code>Future.sequence(futures)</code> 改为 <code>Future.traverse(futures)(x =&gt; x)</code> 即可，此时就会一条条打印，但不保证打印顺序与数组一致。</p><p>　　如果使用 <code>ExecutionContext.Implicits.global</code>，并将上面创建 futures 的代码改为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> futures = <span class="type">Array</span>.range(<span class="number">0</span>, <span class="number">10000</span>).map(i =&gt; <span class="type">Future</span> &#123;</span><br><span class="line">  blocking &#123;</span><br><span class="line">    println(i)</span><br><span class="line">    <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">    i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>　　则控制台会马上将数组全部打印出来，从 VisualVM 中看会有非常多的线程在运行，远远超过 8 个，这是因为 ForkJoinPool 检测到当前线程以全部阻塞，所以需要另开线程继续执行，如果将线程池改为 <code>Executors.newFixedThreadPool(8)</code>，则不会马上将数组全部打印，而是恢复原样，每次打印 8 条。<code>blocking</code> 需要慎用，如果 ForkJoinPool 中线程数太多，同样会 OOM，一般在大量运行时间短内存小的并发任务中使用。</p><hr /><p>　　Parallel Collections 并发编程就很简单了，demo 如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Array</span>.range(<span class="number">0</span>, <span class="number">10000</span>).par.foreach(i =&gt; &#123;</span><br><span class="line">  println(i)</span><br><span class="line">  <span class="type">Thread</span>.sleep(<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div><p>　　关键字为 <code>par</code>，调用该方法即可轻松进行并发计算，不过需要注意的是并发操作的副作用（side-effects）和“乱序”（out of order）语义，副作用就是去写函数外的变量，不仅仅只读写并发操作函数内部声明的变量，乱序语义是指并发操作不会严格按照数组顺序执行，所以如果并发操作会同时操作两个数组元素（eg：reduce），则需要慎重使用，有的操作结果不变，而有的操作会导致结果不唯一。</p><h2 id="经验篇">经验篇</h2><p>　　Shaun 目前使用 Scala 进行多线程编程主要碰到过以下几个问题：</p><ul><li>数据竞争问题</li><li>任务拆分问题</li><li>内存占用问题</li></ul><p>　　数据竞争问题算是多线程编程中最常见的问题，简单来说就是两个线程同时写同一个变量，导致变量值不确定，引发后续问题，解决该问题有很多方法，性能由高到底有：Atomic，volatile，线程安全数据结构（eg：ConcurrentHashMap），Lock，synchronized，前两个方法性能最高，但局限性也很大，如果有现成的线程安全对象使用是最好的，没有的只能用 Lock 和 synchronized，这两种各有优缺点，synchronized 用法简单，能应付绝大部分问题，但对读也会加锁并且无法中断等待线程，Lock 是个接口，有比较多的派生对象（ReentrantLock，ReadWriteLock，ReentrantReadWriteLock 等），能更灵活的控制锁，不过使用起来相对复杂，需要显式地加锁解锁。</p><p>　　任务拆分问题，这个问题发生在任务量非常多（千万级以上）的时候，当需要对千万级数据进行并发处理时，单纯的生成相应的千万级 Future 在默认的 ExecutionContext 中执行会比较慢，甚至出现程序运行一段时间卡一段时间的现象（可能是内存不足，GC 卡了），此时需要人为对千万级任务进行合并。Shaun 这里有两种方案：一种是使用 grouped 将千万级任务划分为 16 组，从而降级为 16 个任务，生成 16 个Future，这时执行速度会快很多，且不会有卡的现象出现；另一种方案就是，每次只生成 10 万个 Future 放进 ExecutionContext 中执行，如此将千万级任务拆分成每次 10 万并发执行，同样能解决问题。</p><p>　　内存占用问题，这个问题发生在单个任务需要占用大量内存（1G 以上）的时候，当单个任务需要 1G 以上内存，8 个任务并行则需要 8G 以上内存，内存占用过高，提高 JVM 的内存，但也只是治标不治本。Shaun 的解决方案是对单个任务进行进一步拆分，将单个任务继续拆分为 16 个子任务，再将 16 个子任务的结果进行合并，作为单个大任务的结果，8 个大任务串行执行，如此内存占用极大减少，只需要单个任务的内存即可完成全部任务，且 CPU 利用率不变，执行速度甚至会更快（Full GC 次数变少）。</p><hr /><p>　　Shaun 在写大文件的时候会用到 newSingleThreadExecutor 和 Future.traverse，将写文件的操作放在 Future 里面，每次只写一个大文件（不用多线程写是因为机械硬盘的顺序读写肯定比随机读写快），而生产大文件内容的操作由默认的 ExecutionContext 执行，从而使生产与消费互不干扰，写大文件操作不会阻塞生产操作。</p><p>　　一个用 Future 实现的生产者消费者 demo：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> poolProducer = <span class="type">Executors</span>.newWorkStealingPool()</span><br><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> ecProducer = <span class="type">ExecutionContext</span>.fromExecutorService(poolProducer)</span><br><span class="line"><span class="keyword">val</span> poolConsumer = <span class="type">Executors</span>.newSingleThreadExecutor()</span><br><span class="line"><span class="keyword">val</span> ecConsumer = <span class="type">ExecutionContext</span>.fromExecutorService(poolConsumer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> futures = <span class="type">Array</span>.range(<span class="number">0</span>, <span class="number">1000</span>).map(i =&gt; <span class="type">Future</span> &#123;</span><br><span class="line">  <span class="keyword">val</span> x = produce(i) <span class="comment">// produce something...</span></span><br><span class="line">  x</span><br><span class="line">&#125;(ecProducer).andThen &#123; <span class="keyword">case</span> <span class="type">Success</span>(x) =&gt;</span><br><span class="line">  consume(x) <span class="comment">// consume something...</span></span><br><span class="line">&#125;(ecConsumer))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> futureSequence = <span class="type">Future</span>.sequence(futures)</span><br><span class="line">futureSequence.onComplete(&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Success</span>(results) =&gt; &#123;</span><br><span class="line">    println(<span class="string">&quot;Success.&quot;</span>)</span><br><span class="line"></span><br><span class="line">    ecProducer.shutdown()</span><br><span class="line">    poolProducer.shutdownNow()</span><br><span class="line">    ecConsumer.shutdown()</span><br><span class="line">    poolConsumer.shutdownNow()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Failure</span>(e) =&gt; println(<span class="string">s&quot;Error processing future operations, error = <span class="subst">$&#123;e.getMessage&#125;</span>&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="type">Await</span>.result(futureSequence, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br></pre></td></tr></table></figure></div><h2 id="后记">后记</h2><p>　　Shaun 这里写的 Scala 多线程编程主要是针对计算密集型任务，而 IO 密集型任务一般会用专门的一些框架，计算密集型考虑的是如何最大化利用 CPU，加快任务执行速度，线程数一般比较固定。Scala 的 Future 多线程编程相比 Java 的多线程编程要简洁了很多，唯一需要控制的就是并行度和任务拆分，Shaun 自己在用时也对 Future 做了简单封装，进一步简化了 Scala 的多线程编程，对 Iterable 的并发计算会更方便。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://docs.scala-lang.org/overviews/core/futures.html">Futures and Promises</a></p><p>[2] <a href="https://stackoverflow.com/questions/29068064/scala-concurrent-blocking-what-does-it-actually-do">scala.concurrent.blocking - what does it actually do?</a></p><p>[3] <a href="https://docs.scala-lang.org/overviews/parallel-collections/overview.html">Parallel Collections</a></p><p>[4] <a href="https://www.cnblogs.com/dolphin0520/p/3923167.html">Java并发编程：Lock</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　多线程的执行方式有两种：并发（Concurrent）和并行（Parallel），简单来说，并发就是两个线程轮流在一个 CPU 核上执行，而并行则是两个线程分别在两个 CPU 核上运行。一般而言，程序员无法直接控制线程是并发执行还是并行执行，线程的执行一般由操作系统直接控制，当然程序运行时也可以做简单调度。所以对于一般程序员来说，只需要熟练使用相关语言的多线程编程库即可，至于是并发执行还是并行执行，可能并不是那么重要，只要能达到预期效果就行。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="language" scheme="http://cniter.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>Google S2 Geometry 浅解</title>
    <link href="http://cniter.github.io/posts/720275bd.html"/>
    <id>http://cniter.github.io/posts/720275bd.html</id>
    <published>2021-09-19T08:21:58.000Z</published>
    <updated>2021-12-18T11:54:13.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　Google S2 Geometry（以下简称 S2） 是 Google 发明的基于单位球的一种地图投影和空间索引算法，该算法可快速进行覆盖以及邻域计算。更多详见 <a href="https://s2geometry.io/">S2Geometry</a>，<a href="https://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/">Google’s S2, geometry on the sphere, cells and Hilbert curve</a>，<a href="https://halfrost.com/go_s2_regioncoverer/">halfrost 的空间索引系列文章</a>。虽然使用 S2 已有一年的时间，但确实没有比较系统的看过其源码，这次借着这段空闲时间，将 Shaun 常用的功能系统的看看其具体实现，下文将结合 S2 的 C++，Java，Go 的版本一起看，由于 Java 和 Go 的都算是 C++ 的衍生版，所以以 C++ 为主，捎带写写这三种语言实现上的一些区别，Java 版本时隔 10 年更新了 2.0 版本，喜大普奔。</p><span id="more"></span><h2 id="坐标篇">坐标篇</h2><figure><img src="https://s2geometry.io/devguide/img/s2cell_global.jpg" alt="s2 projection" /><figcaption aria-hidden="true">s2 projection</figcaption></figure><p>　　S2 的投影方式可简单想象为一个单位球外接一个立方体，从球心发出一条射线得到球面上的点到立方体上 6 个面的投影，即将球面投影为立方体，当然中间为了使面积分布更为均匀，还做了些其他坐标变换。</p><h3 id="s2latlng-坐标">S2LatLng 坐标</h3><p>　　首先是经纬度坐标，默认用弧度（Radians）构造，取值范围为经度 [-π，+π]，纬度 [-π/2，+π/2]，当然也可使用 S1Angle 将角度（Degrees）转成弧度来构造。</p><h3 id="s2point-坐标">S2Point 坐标</h3><p>　　然后球面笛卡尔坐标，这是个三维坐标，由 S2LatLng 到 S2Point 相当于将单位球的极坐标表示法转换为笛卡尔坐标表示法，具体公式为 <span class="math inline">\(x=\cos(lat)cos(lng);　y=cos(lat)sin(lng);　z=sin(lat)\)</span>。</p><h3 id="faceuv-坐标">FaceUV 坐标</h3><p>　　这个坐标并没实际的类与其对应，face 指的是立方体的面，值域为 [0,5]，而 uv 坐标是指面上的点，值域为 [-1,1]。首先需要知道 S2Point 会投影到哪个面上，可以知道 S2 的笛卡尔坐标 X 轴正向指向 0 面，Y 轴正向指向 1 面，Z 轴正向指向 2 面，X 轴负向指向 3 面，Y 轴负向指向 4 面，Z 轴负向指向 5 面，所以 S2Point xyz 哪个分量的绝对值最大，就会投影到哪个轴指向的面，若该分量为正值，则取正向指的面，若该分量为负值，则取负向指的面。至于 uv 的计算方式就是直线与平面的交点了，之前的一篇「计算几何基础」中写过，但这里的平面和直线都比较特殊，所以有快速算法，就直接贴 Go 的代码吧：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="GO"><figure class="highlight hljs go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// validFaceXYZToUV given a valid face for the given point r (meaning that</span></span><br><span class="line"><span class="comment">// dot product of r with the face normal is positive), returns</span></span><br><span class="line"><span class="comment">// the corresponding u and v values, which may lie outside the range [-1,1].</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validFaceXYZToUV</span><span class="params">(face <span class="keyword">int</span>, r r3.Vector)</span> <span class="params">(<span class="keyword">float64</span>, <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> face &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> r.Y / r.X, r.Z / r.X</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> -r.X / r.Y, r.Z / r.Y</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> -r.X / r.Z, -r.Y / r.Z</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">return</span> r.Z / r.X, r.Y / r.X</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">return</span> r.Z / r.Y, -r.X / r.Y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -r.Y / r.Z, -r.X / r.Z</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这里需要注意的是 S2Point xyz 三分量构成的向量与平面法向量的点积必须是正数时 uv 才算正确有效，Go 在计算时没做校验，C++ 和 Java 都有校验，使用时需要注意。</p><h3 id="facest-坐标">FaceST 坐标</h3><p>　　之所以引入 ST 坐标是因为同样的球面面积映射到 UV 坐标面积大小不一，大小差距比较大（离坐标轴越近越小，越远越大），所以再做一次 ST 变换，将面积大的变小，小的变大，使面积更均匀，利于后面在立方体面上取均匀格网（cell）时，每个 cell 对应球面面积差距不大。S2 的 ST 变换有三种：1、线性变换，基本没做任何变形，只是简单将 ST 坐标的值域变换为 [0, 1]，cell 对应面积最大与最小比大约为 5.2；2、二次变换，一种非线性变换，能起到使 ST 空间面积更均匀的作用，cell 对应面积最大与最小比大约为 2.1；3、正切变换，同样能使 ST 空间面积更均匀，且 cell 对应面积最大与最小比大约为 1.4，不过其计算速度相较于二次变换要慢 3 倍，所以 S2 权衡考虑，最终采用了二次变换作为默认的 UV 到 ST 之间的变换。二次变换公式为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="JAVA"><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">stToUV</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s &gt;= <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">4</span> * s * s - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> / <span class="number">3.</span>) * (<span class="number">1</span> - <span class="number">4</span> * (<span class="number">1</span> - s) * (<span class="number">1</span> - s));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">uvToST</span><span class="params">(<span class="keyword">double</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (u &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> * Math.sqrt(<span class="number">1</span> + <span class="number">3</span> * u);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> - <span class="number">0.5</span> * Math.sqrt(<span class="number">1</span> - <span class="number">3</span> * u);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="faceij-坐标">FaceIJ 坐标</h3><p>　　IJ 坐标是离散化后的 ST 坐标，将 ST 空间的平面划分为 <span class="math inline">\(2^{30}×2^{30}\)</span> 个网格，取网格所在的横纵坐标得到 IJ 坐标，所以由 ST 到 IJ 坐标的变换就比较简单了：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="JAVA"><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">stToIj</span><span class="params">(<span class="keyword">double</span> s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Math.max(</span><br><span class="line">    <span class="number">0</span>, Math.min(<span class="number">1073741824</span> - <span class="number">1</span>, (<span class="keyword">int</span>) Math.round(<span class="number">1073741824</span> * s - <span class="number">0.5</span>))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="s2cellid">S2CellId</h3><p>　　这个 id 其实是个一维坐标，而是利用希尔伯特空间填充曲线将 IJ 坐标从二维变换为一维，该 id 用一个 64 位整型表示，高 3 位用来表示 face（0~5），后面 61 位来保存不同的 level（0~30） 对应的希尔伯特曲线位置，每增加一个 level 增加两位，后面紧跟一个 1，最后的位数都补 0。<em>注：Java 版本的 id 是有符号 64 位整型，而 C++ 和 Go 的是无符号 64 位整型，所以在跨语言传递 id 的时候，在南极洲所属的最后一个面（即 face = 5）需要小心处理。</em></p><h4 id="hilbertcurve">HilbertCurve</h4><figure><img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/Hilbert_curve_production_rules%21.svg" alt="hilbert_curve_subdivision_rules" /><figcaption aria-hidden="true">hilbert_curve_subdivision_rules</figcaption></figure><figure><img src="https://upload.wikimedia.org/wikipedia/commons/3/35/Hilbert_curve_3_Orient%21.svg" alt="hilbert_curve" /><figcaption aria-hidden="true">hilbert_curve</figcaption></figure><p>　　上面两张图很明了的展示了希尔伯特曲线的构造过程，该曲线的构造基本元素由 ABCD 4 种“U”形构成，而 BCD 又可由 A 依次逆时针旋转 90 度得到，所以也可以认为只有一种“U”形，每个 U 占 4 个格子，以特定方式进行 1 分 4 得到下一阶曲线形状。</p><p>每个 U 坐标与希尔伯特位置（用二进制表示）对应关系如下：</p><ul><li>A：<code>00 -&gt; (0,0); 01 -&gt; (0,1); 10 -&gt; (1,1); 11 -&gt; (1,0);</code></li><li>B：<code>00 -&gt; (1,1); 01 -&gt; (0,1); 10 -&gt; (0,0); 11 -&gt; (1,0);</code></li><li>C：<code>00 -&gt; (1,1); 01 -&gt; (1,0); 10 -&gt; (0,0); 11 -&gt; (0,1);</code></li><li>D：<code>00 -&gt; (0,0); 01 -&gt; (1,0); 10 -&gt; (1,1); 11 -&gt; (0,1);</code></li></ul><p>每个 U 一分四对应关系如下：</p><ul><li>A：<code>D -&gt; A -&gt; A -&gt; B</code></li><li>B：<code>C -&gt; B -&gt; B -&gt; A</code></li><li>C：<code>B -&gt; C -&gt; C -&gt; D</code></li><li>D：<code>A -&gt; D -&gt; D -&gt; C</code></li></ul><p>　　根据以上两个对应关系就能找到右手坐标系任意阶数的希尔伯特位置及坐标对应关系。以初始 1 阶曲线 A 为例，占据四个格子，然后进行一分四操作，四个格子分成 16 个格子，A 分为 DAAB 四个“U”形，连接起来即为 2 阶曲线，位置与坐标对应关系为（都用二进制表示）：</p><p><code>0000 -&gt; (00, 00); 0001 -&gt; (01, 00); 0010 -&gt; (01, 01); 0011 -&gt; (00, 01)</code>；</p><p><code>0100 -&gt; (00, 10); 0101 -&gt; (00, 11); 0110 -&gt; (01, 11); 0111 -&gt; (01, 10)</code>；</p><p><code>1000 -&gt; (10, 10); 1001 -&gt; (10, 11); 1010 -&gt; (11, 11); 1011 -&gt; (11, 10)</code>；</p><p><code>1100 -&gt; (11, 01); 1101 -&gt; (10, 01); 1110 -&gt; (10, 00); 1111 -&gt; (11, 00)</code>；</p><p>　　从二进制中很容易看出随着阶数的增加，位置与坐标的对应关系：每增加一阶，位置往后增加两位，坐标分量各增加一位，位置增加的两位根据一分四对应关系拼接，坐标各分量增加的一位需先找到一分四对应关系，再找对应位置与坐标对应关系，将得到的坐标分量对应拼接。以一阶的 <code>01 -&gt; (0,1)</code> 到二阶的 <code>0110 -&gt; (01, 11)</code> 为例，首先根据 01 得到当前所属一阶第二块，查找一分四对应关系知道，下一阶这块还是 A，根据 0110 后两位 10 可知这块属于 A 的第三个位置，查找坐标得到是 <code>(1,1)</code>，结合一阶的 <code>(0,1)</code>，对应分量拼接得到坐标 <code>(01,11)</code>，即 <code>(1, 3)</code>，同理可根据第二阶的坐标反查第二阶的位置。有了这些关系，就能生成希尔伯特曲线了，下面就看看 S2 是怎么生成 id 的。</p><h4 id="s2id">S2Id</h4><p>　　首先 S2 中用了两个二维数组分别保存位置到坐标以及坐标到位置的对应的关系：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kIJtoPos[orientation][ij] -&gt; pos</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kIJtoPos[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">// (0,0) (0,1) (1,0) (1,1)</span></span><br><span class="line">  &#123;     <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">2</span>  &#125;,  <span class="comment">// canonical order</span></span><br><span class="line">  &#123;     <span class="number">0</span>,    <span class="number">3</span>,    <span class="number">1</span>,    <span class="number">2</span>  &#125;,  <span class="comment">// axes swapped</span></span><br><span class="line">  &#123;     <span class="number">2</span>,    <span class="number">3</span>,    <span class="number">1</span>,    <span class="number">0</span>  &#125;,  <span class="comment">// bits inverted</span></span><br><span class="line">  &#123;     <span class="number">2</span>,    <span class="number">1</span>,    <span class="number">3</span>,    <span class="number">0</span>  &#125;,  <span class="comment">// swapped &amp; inverted</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kPosToIJ[orientation][pos] -&gt; ij</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPosToIJ[<span class="number">4</span>][<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">// 0  1  2  3</span></span><br><span class="line">  &#123;  <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span> &#125;,    <span class="comment">// canonical order:    (0,0), (0,1), (1,1), (1,0)</span></span><br><span class="line">  &#123;  <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span> &#125;,    <span class="comment">// axes swapped:       (0,0), (1,0), (1,1), (0,1)</span></span><br><span class="line">  &#123;  <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,    <span class="comment">// bits inverted:      (1,1), (1,0), (0,0), (0,1)</span></span><br><span class="line">  &#123;  <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span> &#125;,    <span class="comment">// swapped &amp; inverted: (1,1), (0,1), (0,0), (1,0)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kPosToOrientation[pos] -&gt; orientation_modifier</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kPosToOrientation[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></div><p>　　方向 0（canonical order）相当于上文中 A，方向 1（axes swapped）相当于上文中 D，方向 2（bits inverted）相当于上文中 C，方向 3（swapped &amp; inverted）相当于上文中 B，kPosToOrientation 代表 S2 中方向 0 一分四的对应关系，而 方向 1，2，3 的对应关系可由该值推出，计算公式为 <code>orientation ^ kPosToOrientation</code>，eg：<code>1 -&gt; 1^kPosToOrientation=[0, 1, 1, 2]; 3 -&gt; 3^kPosToOrientation=[2, 3, 3, 0]</code>，与上文中一分四对应关系一致。</p><p>　　随后 S2 初始化了一个 4 阶希尔伯特曲线位置与坐标的对应关系查找表，见 C++ 版的 <code>MaybeInit()</code> 方法，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ij = (i &lt;&lt; <span class="number">4</span>) + j;</span><br><span class="line">lookup_pos[(ij &lt;&lt; <span class="number">2</span>) + orig_orientation] = (pos &lt;&lt; <span class="number">2</span>) + orientation;</span><br><span class="line">lookup_ij[(pos &lt;&lt; <span class="number">2</span>) + orig_orientation] = (ij &lt;&lt; <span class="number">2</span>) + orientation;</span><br></pre></td></tr></table></figure></div><p>　　orig_orientation 代表 4 个初始方向，orientation 代表该位置或坐标下一阶一分四的方向，数组中每个元素是 16 位数，2 个字节，一个四阶希尔伯特曲线是 <span class="math inline">\(2^4×2^4=256\)</span> 个位置，一个初始方向对应一个四阶希尔伯特曲线，所以一个查找表共占内存 <span class="math inline">\(2×256×4=2048=2KB\)</span>，正好一级缓存能放下，再大的话，一级缓存可能放不下，反而会降低查找速度。这两个查找表就相当于 4 个超“U”形的位置与坐标对应关系，同时一分四对应关系保持不变，以超“U”作为基本元素做下一阶希尔伯特曲线，每增加一阶位置往后增加 8 位，IJ 坐标各往后增加 4 位，如此，以更快的速度迭代到 S2 想要的 30 阶希尔伯特曲线。C++ 的这份代码就很精妙了：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">S2CellId <span class="title">S2CellId::FromFaceIJ</span><span class="params">(<span class="keyword">int</span> face, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化超“U”形查找表</span></span><br><span class="line">  <span class="built_in">MaybeInit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// face 向左移 60 位</span></span><br><span class="line">  uint64 n = absl::implicit_cast&lt;uint64&gt;(face) &lt;&lt; (kPosBits - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确定每个面的初始“U”形方向，使每个面都保持相同的右手坐标系，6 个面生成的希尔伯特曲线可以依次相连</span></span><br><span class="line">  uint64 bits = (face &amp; kSwapMask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基于超“U”形得到 30 阶希尔伯特曲线 IJ 坐标对应位置</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BITS(k) do &#123; \</span></span><br><span class="line"><span class="meta">    const int mask = (1 &lt;&lt; kLookupBits) - 1; \</span></span><br><span class="line"><span class="meta">    bits += ((i &gt;&gt; (k * kLookupBits)) &amp; mask) &lt;&lt; (kLookupBits + 2); \</span></span><br><span class="line"><span class="meta">    bits += ((j &gt;&gt; (k * kLookupBits)) &amp; mask) &lt;&lt; 2; \</span></span><br><span class="line"><span class="meta">    bits = lookup_pos[bits]; \</span></span><br><span class="line"><span class="meta">    n |= (bits &gt;&gt; 2) &lt;&lt; (k * 2 * kLookupBits); \</span></span><br><span class="line"><span class="meta">    bits &amp;= (kSwapMask | kInvertMask); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// IJ 只有 30 位，7 这个调用只会导致位置移 4 位，后续调用都移 8 位，得到 4 + 8 * 7 = 60 位</span></span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">7</span>); </span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GET_BITS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 整个 n 向右移一位，再以 1 结尾</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S2CellId</span>(n * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>再来看看根据 id 反算 IJ 坐标：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S2CellId::ToFaceIJOrientation</span><span class="params">(<span class="keyword">int</span>* pi, <span class="keyword">int</span>* pj, <span class="keyword">int</span>* orientation)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 与上面一样</span></span><br><span class="line">  <span class="built_in">MaybeInit</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="keyword">this</span>-&gt;<span class="built_in">face</span>();</span><br><span class="line">  <span class="keyword">int</span> bits = (face &amp; kSwapMask);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 反算 IJ 坐标，k == 7 时，取希尔伯特曲线位置高 4 位，IJ 各前 2 位，其余依次取位置 8 位， IJ 各 4 位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_BITS(k) do &#123; \</span></span><br><span class="line"><span class="meta">    const int nbits = (k == 7) ? (kMaxLevel - 7 * kLookupBits) : kLookupBits; \</span></span><br><span class="line"><span class="meta">    bits += (static_cast<span class="meta-string">&lt;int&gt;</span>(id_ &gt;&gt; (k * 2 * kLookupBits + 1)) \</span></span><br><span class="line"><span class="meta">             &amp; ((1 &lt;&lt; (2 * nbits)) - 1)) &lt;&lt; 2; \</span></span><br><span class="line"><span class="meta">    bits = lookup_ij[bits]; \</span></span><br><span class="line"><span class="meta">    i += (bits &gt;&gt; (kLookupBits + 2)) &lt;&lt; (k * kLookupBits); \</span></span><br><span class="line"><span class="meta">    j += ((bits &gt;&gt; 2) &amp; ((1 &lt;&lt; kLookupBits) - 1)) &lt;&lt; (k * kLookupBits); \</span></span><br><span class="line"><span class="meta">    bits &amp;= (kSwapMask | kInvertMask); \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">7</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">6</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">4</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">GET_BITS</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> GET_BITS</span></span><br><span class="line"></span><br><span class="line">  *pi = i;</span><br><span class="line">  *pj = j;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (orientation != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">S2_DCHECK_EQ</span>(<span class="number">0</span>, kPosToOrientation[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">S2_DCHECK_EQ</span>(kSwapMask, kPosToOrientation[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 0x1111111111111111ULL may be better?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">lsb</span>() &amp; <span class="number">0x1111111111111110</span>ULL) &#123;</span><br><span class="line">      bits ^= kSwapMask;</span><br><span class="line">    &#125;</span><br><span class="line">    *orientation = bits;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> face;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这里的 orientation 实际是指当前位置的方向，即其周围必有 3 个位置与其方向相同，最后一行注释 Shaun 之所以认为应该是 0x1111111111111111ULL，是因为第 30 阶希尔伯特曲线位置（leaf cell）按理说同样需要做异或操作得到方向，不过整个 S2 库都没有需要用到 leaf cell 的方向，所以这就倒无关紧要了。之所以需要做异或操作，是因为 bits 是该位置下一阶一分四的方向，而对于同一个希尔伯特曲线位置，奇数阶与奇数阶下一阶一分四方向相同，偶数阶与偶数阶下一阶一分四方向相同，lsb() 表示二进制 id 从右往左数第一个 1 所代表的数， 所以有 0x1111111111111110ULL 这一魔术数，而异或操作正好能将下一阶一分四方向调整为当前阶方向。</p><p>　　如此 S2 的坐标以及 id 的生成以及反算就很明了了，下面就是 S2 如何使用 id 做计算了。</p><hr /><h3 id="facesiti-坐标">FaceSiTi 坐标</h3><p>　　这个是 S2 内部计算使用的坐标，一般用来计算 cell 的中心坐标，以及根据当前 s 和 t 坐标的精度（小数点后几位）判断对应的级别（level）。由于 S2 本身并不显式存储 ST 坐标（有存 UV 坐标），所以 ST 坐标只能计算出来，每个 cell 的中心点同样如此。计算公式为 <span class="math inline">\(Si=s*2^{31};Ti=t*2^{31}\)</span>。至于为啥是 <span class="math inline">\(2^{31}\)</span>，是因为该坐标是用来描述从 0~ 31 阶希尔伯特曲线网格的中心坐标，0 阶中心以 <span class="math inline">\(1/2^1\)</span> 递增，1 阶中心以 <span class="math inline">\(1/2^2\)</span> 递增，2 阶中心以 <span class="math inline">\(1/2^3\)</span> 递增，……，30 阶中心以 <span class="math inline">\(1/2^{31}\)</span> 递增。S2 计算 id 对应的格子中心坐标，首先就会计算 SiTi 坐标，再将 SiTi 转成 ST 坐标。</p><h2 id="算法篇">算法篇</h2><h3 id="邻域算法">邻域算法</h3><p>　　S2 计算邻域，最关键的是计算不同面相邻的 leaf cell id，即：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">S2CellId <span class="title">S2CellId::FromFaceIJWrap</span><span class="params">(<span class="keyword">int</span> face, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 限制 IJ 最大最小取值为 -1~2^30, 刚好能超出 IJ 正常表示范围 0~2^30-1</span></span><br><span class="line">  i = <span class="built_in">max</span>(<span class="number">-1</span>, <span class="built_in">min</span>(kMaxSize, i));</span><br><span class="line">  j = <span class="built_in">max</span>(<span class="number">-1</span>, <span class="built_in">min</span>(kMaxSize, j));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> kScale = <span class="number">1.0</span> / kMaxSize;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">double</span> kLimit = <span class="number">1.0</span> + DBL_EPSILON;</span><br><span class="line">  <span class="built_in">S2_DCHECK_EQ</span>(<span class="number">0</span>, kMaxSize % <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// IJ -&gt; SiTi -&gt; ST -&gt; UV</span></span><br><span class="line">  <span class="keyword">double</span> u = <span class="built_in">max</span>(-kLimit, <span class="built_in">min</span>(kLimit, kScale * (<span class="number">2</span> * (i - kMaxSize / <span class="number">2</span>) + <span class="number">1</span>)));</span><br><span class="line">  <span class="keyword">double</span> v = <span class="built_in">max</span>(-kLimit, <span class="built_in">min</span>(kLimit, kScale * (<span class="number">2</span> * (j - kMaxSize / <span class="number">2</span>) + <span class="number">1</span>)));</span><br><span class="line"></span><br><span class="line">  face = S2::<span class="built_in">XYZtoFaceUV</span>(S2::<span class="built_in">FaceUVtoXYZ</span>(face, u, v), &amp;u, &amp;v);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">FromFaceIJ</span>(face, S2::<span class="built_in">STtoIJ</span>(<span class="number">0.5</span>*(u+<span class="number">1</span>)), S2::<span class="built_in">STtoIJ</span>(<span class="number">0.5</span>*(v+<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这个算法主要用来计算超出范围（0~2^30-1）的 IJ 对应的 id，核心思想是先将 FaceIJ 转为 XYZ，再使用 XYZ 反算得到正常的 FaceIJ，进而得到正常的 id。中间 IJ -&gt; UV 中坐标实际经过了 3 步，对于 leaf cell，IJ -&gt; SiTi 的公式为 <span class="math inline">\(Si=2×I+1\)</span>，而对于 ST -&gt; UV，这里没有采用二次变换，就是线性变换 <span class="math inline">\(u=2*s-1\)</span>，官方注释上说明用哪个变换效果都一样，所以采用最简单的就行。</p><h4 id="边邻域">边邻域</h4><p>　　边邻域代码很简单，也很好理解：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::GetEdgeNeighbors</span><span class="params">(S2CellId neighbors[<span class="number">4</span>])</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="keyword">this</span>-&gt;<span class="built_in">level</span>();</span><br><span class="line">  <span class="comment">// 计算当前 level 一行或一列对应多少个 30 级的 cell（leaf cell） 2^(30-level)</span></span><br><span class="line">  <span class="keyword">int</span> size = <span class="built_in">GetSizeIJ</span>(level);</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Edges 0, 1, 2, 3 are in the down, right, up, left directions.</span></span><br><span class="line">  neighbors[<span class="number">0</span>] = <span class="built_in">FromFaceIJSame</span>(face, i, j - size, j - size &gt;= <span class="number">0</span>)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">1</span>] = <span class="built_in">FromFaceIJSame</span>(face, i + size, j, i + size &lt; kMaxSize)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">2</span>] = <span class="built_in">FromFaceIJSame</span>(face, i, j + size, j + size &lt; kMaxSize)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">  neighbors[<span class="number">3</span>] = <span class="built_in">FromFaceIJSame</span>(face, i - size, j, i - size &gt;= <span class="number">0</span>)</span><br><span class="line">                 .<span class="built_in">parent</span>(level);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　分别计算当前 IJ 坐标下右上左坐标对应 id，FromFaceIJSame 表示若邻域在相同面，则走 FromFaceIJ，否则走 FromFaceIJWrap，由于这两个函数得到都是 leaf cell，要上升到指定 level，需要用到 parent 方法，即将希尔伯特曲线位置去掉右 <span class="math inline">\(2*(30-level)\)</span> 位，再组合成新的 id，位运算也很有意思：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint64 <span class="title">lsb_for_level</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> uint64&#123;<span class="number">1</span>&#125; &lt;&lt; (<span class="number">2</span> * (kMaxLevel - level));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> S2CellId <span class="title">S2CellId::parent</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  uint64 new_lsb = <span class="built_in">lsb_for_level</span>(level);</span><br><span class="line">  <span class="comment">// 取反加一实际是取负数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">S2CellId</span>((id_ &amp; (~new_lsb + <span class="number">1</span>)) | new_lsb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h4 id="点邻域">点邻域</h4><p>　　S2 的点邻域并不是指常规意义上 4 个顶点相邻左上右上右下左下的 id，而是一种比较特殊的相邻关系，以直角坐标系 (0,0),(0,1),(1,1),(1,0) 为例，(0,0) 的点邻域为 (0,0),(0,-1),(-1,-1),(-1,0)，(0,1) 的点邻域为 (0,1),(0,2),(-1,2),(-1,1)，(1,1) 的点邻域为 (1,1),(1,2),(2,2),(2,1)，(1,0) 的点邻域为 (1,0),(1,-1),(2,-1),(2,0)。具体代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::AppendVertexNeighbors</span><span class="params">(<span class="keyword">int</span> level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     vector&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// level &lt; this-&gt;level()</span></span><br><span class="line">  <span class="built_in">S2_DCHECK_LT</span>(level, <span class="keyword">this</span>-&gt;<span class="built_in">level</span>());</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 IJ 落在 level 对应 cell 的哪个方位？（左下左上右上右下，对应上文的(0,0),(0,1),(1,1),(1,0)坐标）</span></span><br><span class="line">  <span class="keyword">int</span> halfsize = <span class="built_in">GetSizeIJ</span>(level + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> size = halfsize &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">bool</span> isame, jsame;</span><br><span class="line">  <span class="keyword">int</span> ioffset, joffset;</span><br><span class="line">  <span class="keyword">if</span> (i &amp; halfsize) &#123;</span><br><span class="line">    ioffset = size;</span><br><span class="line">    isame = (i + size) &lt; kMaxSize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ioffset = -size;</span><br><span class="line">    isame = (i - size) &gt;= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (j &amp; halfsize) &#123;</span><br><span class="line">    joffset = size;</span><br><span class="line">    jsame = (j + size) &lt; kMaxSize;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    joffset = -size;</span><br><span class="line">    jsame = (j - size) &gt;= <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">parent</span>(level));</span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + ioffset, j, isame).<span class="built_in">parent</span>(level));</span><br><span class="line">  output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i, j + joffset, jsame).<span class="built_in">parent</span>(level));</span><br><span class="line">  <span class="comment">// 则邻域的 IJ 与当前 cell 都不在同一个面，则说明只有三个点邻域</span></span><br><span class="line">  <span class="keyword">if</span> (isame || jsame) &#123;</span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + ioffset, j + joffset,</span><br><span class="line">                                     isame &amp;&amp; jsame).<span class="built_in">parent</span>(level));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　上面的代码算是比较清晰了，3 个点邻域的情况一般出现在当前 id 位于立方体 6 个面的角落，<em>该方法的参数 level 必须比当前 id 的 level 要小</em>。</p><h4 id="全邻域">全邻域</h4><p>　　所谓全邻域，即为当前 id 对应 cell 周围一圈 cell 对应的 id，若周围一圈 cell 的 level 与 当前 id 的 level 一样，则所求即为正常的 9 邻域。具体代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="C++"><figure class="highlight hljs c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">S2CellId::AppendAllNeighbors</span><span class="params">(<span class="keyword">int</span> nbr_level,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  vector&lt;S2CellId&gt;* output)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// nbr_level &gt;= level</span></span><br><span class="line">  <span class="built_in">S2_DCHECK_GE</span>(nbr_level, <span class="built_in">level</span>());</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">int</span> face = <span class="built_in">ToFaceIJOrientation</span>(&amp;i, &amp;j, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 先归一 IJ 坐标，将 IJ 坐标调整为当前 cell 左下角 leaf cell 的坐标</span></span><br><span class="line">  <span class="keyword">int</span> size = <span class="built_in">GetSizeIJ</span>();</span><br><span class="line">  i &amp;= -size;</span><br><span class="line">  j &amp;= -size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> nbr_size = <span class="built_in">GetSizeIJ</span>(nbr_level);</span><br><span class="line">  <span class="built_in">S2_DCHECK_LE</span>(nbr_size, size);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> k = -nbr_size; ; k += nbr_size) &#123;</span><br><span class="line">    <span class="keyword">bool</span> same_face;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      same_face = (j + k &gt;= <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &gt;= size) &#123;</span><br><span class="line">      same_face = (j + k &lt; kMaxSize);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      same_face = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// 生成外包围圈下上两边的 id, 顺序为从左往右</span></span><br><span class="line">      output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + k, j - nbr_size,</span><br><span class="line">                                       j - size &gt;= <span class="number">0</span>).<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">      output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + k, j + size,</span><br><span class="line">                                       j + size &lt; kMaxSize).<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成外包围圈左右两边以及四个边角的 id, 顺序为从下往上</span></span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i - nbr_size, j + k,</span><br><span class="line">                                     same_face &amp;&amp; i - size &gt;= <span class="number">0</span>)</span><br><span class="line">                      .<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    output-&gt;<span class="built_in">push_back</span>(<span class="built_in">FromFaceIJSame</span>(face, i + size, j + k,</span><br><span class="line">                                     same_face &amp;&amp; i + size &lt; kMaxSize)</span><br><span class="line">                      .<span class="built_in">parent</span>(nbr_level));</span><br><span class="line">    <span class="keyword">if</span> (k &gt;= size) <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　知道这个函数的作用，再看代码就很明了了，<em>这个方法的参数 nbr_level 必须大于或等于当前 id 的 level</em>，因为一旦外包围圈的 cell 面积比当前 cell 还大，就无法得到正确的外包围圈。</p><h3 id="覆盖算法">覆盖算法</h3><p>　　S2 的覆盖，是指给定一块区域，能用多少 id 对应的 cell 完全覆盖该区域（GetCovering），当然也有尽量覆盖的算法（GetInteriorCovering），下面主要解析 GetCovering，因为 GetInteriorCovering 也差不多，就是覆盖策略略有不同。</p><p>GetCovering 的区域入参是 S2Region，比较典型的 S2Region 有以下几种：</p><ul><li>S2Cell：S2 id 对应的网格，会保存左下右上两个 UV 坐标，也是覆盖算法使用的基本元素；</li><li>S2CellUnion：多个 S2Cell 集合体，GetCovering 的返回值；</li><li>S2LatLngRect：经纬度矩形区域；</li><li>S2Cap：球帽区域，类比于二维圆的圆弧，球帽的构造比较奇怪，球帽的中心 S2Point 是需要，但另一个变量不是球帽的圆弧角，而是半个圆弧角（S2 代码库对应的 S1Angle 弧度，90 度代表半球，180 度代表全球）所对应弦长的平方，最大值为 4，之所以采用弦长的平方作为默认构造，是因为这就是 3 维中距离，在进行距离比较的场景时会更方便，比如测试是否包含一个 S2Point，计算覆盖多边形时，就不用再比较角度，毕竟角度计算代价比较大；</li><li>S2Loop：多边形的基本组成元素，第一个点与最后一个点隐式连接，逆时针代表封闭，顺时针代表开孔取外围区域，不允许自相交；</li><li>S2Polygon：非常正常的复杂多边形，由多个 S2Loop 构成，S2Loop 之间不能相交；</li><li>S2Polyline：一条折线，同样不能自相交；</li><li>还有些其它不常用的：S2R2Rect（S2Point 矩形区域），S2RegionIntersection（集合相交区域），S2RegionUnion（集合合并区域），……等。</li></ul><p>　　S2 覆盖算法的本质是一种启发式算法，先取满足当前条件最基本的元素，再依照条件进行迭代优化，所以该算法得到的只是一个近似最优解。GetCovering 需要依次满足以下条件：</p><ol type="1"><li>生成的 S2Cell level 不能比指定的 minLevel 小；（必须满足）</li><li>生成的 S2Cell 的个数不能比指定的 maxCells 多；（可以满足，当满足 1 时，数目已经 maxCells 多，迭代停止）</li><li>生成的 S2Cell level 不能比指定的 maxLevel 大；（必须满足）</li></ol><p>　　以上 3 个条件对应 GetCovering 的其他三个参数，当然还有一个参数是 levelModel，表示从 minLevel 向下分到 maxLevel 时，是 1 分 4，还是 1 分 16，还是 1 分 64，对应一次升 1 阶曲线，还是一次升 2 阶，或是一次升 3 阶。下面就来具体看看 GetCovering 的算法流程（代码就不贴了，太多了）：</p><ol type="1"><li>首先获取候选种子 S2Cell。先构造一个临时覆盖器，设置 maxCells 为 4，minLevel 为 0，以快速得到初始覆盖结果，做法为：先得到覆盖输入区域的 S2Cap，再用 S2CellUnion 覆盖该 S2Cap，根据 S2Cap 圆弧度计算 S2Cell 的 level，若最终 level &lt; 0，则说明 S2Cap 非常大，需要取 6 个面对应的 S2Cell，否则只需要取 S2Cap 中心点对应 S2Cell 的 level 级的点邻域 4 个 S2Cell 作为初始候选 S2Cell。</li><li>然后标准化候选种子。第一步，如果候选 S2Cell level 比 maxLevel 大或者候选 S2Cell 的 level 不符合 levelModel，则调整候选 S2Cell 的 level，用指定父级 S2Cell 来代替；第二步，归一化候选 S2Cell，先对 S2Cell 按 id 排序，去除被包含的 id，以及对 id 剪枝（若连续 4 个 S2Cell 共有同一个 parent，则用 parent 代替这 4 个 S2Cell）；第三步，反归一化候选 S2Cell，若候选 S2Cell level 比 minLevel 小或不满足 levelModel，则需要将 S2Cell 分裂，用指定级别的孩子来取代该 S2Cell；第四步，检查是否满足全部条件，若满足，则标准化完成，若不满足，则看候选 S2Cell 的数目是否足够多，若足够多，则需要迭代进行 GetCovering，这样会极大降低算法性能，若不是很多，则迭代合并相同祖先的两个 S2Cell（当然祖先的 level 不能比 minLevel 小），最后再次检查所有候选 S2Cell 是否达到标准化要求，并调整 S2Cell level。</li><li>构造优先级队列。将符合条件（与入参区域相交）的候选 S2Cell 放进一个优先级队列中，优先级会依次根据三个参数进行判断，1、S2Cell 的大小（level 越大，S2Cell 越小），越大的优先级越高；2、入参区域与候选 S2Cell 孩子相交（这里的相交是指相交但不完全包含）的个数，越少优先级越高；3、入参区域完全包含候选 S2Cell 孩子和与无法再细分的孩子的个数，同样是越少优先级越高。在构造这个优先级队列的同时，会输出一些候选 S2Cell 作为覆盖算法的正式结果，这些 S2Cell 满足任意以下条件：1、被入参区域完全覆盖；2、与入参区域相交但不可再细分；3、入参区域包含或相交全部孩子。如此留在优先级队列中的，就都是些与入参区域边界相交的 S2Cell，这些就是真正的候选 S2Cell。</li><li>最后，处理优先级队列中的 S2Cell。处理方式也比较简单粗暴，继续细分并入队，满足上面3个出队条件的任意一个，即可出队作为正式结果，当然，若分到后面可能正式的 S2Cell 太多，甚至超过 maxCells，这时不再细分强行出队作为正式结果。最后，再对正式结果做一次标准化处理，即进行第 2 步，得到最终的覆盖结果。</li></ol><p>　　以上就是 S2 覆盖算法的大致流程，更加细节的东西，还是得看代码，文字有些不是很好描述，代码里面计算候选 S2Cell 的优先级就很有意思。</p><hr /><p>　　当然 S2 中还有很多其他算法（凸包，相交，距离），这里就不做太多介绍了，Shaun 平常用的最多的就是覆盖算法，之前一直没有细看，就简单用用 api，同时为了对一块大的 S2Cell 做多线程处理，需要了解 S2Cell 一分四的方向，经过这次对 S2 的了解，发现之前的用法存在一些问题，可见调包侠同样需要对包有一定的了解才能调好包 ╮(╯▽╰)╭。</p><h2 id="后记">后记</h2><p>　　正如许多经典的算法一样，看完之后总有种我上我也行的感觉，但实际完全不行，S2 全程看下来有些地方确实比较晦涩，而且这一连串的想法也很精妙（单位球立方体投影，ST 空间面积优化，64 位 id 生成等），Shaun 或许能有部分想法，但这么多奇思妙想组合起来，就完全不行。</p><h2 id="附录">附录</h2><h3 id="hilbertcurve-绘制">HilbertCurve 绘制</h3><p>　　在网上随便找了三种实现方式，并用 threejs 简单绘制了一下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> THREE <span class="keyword">from</span> <span class="string">&quot;three&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HilbertCurve</span> </span>&#123;</span><br><span class="line">    order = <span class="number">3</span>; <span class="comment">// 阶数</span></span><br><span class="line">    size = <span class="number">1</span> &lt;&lt; <span class="built_in">this</span>.order; <span class="comment">// 行列数</span></span><br><span class="line">    totalSize = <span class="built_in">this</span>.size * <span class="built_in">this</span>.size; <span class="comment">// 总网格数，希尔伯特长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://www.youtube.com/watch?v=dSK-MW-zuAc</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V1</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path = [];</span><br><span class="line">        <span class="keyword">let</span> origOrientation = [</span><br><span class="line">            [<span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">            [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        ]; <span class="comment">// 倒 U 形</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.totalSize; i++) &#123;</span><br><span class="line">            path.push(hilbertToXY(i, <span class="built_in">this</span>.order));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbertToXY</span>(<span class="params">i: <span class="built_in">number</span>, order: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> index = i &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">let</span> curCoord = origOrientation[index].slice();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> ord = <span class="number">1</span>; ord &lt; order; ord++) &#123;</span><br><span class="line">                i = i &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">                index = i &amp; <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">let</span> delta = <span class="number">1</span> &lt;&lt; ord;</span><br><span class="line">                <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 顺时针旋转 90°</span></span><br><span class="line">                    <span class="keyword">let</span> tmp = curCoord[<span class="number">0</span>];</span><br><span class="line">                    curCoord[<span class="number">0</span>] = curCoord[<span class="number">1</span>];</span><br><span class="line">                    curCoord[<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">1</span>) &#123;</span><br><span class="line">                    curCoord[<span class="number">1</span>] += delta;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">2</span>) &#123;</span><br><span class="line">                    curCoord[<span class="number">0</span>] += delta;</span><br><span class="line">                    curCoord[<span class="number">1</span>] += delta;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index === <span class="number">3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 逆时针旋转 90°</span></span><br><span class="line">                    <span class="keyword">let</span> tmp = delta - <span class="number">1</span> - curCoord[<span class="number">0</span>];</span><br><span class="line">                    curCoord[<span class="number">0</span>] = delta - <span class="number">1</span> - curCoord[<span class="number">1</span>];</span><br><span class="line">                    curCoord[<span class="number">1</span>] = tmp;</span><br><span class="line">                    curCoord[<span class="number">0</span>] += delta;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> curCoord;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hacker&#x27;s Delight</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V2</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path: <span class="built_in">number</span>[][] = [];</span><br><span class="line">        <span class="keyword">let</span> x = -<span class="number">1</span>,</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> s = <span class="number">0</span>; <span class="comment">// along the curve</span></span><br><span class="line"></span><br><span class="line">        step(<span class="number">0</span>);</span><br><span class="line">        hilbert(<span class="number">0</span>, <span class="number">1</span>, <span class="built_in">this</span>.order);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">dir: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (dir &amp; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    x += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    y += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    x -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    y -= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path[s] = [x, y];</span><br><span class="line"></span><br><span class="line">            s += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbert</span>(<span class="params">dir: <span class="built_in">number</span>, rot: <span class="built_in">number</span>, order: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (order === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            dir += rot;</span><br><span class="line">            hilbert(dir, -rot, order - <span class="number">1</span>);</span><br><span class="line">            step(dir);</span><br><span class="line"></span><br><span class="line">            dir -= rot;</span><br><span class="line">            hilbert(dir, rot, order - <span class="number">1</span>);</span><br><span class="line">            step(dir);</span><br><span class="line"></span><br><span class="line">            hilbert(dir, rot, order - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            dir -= rot;</span><br><span class="line">            step(dir);</span><br><span class="line">            hilbert(dir, -rot, order - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.wikipedia.org/wiki/Hilbert_curve</span></span><br><span class="line">    <span class="function"><span class="title">getPath_V3</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> path: <span class="built_in">number</span>[][] = [];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for (let i = 0; i &lt; this.totalSize; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     path.push(hilbertToXY(this.size, i));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> y = <span class="number">0</span>; y &lt; <span class="built_in">this</span>.size; y++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="built_in">this</span>.size; x++) &#123;</span><br><span class="line">                path[xyToHilbert(<span class="built_in">this</span>.size, x, y)] = [x, y];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">rot</span>(<span class="params">N: <span class="built_in">number</span>, rx: <span class="built_in">number</span>, ry: <span class="built_in">number</span>, xy: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (ry === <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rx === <span class="number">1</span>) &#123;</span><br><span class="line">                    xy[<span class="number">0</span>] = N - <span class="number">1</span> - xy[<span class="number">0</span>];</span><br><span class="line">                    xy[<span class="number">1</span>] = N - <span class="number">1</span> - xy[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">let</span> t = xy[<span class="number">0</span>];</span><br><span class="line">                xy[<span class="number">0</span>] = xy[<span class="number">1</span>];</span><br><span class="line">                xy[<span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">hilbertToXY</span>(<span class="params">N: <span class="built_in">number</span>, h: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> t = h;</span><br><span class="line">            <span class="keyword">let</span> xy = [<span class="number">0</span>, <span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> s = <span class="number">1</span>; s &lt; N; s *= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> rx = <span class="number">1</span> &amp; (t / <span class="number">2</span>);</span><br><span class="line">                <span class="keyword">let</span> ry = <span class="number">1</span> &amp; (t ^ rx);</span><br><span class="line">                rot(s, rx, ry, xy);</span><br><span class="line">                xy[<span class="number">0</span>] += s * rx;</span><br><span class="line">                xy[<span class="number">1</span>] += s * ry;</span><br><span class="line">                t /= <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> xy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">xyToHilbert</span>(<span class="params">N: <span class="built_in">number</span>, x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">let</span> xy = [x, y];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> s = N / <span class="number">2</span>; s &gt; <span class="number">0</span>; s /= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">let</span> rx = (xy[<span class="number">0</span>] &amp; s) &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">let</span> ry = (xy[<span class="number">1</span>] &amp; s) &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                h += s * s * ((<span class="number">3</span> * rx) ^ ry);</span><br><span class="line">                rot(N, rx, ry, xy);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> lineGeometry = <span class="keyword">new</span> THREE.Geometry();</span><br><span class="line">        <span class="built_in">this</span>.getPath_V3().forEach(<span class="function">(<span class="params">vertice</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> vecot = <span class="keyword">new</span> THREE.Vector3().fromArray(vertice);</span><br><span class="line">            vecot.setZ(<span class="number">0</span>);</span><br><span class="line">            lineGeometry.vertices.push(vecot);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">let</span> lineMaterial = <span class="keyword">new</span> THREE.LineBasicMaterial(&#123; <span class="attr">color</span>: <span class="number">0x00ffff</span>, <span class="attr">linewidth</span>: <span class="number">1</span> &#125;);</span><br><span class="line">        <span class="keyword">let</span> line = <span class="keyword">new</span> THREE.Line(lineGeometry, lineMaterial);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> line;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　Google S2 Geometry（以下简称 S2） 是 Google 发明的基于单位球的一种地图投影和空间索引算法，该算法可快速进行覆盖以及邻域计算。更多详见 &lt;a href=&quot;https://s2geometry.io/&quot;&gt;S2Geometry&lt;/a&gt;，&lt;a href=&quot;https://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/&quot;&gt;Google’s S2, geometry on the sphere, cells and Hilbert curve&lt;/a&gt;，&lt;a href=&quot;https://halfrost.com/go_s2_regioncoverer/&quot;&gt;halfrost 的空间索引系列文章&lt;/a&gt;。虽然使用 S2 已有一年的时间，但确实没有比较系统的看过其源码，这次借着这段空闲时间，将 Shaun 常用的功能系统的看看其具体实现，下文将结合 S2 的 C++，Java，Go 的版本一起看，由于 Java 和 Go 的都算是 C++ 的衍生版，所以以 C++ 为主，捎带写写这三种语言实现上的一些区别，Java 版本时隔 10 年更新了 2.0 版本，喜大普奔。&lt;/p&gt;</summary>
    
    
    
    <category term="Mathematics" scheme="http://cniter.github.io/categories/Mathematics/"/>
    
    
    <category term="geometry" scheme="http://cniter.github.io/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title>K8S 应用开发指北</title>
    <link href="http://cniter.github.io/posts/55e674ff.html"/>
    <id>http://cniter.github.io/posts/55e674ff.html</id>
    <published>2021-08-28T08:21:58.000Z</published>
    <updated>2021-12-18T11:54:13.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　在周志明的『凤凰架构』中需要思考这样一个问题，如何用不可靠的部件来构造一个可靠的系统？对于程序员来说，写的代码从某种程度上来说都是不可靠的，但这些代码组成的一些系统却可以是可靠的。程序员对于错误的处理可以分为两派，一派是必须对错误进行处理，以保证系统的稳定行；另一派不对错误进行处理，任由程序 crash，只要有兜底方案，后面再不断完善。这两派并无孰优孰劣，只是两种不同的思维方式，甚至在同一个程序中，有些错误会处理，有些错误不会处理，这都是可能的。K8S 作为事实上的云原生操作系统，其目的就是为了将程序员写的各个程序组装成一个稳定的系统，并减少运维成本。</p><span id="more"></span><h2 id="基础篇">基础篇</h2><p>　　K8S 调度的基本单元是 Pod，Pod 也是 K8S 自带的一个资源对象，其可以简单理解为是一个容器集合体，程序员可控的容器有两类（Pause 容器除外），一类是 InitContainer，另一类是普通业务容器，InitContainer 按数组顺序创建，顺序执行，若一个失败，则整个 Pod 创建失败，普通业务容器同样按数组顺序创建，但异步执行，所以执行顺序不可控（可以通过 postStart Hook 简单控制一下）。由于 InitContainer 先于 Pod 其他容器执行，所以一般用来做普通业务容器执行前置条件的一些事情，比如：下载文件，初始化配置，状态消息通知等。</p><p>　　同一 Pod 中存储卷和网络可以共享。存储卷共享是指 Pod 内各容器可以挂载相同存储卷，从而数据共享。K8S 目前支持的存储卷共有三种：第一种是 emptyDir，这种存储是临时的，只能在 Pod 内使用，当 Pod 被销毁时，该存储的内容也会消失，只能在同一 Pod 内共享数据；第二种是 hostPath，这种存储会直接和集群中物理机存储相关联，是一种跨 Pod 持久化存储，但仅限该物理机，当 pod 被调度到其他物理机时就无法实现跨 Pod 共享数据；最后一种是外部存储（NFS，Ceph，GlusterFS，AWS EBS 等），这种方式可以真正实现数据持久化并共享，而且可以支持存储与计算分离，对系统会更友好一些，当然运维的成本也会更大。当然除了 K8S 自身提供的存储卷挂载可以实现数据共享，从程序的角度上，使用传统的方式一样也能数据共享，如数据库，DFS，OSS 等。</p><p>　　而网络共享是指 Pod 内各容器直接可以使用 localhost 以及容器暴露的端口进行相互通信，K8S 的端口有三种，分别为：容器端口（containerPort，容器中对外暴露的端口），集群内端口（port，集群内 pod 相互通信的端口），集群外端口（nodePort，集群外请求集群内的端口），其中容器端口和集群内是正常的动态端口，取值范围为 [1024, 65535]，集群外端口只能设置为 [30000, 32767]，若集群中服务不与集群外通信，则只需要设置集群内端口就行。K8S 中 IP 也同样有三种，分别为：Pod IP（两不同 Pod 资源对象相互通信的地址，集群外不可访问），Cluster IP（Service 资源对象的通信地址，集群外不可访问），Node IP（K8S 物理节点的 IP 地址，是真实的物理网络，集群外配合 nodePort 即可访问）。集群内端口和集群外端口由 K8S 的 Service 资源提供设置。<em>在创建 Service 时需要注意，一个 Pod 资源对应一个 Service 资源，不要想着一个 Service 管理两个 Pod 暴露的端口，这样做会使 Service 提供服务的能力异常，经常会接口超时</em>。</p><p>　　K8S 编程可以简单称之为面向 config 编程，一切需要动态变化的程序初始化变量，都应该以 config 的形式提供，然后交给运维就行，这样可以避免程序员频繁的修改程序，减少运维负担，K8S 的 config 有三种形式，第一种是程序启动参数，通过创建容器时的 args 参数配置；第二种是系统环境变量，通过创建容器时的 env 参数配置；最后一种是 K8S 提供的 ConfigMap 资源，该资源可以从文件，目录或 key-value 字符串创建，创建后的 ConfinMap 被全集群同命名空间所共享，可以通过 volumes 参数挂载到 pod 中，进而 mount 进容器中，被程序读取。前两种 config 方式对于配置变量少的可以使用，当配置变量很多或配置参数很长时，还是使用 ConfigMap 比较合适。</p><h2 id="调度篇">调度篇</h2><p>　　调度，广义上的调度可指一切管理安排，CPU 的指令执行就涉及到三级缓存的调度，程序运行时的 GC 可认为是运行时对内存资源的调度，操作系统的进程轮转可认为是系统对进程的调度，而 K8S 中的调度可简单理解为是对操作系统的调度。</p><p>　　K8S 的调度可简单分为两个层面上的调度，最底层的调度自然是 K8S 自身的调度策略，根据不同的资源用度和调度策略将 Pod 分配到不同的物理节点之上执行，根据指定的重启或恢复策略启动相应的 Pod，这个层面上的调度，K8S 有一套默认的调度器，对于特殊的调度需求，K8S 也支持自定义调度器，使用外部调度器代替默认调度器，这个层面的调度器 Shaun 没做太多研究，所以在这篇里对这层面的调度器不做过多描述。Shaun 接触过的是更上层的调度器，业务层面的调度服务，业务调度服务一般与业务紧密相关，但最核心的一点就是能够从业务入手，负责 Pod 的创建和销毁，并能掌握其运行状态，就算是完成了一个基础的业务调度服务器。</p><p>　　在设计业务调度服务时，有一种通用的模式，可以称之为 master-worker 模式，与同名的并发模式细节上有所不同，这里的 master 是指调度服务本体，只负责对外服务，资源监控，以及任务分发，任务状态感知等，不负责做具体的任务，一般也不关心任务的输入输出。在部署 master 时，一般会创建一个 Service 资源对象，毕竟其主要功能就是对外服务，master 一般由运维进行部署创建销毁。而 worker 是指真正做任务的 Pod，该 Pod 中可能会有多个容器，主容器负责真正执行任务，其他一些容器可能会负责保障任务的前置条件（输入，配置等），以及向 master 汇报任务执行状态信息（执行任务的主容器可能并不知道 master 的存在）等。worker 对应的 Pod 一般由 master 进行创建销毁，worker 的一些配置信息则可能会由运维管理。</p><p>　　由于 K8S 并没有在整个集群物理资源之上抽象出一层集群资源，所以 K8S 分配的节点实际还是在物理机上，若所有物理机剩余资源（是单个剩余资源，而不是所有剩余资源之和）都不满足 Pod 所需资源，则该 Pod 无法调度，类比内存碎片化，可以称之为资源碎片化。所以在创建 Pod 时，所需资源最好不要太多，以免调度失败。</p><h2 id="实践篇">实践篇</h2><p>　　Shaun 目前在 K8S 上开发的主要就是重计算（单机计算时间以小时计）调度服务。这类调度服务其实也分两种，一种是并发调度，一种是流水线（pipeline）式的串行调度，当然也可以将这两种混合起来，串行中有并行。在设计这类调度服务时，需要考虑集群上的资源（内存，CPU）是否足够，若不足，则可以考虑加入一个简单的等待机制，将任务放进一个队列中，当然加入这样一个等待机制，又会增加系统复杂性，需要考虑队列容量，队列优先级等。所以可执行的最小任务消耗的资源越少约好，否则集群中可能完全无法执行相关任务。</p><p>　　由于 Shaun 是独立开发，能完全控制 master 和 worker 的编写，所以 worker 设计的比较简单，一个主容器即完成了前置数据处理，主任务执行，执行状态汇报等全部事情，这是从时间和性能上以及系统复杂度上等多方面权衡的结果，当然在时间足够人手够的情况，是应该把现有的 worker 进一步分离的，而 master 就是比较通用的设计，资源监控，任务队列，任务 Pod 创建与销毁，任务状态信息保存，服务接口等，其中常规的服务接口应该有添加任务，开始任务，停止任务，恢复任务，删除任务，任务状态查询，任务日志查询，任务状态汇报等接口，如果任务是并行且无依赖的，还应该支持开始指定子任务等接口。</p><p>　　在工作中，Shaun 也接触到一个 pipeline 式的任务调度服务，pipeline 式的工作流有个特点就是下一个子任务的输入必定依赖上一个子任务的输出，在这个任务调度服务中，其子任务的输入输出都是文件态，并且 master 不关心子任务的输入输出，子任务的执行程序也不知道 master 的存在，尽量低耦合。在云上，文件态的存储载体比较好的自然是 OSS，但原本的子任务执行程序只支持本地读取文件，而且在原来的程序中引入 OSS 的读写逻辑并不十分合适，所以在 K8S 中引入了 NFS，由 master 负责将 NFS 挂载到各子任务的 Pod 中，并在挂载到主容器时使用 SubPath 完成 pipeline 之间的资源隔离，使用 emptyDir 完成各子任务之间的资源隔离，每条 pipeline 开始的子任务是从 OSS 中拉取文件到 NFS 中对应的 SubPath 目录中，结束的子任务是将 NFS 中对应的 SubPath 目录中约定好的生成物上传到 OSS 中，并清空该 SubPath 目录，从而使原来的程序在 IO 这块完全不用改动。在监听任务运行状态方面，有两种方案：一种是利用 K8S 的 InitContainer，另一种是借助 K8S 的 shareProcessNamespace。InitContainer 的方案比较简单，InitContainer 第一个容器只做汇报子任务开始这一件事， 第二个容器则是真正执行子任务的容器，而业务容器只做汇报子任务结束这一件事，该方案利用 InitContainer 顺序且先于业务容器执行这两特点，并且若执行子任务的容器失败，则 Pod 也会创建失败，查询 Pod 状态即可知道子任务是否正常运行。而 shareProcessNamespace 的方案稍微复杂一些，同样使用一个 InitContainer 做汇报子任务开始这件事，而业务容器中放两个容器：一个主容器和一个 sidecar 容器（希望 K8S 原生支持的 SideCar 早日做好 ╯△╰），sidecar 容器中以轮询的方式监听主容器的运行状态（查询是否存在主进程）以及是否正常退出（获取容器退出码），并向 master 推送状态信息，该方案借助进程空间共享，使 sidecar 容器能直接查询主容器中的进程，从而达到监听主容器运行状态的目的，该方案的执行还需要一个小 trick，就是要让主容器先执行，由两种方案：一种是借助 postStart Hook，另一种是直接让 sidecar 容器先休眠个 10s 钟。关于 sidecar 容器的另外一种应用方案可参考 <a href="https://zhuanlan.zhihu.com/p/143845408">Nginx容器配置文件如何热更新？</a> 。</p><p>　　虽然分布式任务调度框架有很多，eg：<a href="https://airflow.apache.org/">Airflow</a>、<a href="https://github.com/spotify/luigi">Luigi</a> 以及 <a href="https://dolphinscheduler.apache.org">DolphinScheduler</a> 等，但目前与 K8S 联系最紧密的应该就是 <a href="https://argoproj.github.io/">Argo</a> 了，其利用 K8S 的自定义资源对 K8S 已有功能进行扩展，仅使用 YAML 即可完成整个 pipeline 的任务调度和部署，虽然在并发任务调度时有一定的缺陷，但仅使用 YAML 表示其对 K8S 运维的足够友好性，对于常规 pipeline 式任务，Argo 已足以应付，除特殊需求外，程序员可少写很多代码。</p><h3 id="附录">附录</h3><p>　　对于 Spring 编写的程序，在 K8S 中运行，在导出日志时可参考 <a href="https://www.cnblogs.com/varyuan/p/14243472.html">k8s:获取pod的ip</a>，通过 valueFrom 使用 Pod 的 metadata 作为环境变量，以区分日志的来源，不过挂载存储时最好还是用外部存储，用 hostPath 的话就需要保证每个物理节点都有相同的日志存储目录。</p><h2 id="后记">后记</h2><p>　　K8S 作为云原生时代的操作系统，不要求人人都完全掌握，但至少需要了解，知道什么该开发干，什么该运维干，这样才能充分发挥各个角色（包括 K8S）的价值。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　在周志明的『凤凰架构』中需要思考这样一个问题，如何用不可靠的部件来构造一个可靠的系统？对于程序员来说，写的代码从某种程度上来说都是不可靠的，但这些代码组成的一些系统却可以是可靠的。程序员对于错误的处理可以分为两派，一派是必须对错误进行处理，以保证系统的稳定行；另一派不对错误进行处理，任由程序 crash，只要有兜底方案，后面再不断完善。这两派并无孰优孰劣，只是两种不同的思维方式，甚至在同一个程序中，有些错误会处理，有些错误不会处理，这都是可能的。K8S 作为事实上的云原生操作系统，其目的就是为了将程序员写的各个程序组装成一个稳定的系统，并减少运维成本。&lt;/p&gt;</summary>
    
    
    
    <category term="CloudNative" scheme="http://cniter.github.io/categories/CloudNative/"/>
    
    
    <category term="k8s" scheme="http://cniter.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL坐标系统与渲染管线</title>
    <link href="http://cniter.github.io/posts/81321445.html"/>
    <id>http://cniter.github.io/posts/81321445.html</id>
    <published>2021-05-28T10:22:41.000Z</published>
    <updated>2021-12-18T11:54:13.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　图形学中最基础的东西就是坐标系统，三维的东西如何在二维中显示，这中间经历了数次坐标变换，同时坐标变换也贯穿了整个计算机图形渲染管线。</p><span id="more"></span><h2 id="坐标篇">坐标篇</h2><figure><img src="https://learnopengl-cn.github.io/img/01/08/coordinate_systems.png" alt="coordinate_systems" /><figcaption aria-hidden="true">coordinate_systems</figcaption></figure><p>　　在计算机图形世界中，为更灵活的控制三维物体显示在二维中，将变换的过程大致分为 5 个空间：1、局部空间（Local Space，或者称为物体空间（Object Space））；2、世界空间（World Space）；3、观察空间（View Space，或者称为视觉空间（Eye Space））；4、裁剪空间（Clip Space）；5、屏幕空间（Screen Space）。局部空间中是物体相对于坐标原点的坐标，也是物体的固有坐标，在依次经历过缩放旋转平移，也即模型矩阵（Model Matrix）变换后，物体局部坐标变换为世界坐标，世界坐标中即定义了物体所在的位置，以及产生的旋转和缩放。在世界空间中加入相机，以相机的视角看世界中的物体，即通过观察矩阵（View Matrix，也称视图矩阵）变换后，将世界坐标转换为观察坐标，由于一张屏幕能显示的东西是有限的，而三维世界中的物体是无限，所以需要通过投影矩阵（Projection Matrix）对三维空间进行裁剪，以决定哪些物体能显示在屏幕上，为方便的计算机判断，处于裁剪空间内的坐标会被转换为 [-1, 1]，为顺利在屏幕上显示，又需要通过视窗变换（Viewport Transform）将 [-1, 1] 映射为 viewport 中的图元坐标，再通过渲染管线的其他流程输出为屏幕上的像素点。</p><h2 id="变换篇">变换篇</h2><p>　　矩阵相乘一般有左乘和右乘之分，左乘和右乘的区别在于坐标是按列还是按行排列（OpenGL 中是按列，所以是左乘，DX 中按行，所以是右乘，同一种变换，传入 DX 中的矩阵与传入 OpenGL 中的矩阵互为转置），坐标与矩阵相乘越靠近坐标的矩阵表示该坐标越先做相应矩阵变换。</p><p>　　模型矩阵，视图矩阵，投影矩阵，在简单的顶点着色器编程中，这三个矩阵一般会合并成一个 MVP 矩阵传入 GPU 中。</p><h3 id="模型矩阵">模型矩阵</h3><p>　　模型矩阵一般定义了物体的缩放旋转平移状态，缩放矩阵的构造很简单，若物体在 <span class="math inline">\((x,y,z)\)</span> 方向上缩放尺度分别为 <span class="math inline">\((S_x, S_y, S_z)\)</span>，则缩放矩阵为： <span class="math display">\[M_{scaling} = \begin{bmatrix} S_x &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; S_y &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; S_z &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\]</span> 　　旋转矩阵就非常麻烦了，这里暂且不讨论其如何计算，只给出矩阵，物体绕任意轴 <span class="math inline">\((R_X, R_y, R_z)\)</span> 旋转 θ 角的矩阵为： <span class="math display">\[M_{rotation} = \begin{bmatrix} cos\theta+R_x^2(1-cos\theta) &amp; R_xR_y(1-cos\theta)-R_zsin\theta &amp; R_xR_z(1-cos\theta)+R_ysin\theta &amp; 0 \\ R_yR_x(1-cos\theta)+R_zsin\theta &amp; cos\theta+R_y^2(1-cos\theta) &amp; R_yR_z(1-cos\theta)-R_xsin\theta &amp; 0 \\ R_zR_x(1-cos\theta)-R_ysin\theta &amp; R_zR_y(1-cos\theta)+R_xsin\theta &amp; cos\theta+R_z^2(1-cos\theta) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\]</span> 　　当然，由于万向节锁的存在，一般不会直接使用欧拉角和旋转轴计算旋转矩阵，而是会通过四元数得到旋转矩阵，这样既高效又能避免万向节锁，详情可看「LearnOpenGL」译者的<a href="https://krasjet.github.io/quaternion/">教程</a>。</p><p>　　至于平移矩阵也非常简单，若物体在 <span class="math inline">\((x,y,z)\)</span> 方向上平移量分别为 <span class="math inline">\((T_x, T_y, T_z)\)</span>，则平移矩阵为： <span class="math display">\[M_{translation} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; T_x \\ 0 &amp; 1 &amp; 0 &amp; T_y \\ 0 &amp; 0 &amp; 1 &amp; T_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\]</span> 　　前面的缩放和旋转矩阵其实只需要用到 3×3 的矩阵，而之所以用 4×4 的表示也是因为平移矩阵，普通的 3 维坐标必须增加一维 <span class="math inline">\(w\)</span> 构成齐次坐标才能进行平移操作，<span class="math inline">\(w\)</span> 一般都是 1.0，而从齐次坐标<span class="math inline">\((x,y,z,w)\)</span> 变为普通的 3 维坐标需要每个分量除以 <span class="math inline">\(w\)</span>，即 <span class="math inline">\((x/w, y/w, z/w)\)</span> 。</p><p>则模型矩阵 <span class="math inline">\(M_{model} = M_{translation} \cdot M_{rotation} \cdot M_{scaling}\)</span>。</p><h3 id="视图矩阵">视图矩阵</h3><p>　　视图矩阵描述的是三维场景中模拟相机的状态，根据模拟相机的状态确定一套以相机为原点的相机坐标系，从而使用视图矩阵进行坐标变换，至于为啥是模拟相机，是因为 OpenGL 本身并没有相机的概念，通过模拟相机来实现在三维场景中的漫游。</p><figure><img src="https://learnopengl-cn.github.io/img/01/09/camera_axes.png" alt="camera_axes" /><figcaption aria-hidden="true">camera_axes</figcaption></figure><p>　　模拟相机有三个关键点，分别为相机位置（cameraPos），相机朝向点（cameraTarget），相机上向量（top），根据相机位置和相机朝向点可确定相机坐标系的 z 轴正向向量 <span class="math inline">\(cameraDirection = (cameraPos - cameraTarget).normalize\)</span>，叉乘相机上向量和相机 z 轴正向向量可得到相机坐标系 x 轴正向向量 <span class="math inline">\(cameraRight = top.cross(cameraDirection).normalize\)</span>，最后将相机 z 轴正向向量与 x 轴正向向量叉乘得到 y 轴正向向量 <span class="math inline">\(cameraUp = cameraDirection.cross(cameraRight)\)</span>，如此即可建立完整的相机坐标系，从而得到变换矩阵，即视图矩阵： <span class="math display">\[M_{view} = \begin{bmatrix} R_x &amp; R_y &amp; R_z &amp; 0 \\ U_x &amp; U_y &amp; U_z &amp; 0 \\ D_x &amp; D_y &amp; D_z &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -P_x \\ 0 &amp; 1 &amp; 0 &amp; -P_y \\ 0 &amp; 0 &amp; 1 &amp; -P_z \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}\]</span> 其中 <span class="math inline">\(R\)</span> 是相机 x 轴正向向量，<span class="math inline">\(U\)</span> 是相机 y 轴正向向量，<span class="math inline">\(D\)</span> 是相机 z 轴正向向量， <span class="math inline">\(P\)</span> 是相机位置向量。</p><h3 id="投影矩阵">投影矩阵</h3><p>　　投影矩阵描述的是摄像机前的可视区域（Frustum），根据可视区域的形状可分为正射投影（Orthographic Projection）和透视投影（Perspective Projection）。</p><p><img src="https://learnopengl-cn.github.io/img/01/08/orthographic_frustum.png" alt="orthographic projection frustum" /> <img src="https://learnopengl-cn.github.io/img/01/08/perspective_frustum.png" alt="perspective_frustum" /></p><p>　　对于这两种投影，都有远（far）近（near）参数，不同的是，正射投影是个立方体，所以有左（left）右（right）上（top）下（bottom）四个参数，而透视投影是个类梯形台，所以还有垂直方向视野（Field of View，fov），以及一个宽高比（aspect）两个参数。远近两个参数决定摄像机能看到多近和多远的物体，太近和太远都会看不见，一般可设 near = 0.1，far = 1000；若渲染视窗（viewport）宽为 W，高为 H，则一般 <span class="math inline">\(left=-W/2, right=W/2, top=H/2, bottom=-H/2\)</span> ；透视投影的 fov 是角度，一般设为 45.0，而 <span class="math inline">\(aspect = W/H\)</span> 。这两种投影的矩阵分别为： <span class="math display">\[M_{orth} = \begin{bmatrix} \frac{2}{right-left} &amp; 0 &amp; 0 &amp; -\frac{right+left}{right-left} \\ 0 &amp; \frac{2}{top-bottom} &amp; 0 &amp; -\frac{top+bottom}{top-bottom} \\ 0 &amp; 0 &amp; \frac{-2}{far-near} &amp; -\frac{far+near}{far-near} \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \\M_{pers} = \begin{bmatrix} \frac{2near}{right-left} &amp; 0 &amp; \frac{right+left}{right-left} &amp; 0 \\ 0 &amp; \frac{2near}{top-bottom} &amp; \frac{top+bottom}{top-bottom} &amp; 0 \\ 0 &amp; 0 &amp; \frac{-(far+near)}{far-near} &amp; \frac{-2far*near}{far-near} \\ 0 &amp; 0 &amp; -1 &amp; 0 \end{bmatrix}\]</span></p><p>　　在 three.js 中，对于透视投影矩阵中 left, right, top, bottom 计算方式为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="JAVASCRIPT"><figure class="highlight hljs javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> top = near * <span class="built_in">Math</span>.tan( _Math.DEG2RAD * <span class="number">0.5</span> * <span class="built_in">this</span>.fov ) / <span class="built_in">this</span>.zoom;</span><br><span class="line"><span class="keyword">let</span> height = <span class="number">2</span> * top;</span><br><span class="line"><span class="keyword">let</span> width = <span class="built_in">this</span>.aspect * height;</span><br><span class="line"><span class="keyword">let</span> left = - <span class="number">0.5</span> * width;</span><br><span class="line"><span class="keyword">let</span> right = left + width;</span><br><span class="line"><span class="keyword">let</span> bottom = top - height;</span><br></pre></td></tr></table></figure></div><p>　　对于透视投影，由于计算出的齐次坐标 w 分量显然不为 1.0，所以必须进行透视除法（x,y,z 各分量分别除以 w），得到真正的 3 维坐标。</p><p>　　正射投影一般用来模拟 2D 空间，透视投影用来模拟 3D 空间，当透视投影 near 和 far 设置的相差太大时，很容易引发 z-fighting 现象，原因是离近平面越远时，计算出的深度精度越低，three.js 中为解决这一问题，引入了一个 logarithmicDepthBuffer 参数来决定是否开启使用对数函数优化深度计算，具体可看源码中的 logdepthbuf_vertex.glsl.js 和 logdepthbuf_fragment.glsl.js 文件，开启该参数会造成渲染性能下降。</p><h3 id="小结">小结</h3><p>　　<span class="math inline">\(M_{mvp} = M_{projection}M_{view}M_{model}\)</span>，一个局部坐标 <span class="math inline">\(V_{local}\)</span> 在经过 MVP 矩阵变换之后可得到裁剪坐标 <span class="math inline">\(V_{clip} = M_{mvp}V_{local}\)</span> ，在 OpenGL 中，<span class="math inline">\(V_{clip}\)</span> 会被赋值到顶点着色器中的 <code>gl_Position</code>，并且 OpenGL 会自动进行透视除法和裁剪。</p><p>　　3 维中的相机一般可分为两种，第一人称相机（常规 FPS 游戏）和第三人称相机（常规 ARPG 游戏），第一人称相机的特点是灵活，相机往往可以任意改变位置和朝向，所以会对某些人造成一种 “晕 3D” 的现象，而第三人称相机虽然可以改变相机朝向点和位置，但当朝向点和到朝向点的距离一旦固定，则相机只能沿着以朝向点为球心，以到朝向点的距离为半径的球面上运动，这两种相机一般看具体业务需求进行选择。</p><p>　　缩放操作是很常规的一种操作，镜头拉近代表放大，拉远代表缩小。在使用透视投影的 3 维场景中，只需要改变相机到朝向点的距离即可简单实现缩放操作，而在使用正射投影的场景中，改变距离并不能实现缩放，而是需要改变 左右上下 四个参数，所以在相机中往往会在引入一个 zoom 的参数，用 左右上下 四个参数分别除以 zoom 得到真正的 左右上下，从而改变 zoom，就可以改变相机参数，进而实现正射投影的缩放。</p><h2 id="管线篇">管线篇</h2><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="processonSvg1000" viewBox="-14.0 -19.5 759.0 557.625" width="600" height="500"><defs id="ProcessOnDefs1001"><marker id="ProcessOnMarker1009" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1010" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1017" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1018" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1025" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1026" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1038" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1039" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1047" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1048" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1055" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1056" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1063" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1064" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1071" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1072" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1083" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1084" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1089" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1090" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1105" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1106" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1116" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1117" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1122" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1123" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker><marker id="ProcessOnMarker1138" markerUnits="userSpaceOnUse" orient="auto" markerWidth="16.23606797749979" markerHeight="10.550836550532098" viewBox="-1.0 -1.3763819204711736 16.23606797749979 10.550836550532098" refX="-1.0" refY="3.8990363547948754"><path id="ProcessOnPath1139" d="M12.0 3.8990363547948754L0.0 7.798072709589751V0.0Z" stroke="#999" stroke-width="2.0" fill="#999" transform="matrix(1.0,0.0,0.0,1.0,0.0,0.0)"></path></marker></defs><g id="ProcessOnG1002"><path id="ProcessOnPath1003" d="M-14.0 -19.5H745.0V538.125H-14.0V-19.5Z" fill="none"></path><g id="ProcessOnG1004"><g id="ProcessOnG1005" transform="matrix(1.0,0.0,0.0,1.0,6.0,122.0)" opacity="1.0"><path id="ProcessOnPath1006" d="M0.0 39.5C0.0 -13.166666666666666 84.0 -13.166666666666666 84.0 39.5C84.0 92.16666666666667 0.0 92.16666666666667 0.0 39.5Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1007"><path id="ProcessOnPath1008" d="M90.0 161.5L137.3829796415478 161.5" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1009)"></path></g><g id="ProcessOnG1011" transform="matrix(1.0,0.0,0.0,1.0,152.6190476190476,126.5)" opacity="1.0"><path id="ProcessOnPath1012" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1013" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1014" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="16" x="39.0" y="16.4">顶点着色器</text></g></g><g id="ProcessOnG1015"><path id="ProcessOnPath1016" d="M252.6190476190476 161.5L263.7639320225002 161.5" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1017)"></path></g><g id="ProcessOnG1019" transform="matrix(1.0,0.0,0.0,1.0,279.0,126.5)" opacity="1.0"><path id="ProcessOnPath1020" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1021" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1022" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="16" x="39.0" y="16.4">图元装配</text></g></g><g id="ProcessOnG1023"><path id="ProcessOnPath1024" d="M379.0 161.5L413.7639320225002 161.5" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1025)"></path></g><g id="ProcessOnG1027" transform="matrix(1.0,0.0,0.0,1.0,429.0,126.5)" opacity="1.0"><path id="ProcessOnPath1028" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1029" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1030" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="16" x="39.0" y="16.4">光栅器</text></g></g><g id="ProcessOnG1031" transform="matrix(1.0,0.0,0.0,1.0,24.5,150.0)" opacity="1.0"><path id="ProcessOnPath1032" d="M0.0 0.0L47.0 0.0L47.0 23.0L0.0 23.0Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1033" transform="matrix(1.0,0.0,0.0,1.0,0.0,-7.25)"><text id="ProcessOnText1034" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="22.5" y="15.375">顶点</text><text id="ProcessOnText1035" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="22.5" y="34.125">缓冲区</text></g></g><g id="ProcessOnG1036"><path id="ProcessOnPath1037" d="M529.0 161.5L548.5 161.5L548.5 161.5L552.7639320225002 161.5" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1038)"></path></g><g id="ProcessOnG1040" transform="matrix(1.0,0.0,0.0,1.0,568.0,126.5)" opacity="1.0"><path id="ProcessOnPath1041" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1042" transform="matrix(1.0,0.0,0.0,1.0,10.0,15.0)"><text id="ProcessOnText1043" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">片元着色</text><text id="ProcessOnText1044" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="36.4">器</text></g></g><g id="ProcessOnG1045"><path id="ProcessOnPath1046" d="M668.0 161.5L725.0 161.5L725.0 271.8354430379747L710.2360679774998 271.8354430379747" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1047)"></path></g><g id="ProcessOnG1049" transform="matrix(1.0,0.0,0.0,1.0,595.0,236.8354430379747)" opacity="1.0"><path id="ProcessOnPath1050" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1051" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1052" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">归属测试</text></g></g><g id="ProcessOnG1053"><path id="ProcessOnPath1054" d="M595.0 271.8354430379747L556.0 271.8354430379747L556.0 271.8354430379747L532.2360679774998 271.8354430379747" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1055)"></path></g><g id="ProcessOnG1057" transform="matrix(1.0,0.0,0.0,1.0,417.0,236.8354430379747)" opacity="1.0"><path id="ProcessOnPath1058" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1059" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1060" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">模板测试</text></g></g><g id="ProcessOnG1061"><path id="ProcessOnPath1062" d="M417.0 271.8354430379747L378.5 271.8354430379747L378.5 271.8354430379747L355.2360679774998 271.8354430379747" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1063)"></path></g><g id="ProcessOnG1065" transform="matrix(1.0,0.0,0.0,1.0,240.0,236.8354430379747)" opacity="1.0"><path id="ProcessOnPath1066" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1067" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1068" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">深度测试</text></g></g><g id="ProcessOnG1069"><path id="ProcessOnPath1070" d="M240.0 271.8354430379747L207.0 271.8354430379747L207.0 271.8354430379747L189.2360679774998 271.8354430379747" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1071)"></path></g><g id="ProcessOnG1073" transform="matrix(1.0,0.0,0.0,1.0,74.0,236.8354430379747)" opacity="1.0"><path id="ProcessOnPath1074" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1075" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1076" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">融合</text></g></g><g id="ProcessOnG1077" transform="matrix(1.0,0.0,0.0,1.0,74.0,444.25)" opacity="1.0"><path id="ProcessOnPath1078" d="M0.0 4.0Q0.0 0.0 4.0 0.0L96.0 0.0Q100.0 0.0 100.0 4.0L100.0 66.0Q100.0 70.0 96.0 70.0L4.0 70.0Q0.0 70.0 0.0 66.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1079" transform="matrix(1.0,0.0,0.0,1.0,10.0,25.0)"><text id="ProcessOnText1080" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="微软雅黑" text-anchor="middle" font-size="16" x="39.0" y="16.4">抖动</text></g></g><g id="ProcessOnG1081"><path id="ProcessOnPath1082" d="M74.0 271.8354430379747L20.0 271.8354430379747L20.0 479.25L58.763932022500214 479.25" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1083)"></path></g><g id="ProcessOnG1085" transform="matrix(1.0,0.0,0.0,1.0,250.05952380952385,440.375)" opacity="1.0"><path id="ProcessOnPath1086" d="M0.0 38.875C0.0 -12.958333333333334 79.88095238095235 -12.958333333333334 79.88095238095235 38.875C79.88095238095235 90.70833333333333 0.0 90.70833333333333 0.0 38.875Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1087"><path id="ProcessOnPath1088" d="M174.0 479.25L212.02976190476193 479.25L212.02976190476193 479.25L234.82345583202405 479.25" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1089)"></path></g><g id="ProcessOnG1091" transform="matrix(1.0,0.0,0.0,1.0,268.73809523809524,467.75)" opacity="1.0"><path id="ProcessOnPath1092" d="M0.0 0.0L47.0 0.0L47.0 23.0L0.0 23.0Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1093" transform="matrix(1.0,0.0,0.0,1.0,0.0,-7.25)"><text id="ProcessOnText1094" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="22.5" y="15.375">颜色</text><text id="ProcessOnText1095" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="22.5" y="34.125">缓冲区</text></g></g><g id="ProcessOnG1096" transform="matrix(1.0,0.0,0.0,1.0,624.0,3.500000000000014)" opacity="1.0"><path id="ProcessOnPath1097" d="M0.0 38.49999999999999C0.0 -12.83333333333333 82.0 -12.83333333333333 82.0 38.49999999999999C82.0 89.83333333333331 0.0 89.83333333333331 0.0 38.49999999999999Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1098" transform="matrix(1.0,0.0,0.0,1.0,639.2619047619048,30.16455696202533)" opacity="1.0"><path id="ProcessOnPath1099" d="M0.0 0.0L51.476190476190474 0.0L51.476190476190474 25.32911392405063L0.0 25.32911392405063Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1100" transform="matrix(1.0,0.0,0.0,1.0,0.0,-6.085443037974684)"><text id="ProcessOnText1101" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="24.738095238095237" y="15.375">纹理</text><text id="ProcessOnText1102" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="24.738095238095237" y="34.125">缓冲区</text></g></g><g id="ProcessOnG1103"><path id="ProcessOnPath1104" d="M665.0 80.5L665.0 103.5L618.0 103.5L618.0 111.26393202250021" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1105)"></path></g><g id="ProcessOnG1107" transform="matrix(1.0,0.0,0.0,1.0,252.6190476190476,346.0)" opacity="1.0"><path id="ProcessOnPath1108" d="M0.0 37.0C0.0 -12.333333333333334 74.76190476190476 -12.333333333333334 74.76190476190476 37.0C74.76190476190476 86.33333333333333 0.0 86.33333333333333 0.0 37.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1109" transform="matrix(1.0,0.0,0.0,1.0,264.26190476190476,370.33544303797464)" opacity="1.0"><path id="ProcessOnPath1110" d="M0.0 0.0L51.476190476190474 0.0L51.476190476190474 25.32911392405063L0.0 25.32911392405063Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1111" transform="matrix(1.0,0.0,0.0,1.0,0.0,-6.085443037974684)"><text id="ProcessOnText1112" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="24.738095238095237" y="15.375">深度</text><text id="ProcessOnText1113" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="24.738095238095237" y="34.125">缓冲区</text></g></g><g id="ProcessOnG1114"><path id="ProcessOnPath1115" d="M290.0 306.8354430379747L290.0 326.4177215189874L289.99999999999994 326.4177215189874L289.99999999999994 330.7639320225002" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1116)"></path></g><g id="ProcessOnG1118" transform="matrix(1.0,0.0,0.0,1.0,78.0,25.0)" opacity="1.0"><path id="ProcessOnPath1119" d="M0.0 39.5C0.0 -13.166666666666666 84.0 -13.166666666666666 84.0 39.5C84.0 92.16666666666667 0.0 92.16666666666667 0.0 39.5Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1120"><path id="ProcessOnPath1121" d="M120.0 104.0L120.0 161.5L137.3829796415478 161.5" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1122)"></path></g><g id="ProcessOnG1124" transform="matrix(1.0,0.0,0.0,1.0,78.75,48.5)" opacity="1.0"><path id="ProcessOnPath1125" d="M0.0 0.0L82.5 0.0L82.5 32.0L0.0 32.0Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1126" transform="matrix(1.0,0.0,0.0,1.0,0.0,-2.75)"><text id="ProcessOnText1127" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="40.25" y="15.375">uniform</text><text id="ProcessOnText1128" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="40.25" y="34.125">数据</text></g></g><g id="ProcessOnG1129" transform="matrix(1.0,0.0,0.0,1.0,529.0,0.5)" opacity="1.0"><path id="ProcessOnPath1130" d="M0.0 40.0C0.0 -13.333333333333334 82.0 -13.333333333333334 82.0 40.0C82.0 93.33333333333333 0.0 93.33333333333333 0.0 40.0Z" stroke="#999" stroke-width="2.0" stroke-dasharray="none" opacity="1.0" fill="none"></path></g><g id="ProcessOnG1131" transform="matrix(1.0,0.0,0.0,1.0,529.75,26.829113924050645)" opacity="1.0"><path id="ProcessOnPath1132" d="M0.0 0.0L82.5 0.0L82.5 32.0L0.0 32.0Z" stroke="#999" stroke-width="0.0" stroke-dasharray="none" opacity="1.0" fill="none"></path><g id="ProcessOnG1133" transform="matrix(1.0,0.0,0.0,1.0,0.0,-2.75)"><text id="ProcessOnText1134" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="40.25" y="15.375">uniform</text><text id="ProcessOnText1135" fill="#999" font-weight="normal" font-style="normal" text-decoration="none" font-family="Arial,宋体" text-anchor="middle" font-size="15" x="40.25" y="34.125">数据</text></g></g><g id="ProcessOnG1136"><path id="ProcessOnPath1137" d="M570.0 80.5L570.0 103.5L618.0 103.5L618.0 111.26393202250021" stroke="#999" stroke-width="2.0" stroke-dasharray="none" fill="none" marker-end="url(#ProcessOnMarker1138)"></path></g></g></g></svg><p>　　渲染管线，图形学中最重要的概念之一，既然称之为管线，自然有像流水线一样的步骤，各个步骤具体做的事情如下：</p><ol type="1"><li>顶点着色器：负责将顶点数据进行坐标变换，该着色器中一般存在 MVP 矩阵，负责将三维坐标变换为二维坐标，该阶段也可以优化每个点的深度值，以便管线后续进行深度测试，也可以利用光照简单优化每个顶点的颜色；</li><li>图元装配：将输入的顶点数据进行组装，形成图元，常见的图元包括：点(GL_POINTS)、线(GL_LINES)、线条(GL_LINE_STRIP)、三角面(GL_TRIANGLES)，在该过程中，一般 GPU 会做一些裁剪和背面剔除等操作，以减少图元的数量，同时完成透视除法以进行屏幕映射；</li><li>光栅化：负责计算每个图元到屏幕像素点的映射。光栅化会计算每个图元所覆盖的片元，同时利用顶点属性插值计算每个片元的属性，片元可认为是候选像素，经过后续管线阶段即可变为真正的像素。</li><li>片元着色器：将光栅化得到的片元进行颜色计算。图形学中几乎所有的高级特效都会在这一步完成，光照计算，阴影处理，纹理，材质，统统在这一步进行处理；</li><li>归属测试：即测试片元所在位置是否位于当前上下文视窗内，若一个显示帧缓冲区视窗被另一个视窗所遮蔽，则剔除该部分片元。</li><li>模板测试：即测试片元是否满足一定条件（可大于或小于某个值等），若测试不满足，则剔除该该片元， OpenGL 可自行选择开启或关闭模板测试。</li><li>深度测试：用来测试片元的远近，远的片元被遮挡。在深度测试，若两片元深度值接近，则可能会引起 Z-fighting 现象，即像素闪烁，这是因为此时 GPU 无法确定该剔除哪个片元，导致这一帧可能绘制这个片元，下一帧绘制另一个片元。若开启 Alpha 测试，即启用透明度，则会在下一阶段进行 Alpha 混合，从而达到透明效果。</li><li>混合：将新生成的片元颜色和帧缓冲区中对应位置的颜色进行混合，得到像素颜色。</li><li>抖动：一种以牺牲分辨率为代价来增加颜色表示范围技术，从视觉效果上来看就是颜色过度更平滑。</li></ol><p>　　以上这些阶段中，能完全被编程控制的也就顶点着色器和片元着色器两个阶段，其余阶段要么完全无法控制，要么只能通过已有的参数进行设置，当然也可以通过顶点着色器和片元着色器影响余下阶段，顶点着色器和片元着色器也统称 Shader 编程。</p><p>　　有时候为了做更好看的特效，需要进行多次渲染，将上一次渲染的结果作为下一次渲染的输入，此时可以将颜色缓冲区作为一张纹理，并构造新的帧缓冲区，将该纹理作为输入，重新放进渲染管线中，这种操作方式也叫后期处理（Post Processing），虽然好看，但对 GPU 的负载很大，需要合理使用。</p><p>　　对于渲染管线，Shaun 的理解也就到此为止了，非常粗浅，Shader 也只是刚入门的水平，Shaun 在图形学方面做的更多是降低 Draw-Call 和 CPU 层面的 Tessellation，以及 Geometry 上的事，对纹理材质颜色光照阴影等方面涉及的较少。</p><h2 id="后记">后记</h2><p>　　虽然目前 OpenGL 已停止更新，但学习图形学编程，OpenGL 总是绕不过去（至少暂时以及未来很长一段时间都会是这样），而且图形学基础知识本质都是相同的，不管是 DirectX 还是 Vulkan，变的只是写法形式而已，数学知识总是在那里，两种 shader 也同样需要，所以了解这些东西还是有必要的。</p><h2 id="附录">附录</h2><h3 id="二维图像的图像透视投影变换">二维图像的图像透视投影变换</h3><p>　　图像的透视投影变换常用于图像的矫正，OpenCV 中就有现成的 api（getPerspectiveTransform 和 warpPerspective），用于将不规整的四边形区域变换为规整的矩形区域。其基本的数学原理为，先构造一个投影变换等式： <span class="math display">\[\begin{bmatrix} XW \\ YW \\ W \end{bmatrix} = \begin{bmatrix} a &amp; b &amp; c \\ d &amp; e &amp; f \\ g &amp; h &amp; 1 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}\]</span> 设四边形中四个点分别为 <span class="math inline">\((X_1, Y_1),(X_2, Y_2),(X_3, Y_3),(X_4, Y_4)\)</span> ，对应矩形中四个点为 <span class="math inline">\((x_1, y_1),(x_2, y_2),(x_3, y_3),(x_4, y_4)\)</span>。则可构造齐次线性方程组： <span class="math display">\[\begin{bmatrix} x_1 &amp; y_1 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -X_1x_1 &amp; -X_1y_1 \\ 0 &amp; 0 &amp; 0 &amp; x_1 &amp; y_1 &amp; 1 &amp; -Y_1x_1 &amp; -Y_1y_1 \\ x_2 &amp; y_2 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -X_2x_2 &amp; -X_2y_2 \\ 0 &amp; 0 &amp; 0 &amp; x_2 &amp; y_2 &amp; 1 &amp; -Y_2x_2 &amp; -Y_2y_2 \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\ x_n &amp; y_n &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; -X_nx_n &amp; -X_ny_n \\ 0 &amp; 0 &amp; 0 &amp; x_n &amp; y_n &amp; 1 &amp; -Y_nx_n &amp; -Y_ny_n \end{bmatrix} \begin{bmatrix} a \\ b \\ c \\ d \\ e \\ f \\ g \\ h \end{bmatrix} = \begin{bmatrix} X_1 \\ Y_1 \\ X_2 \\ Y_2 \\ \vdots \\ X_n \\ Y_n \end{bmatrix}\]</span> 解这个方程组得到 abcdefg ，使用上面的投影变换等式可计算 <span class="math inline">\(X = XW / W, Y = YW / W\)</span> ，从而使用插值得到规整矩形图形的各个像素值。</p><h3 id="shader-学习资料">Shader 学习资料</h3><p>shader 入门书：https://thebookofshaders.com，在线编写 shader ：https://thebookofshaders.com/edit.php</p><p>glslsandbox 网站：http://glslsandbox.com/</p><p>shadertoy 网站：https://www.shadertoy.com/</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/">坐标系统</a>（https://learnopengl-cn.github.io）</p><p>[2] <a href="http://www.yanhuangxueyuan.com/webgl_course/hardware.html">WebGL图形系统、渲染管线_郭隆邦技术博客</a></p><p>[3] <a href="http://www.songho.ca/opengl/gl_projectionmatrix.html">OpenGL Projection Matrix</a></p><p>[4] <a href="https://www.cnblogs.com/dojo-lzz/p/11250327.html">WebGL着色器32位浮点数精度损失问题</a></p><p>[5] <a href="https://stackoverflow.com/questions/3190483/transform-quadrilateral-into-a-rectangle">Transform quadrilateral into a rectangle?</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　图形学中最基础的东西就是坐标系统，三维的东西如何在二维中显示，这中间经历了数次坐标变换，同时坐标变换也贯穿了整个计算机图形渲染管线。&lt;/p&gt;</summary>
    
    
    
    <category term="Image&amp;Graphic" scheme="http://cniter.github.io/categories/Image-Graphic/"/>
    
    
    <category term="algorithm" scheme="http://cniter.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Scala 学习小结</title>
    <link href="http://cniter.github.io/posts/8d3d87a2.html"/>
    <id>http://cniter.github.io/posts/8d3d87a2.html</id>
    <published>2021-02-16T16:12:28.000Z</published>
    <updated>2021-12-18T11:54:13.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　最近要改行做大数据相关的东西了，经调研大数据开发的语言还是用 Scala 好，当然 Java 也可以，毕竟都运行在 JVM 上，不过 Java 也有很长时间没用过了，所以对于 Shaun 来说用 Scala 和 Java 的代价是一样的，都需要学习一下，所以决定用对大数据更友好的 Scala。</p><span id="more"></span><p>　　以 Martin Odersky 14 年写的「Scala By Example」为参考，虽然是 14 年的，但 Scala 的基本语法还是没变的，就学习本身而言没问题，毕竟不兼容的只是更上层的 API，Shaun 学习用的 Scala 版本为 2.12.12。Alvin Alexander 的「Scala Cookbook, 2nd Edition」预计今年 8 月会出版，到时可能这本书用来入门更好，但 Shaun 不需要系统的学，就简单的能上手写出比较理想的 Scala 代码就行了。</p><h2 id="学习篇">学习篇</h2><h3 id="第一章入门基础">第一章：入门基础</h3><h4 id="helloworld">HelloWorld</h4><p>　　由于「Scala By Example」第一章没啥内容，也为了在正式写 Scala 之前简单熟悉一下，这里先用「A Scala Tutorial for Java Programmers」简单上手一下，首先写个 HelloWorld，具体代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　和 C 语言类似，程序唯一入口函数都是 main 函数，但 Scala 的变量在前，声明的类型在后，相比常规的语言是有点奇怪了，但这种语法规则和 Typescript 一样，所以很容易接受，但其模板的表示就有点奇怪了，Array[String] 表示一个 String 类型的数组，即表示方法为 Array[T]，常规的模板方式为 <code>Array&lt;T&gt;</code> 或 <code>T[]</code>，def 关键字用来定义一个函数，object 用来表示一个单例类，即在定义类的同时，又创建了一个类的实例。Scala 中没有 static 关键字，需要用 static 修饰的都放在 object 中即可。</p><h4 id="调用-java">调用 Java</h4><p>Scala 中默认已导入 java.lang 中的全部类，但其它类需要显式导入，以格式化输出本地日期为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">Date</span>, <span class="type">Locale</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.text.<span class="type">DateFormat</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">LocalDate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> now = <span class="keyword">new</span> <span class="type">Date</span></span><br><span class="line">        <span class="keyword">val</span> df = getDateInstance(<span class="type">LONG</span>, <span class="type">Locale</span>.<span class="type">CHINA</span>)</span><br><span class="line">        println(df format now) <span class="comment">// df format(now)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　Scala 中的导入和 java 中 import 基本一样，但功能更强大，可以使用 <code>&#123;&#125;</code> 导入部分，也使用 <code>_</code> 导入全部（java 导入全部为 <code>*</code>，这不一样），当一个函数只有一个参数，可以通过 <em>空格+参数</em> 的形式调用，而不需要使用 <em>括号包裹</em> 的形式。这里采用 <code>val</code> 关键字声明的是常量，而要声明变量需要用 <code>var</code>。</p><h4 id="对象">对象</h4><p>Scala 中万物皆对象，一个数字也是一个对象，一个函数也是一个对象，具体如下图：</p><figure><img src="http://coredumper.cn/wordpress/wp-content/uploads/2017/06/MacHi-2017-06-03-17-18-18.png" alt="enter image description here" /><figcaption aria-hidden="true">enter image description here</figcaption></figure><p>以简单计时器函数为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Timer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">oncePerSecond</span></span>(callback: () =&gt; <span class="type">Unit</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            callback();</span><br><span class="line">            <span class="type">Thread</span> sleep <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">timeFiles</span></span>() &#123;</span><br><span class="line">        println(<span class="string">&quot;time files like an arrow...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="comment">// oncePerSecond(timeFiles);</span></span><br><span class="line">        oncePerSecond(() =&gt; &#123;</span><br><span class="line">            println(<span class="string">&quot;time files like an arrow...&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这个和 Typescript 函数式编程的用法基本差不多，唯一不同这里声明的函数返回的是 <code>Unit</code> ，这个 Unit 可认为是无返回的函数，大部分情况等同于 void，在 Scala 中真正的没有值指的是 Nothing。</p><h4 id="类">类</h4><p>Scala 中同样有类，具体代码示例如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">real: <span class="type">Double</span>, imaginary: <span class="type">Double</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// def re() = real;</span></span><br><span class="line">    <span class="comment">// def im() = imaginary;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">re</span> </span>= real;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">im</span> </span>= imaginary;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = <span class="string">&quot;&quot;</span> + re + (<span class="keyword">if</span> (im &lt; <span class="number">0</span>) <span class="string">&quot;&quot;</span> <span class="keyword">else</span> <span class="string">&quot;+&quot;</span>) + im + <span class="string">&quot;i&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ComplexNumbers</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">Complex</span>(<span class="number">1.2</span>, <span class="number">-3.4</span>);</span><br><span class="line">        <span class="comment">// println(&quot;real part: &quot; + c.re() + &quot; imaginary part: &quot; + c.im());</span></span><br><span class="line">        println(c.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　在 Scala 中所有类都会继承某个父类，若没有显式声明父类，则默认继承 scala.AnyRef 类，如上面的 Complex 类，若需要覆盖父类的函数，则需要在函数声明前加上 override 关键字。当函数没有参数时，可以不用加括号，在调用时也不用加括号，如上面示例的注释和非注释的代码。</p><h4 id="模式匹配与条件类">模式匹配与条件类</h4><p>　　接下来用 Scala 来写一个树结构表示表达式的示例代码，树的非叶节点表示操作符，叶子节点表示数值（这里为常量或变量），具体代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Sum</span>(<span class="params">l: <span class="type">Tree</span>, r: <span class="type">Tree</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Var</span>(<span class="params">n: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Const</span>(<span class="params">v: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Tree</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Environment</span> </span>= <span class="type">String</span> =&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span></span>(t: <span class="type">Tree</span>, env: <span class="type">Environment</span>): <span class="type">Int</span> = t <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; eval(l, env) + eval(r, env)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Var</span>(n) =&gt; env(n)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Const</span>(v) =&gt; v</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">derive</span></span>(t: <span class="type">Tree</span>, v: <span class="type">String</span>): <span class="type">Tree</span> = t <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sum</span>(l, r) =&gt; <span class="type">Sum</span>(derive(l, v), derive(r, v))</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Var</span>(n) <span class="keyword">if</span> (v == n) =&gt; <span class="type">Const</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="type">Const</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> exp: <span class="type">Tree</span> = <span class="type">Sum</span>(<span class="type">Sum</span>(<span class="type">Var</span>(<span class="string">&quot;x&quot;</span>), <span class="type">Var</span>(<span class="string">&quot;x&quot;</span>)), <span class="type">Sum</span>(<span class="type">Const</span>(<span class="number">7</span>), <span class="type">Var</span>(<span class="string">&quot;y&quot;</span>))) </span><br><span class="line">        <span class="keyword">val</span> env: <span class="type">Environment</span> = &#123;<span class="keyword">case</span> <span class="string">&quot;x&quot;</span> =&gt; <span class="number">5</span> <span class="keyword">case</span> <span class="string">&quot;y&quot;</span> =&gt; <span class="number">7</span>&#125;</span><br><span class="line">        println(<span class="string">&quot;Expression: &quot;</span> + exp)</span><br><span class="line">        println(<span class="string">&quot;Evalution with x=5, y=7: &quot;</span> + eval(exp, env))</span><br><span class="line">        println(<span class="string">&quot;Derivative relative to x:\n&quot;</span> + derive(exp, <span class="string">&quot;x&quot;</span>))</span><br><span class="line">        println(<span class="string">&quot;Derivative relative to y:\n&quot;</span> + derive(exp, <span class="string">&quot;y&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　该示例主要用来说明两种 case 关键字，分别为：case class 和 ... match case ...，前者可认为是一个结构体，实例化时可以省略 new 关键字，参数有默认的 getter 函数，整个 case class 有默认的 equals 和 hashCode 方法实现，通过这两个方式可实现根据值判断类的两个实例是否相等，而不是通过引用，条件类同样有默认的 toString 方法实现；后者可认为是一种特殊的 switch case ，只不过 case 的判定和执行是函数式的，case class 可直接参与 match case 的判定（判定是不是属于该类）。第 7 行中有个 type 关键字，可认为是定义了一种新的类型（不是数据类型），示例中是函数类型，通过这个 type ，可直接将字符串映射为整型，23 行中将这个 type 与 case 结合使用，定义多个字符串映射多个整型的变量。第 18 行中有个 <code>_</code> ，这是 scala 中的通配符，不同的语义下表示的含义不同，这里的含义是指，当上面的模式都不匹配时，将执行这个，相当于 switch case 中的 default。</p><h4 id="scala-中的-trait">Scala 中的 trait</h4><p>　　简单理解就是 Java 中的 Interface（接口），Scala 中没有 interface 关键字，但是 trait 比 Interface 的功能更多，其中可直接定义属性和方法的实现，Scala 中可通过 trait 来实现多重继承。下面的示例用 trait 简单实现了一个比较接口：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;=</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = (<span class="keyword">this</span> &lt; that) || (<span class="keyword">this</span> == that)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = !(<span class="keyword">this</span> &lt;= that)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&gt;=</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = !(<span class="keyword">this</span> &lt; that)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>(<span class="params">y: <span class="type">Int</span>, m: <span class="type">Int</span>, d: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">year</span> </span>= y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">month</span> </span>= m</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day</span> </span>= d</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>(): <span class="type">String</span> = year + <span class="string">&quot;-&quot;</span> + month + <span class="string">&quot;-&quot;</span> + day</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        that.isInstanceOf[<span class="type">Date</span>] &amp;&amp; &#123;</span><br><span class="line">            <span class="keyword">val</span> o = that.asInstanceOf[<span class="type">Date</span>]</span><br><span class="line">            o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">&lt;</span></span>(that: <span class="type">Any</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (!that.isInstanceOf[<span class="type">Date</span>]) &#123;</span><br><span class="line">            sys.error(<span class="string">&quot;cannot compare &quot;</span> + that + <span class="string">&quot; and a Date&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> o = that.asInstanceOf[<span class="type">Date</span>]</span><br><span class="line">        (year &lt; o.year) || (year == o.year &amp;&amp; (month &lt; o.month || (month == o.month &amp;&amp; day &lt; o.day)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> d1 = <span class="keyword">new</span> <span class="type">Date</span>(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        <span class="keyword">val</span> d2 = <span class="keyword">new</span> <span class="type">Date</span>(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        println(d1 &lt; d2)</span><br><span class="line">        println(d1 &lt;= d2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　比较关系一般只需要确定 小于 和 等于 关系即可，其它关系都可由这两关系推出来，由于等于方法默认存在于所有对象中，所以只需要重写小于即可， 其它的比较方法都可以在 trait 中定义好。在上面的示例中有两个函数 isInstanceOf 和 asInstanceOf，前者用来判断对象是否是指定类型，后者用来将对象转换为指定类型，一般用在将父类转为子类时，在使用 asInstanceOf 之前一般需要先使用 isInstanceOf。</p><h4 id="泛型">泛型</h4><p>　　这东西没啥好说的，基本有编程经验的或见过或用过，只是 Scala 的泛型语法确实有点奇怪就是了，可能也是为了函数式那些乱七八糟的操作符，具体示例代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reference</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> contents: <span class="type">T</span> = _</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span></span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">        contents = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">T</span> = contents</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntegerReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> cell = <span class="keyword">new</span> <span class="type">Reference</span>[<span class="type">Int</span>]</span><br><span class="line">        cell.set(<span class="number">13</span>)</span><br><span class="line">        println(<span class="string">&quot;Reference contains the half of &quot;</span> + (cell.get * <span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　这里同样有个 <code>_</code>，这里表示的是默认值，对于数字类型来说是 0，对于 boolean 来说是 false，对于 Unit（函数签名）来说是()（无参数无返回），对于其他来说是 null。</p><p>简单的了解 Scala 就到这里了。</p><hr /><h3 id="第二章快排">第二章：快排</h3><p>开场就是一个快排，示例代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qSort</span></span>(xs: <span class="type">Array</span>[<span class="type">Int</span>]) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">swap</span></span>(i: <span class="type">Int</span>, j: <span class="type">Int</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> t = xs(i); xs(i) = xs(j); xs(j) = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sort</span></span>(l: <span class="type">Int</span>, r: <span class="type">Int</span>) &#123;</span><br><span class="line">            <span class="keyword">val</span> pivot = xs(l);</span><br><span class="line">            <span class="keyword">var</span> i = l+<span class="number">1</span>; <span class="keyword">var</span> j = r;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">while</span> (i &lt;= r &amp;&amp; xs(i) &lt; pivot) i += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &gt; l &amp;&amp; xs(j) &gt; pivot) j -= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                    swap(i, j);</span><br><span class="line">                    i += <span class="number">1</span>;</span><br><span class="line">                    j -= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                    i = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; l &amp;&amp; xs(i) &gt; pivot) &#123;</span><br><span class="line">                i -= <span class="number">1</span>; j -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(i, l);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &lt; j<span class="number">-1</span>) sort(l, j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span> &lt; r) sort(j+<span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(<span class="number">0</span>, xs.length<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="comment">// val xs = Array(4, 1, 2, 5, 6);</span></span><br><span class="line">        <span class="comment">// val xs = Array(1, 2, 4, 4, 55, 5, 6);</span></span><br><span class="line">        <span class="comment">// val xs = Array(55, 6, 6);</span></span><br><span class="line">        <span class="keyword">val</span> xs = <span class="type">Array</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        qSort(xs);</span><br><span class="line">        println(xs.mkString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　从这段快排代码可看出，Scala 支持函数嵌套和闭包，即在函数内部定义子函数，子函数可直接使用父函数的变量，同时，这里也简单说明一下 Scala 中数组的一些使用方法，用下标取数组元素时使用的是小括号 <code>()</code>，而不是其它语言常见的中括号 <code>[]</code>。当然 Scala 作为一种函数式语言，提供了非常多的函数式操作符，这篇也只会简单介绍。</p><h3 id="第三章actor">第三章：Actor</h3><p>　　Actor，Scala 中的多线程编程模型，下方的示例代码在 Scala 2.11 及之后的版本无法运行，因为 Actor 已从 Scala 库独立出来，见 <a href="https://stackoverflow.com/questions/29343770/object-actors-is-not-a-member-of-package-scala">object-actors-is-not-a-member-of-package-scala</a>。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.actors.<span class="type">Actor</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionMessage</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Offer</span>(<span class="params">bin: <span class="type">Int</span>, client: <span class="type">Actor</span></span>) <span class="keyword">extends</span> <span class="title">AuctionMessage</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Inquire</span>(<span class="params">client: <span class="type">Actor</span></span>) <span class="keyword">extends</span> <span class="title">AuctionMessage</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionReply</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Status</span>(<span class="params">asked: <span class="type">Int</span>, expire: <span class="type">Date</span></span>) <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">BestOffer</span> <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BeatenOffer</span>(<span class="params">maxBid: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">AuctionConCluded</span>(<span class="params">seller: <span class="type">Actor</span>, client: <span class="type">Actor</span></span>) <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">AuctionFailed</span> <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">object</span> <span class="title">AuctionOver</span> <span class="keyword">extends</span> <span class="title">AuctionReply</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Auction</span>(<span class="params">seller: <span class="type">Actor</span>, minBid: <span class="type">Int</span>, closing: <span class="type">Date</span></span>) <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> timeToShutdown = <span class="number">36000000</span> <span class="comment">// msec</span></span><br><span class="line">    <span class="keyword">val</span> bidIncrement = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">        <span class="keyword">var</span> maxBid = minBid - bidIncrement</span><br><span class="line">        <span class="keyword">var</span> maxBidder: <span class="type">Actor</span> = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">var</span> running = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            receiveWithin ((closing.getTime() - <span class="keyword">new</span> <span class="type">Date</span>().getTime())) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Offer</span>(bid, client) =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (bid &gt;= maxBid + bidIncrement) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (maxBid &gt;= minBid)   maxBidder ! <span class="type">BeatenOffer</span>(bid)</span><br><span class="line">                        maxBid = bid; maxBidder = client; client ! <span class="type">BestOffer</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        client ! <span class="type">BeatenOffer</span>(maxBid)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">Inquire</span>(client) =&gt; &#123;</span><br><span class="line">                    client ! <span class="type">BeatenOffer</span>(maxBid)</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="type">TIMEOUT</span> =&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxBid &gt;= minBid) &#123;</span><br><span class="line">                        <span class="keyword">val</span> reply = <span class="type">AuctionConCluded</span>(seller, maxBidder)</span><br><span class="line">                        maxBidder ! reply; seller ! reply</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        seller ! <span class="type">AuctionFailed</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    receiveWithin(timeToShutdown) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="type">Offer</span>(_, client) =&gt; client ! <span class="type">AuctionOver</span></span><br><span class="line">                        <span class="keyword">case</span> <span class="type">TIMEOUT</span> =&gt; running = <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloActor</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">act</span></span>() &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            receive &#123;</span><br><span class="line">                <span class="keyword">case</span> name: <span class="type">String</span> =&gt; println(<span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">AuctionService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> seller: <span class="type">Actor</span> = <span class="keyword">new</span> <span class="type">HelloActor</span></span><br><span class="line">        <span class="keyword">val</span> client: <span class="type">Actor</span> = <span class="keyword">new</span> <span class="type">HelloActor</span></span><br><span class="line">        <span class="keyword">val</span> minBid = <span class="number">10</span></span><br><span class="line">        <span class="keyword">val</span> closing = <span class="keyword">new</span> <span class="type">Date</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> helloActor = <span class="keyword">new</span> <span class="type">HelloActor</span></span><br><span class="line">        helloActor.start()</span><br><span class="line">        helloActor ! <span class="string">&quot;leo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　通过重写 Actor 中的 <code>act</code> 方法即可简单的实现多线程编程，Actor 中有个特殊的标识符 <code>!</code>，该符号其实是是一种缩写，即可将 <code>helloActor.!("leo")</code> 缩写为 <code>helloActor ! "leo"</code>，代表将数据传递给 Actor，由 Actor 内部的 <code>receive case</code> 接受数据并处理，当然也可通过 <code>receiveWithin</code> 控制数据传递时间，若超时，则默认触发 <code>TIMEOUT</code> 处理模式。</p><h3 id="第四章表达式与简单函数">第四章：表达式与简单函数</h3><p>该章主要有两个例子：1、牛顿法求平方根；2、尾递归，具体如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sqrt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sqrtIter</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> (isGoodEnough(guess, x)) guess</span><br><span class="line">            <span class="keyword">else</span> sqrtIter(improve(guess, x), x)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">improve</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) = &#123;</span><br><span class="line">            (guess + x / guess) / <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isGoodEnough</span></span>(guess: <span class="type">Double</span>, x: <span class="type">Double</span>) = (guess * guess - x).abs &lt; <span class="number">0.001</span>    <span class="comment">// guess * guess == x</span></span><br><span class="line"></span><br><span class="line">        sqrtIter(<span class="number">1.0</span>, x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TailRecursion</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(a: <span class="type">Int</span>, b: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (b == <span class="number">0</span>) a <span class="keyword">else</span> gcd(b, a % b)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">facorial</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> n * facorial(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">facorialTail</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">facorialIter</span></span>(n: <span class="type">Int</span>, res: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">0</span>) res</span><br><span class="line">            <span class="keyword">else</span> facorialIter(n<span class="number">-1</span>, res * n)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        facorialIter(n, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SimpleFunc</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> sqrtValue = <span class="type">Sqrt</span>.sqrt(<span class="number">0.01</span>)</span><br><span class="line">        println(sqrtValue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> gcdValue = <span class="type">TailRecursion</span>.gcd(<span class="number">14</span>,<span class="number">21</span>)</span><br><span class="line">        println(gcdValue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> facorialValue = <span class="type">TailRecursion</span>.facorial(<span class="number">5</span>)</span><br><span class="line">        println(facorialValue)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> facorialTailValue = <span class="type">TailRecursion</span>.facorialTail(<span class="number">5</span>)</span><br><span class="line">        println(facorialTailValue)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　由于并没有引入新的语法，就简单聊聊这两个例子吧。牛顿法求平方根主要在于构造一个特殊的二分函数 <span class="math inline">\(y_{i+1} = (y_i + x / y_i)/2, i=0,1,2,3,..., y_0=1\)</span> ，如此迭代，直到 <span class="math inline">\(|y_i^2-x| &lt; \epsilon\)</span> ，得到 <span class="math inline">\(y_i\)</span> 即为 x 的平方根，更朴素一点的求多次方根就是利用二分法，分 [0, 1] 和 [1, +∞] 两个区间即可，对应从 [x, 1] 和 [1, x] 开始二分取值。至于尾递归，以前简单的写过一点，即最后递归调用原函数时，原函数不会再参与任何计算表达式。尾递归的好处在于当编译器或解释器支持尾递归时，将不会产生普通递归时的压栈操作，即不用担心递归层次太深，尾递归将类似循环迭代处理。</p><h3 id="第五章高阶函数">第五章：高阶函数</h3><p>　　高阶函数（First-Class Functions），支持以函数作为参数或返回值，也可将函数赋值给其它变量，由此也可引出闭包和柯里化，闭包是指将内嵌函数作为返回值，而柯里化是指将多个参数分解为独立参数传递给函数，如：<span class="math inline">\(f(args_1,args_2,...,args_n)=f(args_1)(args_2)(...)(args_n)\)</span>。下面以求函数的不动点为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">FirstClassFunctions</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> tolerance = <span class="number">0.0001</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isCloseEnough</span></span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) = ((x-y) / x).abs &lt; tolerance</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fixedPoint</span></span>(f: <span class="type">Double</span> =&gt; <span class="type">Double</span>)(firstGuess: <span class="type">Double</span>) = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">iterate</span></span>(guess: <span class="type">Double</span>): <span class="type">Double</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> next = f(guess)</span><br><span class="line">            <span class="keyword">if</span> (isCloseEnough(guess, next)) next</span><br><span class="line">            <span class="keyword">else</span> iterate(next)</span><br><span class="line">        &#125;</span><br><span class="line">        iterate(firstGuess)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averageDamp</span></span>(f: <span class="type">Double</span> =&gt; <span class="type">Double</span>)(x: <span class="type">Double</span>) = (x + f(x)) / <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sqrt</span></span>(x: <span class="type">Double</span>) = fixedPoint(averageDamp(y =&gt; x/y))(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        println(sqrt(<span class="number">0.01</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　该示例简单明了的展示了 Scala 中匿名函数，函数柯里化以及闭包。</p><h3 id="第六章类和对象">第六章：类和对象</h3><p>直接看下面的有理数示例吧，</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span>(<span class="params">n: <span class="type">Int</span>, d: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">AnyRef</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">gcd</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) y</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; <span class="number">0</span>) gcd(-x, y)</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &lt; <span class="number">0</span>) -gcd(x, -y)</span><br><span class="line">        <span class="keyword">else</span> gcd(y % x, x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> g = gcd(n, d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数重载（辅助构造函数）</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>, <span class="number">0</span>)  <span class="comment">// 调用主构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> number: <span class="type">Int</span> = <span class="keyword">if</span> (g != <span class="number">0</span>) n / g <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> denom: <span class="type">Int</span> = <span class="keyword">if</span> (g != <span class="number">0</span>) d / g <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(number * that.denom + that.number * denom, denom * that.denom)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">-</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(number * that.denom - that.number * denom, denom * that.denom)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(number * that.number, denom * that.denom)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">/</span></span>(that: <span class="type">Rational</span>) = <span class="keyword">new</span> <span class="type">Rational</span>(number * that.denom, denom * that.number)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toNumber</span></span>: <span class="type">Double</span> = <span class="keyword">if</span> (denom != <span class="number">0</span>) number.toDouble / denom <span class="keyword">else</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">&quot;&quot;</span> + number + <span class="string">&quot;/&quot;</span> + denom</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Rational</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> rational = <span class="keyword">new</span> <span class="type">Rational</span>(<span class="number">2</span>,<span class="number">1</span>) / <span class="keyword">new</span> <span class="type">Rational</span>()</span><br><span class="line">        println(rational.toNumber);</span><br><span class="line">        println(rational.toString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　从有理数这个示例可以看出，Scala 的类支持操作符重载，也支持构造函数重载，同样支持继承，多继承也是支持的，每个父类用 <code>with</code> 关键字分隔就行。</p><h3 id="第七章条件类和模式匹配">第七章：条件类和模式匹配</h3><p>大致和第一章内容差不多，就不重复写了。</p><h3 id="第八章泛型">第八章：泛型</h3><p>　　大致也和第一章内容差不多，<em>值得一提的书中实现的泛型栈本质是一个链表，实现方法挺有意思的</em>。通过 <code>&lt;:</code> 标识符可约束泛型的类型，如 <code>[T &lt;: P[T]]</code> 表明泛型 T 必须类型 P 的子类型。而标识符 <code>&lt;%</code> 比 <code>&lt;:</code> 约束性弱一点，只要 T 能够通过隐式类型变换为 P 即可。若想约束为父类型，则需使用 <code>&gt;:</code> 标识符。</p><p>　　Scala 中有一种特殊的泛型，就是变化型注解，<code>trait List[+T]</code> 代表协变，表示当 B 类型是 A 类型子类时，<code>List[B]</code> 也可认为是 <code>List[A]</code> 的子类；<code>trait List[-T]</code> 代表逆变，当 B 类型是 A 类型子类时，<code>List[B]</code> 可认为是 <code>List[A]</code> 的父类。</p><p>　　Scala 中同样有元组，使用时也很方便，简单使用直接用括号声明即可，如 <code>def divmod(x: Int, y: Int): (Int, Int) = (x / y, x % y)</code>，该函数即返回一个元组，也可声明一个元组 <code>case class Tuple2[A, B](_1: A, _2: B)</code>，若需要取元组的元素可通过 <code>_i</code> 的方式，如 <code>val xy = divmod(3, 4); xy._1; xy._2;</code>，也可通过 match-case 语句取，如 <code>xy match &#123; case (n, d) =&gt; println("quotient: " + n + ", rest: " + d) &#125;</code>。</p><h3 id="第九章list">第九章：List</h3><p>　　Scala 中的 List 其实是数组结构，并且是不可变的，可认为是 C++ 里的静态数组，不能往其中添加或删除元素，下面用数组排序示例下 List 的用法：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertSort</span></span>(xsl: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">insert</span></span>(x: <span class="type">Int</span>, xs: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">            xs <span class="keyword">match</span> &#123;</span><br><span class="line">                <span class="comment">// case Nil =&gt; List(x)</span></span><br><span class="line">                <span class="keyword">case</span> <span class="type">List</span>() =&gt; <span class="type">List</span>(x)</span><br><span class="line">                <span class="keyword">case</span> y :: ys =&gt; <span class="keyword">if</span> (x &lt;= y) x :: xs <span class="keyword">else</span> y :: insert(x, ys)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (xsl.isEmpty) <span class="type">Nil</span></span><br><span class="line">        <span class="keyword">else</span> insert(xsl.head, insertSort(xsl.tail))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span></span>[<span class="type">A</span>](less: (<span class="type">A</span>, <span class="type">A</span>) =&gt; <span class="type">Boolean</span>)(xs: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(xs1: <span class="type">List</span>[<span class="type">A</span>], xs2: <span class="type">List</span>[<span class="type">A</span>]): <span class="type">List</span>[<span class="type">A</span>] = &#123;</span><br><span class="line">            <span class="keyword">if</span> (xs1.isEmpty) xs2</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (xs2.isEmpty) xs1</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2)</span><br><span class="line">            <span class="keyword">else</span>  xs2.head :: merge(xs1, xs2.tail)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> n = xs.length / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) xs</span><br><span class="line">        <span class="keyword">else</span> merge(mergeSort(less)(xs take n), mergeSort(less)(xs drop n))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> xs = <span class="type">List</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// val xs = 3::2::1::1::Nil;</span></span><br><span class="line">        println(xs(<span class="number">0</span>), xs(<span class="number">1</span>), xs(xs.length<span class="number">-1</span>)) <span class="comment">// (4,1,6)</span></span><br><span class="line">        <span class="comment">// val ys = insertSort(xs);</span></span><br><span class="line">        <span class="keyword">val</span> ys = mergeSort((x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x &gt; y)(xs);</span><br><span class="line">        println(ys.mkString(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　List 中有两个操作符非常类似，即 <code>::</code> 和 <code>:::</code>， 前者用于 List 中的元素和 List 连接，即创建一个新 List，新 List 为原 List 头插入元素后的 List，后者用于连接两个 List，即创建一个新 List ，新 List 为将第二个 List 的元素全部放入第一个 List 尾部的 List。字符 <code>Nil</code> 代表空 List 和 <code>List()</code> 等效，<code>head</code> 方法返回 List 的第一个元素，<code>tail</code> 方法返回除第一个元素之外的其它所有元素，还是一个 List，<code>isEmpty</code> 方法当 List 为空时返回 <code>true</code>。List 的 case-match 方法中，<code>case y :: ys</code> 其中 y 代表 xs.head，ys 代表 xs.tail。<code>(xs take n)</code> 表示取 List 前 n 个元素，<code>(xs drop n)</code> 表示取 List 前 n 个元素之外的元素，即与 (xs take n) 取得元素正好互补，而 <code>(xs split n)</code> 返回一个元组，元组中第一个元素为 (xs take n)，第二个元素为 (xs drop n)。关于 List 还有些更高阶得方法：filter，map, flatMap, reduceRight, foldRight 等方法就不继续写了。至于动态 List 可用 <code>ListBuffer</code> 结构，当然 Scala 中直接用 <code>Seq</code> 作为返回值和参数一般会更好些。</p><h3 id="第十章序列理解">第十章：序列理解</h3><p>　　Scala 中用来做序列理解的表达式是 <code>For-Comprehensions</code>，具体示例如下：<code>for (p &lt;persons if p.age &gt; 20) yield p.name</code> 相当于 <code>persons filter (p =&gt; p.age &gt; 20) map (p =&gt; p.name)</code>，可以简单认为 for-yield 方法是 filter 和 map 的集合体。下面具体用个 N-皇后（特例是 8 皇后）的示例来具体说明：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">NQueen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">queens</span></span>(n: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isSafe</span></span>(col: <span class="type">Int</span>, queenList: <span class="type">List</span>[<span class="type">Int</span>], delta: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">            <span class="keyword">val</span> curRow = queenList.length<span class="number">-1</span> + delta</span><br><span class="line">            <span class="keyword">for</span> (row &lt;- <span class="type">List</span>.range(<span class="number">0</span>, queenList.length)) &#123;</span><br><span class="line">                <span class="keyword">val</span> queenCol = queenList(row)</span><br><span class="line">                <span class="keyword">val</span> queenRow = queenList.length<span class="number">-1</span> - row</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (queenCol == col) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> (queenRow == curRow) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">if</span> ((queenCol - col).abs == (queenRow - curRow).abs) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">placeQueens</span></span>(k: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="type">List</span>(<span class="type">List</span>())</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">for</span> &#123; </span><br><span class="line">                queens &lt;- placeQueens(k<span class="number">-1</span>);</span><br><span class="line">                column &lt;- <span class="type">List</span>.range(<span class="number">0</span>, n);</span><br><span class="line">                <span class="keyword">if</span> isSafe(column, queens, <span class="number">1</span>) </span><br><span class="line">            &#125; <span class="keyword">yield</span> column :: queens</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        placeQueens(n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line">        <span class="keyword">val</span> queenList = queens(<span class="number">8</span>);</span><br><span class="line">        println(<span class="string">&quot;queenCount: &quot;</span> + queenList.length)  <span class="comment">// 92</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>for-yield 表达式中 for 中可以写多条语句，代表多重循环，第 5 行的 for 代表 for 循环，<code>&lt;-</code> 表示取 List 中的元素。</p><hr /><p>　　剩下的几章就没啥特别要写的，重点就两个特性，一个是 Stream ，一个 Lazy，Stream 和 List 有点类似，主要区别在于 Stream 是即时返回的，算一个返回一个，而 List 一般是全部计算完再返回一个 List；Lazy 一般用作常量的修饰符，主要作用是只用该常量被用到时才赋值，否则一直为空，有点类似常见的先判空再取值的封装。</p><h2 id="后记">后记</h2><p>　　曾看到过通过刷题去学习新语言的方式，一直都以为很粗暴，但这次照着「Scala By Example」敲下来，感觉还挺有效的，同时也巩固了一下基本的算法知识，后续再把 twitter 的 「Effective Scala」再看一下应该就差不多了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　最近要改行做大数据相关的东西了，经调研大数据开发的语言还是用 Scala 好，当然 Java 也可以，毕竟都运行在 JVM 上，不过 Java 也有很长时间没用过了，所以对于 Shaun 来说用 Scala 和 Java 的代价是一样的，都需要学习一下，所以决定用对大数据更友好的 Scala。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="language" scheme="http://cniter.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>2020年小结</title>
    <link href="http://cniter.github.io/posts/28416d7c.html"/>
    <id>http://cniter.github.io/posts/28416d7c.html</id>
    <published>2021-02-12T12:15:16.000Z</published>
    <updated>2021-12-18T11:54:13.930Z</updated>
    
    <content type="html"><![CDATA[<p>　　社畜不易，行者多难，披荆斩棘，前路莫测，步履不停。</p><span id="more"></span><h2 id="前言">前言</h2><p>　　20 年，也算是正式步入社畜生活的第一年，新鲜感自然少不了，但也没持续很长时间。这一年中基本都在学习，工作中生活中都在熟悉新事物新模式。</p><h2 id="技术篇">技术篇</h2><p>　　开始独立负责项目，从无到有写完了一个产品，做了半个地图可视化项目，图形学相关知识从完全不会到熟练使用 Shader 做简单特效，学习新语言使用新工具，这就是 Shaun 过去一年在工作中的写照。</p><p>　　在产品中，Shaun 基本独立完成了调研设计编码的全过程，这款网页版的 OpenDrive 路网编辑器，让 Shaun 基本熟悉的前端开发的主流框架和打包流程，甚至基于这款编辑器继续引申出两个 SDK，虽然开发模式和真正的前端有所区别（Shaun 是把 Typescript 当 C# 用的，将网页程序当客户端程序开发），但感觉现在的浏览器完全能撑的住，完全可以将更多的计算和存储任务直接在前端全部做完，但同时也感到了纯前端的无力，没有后端，前端网页能呈现的数据和效果确实有限，网页的内存有限制，webgl 渲染的三角形也有限制，只能做些小东西，大场景就很难施展。路网编辑器中涉及的前端技术栈也有很多，主要是现在无论开发一个什么应用，都不可能从语言最底层的 api 写起，总会用到别人写好的库，熟悉，吸收，再修改，用着用着就需要自己写了，从用轮子到造轮子，从而产生更多的轮子，也算是一种良性循环。</p><p>　　半个地图可视化项目，主要用的 mapbox-gl + geoserver 显示地图，做完这个项目，同时也基本了解了国内的百度和高德两家的地图突然变好看了的原因，其背后的技术也同样源自于 mapbox，一家真正小而美的公司，定义了一套前端渲染地图的数据标准（Vector Tile），在非 3D 地图上，这套标准就是业内通用的标准了，如今的导航地图用的都是这套前端渲染技术，美观又高效。</p><h2 id="生活篇">生活篇</h2><p>　　整个 20 年出去玩的时间也不多，工作地所在能玩的地方基本也玩的差不多了，大部分时间都是宅在屋里看电影，学技术，感觉就非常平淡，也没啥特别好说的。20年，开始学习理财，锻炼买入卖出的感觉，由于整个 20 年股市一片良好，以至于 Shaun 这个新手也赚了些钱，但由于本钱不多，赚的也非常有限，赚大钱的机会，要么拿不住，要么下不去手，最终都失之交臂，这样一来，赚的就更少了，不过，股市中赚到的钱终究只是个数字，到手的才是赚到的，没到手是赚是亏还不好说，作为新手而言，Shaun 也就当玩玩而已，亏也不多，主要是锻炼自己的感觉或承受能力，反正理财是一辈子的事，不急于这一时。</p><h2 id="总结">总结</h2><p>　　生活一年如一日的平淡如水，依旧独自前行，由于疫情的原因，出去看看都嫌太麻烦，只能周边走走，着实无聊，好在工作上的东西对 Shaun 来说是新的知识，稍微有点挑战，每解决一个问题，总会带来一些成就感，冲淡些许无聊，可这成就感越来越少了，或许哪天成就感完全消失，就是 Shaun 换个新环境的时候。</p><div style="text-align:center; font-family: Allura, Consolas, Helvetica, Tahoma, Arial, Microsoft YaHei, 微软雅黑, SimSun, 宋体, Heiti, 黑体, sans-serif; font-size:1.3em; color:#4094c3; font-weight:700; margin:.5em auto;">20 年获得技能：<strong><em>触类旁通</em></strong><br />20 年获得成就：<strong><em>独挡一面</em></strong></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　社畜不易，行者多难，披荆斩棘，前路莫测，步履不停。&lt;/p&gt;</summary>
    
    
    
    <category term="Life" scheme="http://cniter.github.io/categories/Life/"/>
    
    
    <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>时空查询之ECQL</title>
    <link href="http://cniter.github.io/posts/489fa7b3.html"/>
    <id>http://cniter.github.io/posts/489fa7b3.html</id>
    <published>2021-01-23T12:59:21.000Z</published>
    <updated>2021-12-18T11:54:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　ECQL 是 CQL 的扩展，CQL 是 OGC 标准查询语言，而 ECQL 是 GeoTools 为更好的方便查询，在编程实现时扩展了 CQL，主要扩展在于其移除了 CQL 的一些限制（属性必须在比较运算符的左边，不能创建 Id Filter 进行查询等限制），也和 SQL 更相似。所以可简单认为 CQL 是书面上的标准，而 ECQL 是事实上的标准。</p><span id="more"></span><h2 id="谓词篇">谓词篇</h2><p>时间查询主要有以下几个查询谓词：</p><table><colgroup><col style="width: 36%" /><col style="width: 63%" /></colgroup><thead><tr class="header"><th>谓词</th><th>作用</th></tr></thead><tbody><tr class="odd"><td>T <strong>TEQUALS</strong> Time</td><td>测试 T 和给定时间相等，相当于 T == Time。</td></tr><tr class="even"><td>T <strong>BEFORE</strong> Time</td><td>测试 T 在给定时间之前，相当于 T &lt; Time。</td></tr><tr class="odd"><td>T <strong>BEFORE OR DURING</strong> Time Period</td><td>测试 T 在给定时间段之前或其中，相当于 T &lt;= TimePeriod[1]。</td></tr><tr class="even"><td>T <strong>DURING</strong> Time Period</td><td>测试 T 在给定时间段其中，相当于 TimePeriod[0] &lt;= T &lt;= TimePeriod[1]。</td></tr><tr class="odd"><td>T <strong>DURING OR AFTER</strong> Time Period</td><td>测试 T 在给定时间段其中或之后，相当于 TimePeriod[0] &lt;= T。</td></tr><tr class="even"><td>T <strong>AFTER</strong> Time</td><td>测试 T 在给定时间之后，相当于 T &gt; Time。</td></tr></tbody></table><p>时间段以 <code>/</code> 分隔符区分前后两个时间，时间格式一般为 yyyy-MM-dd'T'HH:mm:ss.SSS'Z'。</p><p>空间查询主要有以下几个查询谓词：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>谓词</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><strong>INTERSECTS</strong>(A: Geometry, B: Geometry)</td><td>测试 A 与 B 相交，与 DISJOINT 相反。</td></tr><tr class="even"><td><strong>DISJOINT</strong>(A: Geometry, B: Geometry)</td><td>测试 A 与 B 不相交，与 INTERSECTS 相反。</td></tr><tr class="odd"><td><strong>CONTAINS</strong>(A: Geometry, B: Geometry)</td><td>测试 A 包含 B，与 WITHIN 相反。</td></tr><tr class="even"><td><strong>WITHIN</strong>(A: Geometry, B: Geometry)</td><td>测试 B 包含 A，即 A 在 B 中，与 CONTAINS 相反。</td></tr><tr class="odd"><td><strong>TOUCHES</strong>(A: Geometry, B: Geometry)</td><td>测试 A 的边界是否与 B 的边界接触，但内部不相交。</td></tr><tr class="even"><td><strong>CROSSES</strong>(A: Geometry, B: Geometry)</td><td>测试 A 与 B 是否相交，但不存在包含关系。</td></tr><tr class="odd"><td><strong>OVERLAPS</strong>(A: Geometry, B: Geometry)</td><td>测试 A 与 B 是否重叠，需满足 A 与 B 是同一类型（如都是 POLYGON），并且相交区域同样是 A 和 B 的类型（只能是 POLYGON，不能是 POINT）。</td></tr><tr class="even"><td><strong>EQUALS</strong>(A: Geometry, B: Geometry)</td><td>测试 A 与 B 完全相等。</td></tr><tr class="odd"><td><strong>RELATE</strong>(A: Geometry, B: Geometry, nineIntersectionModel: String)</td><td>测试 A 与 B 是否满足 <strong>DE-9IM</strong> 模型，该模型可模拟上述所有情况。</td></tr><tr class="even"><td><strong>DWITHIN</strong>(A: Geometry, B: Geometry, distance: double, units: String)</td><td>测试 A 与 B 的最短距离是否不超过多少距离，单位有（<code>feet</code>, <code>meters</code>, <code>statute miles</code>, <code>nautical miles</code>, <code>kilometers</code>）。</td></tr><tr class="odd"><td><strong>BEYOND</strong>(A: Geometry, B: Geometry, distance: Double, units: String)</td><td>测试 A 与 B 的最短距离是否超过多少距离。</td></tr><tr class="even"><td><strong>BBOX</strong>(A: Geometry, leftBottomLng: Double, leftBottomLat: Double, rightTopLng: Double, rightTopLat: Double, crs="EPSG:4326")</td><td>测试 A 是否与给定 box 相交。</td></tr></tbody></table><p>Geometry 是指 WKT 格式的数据，主要有以下几种：</p><table><colgroup><col style="width: 26%" /><col style="width: 73%" /></colgroup><thead><tr class="header"><th>类型</th><th>示例</th></tr></thead><tbody><tr class="odd"><td><strong>POINT</strong></td><td>POINT(6 10)</td></tr><tr class="even"><td><strong>LINESTRING</strong></td><td>LINESTRING(3 4,10 50,20 25)</td></tr><tr class="odd"><td><strong>POLYGON</strong></td><td>POLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))</td></tr><tr class="even"><td><strong>MULTIPOINT</strong></td><td>MULTIPOINT(3.5 5.6, 4.8 10.5)</td></tr><tr class="odd"><td><strong>MULTILINESTRING</strong></td><td>MULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))</td></tr><tr class="even"><td><strong>MULTIPOLYGON</strong></td><td>MULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))</td></tr><tr class="odd"><td><strong>GEOMETRYCOLLECTION</strong></td><td>GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))</td></tr></tbody></table><p><strong><em>※注：</em></strong> POLYGON 中的边界点必须闭合，即首尾点相同，若存在多个边界，则需要遵循 逆时针,顺时针,逆时针,顺时针... 的点排列顺序，逆时针封闭，顺时针开孔，以形成具有岛和洞的复杂多边形。</p><p>　　由于 WKT 标准只支持二维的坐标，为支持三维坐标以及齐次线性计算，所以在 PostGIS 中又有 EWKT 标准实现，EWKT 扩展了 WKT，带 <code>Z</code> 结尾用来支持三维坐标，带 <code>M</code> 结尾用来支持齐次线性计算，如 <code>POINTZ(6 10 3)</code>，<code>POINTM(6 10 1)</code>，<code>POINTZM(6 10 3 1)</code>，同时还支持坐标内嵌空间参考系，如 <code>SRID=4326;LINESTRING(-134.921387 58.687767, -135.303391 59.092838)</code>。GeoTools 19.0 之后也默认以 EWKT 进行解析和编码。</p><h2 id="查询篇">查询篇</h2><h3 id="属性字段查询">属性字段查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 查询属性 ATTR1 小于 7 的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; (1 + ((3 / 2) * 4))&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 小于属性 ATTR2 绝对值的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; abs(ATTR2)&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 为 test 字符串的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;ATTR1 == &#x27;test&#x27;&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 在 10 和 20 之间的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 BETWEEN 10 AND 20&quot; );</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 &gt;= 10 AND ATTR1 &lt;= 20&quot; );</span><br><span class="line"></span><br><span class="line">// 多条件查询</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; 10 AND ATTR2 &lt; 2 OR ATTR3 &gt; 10&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 为 silver 或 oil 或 gold 的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;ATTR1 IN (&#x27;silver&#x27;,&#x27;oil&#x27;, &#x27;gold&#x27; )&quot;);</span><br><span class="line"></span><br><span class="line">// 以 ID 主键进行查询</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;IN (&#x27;river.1&#x27;, &#x27;river.2&#x27;)&quot;);</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;IN (300, 301)&quot;);</span><br></pre></td></tr></table></figure></div><h3 id="模糊查询">模糊查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 查询属性 ATTR1 包含 abc 字符串的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 LIKE &#x27;%abc%&#x27;&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 开头不为 abc 字符串的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 NOT LIKE &#x27;abc%&#x27;&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 cityName 开头为 new 的数据，忽略 new 的大小写</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;cityName ILIKE &#x27;new%&#x27;&quot;);</span><br><span class="line"></span><br><span class="line">// 测试字符串是否包含</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;&#x27;aabbcc&#x27; LIKE &#x27;%bb%&#x27;&quot;);</span><br></pre></td></tr></table></figure></div><h3 id="空属性查询">空属性查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查询有属性 ATTR1 存在的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 EXISTS&quot; );</span><br><span class="line"></span><br><span class="line">// 查询属性 ATTR1 不存在的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;ATTR1 DOES-NOT-EXIST&quot; );</span><br><span class="line"></span><br><span class="line">// 查询 Name 为 NULL 的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;Name IS NULL&quot;);</span><br></pre></td></tr></table></figure></div><h3 id="时间查询">时间查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 查询时间属性 dtg 等于的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;dtg TEQUALS 2006-11-30T01:30:00Z&quot; );</span><br><span class="line"></span><br><span class="line">// 查询时间属性 dtg 在之后的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;dtg AFTER 2006-11-30T01:30:00Z&quot;);</span><br><span class="line"></span><br><span class="line">// 查询时间属性 dtg 在之前的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;dtg BEFORE 2006-11-30T01:30:00Z&quot;);</span><br><span class="line"></span><br><span class="line">// 查询时间属性 dtg 在之间的数据，+3:00 代表 GMT 时间 +3 小时，以 Z 结尾的时间就是 GMT 时间</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;dtg DURING 2006-11-30T00:30:00+03:00/2006-11-30T01:30:00+03:00 &quot;);</span><br><span class="line"></span><br><span class="line">// 查询时间属性 dtg 等于的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;dtg = 1981-06-20&quot;);</span><br><span class="line"></span><br><span class="line">// 查询时间属性 dtg 小于等于的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;dtg &lt;= 1981-06-20T12:30:01Z&quot;);</span><br></pre></td></tr></table></figure></div><h3 id="空间查询">空间查询</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 查询空间属性 geom 包含点的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;CONTAINS(geom, POINT(1 2))&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与 box 相交的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;BBOX(geom, 10,20,30,40)&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与点最短距离不超过 10 千米的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;DWITHIN(geom, POINT(1 2), 10, kilometers)&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与线相交的数据（geom 也必须是线）</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;CROSS(geom, LINESTRING(1 2, 10 15))&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与 GEOMETRYCOLLECTION 相交的数据（geom 也必须是 GEOMETRYCOLLECTION）</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;INTERSECT(geom, GEOMETRYCOLLECTION (POINT (10 10),POINT (30 30),LINESTRING (15 15, 20 20)) )&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与线相交的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;CROSSES(geom, LINESTRING(1 2, 10 15))&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与 GEOMETRYCOLLECTION 相交的数据</span><br><span class="line">Filter filter = ECQL.toFilter( &quot;INTERSECTS(geom, GEOMETRYCOLLECTION (POINT (10 10),POINT (30 30),LINESTRING (15 15, 20 20)) )&quot; );</span><br><span class="line"></span><br><span class="line">// 查询空间属性 geom 与包含线的数据</span><br><span class="line">Filter filter = ECQL.toFilter(&quot;RELATE(geom, LINESTRING (-134.921387 58.687767, -135.303391 59.092838), T*****FF*)&quot;);</span><br></pre></td></tr></table></figure></div><hr /><p>　　在 GeoTools 中，可通过 FilterFactory 来构造 Filter，而不是直接写字符串，具体示例如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="JAVA"><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 Filter filter1 = ECQL.toFilter(&quot;ATTR1 = 1 AND ATTR2 &lt; 4&quot; );</span></span><br><span class="line">List&lt;Filter&gt; filterList = ECQL.toFilterList(<span class="string">&quot;ATTR1=1; ATTR2&lt;4&quot;</span>);</span><br><span class="line">Filter filter1 = ff.and(filterList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 Filter filter2 = ECQL.toFilter( &quot;BBOX(geom, 10,20,30,40)&quot; );</span></span><br><span class="line">Filter filter2 = ff.bbox(<span class="string">&quot;geom&quot;</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="string">&quot;EPSG:4326&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于 Filter filter3 = ECQL.toFilter( &quot;dtg DURING 2006-11-29T00:30:00Z/2006-11-30T00:30:00Z&quot;);</span></span><br><span class="line">Date startTime = ZonedDateTime.of(<span class="number">2006</span>, <span class="number">11</span>, <span class="number">29</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneOffset.UTC);</span><br><span class="line">Date endTime = Date.from(startTime.plusDays(<span class="number">1</span>).toInstant());</span><br><span class="line">Filter filter3 = ff.between(ff.property(<span class="string">&quot;dtg&quot;</span>), ff.literal(startTime), ff.literal(endTime));</span><br></pre></td></tr></table></figure></div><h2 id="后记">后记</h2><p>　　基本可认为 CQL 和 SQL 中查询条件差不多，虽然不支持分组查询等复杂 SQL 特性，但对于一般的时空查询基本够用，CQL 中还有些空间操作函数就不继续写了，如取面积，取缓冲区，取交集，取长度等等，有需要的可自行查询 <a href="http://udig.github.io/docs/user/concepts/Constraint%20Query%20Language.html">uDig Common Query Language</a>。</p><h2 id="参考资料">参考资料</h2><p><a href="http://docs.geotools.org/latest/userguide/library/cql/cql.html">GeoTools CQL</a></p><p><a href="http://docs.geotools.org/stable/userguide/library/cql/ecql.html">GeoTools ECQL</a></p><p><a href="https://docs.geoserver.org/latest/en/user/filter/ecql_reference.html#ecql-reference">GeoServer ECQL Reference</a> / <a href="https://blog.csdn.net/neimeng0/article/details/79914880">GeoServer 属性查询和空间查询支持 CQL / ECQL过滤器语言</a></p><p><a href="https://blog.csdn.net/ucs426/article/details/99780891">WKT解读</a></p><p><a href="https://www.cnblogs.com/denny402/p/4968201.html">GEOS库学习之三：空间关系、DE-9IM和谓词</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　ECQL 是 CQL 的扩展，CQL 是 OGC 标准查询语言，而 ECQL 是 GeoTools 为更好的方便查询，在编程实现时扩展了 CQL，主要扩展在于其移除了 CQL 的一些限制（属性必须在比较运算符的左边，不能创建 Id Filter 进行查询等限制），也和 SQL 更相似。所以可简单认为 CQL 是书面上的标准，而 ECQL 是事实上的标准。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="language" scheme="http://cniter.github.io/tags/language/"/>
    
  </entry>
  
  <entry>
    <title>GeoMesa踩坑指北</title>
    <link href="http://cniter.github.io/posts/9978824c.html"/>
    <id>http://cniter.github.io/posts/9978824c.html</id>
    <published>2021-01-16T09:52:09.000Z</published>
    <updated>2021-12-18T11:54:13.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　需要做个 GeoMesa 的微服务，简单熟悉一下 GeoMesa。</p><span id="more"></span><h2 id="基础篇">基础篇</h2><p>　　GeoMesa 可以说是大数据中的 PostGIS，主要用来在存储和处理 GIS 数据时提供相应的索引，从而加快处理速度。GeoMesa 基于 GeoTools，其中最重要的两个概念就是 SimpleFeatureType 和 SimpleFeature，SimpleFeatureType 对应的是关系型数据库中表的描述（表明，表的列字段属性信息等），而 SimpleFeature 对应的是表中每行数据。下面重点谈谈 GeoMesa 中的 SimpleFeatureType 以及其创建索引方式。</p><p>　　在 GeoMesa 中通常使用 SimpleFeatureTypes.createType 方法进行创建，该方法有两个重载，以没有 namespace 参数的方法为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createType</span></span>(typeName: <span class="type">String</span>, spec: <span class="type">String</span>): <span class="type">SimpleFeatureType</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> (namespace, name) = parseTypeName(typeName)</span><br><span class="line">    createType(namespace, name, spec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>先通过 parseTypeName 解析 typeName，以 <code>:</code> 作为分隔符，取最后一个有效（不为空）字符串作为表名（name），其余部分如有效则作为 namespace，否则 namespace 则为 null。spec 参数的通用形式有以下几种：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> spec = <span class="string">&quot;name:String,dtg:Date,*geom:Point:srid=4326&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> spec = <span class="string">&quot;name:String,dtg:Date,*geom:Point:srid=4326;geomesa.indices.enabled=&#x27;z2,id,z3&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> spec = <span class="string">&quot;name:String:index=true,tags:String:json=true,dtg:Date:default=true,*geom:Point:srid=4326;geomesa.indices.enabled=&#x27;z2,id,z3&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> spec = <span class="string">&quot;userId:String,trackId:String,altitude:Double,dtg:Date,*geom:Point:srid=4326;geomesa.index.dtg=&#x27;dtg&#x27;,geomesa.table.sharing=&#x27;true&#x27;,geomesa.indices=&#x27;z3:4:3,z2:3:3,id:2:3&#x27;,geomesa.table.sharing.prefix=&#x27;\\u0001&#x27;&quot;</span></span><br></pre></td></tr></table></figure></div><p>先使用 <code>;</code> 分隔符，再使用 <code>,</code> 分隔符，最后使用 <code>:</code> 分隔符。<code>;</code> 分隔符将 spec 分割为两个字符串：前者表示表中的全部列属性信息，列属性经过 <code>,</code> 分隔符分割为多列，列又经过 <code>:</code> 分隔符分割为 列名，列数据类型，列的一些属性（是否是索引，json 数据，默认索引等），而列名首字母 <code>*</code> 代表该字段是用于索引的 geometry 类型，一般采用 WKT 格式进行描述，当然存在数据库时会以字节码进行压缩；后者表示创建表时的 userData，同样经过 <code>,</code> 分隔符分割为多个 userData，userData 的一些默认属性可在 SimpleFeatureTypes.Configs 中看到，其它的可以用户自定义，这里重点说一下 <code>geomesa.indices.enabled</code> 属性，目前 GeoMesa 支持 8 种索引，分别为：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;attr&quot;, // 属性索引</span><br><span class="line">&quot;id&quot;, // 主键索引</span><br><span class="line">&quot;s2&quot;, // Hilbert 曲线点空间索引</span><br><span class="line">&quot;s3&quot;, // Hilbert 曲线点时空索引</span><br><span class="line">&quot;z2&quot;, // Z 型曲线点空间索引</span><br><span class="line">&quot;xz2&quot;, // Z 型曲线线面空间索引</span><br><span class="line">&quot;z3&quot;,  // Z 型曲线点时空索引</span><br><span class="line">&quot;xz3&quot; // Z 型曲线线面时空索引</span><br></pre></td></tr></table></figure></div><p>　　由于 GeoMesa 中的索引一般存在多个版本，而 <code>geomesa.indices.enabled</code> 默认使用最新的版本，若需要指定版本，需要使用 <code>geomesa.indices</code>，<strong><em>该属性是 geomesa 内部属性，不对外开放</em></strong>，通用格式为：</p><p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">s&quot;<span class="subst">$name</span>:<span class="subst">$version</span>:<span class="subst">$&#123;mode.flag&#125;</span>:<span class="subst">$&#123;attributes.mkString(&quot;:&quot;)&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure></div></p><p>name 代表索引类别，version 代表索引版本，mode.flag 代表索引模式（是否支持读写，一般为3，支持读也支持写），attributes 代表是哪些字段需要建立该索引。spec 参数可以只有描述列属性的字段，即不带任何 useData 信息，GeoMesa 会默认添加索引信息，若存在空间和时间字段，则会默认建立 z3（空间字段为点 Point 类型） 或 xz3（空间字段为线面 非Point 类型） 索引，若有多个空间和时间字段，建立索引的字段为第一个空间和第一个时间字段；若只存在空间字段，则会建立 z2 或 xz2 索引；若只有时间字段，则默认建立时间属性索引。当然如没有在 spec 指明索引信息，可以在后续继续添加信息，如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="JAVA"><figure class="highlight hljs java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.locationtech.geomesa.utils.interop.SimpleFeatureTypes;</span><br><span class="line"></span><br><span class="line">String spec = <span class="string">&quot;name:String,dtg:Date,*geom:Point:srid=4326&quot;</span>;</span><br><span class="line">SimpleFeatureType sft = SimpleFeatureTypes.createType(<span class="string">&quot;mySft&quot;</span>, spec);</span><br><span class="line"><span class="comment">// enable a default z3 and a default attribute index</span></span><br><span class="line">sft.getUserData().put(<span class="string">&quot;geomesa.indices.enabled&quot;</span>, <span class="string">&quot;z3,attr:name&quot;</span>);</span><br><span class="line"><span class="comment">// or, enable a default z3 and an attribute index with a Z2 secondary index</span></span><br><span class="line">sft.getUserData().put(<span class="string">&quot;geomesa.indices.enabled&quot;</span>, <span class="string">&quot;z3,attr:name:geom&quot;</span>);</span><br><span class="line"><span class="comment">// or, enable a default z3 and an attribute index with a temporal secondary index</span></span><br><span class="line">sft.getUserData().put(<span class="string">&quot;geomesa.indices.enabled&quot;</span>, <span class="string">&quot;z3,attr:name:dtg&quot;</span>);</span><br></pre></td></tr></table></figure></div><h2 id="坑篇">坑篇</h2><h3 id="导入-osm-数据问题">导入 OSM 数据问题</h3><p>　　在<a href="https://www.geomesa.org/documentation/stable/user/convert/premade/osm.html">导入 osm 数据</a>时，若使用 osm-ways 作为 SimpleFeatureType，则 geomesa 会使用数据库存储 node 临时使用，这时其默认使用 H2 Database，若想使用其它数据库，则需要在 lib 导入相应 jdbc 包，若使用 postgresql 数据库，则 geomesa 会触发一个 bug，因为 postgresql 没有 double 类型，只有 double precision 类型，这将导致建表出错。详情见 geomesa/geomesa-convert/geomesa-convert-osm/src/main/scala/org/locationtech/geomesa/convert/osm/OsmWaysConverter.scala 中</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SCALA"><figure class="highlight hljs scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createNodesTable</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sql = <span class="string">&quot;create table nodes(id BIGINT NOT NULL PRIMARY KEY, lon DOUBLE, lat DOUBLE);&quot;</span></span><br><span class="line">    <span class="type">WithClose</span>(connection.prepareStatement(sql))(_.execute())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>所以若需要使用 geomesa-convert-osm 导入 osm 数据时，需要进入 geomesa/geomesa-convert/geomesa-convert-osm 文件夹中输入命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn dependency:copy-dependencies -DoutputDirectory=./depLib</span><br></pre></td></tr></table></figure></div><p>导出 geomesa-convert-osm 依赖包，将其中的 h2，osm4j，dynsax，trove4j 等一系列库放入 $GEOMESA_HBASE_HOME/lib 中。</p><h3 id="s2-索引问题">s2 索引问题</h3><p>　　s2 索引即 Google S2 Geometry 算法基于 Hilbert 曲线生成一种索引，GeoMesa 的 s2 索引是一个国人提交的，目前 3.2 版本只支持点的时空索引，不支持线面的时空索引，当然官方也在实现自己的 Hilbert 曲线，希望后续 GeoMesa 中会有 h2 索引。Shaun 在导入 osm 数据并启用 s2 索引时，报错，被提示不支持，对比 geomesa-index-api2Index.scala 和 geomesa-index-api2Index.scala 两文件的 defaults 函数可发现 S2Index 直接返回空，而在 geomesa-index-api.scala 中 fromName 函数需要调用 defaults 函数，从而导致 s2 索引不支持，修改 S2Index 的 defaults 函数即可（别忘了在 S2Index 类中首行加上 <code>import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType</code>）。</p><h2 id="后记">后记</h2><p>　　暂时就了解了这么多，等后续熟悉的更多再继续更吧 (ง •_•)ง。</p><h2 id="附录">附录</h2><h3 id="geomesa-命令行工具部分参数">GeoMesa 命令行工具部分参数</h3><p>Geomesa 命令行参数：</p><table><colgroup><col style="width: 25%" /><col style="width: 74%" /></colgroup><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>-c, --catalog *</td><td>存放 schema 元数据的catalog 表（相当于数据库）</td></tr><tr class="even"><td>-f, --feature-name</td><td>schema 名（相当于数据库中的表）</td></tr><tr class="odd"><td>-s, --spec</td><td>要创建 SimpleFeatureType 的说明（即表中列的描述信息，表的 schema，如 "name:String,age:Int,dtg:Date,*geom:Point:srid=4326"）</td></tr><tr class="even"><td>-C, --converter</td><td>指定转换器，必须为一下之一：1、已经在classpath中的converter 名；2、converter 的配置（一个字符串）；3、包括converter的配置的名</td></tr><tr class="odd"><td>–converter-error-mode</td><td>自定义的转换器的error mode</td></tr><tr class="even"><td>-t, --threads</td><td>指定并行度</td></tr><tr class="odd"><td>–input-format</td><td>指定输入源格式（如csv, tsv, avro, shp, json,）</td></tr><tr class="even"><td>–no-tracking</td><td>指定提交的 ingest job何时终止（在脚本中常用）</td></tr><tr class="odd"><td>–run-mode</td><td>指定运行模式，必须为：local（本地）、distributed （分布式）、distributedcombine（分布式组合）之一</td></tr><tr class="even"><td>–split-max-size</td><td>在分布式中，指定切片最大大小（字节）</td></tr><tr class="odd"><td>–src-list</td><td>输入文件为文本文件，按行输入</td></tr><tr class="even"><td>–force</td><td>禁用任何的提示</td></tr><tr class="odd"><td>[files]…</td><td>指定输入的文件</td></tr></tbody></table><p>参考资料：<a href="https://blog.csdn.net/qq_21705851/article/details/93392202">GeoMesa命令行工具---摄取命令</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　需要做个 GeoMesa 的微服务，简单熟悉一下 GeoMesa。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="bigdata" scheme="http://cniter.github.io/tags/bigdata/"/>
    
    <category term="geomesa" scheme="http://cniter.github.io/tags/geomesa/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用Docker环境开发调试</title>
    <link href="http://cniter.github.io/posts/3692cd6.html"/>
    <id>http://cniter.github.io/posts/3692cd6.html</id>
    <published>2021-01-10T08:50:12.000Z</published>
    <updated>2021-12-18T11:54:13.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　IDEA 以前基本没用过，只是简单用过 Android Studio，还基本都忘记了 ( ╯□╰ )，以后应该会用 Scala 做一些大数据方面的东西，而大数据的环境都是 Linux 下的，而 Shaun 日常都是在 Windows 下开发，所以需要用日前做的容器环境来测试调试运行程序，简单记录一下 IDEA 在这方面的使用方法。</p><span id="more"></span><h2 id="运行篇">运行篇</h2><p>　　右键项目名（HelloWorld），新建文件（New =》File），指定文件名为 <code>Dockerfile</code> 。写入内容示例如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="DOCKERFILE"><figure class="highlight hljs dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> stc:<span class="number">2.0</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./target/classes/ /tmp</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">&quot;scala&quot;</span>,<span class="string">&quot;HelloWorld&quot;</span>]</span></span><br></pre></td></tr></table></figure></div><p>点击左上角绿色双箭头，可编辑 Dockerfile（Edit 'Dockerfile'） ，指定当前上下文目录（Context folder），Contaier name 等容器启动选项。直接运行 Dockerfile（Run 'Dockerfile'），IDEA 即可自动创建容器，并在容器中运行程序，程序运行完则容器自动停止，若需要运行存在外部依赖的程序，则只能以 jar 包的方式运行。</p><p>　　设置 IDEA 生成 jar 包如下：在最上面的菜单栏中 File =》Project Structure =》Artifacts =》+ =》JAR =》From modules with dependencies，选择 Main Class，点击右边的文件夹图标即可选择相应类，由于存在外部依赖，所以不能直接用默认的 extract to the target JAR，而是应该选择下面的 <strong>copy to the output directory and link via manifest</strong>，点击 OK 后，自动或手动选择导出的依赖 jar 包，点击 OK。在最上面的菜单栏中 Build =》Build Artifacts...，可在 out/artifacts/HelloWorld_jar 文件夹中生成所有 jar 包。之后编辑 Dockerfile， <strong>更改 Dockerfile 上下文目录</strong>为 out/artifacts/HelloWorld_jar ，指定容器名，在 Command 中输入 <code>java -jar HelloWorld.jar</code> 修改 Dockerfile 中第 2 行命令为 <code>COPY . /tmp</code>，修改第 4 行命令为 <code>CMD ["java", "-jar", "HelloWorld.jar"]</code>。之后运行 Dockerfile 即可在下面 Services 栏对应 Docker 容器 Attached Console 中看到程序运行结果。</p><h2 id="调试篇">调试篇</h2><p>　　除了使用 IDEA 生成 jar 包外，还需要使用 IDEA 的远程调试功能，设置 IDEA 远程调试功能如下：在最上面的菜单栏中 Run =》Edit Configurations... =》+ =》Remote JVM Debug，上方的 Debugger mode 中使用默认的 Attach to remote JVM， 在下面的 Before launch 添加 Launch Docker before debug。在弹窗中选择相应 Dockerfile，在下方的 Custom command 中输入 <code>java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 -jar HelloWorld.jar</code>， 完成后即可使用该配置在 IDEA 调试容器中运行的程序。</p><h2 id="后记">后记</h2><p>　　用这种方式使用 IDEA 确实达到了 Shaun 理想的结果，Windows 下开发，Docker 中调试和运行，应付简单的代码调试和运行确实是没问题，但是在复杂的分布式环境下总会碰到一些莫名奇妙的问题，这些问题就是纯粹的经验了。</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.jetbrains.com/help/idea/supported-languages.html/running-a-java-app-in-a-container.html">Run a Java application in a Docker container</a></p><p><a href="https://www.jetbrains.com/help/idea/supported-languages.html/debug-a-java-application-using-a-dockerfile.html#create-dockerfile-run-config">Debug a Java application using a Dockerfile</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　IDEA 以前基本没用过，只是简单用过 Android Studio，还基本都忘记了 ( ╯□╰ )，以后应该会用 Scala 做一些大数据方面的东西，而大数据的环境都是 Linux 下的，而 Shaun 日常都是在 Windows 下开发，所以需要用日前做的容器环境来测试调试运行程序，简单记录一下 IDEA 在这方面的使用方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="devtool" scheme="http://cniter.github.io/tags/devtool/"/>
    
  </entry>
  
  <entry>
    <title>大数据环境搭建笔记</title>
    <link href="http://cniter.github.io/posts/af5e9ace.html"/>
    <id>http://cniter.github.io/posts/af5e9ace.html</id>
    <published>2021-01-03T01:50:26.000Z</published>
    <updated>2021-12-18T11:54:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　准备开始搞时空数据了，先简单搭一下环境。</p><span id="more"></span><p>准备搭的环境为：jdk-1.8.0，hadoop-3.2.1，hbase-2.2.6，geomesa-hbase_2.11-3.1.0，spark-3.0.1-bin-hadoop3.2，geoserver-2.16.5-bin，geomesa-hbase_2.11-3.2.0-SNAPSHOT，所用的包都已下好并解压到 /home 目录下。</p><p><strong><em>※注</em></strong>： <em>hbase-2.2.6 暂不支持最新的 hadoop-3.3.0</em>，Hadoop 也最好使用 jdk-1.8.0，java-11 会有问题。</p><h2 id="hadoop-环境">Hadoop 环境</h2><p>　　首先修改 /etc/hosts 文件中本机 ip 对应的名称为 master，若在容器中安装则需要在 run 开启容器就指定 <code>--hostname master</code>，否则改了也没用，下次启动容器时 hostname 又会回到初始状态，下面开启正式的配置。</p><p>修改 /home/hadoop-3.2.1/etc/hadoop/hadoop-env.sh 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_HOME</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hadoop-3.2.1/etc/hadoop/core-site.xml 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="XML"><figure class="highlight hljs xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- master 前面配置的主机名称 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;property&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;fs.default.name&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;value&gt;hdfs://master:9000&lt;/value&gt;</span></span><br><span class="line"><span class="comment">  &lt;/property&gt; --&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hadoop/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hadoop-3.2.1/etc/hadoop/hdfs-site.xml 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="XML"><figure class="highlight hljs xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定SecondaryNameNode位置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hadoop-3.2.1/etc/hadoop/yarn-site.xml 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="XML"><figure class="highlight hljs xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hadoop-3.2.1/etc/hadoop/mapred-site.xml 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="XML"><figure class="highlight hljs xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>在 /home/hadoop-3.2.1/sbin/start-dfs.sh 和 /home/hadoop-3.2.1/sbin/stop-dfs.sh 文件头添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HDFS_DATANODE_SECURE_USER=hdfs</span><br><span class="line">HDFS_NAMENODE_USER=root</span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure></div><p>在 /home/hadoop-3.2.1/sbin/start-yarn.sh 和 /home/hadoop-3.2.1/sbin/stop-yarn.sh 文件头添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure></div><p>设置环境变量，在 /etc/profile 中添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Hadoop Environment Setting</span></span><br><span class="line">export HADOOP_HOME=/home/hadoop-3.2.1</span><br><span class="line">export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/native</span><br><span class="line">export LD_LIBRARY_PATH=$JAVA_LIBRARY_PATH</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure></div><p>由于容器中默认为 root 用户，所以在 /root/.bashrc 文件末尾添加 <code>source /etc/profile</code>，以开机启用设置的环境变量。</p><p>在启动 Hadoop 之前需要执行 <code>hdfs namenode -format</code> 进行格式化，启动命令为 <code>/home/hadoop-3.2.1/sbin/start-all.sh</code>。<em>后续若需要清空并重新设置 Hadoop 时，必须先删除 /home/hadoop/ 目录，再重新进行格式化。</em></p><h2 id="hbase-环境">HBase 环境</h2><p>修改 /home/hbase-2.2.6/conf/hbase-env.sh 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="comment"># 使用自带的ZooKeeper管理</span></span><br><span class="line"><span class="built_in">export</span> HBASE_MANAGES_ZK=<span class="literal">true</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hbase-2.2.6/conf/hbase-site.xml 文件，添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="XML"><figure class="highlight hljs xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.dynamic.jars.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://master:9000/hbase/lib<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.master.maxclockskew<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>180000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Time difference of regionserver from master<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 修改默认8080 端口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rest.port<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>8088<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2181 默认端口，尽量不要修改，geomesa-hbase 导入数据时默认连接端口为 2181--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>2181<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/hbase/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- geomesa-hbase --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.coprocessor.user.region.classes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.locationtech.geomesa.hbase.server.coprocessor.GeoMesaCoprocessor<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div><p>修改 /home/hbase-2.2.6/conf/regionservers 文件，修改为（原来为 localhost）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master</span><br></pre></td></tr></table></figure></div><p>设置环境变量，在 /etc/profile 中添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">HBase Environment Setting</span></span><br><span class="line">export HBASE_HOME=/home/hbase-2.2.6</span><br><span class="line">export PATH=$PATH:$HBASE_HOME/bin</span><br></pre></td></tr></table></figure></div><p>配置好之后，执行 <code>start-hbase.sh</code> 启动 HBase。</p><h2 id="spark-环境">Spark 环境</h2><p>修改 /home/spark-3.0.1-bin-hadoop3.2/conf/spark-env.sh 文件，在文件末尾添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置JAVA_HOME，一般来说，不配置也可以，但是可能会出现问题，还是配上吧</span></span><br><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="variable">$JAVA_HOME</span></span><br><span class="line"><span class="comment"># 一般来说，spark任务有很大可能性需要去HDFS上读取文件，所以配置上</span></span><br><span class="line"><span class="comment"># 如果说你的spark就读取本地文件，也不需要yarn管理，不用配</span></span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=<span class="variable">$HADOOP_HOME</span>/etc/hadoop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置Master的主机名</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=master</span><br><span class="line"><span class="comment"># 提交Application的端口，默认就是这个，万一要改呢，改这里</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"><span class="comment"># 每一个Worker最多可以使用的cpu core的个数，我虚拟机就一个...</span></span><br><span class="line"><span class="comment"># 真实服务器如果有32个，你可以设置为32个</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_CORES=1</span><br><span class="line"><span class="comment"># 每一个Worker最多可以使用的内存，我的虚拟机就2g</span></span><br><span class="line"><span class="comment"># 真实服务器如果有128G，你可以设置为100G</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_MEMORY=2g</span><br><span class="line"><span class="comment"># master web UI端口默认8080</span></span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_WEBUI_PORT=8090</span><br><span class="line"><span class="comment"># worker web UI端口默认8081</span></span><br><span class="line"><span class="built_in">export</span> SPARK_WORKER_WEBUI_PORT=8089</span><br></pre></td></tr></table></figure></div><p>复制 /home/spark-3.0.1-bin-hadoop3.2/conf/slaves.template 文件，并重命名为 slaves，将该文件尾修改为</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 里面的内容原来为localhost，改为master </span></span><br><span class="line">master</span><br></pre></td></tr></table></figure></div><p>设置环境变量，在 /etc/profile 中添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/home/spark-3.0.1-bin-hadoop3.2</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin</span><br></pre></td></tr></table></figure></div><p>将 /home/spark-3.0.1-bin-hadoop3.2/sbin/start-all.sh 重命名为 start-spark-all.sh，将 /home/spark-3.0.1-bin-hadoop3.2/sbin/stop-all.sh 重命名为 stop-spark-all.sh，执行 <code>start-spark-all.sh</code> 启动 Spark。</p><h2 id="geomesa-hbase-环境">geomesa-hbase 环境</h2><h3 id="编译-geomesa">编译 geomesa</h3><p>克隆 <a href="https://gitee.com/mirrors/geomesa">LocationTech GeoMesa</a> ，<strong>修改 pom.xml</strong>，即修改对应依赖的 hadoop 和 hbase 以及 spark 版本（spark 最新的3.0.1版本由 Scala-2.12 编译，而 Geomesa 编译目前采用 Scala-2.11， 所以 Spark 不能使用最新的版本，只能用 2.4.7）。进入 geomesa 根目录，使用命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -DskipTests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或仅编译 geomesa-hbase</span></span><br><span class="line">mvn clean install -pl geomesa-hbase -am -DskipTests</span><br></pre></td></tr></table></figure></div><p>编译 geomesa，中间可能会失败很多次，包下不来，可能需要挂代理或换源，重复使用命令多次即可。</p><h3 id="配置-geomesa-hbase">配置 geomesa-hbase</h3><p>将 /home/geomesa/geomesa-hbase/geomesa-hbase-dist/target/geomesa-hbase_2.11-3.2.0-SNAPSHOT-bin.tar.gz 解压为 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT，<strong>将 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/dist/hbase/geomesa-hbase-distributed-runtime-hbase2_2.11-3.2.0-SNAPSHOT.jar 复制到 /home/hbase-2.2.6/lib/ 文件夹中</strong>，修改 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/conf/dependencies.sh 文件，设置正确的Hadoop 和 hbase 版本，依次执行 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-dependencies.sh 和 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-shapefile-support.sh。设置环境变量，在 /etc/profile 中添加</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GEOMESA_HBASE_HOME=/home/geomesa-hbase_2.11-3.2.0-SNAPSHOT</span><br><span class="line"><span class="built_in">export</span> GEOMESA_LIB=<span class="variable">$GEOMESA_HBASE_HOME</span>/lib</span><br><span class="line"><span class="built_in">export</span> GEOMESA_CONF_DIR=<span class="variable">$&#123;GEOMESA_HBASE_HOME&#125;</span>/conf</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=<span class="variable">$CLASSPATH</span>:<span class="variable">$GEOMESA_LIB</span>:<span class="variable">$GEOMESA_CONF_DIR</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GEOMESA_HBASE_HOME</span>/bin</span><br></pre></td></tr></table></figure></div><h3 id="测试-geomesa-hbase">测试 geomesa-hbase</h3><p>启动 Hadoop 和 HBase 之后，可直接使用命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geomesa-hbase ingest --catalog TestGeomesa --feature-name road --input-format shp <span class="string">&quot;/home/shpdata/road.shp&quot;</span></span><br></pre></td></tr></table></figure></div><p>导入 shp 数据，<strong>shp 不能有 id 字段</strong>，因为 Geomesa 在创建表时会默认生成一个 id 字段。</p><p>也可克隆 <a href="https://gitee.com/xfilove/geomesa-tutorials">geomesa-tutorials</a> ，同样修改其中的 pom.xml 文件，进入 geomesa-tutorials 根目录，使用命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install -pl geomesa-tutorials-hbase/geomesa-tutorials-hbase-quickstart -am</span><br></pre></td></tr></table></figure></div><p>编译 geomesa-tutorials，编译完成后，使用命令</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp geomesa-tutorials-hbase/geomesa-tutorials-hbase-quickstart/target/geomesa-tutorials-hbase-quickstart-3.2.0-SNAPSHOT.jar org.geomesa.example.hbase.HBaseQuickStart --hbase.zookeepers localhost --hbase.catalog geomesaTest</span><br></pre></td></tr></table></figure></div><p>导入数据进 Hbase，导入成功后可通过 <code>hbase shell</code> 进入 hbase，在 hbase shell 中通过 <code>list</code> 查看 hbase 现有的表。</p><h3 id="整合-geoserver">整合 geoserver</h3><p>导入依赖插件</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">manage-geoserver-plugins.sh -l <span class="variable">$&#123;GEOSERVER_HOME&#125;</span>/webapps/geoserver/WEB-INF/lib/ -i</span><br></pre></td></tr></table></figure></div><p>修改 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-dependencies.sh 中第33行：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SH"><figure class="highlight hljs sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install_dir=&quot;$&#123;GEOMESA_HBASE_HOME&#125;/lib&quot;</span></span><br><span class="line">install_dir=<span class="string">&quot;<span class="variable">$&#123;GEOSERVER_HOME&#125;</span>/webapps/geoserver/WEB-INF/classes&quot;</span></span><br></pre></td></tr></table></figure></div><p>执行 install-dependencies.sh 安装插件，安装完后将 classes 中的 lib 都移到 ${GEOSERVER_HOME}/webapps/geoserver/WEB-INF/lib中。</p><h2 id="后记">后记</h2><p>　　环境搞起来真麻烦，在编译和运行 Geomesa 时总能遇到一些莫名奇妙的问题，Java 系的这一套确实很麻烦，尤其是各种依赖关系，不过最后总算是搞好了，能直接在 geoserver 中看到 geomesa 存在 hbase 里的地图。</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.cnblogs.com/Mr-lin66/p/13378248.html">Centos7系统 Hadoop+HBase+Spark环境搭建</a></p><p><a href="https://blog.csdn.net/weixin_41834634/article/details/89176473">GeoMesa-HBase操作篇——安装</a></p><p><a href="https://blog.csdn.net/hsg77/article/details/82221531">centos7安装geomesa2.0.2_hbase_geoserver2.13.2的方法</a></p><p><a href="https://www.cnblogs.com/heidsoft/p/8558419.html">hadoop fs 命令使用</a></p><p><a href="https://www.geomesa.org/documentation/stable/tutorials/geomesa-quickstart-hbase.html">GeoMesa HBase Quick Start</a></p><p><a href="https://www.geomesa.org/documentation/stable/user/hbase/install.html">Installing GeoMesa HBase</a></p><p><a href="https://www.cnblogs.com/yszd/p/10039249.html">Spark完全分布式集群搭建【Spark2.4.4+Hadoop3.2.1】</a></p><h2 id="附录">附录</h2><p>最后附上一些常用的端口及说明：</p><h3 id="hbase">Hbase</h3><table><thead><tr class="header"><th>配置</th><th>端口</th><th>说明</th><th></th></tr></thead><tbody><tr class="odd"><td>hbase.master.port</td><td>16000</td><td>HMaster绑定端口</td><td></td></tr><tr class="even"><td><strong>hbase.master.info.port</strong></td><td><strong>16010</strong></td><td><strong>HBase Master的Web UI端口</strong></td><td></td></tr><tr class="odd"><td>hbase.regionserver.port</td><td>16020</td><td>HBase RegionServer绑定的端口</td><td></td></tr><tr class="even"><td><strong>hbase.regionserver.info.port</strong></td><td><strong>16030</strong></td><td><strong>HBase RegionServer的Web UI端口</strong></td><td></td></tr><tr class="odd"><td>hbase.zookeeper.property.clientPort</td><td>2181</td><td>Zookeeper客户端连接端口</td><td></td></tr><tr class="even"><td>hbase.zookeeper.peerport</td><td>2888</td><td>Zookeeper节点内部之间通信的端口</td><td></td></tr><tr class="odd"><td>hbase.zookeeper.leaderport</td><td>3888</td><td>Zookeeper用来选举主节点的端口</td><td></td></tr><tr class="even"><td>hbase.rest.port</td><td>8080</td><td>HBase REST server的端口</td><td></td></tr><tr class="odd"><td>hbase.master.port</td><td>60000</td><td>HMaster的RPC端口</td><td></td></tr><tr class="even"><td>hbase.master.info.port</td><td>60010</td><td>HMaster的http端口</td><td></td></tr><tr class="odd"><td>hbase.regionserver.port</td><td>60020</td><td>HRegionServer的RPC端口</td><td></td></tr><tr class="even"><td>hbase.regionserver.info.port</td><td>60030</td><td>HRegionServer的http端口</td><td></td></tr><tr class="odd"><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="hadoop">Hadoop</h3><table><thead><tr class="header"><th>配置</th><th>端口</th><th>说明</th><th></th></tr></thead><tbody><tr class="odd"><td>fs.defaultFS</td><td>9000</td><td>hdfs访问端口</td><td></td></tr><tr class="even"><td>dfs.namenode.rpc-address</td><td>9001</td><td>DataNode会连接这个端口</td><td></td></tr><tr class="odd"><td>dfs.datanode.address</td><td>9866</td><td>DataNode的数据传输端口</td><td></td></tr><tr class="even"><td><strong>dfs.namenode.http-address</strong></td><td><strong>9870</strong></td><td><strong>namenode的web UI 端口</strong></td><td></td></tr><tr class="odd"><td><strong>yarn.resourcemanager.webapp.address</strong></td><td><strong>8088</strong></td><td><strong>YARN的http端口</strong></td><td></td></tr></tbody></table><h3 id="spark">Spark</h3><table><thead><tr class="header"><th></th><th>端口</th><th>说明</th><th></th></tr></thead><tbody><tr class="odd"><td></td><td>8080</td><td>master的webUI，Tomcat的端口号（已修改为8090）</td><td></td></tr><tr class="even"><td></td><td>8081</td><td>worker的webUI的端口号（已修改为8089）</td><td></td></tr><tr class="odd"><td></td><td>18080</td><td>historyServer的webUI的端口号</td><td></td></tr></tbody></table><p>需开放端口 22，2181，5432，8080，8088，8089，8090，9870，16010，16030。</p><p><code>docker run -dit --privileged=true --name STC2 --hostname master -v E:/Docker/ShareFile:/mnt/sharefile -p 22:22 -p 80:80 -p 2181:2181 -p 5432:5432 -p 8080-8090:8080-8090 -p 9870:9870 -p 16010:16010 -p 16030:16030 stc:2.0 init</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　准备开始搞时空数据了，先简单搭一下环境。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="note" scheme="http://cniter.github.io/tags/note/"/>
    
    <category term="bigdata" scheme="http://cniter.github.io/tags/bigdata/"/>
    
  </entry>
  
  <entry>
    <title>设计模式浅谈</title>
    <link href="http://cniter.github.io/posts/ae780057.html"/>
    <id>http://cniter.github.io/posts/ae780057.html</id>
    <published>2020-12-27T10:28:56.000Z</published>
    <updated>2021-12-18T11:54:13.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　进入职场一年半以来，Shaun 完全独立从 0 到 1 开发了 1.5 个项目（当然也有参与其它项目，但不是 Shaun 独立从 0 到 1 开发的，没多少控制权，就不谈了），一个网页版的高精地图编辑器，半个地图可视化系统，这里面 Shaun 用了不少设计模式，这篇就谈谈 Shaun 用过的和没用过的一些设计模式。</p><span id="more"></span><p>　　以「Head First 设计模式」为参考，Shaun 用 C++ 实现了一遍书中的例子（代理模式及其后面的模式除外），下面进入正文。</p><h2 id="模式篇">模式篇</h2><h3 id="策略模式">策略模式</h3><p>　　Shaun 个人认为最能体现面向对象编程思想（抽象封装继承多态）的一种模式，换句话说，只要真正理解和运用面向对象编程，一定会自然而然的用到策略模式。Shaun 在做高精地图编辑器时，需要设计一个渲染模块，渲染模块会包含高亮行为，高亮有两种，一种是直接改变颜色，一种是使用后期处理（OutlinePass 或 UnrealBloomPass 等）进行高亮，这时就需要在渲染类中组合高亮行为。</p><p>　　策略模式中涉及到的原则有：1、封装变化；2、多用组合，少用继承；3、针对接口编程，不针对实现编程。封装变化这点很考验程序员的经验水平，在写代码之初，往往预料不到变化，所以这一点一般是在编码过程中逐渐完善的，不断进行抽象，从而生成比较合理的基类；第二点一般也是对的，但有时在编码过程中难免会碰到到底是用继承还是组合的问题，这时候可以多想想，组合并不是万能的，有时继承更合适，这时可以请教身边更有经验的程序员，组合的优势在于当子类不想要这个对象时，可以随时丢弃，而继承的优势在于，当子类不想实现这个行为时，可以有默认的行为，而且有些时候只能用继承；针对接口编程没啥好说的，就是抽象。</p><h3 id="观察者模式">观察者模式</h3><p>　　这个模式如果在分布式系统中又叫发布订阅模式，该模式常用于消息通知。前端有个 RxJS 的库将这一模式玩出花来了，Shaun 在高精地图编辑器的事件流管理中就使用了该库。在 threejs 中所有渲染对象的都有一个统一的基类 EventDispatcher，该类中就实现了一个简单的观察者模式，用来处理事件监听触发和通知，和真正的观察者相比，区别在于观察者只是一个函数，而不是一个类，其实浏览器的事件监听机制实现方式也和这个类差不多。</p><p>　　观察者模式中涉及到原则有：松耦合。这里的松耦合是指主题和观察者之间是隔离的，观察者可自行实现自己的更新行为，而主题同样可实现自己的通知机制，两者虽有关联但互不影响。松耦合原则说起来人人会说，但真正能实现松耦合的却不多，实现松耦合的关键在于怎样分离两个系统，两个系统的连接点在哪，这有时很难理清，从而造成逻辑混乱，bug 丛生。</p><h3 id="装饰者模式">装饰者模式</h3><p>　　利用该模式可以很方便的扩展一些方法和属性，尤其是遇到主体和配件这样的关系时，可以很轻松的添加配件到主体上。Shaun 没用过这个模式，本来在扩展 threejs 一个类时想用，但确实没找到非常明确的主体和配件这样的关系，最后还是简单的使用继承了。</p><p>　　装饰者模式涉及到的原则有：开放——封闭原则。设计一个类需要考虑对扩展开放，对修改关闭。修改和扩展看似矛盾，但实则可以独立存在，装饰者的配件可以无限加，这是扩展，是开放，而在加配件时无需修改现有代码，这是封闭。当然这一原则并不独属于装饰者模式，应该说是只要用到面向对象的思想开发程序，就一定会用到该原则，否则也就失去了面向对象的意义。但有时这个原则又没必要贯彻彻底，因为对于有些需求可能很难弄清修改和扩展的界限，这时就达到能尽量重用父类的方法就好。</p><h3 id="工厂模式">工厂模式</h3><p>　　该模式在稍微大一点的系统中应该都会用到，根据不同的输入，生成不同的对象，这就是工厂模式的本质。至于工厂模式的实现方式一般会根据需求的复杂度来决定：1、只有一个工厂，一类产品，只是为了集中一层 if-else，可用简单工厂模式，甚至一个 builder 函数即可；2、有多个工厂，还是只有一类产品，用工厂模式，多个工厂继承一个工厂父类即可，相当于多个简单工厂组合；3、有多个工厂，多类产品，哪个工厂生产什么产品可能有变化，这时需要用到抽象工厂模式，除正常的继承之外，还需使用组合，组合组成产品的父类，相当于再组合一个工厂。Shaun 在高精地图编辑器中当然是大量使用的工厂模式和简单工厂模式，主要是为了集中 if-else 的处理，比如根据不同的数据类型创建不同的属性栏界面（枚举用下拉框，字符串用文本框，数字用数字栏等），根据不同的路网元素创建对应的渲染器对象以及对应的属性界面等。</p><p>　　工厂模式涉及到的原则有：依赖倒置原则。尽量依赖抽象，而不是具体类。这其实也是抽象一种作用或好处，即在使用过程中尽量使用最上层的父类，具体类只在创建实例时使用。</p><h3 id="单例模式">单例模式</h3><p>　　写程序的基本都会用到该模式，主要用来创建全局唯一对象，可用来存储和处理系统中常用的各个模块都会用到的一些数据。Shaun 在编辑器中单例模式用了好几个，比如全局唯一的 viewport，用力绘制 3d 图形；全局唯一的路网数据；当然系统中存在太多的单例模式也不好，最好是只有一个，如 Shaun 的编辑器中最好的模式就是创建一个单例的 Editor 类，需要做单例的对象都可以放在该类中，如此保证系统中只有一个单例类，以进行统一管理。</p><p>　　该模式与面向对象倒是没多大关系了，可以认为是全局变量的优化版，毕竟大的系统中全局变量基本不可避免，这时就可以使用单例模式。</p><h3 id="命令模式">命令模式</h3><p>　　该模式主要用来将函数方法封装成类，这样做的好处就是可以更灵活的执行该方法（将方法放进队列中依次执行，将方法持久化以便系统启动执行），同时也可以保存该方法的一些中间状态，以便撤销操作，回到系统执行该方法前的状态。Shaun 在编辑器中主要用命令模式做撤销重做功能，这基本也是编辑器的必备功能了，可以说没有撤销重做功能的编辑器是不完整的，要实现撤销重做功能除了基本的命令模式之外，还要提供撤销和重做两个栈以保存操作命令。</p><p>　　该模式与面向对象也没很大关系，只是提供了一个实现一些特殊功能的标准或通用方案。</p><h3 id="适配器模式">适配器模式</h3><p>　　该模式正如其名，主要用来转换接口，将一个类的方法用其它类封装一下，以达到兼容其它类接口的目的，同时对外可接口保持不变，该模式通过对象组合实现。Shaun 没使用过该模式，就 Shaun 感觉这个模式应该可以用在维护了好几年的系统上，当新作的东西需要兼容老接口时，可以用适配器模式将新街口封装一下。</p><p>　　该模式同样只是提供了一种新接口兼容老接口的一种优良方案，当然实际使用过程中可能很难这么完美，但算是一种思路。</p><h3 id="外观模式">外观模式</h3><p>　　该模式算是封装的一种体现。当一个功能需要经过多次函数调用才能完成时，这时可以用另一个方法将这些函数都封装起来，从而简化调用方式。Shaun 用该模式处理整个渲染模块的初始化和资源释放，因为初始化时需要分配好很多东西（光照，viewport，固定图层，地面，天空盒等），而释放时同样需要释放这些东西。该模式同样只能算是提供了一种好的编程实践，实际使用过程可能每个函数都有很多参数，调用顺序可能有变，这时简化调用反而没有必要，让用户自己决定怎样调用更好。</p><p>　　外观模式涉及到的原则有：最少知识原则。该原则主要用来减少对象依赖，即尽量不将类中组合的对象直接暴露出去，而应该将组合对象的方法再简单封装一下，再将封装后的方法暴露出去，以减少另外的类又依赖类中组合对象的现象。该原则可以适当遵守，因为有时直接使用更方便一点，多次封装之后反而显得逻辑混乱，增加系统的复杂度。</p><h3 id="模板方法模式">模板方法模式</h3><p>　　该模式是抽象的一种体现。首先抽象出一套固定化的流程，流程中每个步骤的具体行为并一致，有些默认，有些可以重写，父类固定流程，子类负责重写流程中每个步骤，这就时模板方法模式。Shaun 没写过完全符合该模式的代码，只是写了个类似该模式的模块，该模块有三个功能（编辑道路节点，编辑车道节点，编辑车道线），做完前两个功能后，发现这里有一套逻辑是通用的，那就是滑过节点高亮，选择节点，出现 gizmo，拖动 gizmo，完成编辑（当然还有选择节点后不拖动 gizmo 等一套 if-else 中间处理状态），于是 Shaun 把这一套流程抽象出来，固化方法，这三个功能都继承该类，方法该重写的重写，不仅减少了代码量，同时整个流程也更清晰了，很快完成了第三个功能。</p><p>　　模板方法涉及到的原则有：好莱坞原则。即由父类负责函数调用，而子类负责重写被调用的函数，不用管父类的调用逻辑，也最好不要调用父类的函数。该原则用来理清流程很方便，只需要看父类即可，但实际编程过程中可能也会遇到子类不可避免的会调用父类的一些公共函数的情况，Shaun 觉得只要流程没问题的话，调用父类函数也能接受，并不需要严格遵守模式。</p><h3 id="迭代器模式">迭代器模式</h3><p>　　迭代器，即对遍历进行封装，一般只能顺序执行，提供 next() 方法获取下一个元素，集合容器的遍历方式一般都会用迭代器进行封装。Shaun 在这一个半项目里没写过迭代器，毕竟这是非常底层的一个模式，语言库本身有的数据结构大多自己实现了迭代器，除非需要设计一个新的集合或容器数据结构，才需要提供相应的迭代器。因为 js 没有 SortedMap 数据结构，为了高效分配路网元素 id，Shaun 利用 object 简单实现了一个，提供了相应的 forEach 方法。</p><p>　　迭代器模式涉及到的原则有：单一责任原则。即一类只做一件事，这个原则对于涉及最最底层的接口很实用，而大多具体类很难只做一件事。迭代器模式对于顺序访问来说还是非常有用的，毕竟使用迭代器的人不需要管底层到底用的什么数据结构，反正可以顺序遍历即可。</p><h3 id="组合模式">组合模式</h3><p>　　组合模式与其说是一种模式，更不如说就是一颗树，只是树的节点都是可供继承的类。在标准的组合模式中，父类中一定会有全部子类的全部函数，即所有子类的函数要么是继承自父类，要么是重写父类函数的，这其实是违背上面单一责任原则的，因为这必然会造成有些子类不需要这么多函数。而从组合模式会存储孩子节点这点来看，和装饰者模式有点类似，只不过装饰者只会存一个孩子，而组合模式可能会存多个，当然两者做的事是不一样，只是实现手法类似而已。Shaun 没写过标准的组合模式，如果只要符合树形模式都可认为是组合模式，那在高精地图编辑器中，所有路网元素都会继承一个父类，而道路中又包含车道簇，车道簇中包含车道，这也算组合模式。在 threejs 中有个 Object3D 的基类，所有渲染对象都会继承该类，该类中又包含若干孩子，threejs 计算 Model 矩阵时就是一层层孩子的 Model 矩阵乘下去，直到最后的孩子，结果就是最后 Shader 中的 Model 矩阵。</p><h3 id="状态模式">状态模式</h3><p>　　状态机的状态转移可以说是程序设计中最麻烦的部分之一了，这部分如果写不好的话，根本没法修改维护，同时会造成 bug 频发。在高精地图编辑器中鼠标操作有两类模式，一种是选择模式，另一种是编辑模式，选择模式又分为点选和框选，而编辑模式就非常多了，针对路网的不同元素，编辑模式的具体实现都不会一样，Shaun 首先使用 RxJS 封装了一个鼠标操作类（左键右键中键移动等），后续的鼠标操作都继承自该类，可以算是状态模式的父类，后续的鼠标操作就针对相应的需求实现相应的方法即可，当然其中鼠标操作自身也存在状态转移（左键到右键，左键到鼠标移动等），这些一般都是针对特定需求来的，所以这些小的状态转移一般在鼠标操作内部实现，但需要支持随时从编辑模式到选择模式，这意味着编辑模式编辑到一半的东西都需要支持随时释放，恢复编辑前的样子，这算是一个麻烦的地方，有时忘了释放就会出现问题。</p><p>　　状态模式算是为解决状态转移问题提供一种理想的方案，但其具体实现并不一定要和书上一样，Shaun 在用 C++ 实现时就采用另一套方案，状态类是独立的，控制状态转移的代码都在状态机内，而不是书中这种直接在状态类中控制状态机。好处坏处都有，看具体需求，Shaun 的方式就是状态类和状态机是分离的，状态类不需要管状态机怎么实现的，只需要管当前状态的情况，但需要在状态机中管理状态转移，而书中实现方式状态机的状态转移放到状态类中了，也因此状态类需要依赖状态机。</p><hr /><p><em>剩下的模式，Shaun 就没直接写代码实践了，因为大多都需要跨模块实现，有的甚至就是个小项目了，所以就简要谈谈 Shaun 的个人理解</em>。</p><h3 id="代理模式">代理模式</h3><p>　　主要可以用来做权限控制，在模块与模块之间的调用过程中，有时不想要一个模块可以访问另一个模块的全部内容，这时可以使用代理模式，创建一个中间模块，避免两个模块直接调用，同时进行访问控制。代理模式在如今的互联网时代不可避免的会用到，或直接或间接，往最小的说，对象组合也可用来实现代理模式。</p><h3 id="复合模式">复合模式</h3><p>　　将多种模式组合在一起使用，比如 MVC 模式，这种模式与其说是模式，更不如说就是一种架构，一种开发包含客户端系统的通用架构，当然每一层都会有很多模式进行组合，从而造成具体实现差异非常大。</p><h3 id="反模式">反模式</h3><p>　　反模式指的是用“不好的解决方案”去解决一个问题，Shaun 主要想谈谈开发反模式，因为这非常常见。有时候一个解决方案好不好要从多个角度进行衡量，比如现有技术，长期短期，上手难度，开发效率，维护难度等角度，当出现一个新问题时，往往意味着就有解决方案有缺陷，这种缺陷可能很容易弥补，更可能很难，当很难解决时，往往要采用全新的解决方案，这时团队对新解决方案可能都不熟，也没有魄力去采用新解决方案，只能去老解决方案继续强行打补丁，直到最后没法维护，白白浪费了大量的人力和时间，这是非常典型的一种反模式。</p><h3 id="桥接模式">桥接模式</h3><p>　　将抽象接口和实现分开，并独立派生，以支持抽象和实现的同时改变，并相互独立，可适用在需要跨平台跨不同设备的系统上。</p><h3 id="生成器模式">生成器模式</h3><p>　　有点像是模板方法模式和工厂模式的结合版，使用多个步骤创建一个对象，但步骤没有固定顺序，可适用于流程复杂的规划系统中。</p><h3 id="责任链模式">责任链模式</h3><p>　　可以认为是模板方法模式的进阶版，只是模板的步骤方法变成了一个个对象，并且支持步骤的增加和删除，以及更换顺序，一旦某个步骤成功执行，则整个链条终止，可适用于消除显式的 if-else，处理键盘或鼠标事件时，需要针对不同按键触发不同操作，这时可以采用该模式，缺点是链条很长时，要写很多类，导致执行啥很不直观。</p><h3 id="蝇量模式">蝇量模式</h3><p>　　这个模式算是一种优化内存占用的方案，通过牺牲类的独立性来减少内存，更彻底一点就是不创建类，直接用函数调用来处理就行。</p><h3 id="解释器模式">解释器模式</h3><p>　　可用来实现简单语法规则语言的解释器或编译器，每个语法规则都由一个类进行解析，然后组合。</p><h3 id="中介者模式">中介者模式</h3><p>　　可认为是状态模式和代理模式的结合版，不过各个状态可以是不同类，由中介者控制系统流转，集中控制逻辑，使被控制对象解耦，但可能会造成中介者本身非常复杂。</p><h3 id="备忘录模式">备忘录模式</h3><p>　　可用于系统（游戏）存档，存储系统中关键对象的运行状态，通常实现的方案一般是序列化/持久化，为了效率考虑，难的是有时需要增量存档。</p><h3 id="原型模式">原型模式</h3><p>　　js 的原型链应该是原型模式的典型，不仅实现了动态扩展实例，更实现了动态扩展对象，即继承。在高精地图编辑器中，由于需要做自动保存，所以在做序列化和反序列化的同时也简单实现了对象的 clone()，即从当前实例中创建一个完全一样的实例，可认为是 C++ 中的深拷贝。</p><h3 id="访问者模式">访问者模式</h3><p>　　相当于加个中间层，从而以最小的代价修改现有系统（一般是增加一个方法），达到外部可以取得系统内部信息的目的。</p><h2 id="后记">后记</h2><p>　　曾看过这样一句话：抽象能力决定编程能力，Shaun 个人认为，所谓抽象即提炼事物的共同点，这也是设计模式中反复使用接口的原因，接口即一组具体类的共同点，接口中的函数和变量即为这些具体类共有的，虽然具体行为可以不一样，但行为本身总是存在的。而又有这样一句话：程序等于数据结构加算法，Shaun 的理解是，狭义上的程序确实是这样，一段代码解决一个问题，这是程序，多段代码解决一个问题，这也是程序，多段代码解决多个问题，这亦是程序，一个软件，一个系统，一个平台，都是程序，但显然这些程序不是简单的数据结构和算法就能概括的，其内部必然有一套合理的逻辑进行组织，这套逻辑可以称之为“设计模式”，但这个“设计模式”不仅仅是上面谈的这些模式概念。Shaun 认为好的数据结构和算法确实能使程序达到当前最优，但对于一个大型系统或平台来说，这种最优只能是一种局部最优，这对整个系统的全局最优来说可能是微不足道的，而“设计模式”要解决的是怎样使一个系统达到全局最优，怎么合理组织局部最优。面对现代的超大型系统或平台，传统意义上的设计模式也只能达到局部最优，全局最优基本很少有人能驾驭，都是针对特定的业务需要，不断的试错改进优化，逐渐趋于稳定，但这种稳定可能很难抽象，放进其它的业务中，又得花费大量的人力物力去修改。</p><p>　　Shaun 个人对现代大型系统架构的理解就是分层分模块，功能太多分模块，模块太多就分层，一层不够分两层，两层不够分三层，三层不够继续分，根据数据流的处理分层，根据功能的不同分模块，模块内部依靠设计模式进行组织，设计模式调度的就是数据结构与算法。Shaun 目前的设计原则就是：每层一个独立的服务控制模块，每个模块一个对外服务功能（或事件或 socket ），同层的各模块之间尽量保持独立，不相互依赖，若各模块存在共同点，则将共同点抽出来，将其作为公共模块或独立为小层，层与层之间通过服务控制模块进行数据流的传输，除服务控制模块之外，模块之间尽量避免相互通信，即每个模块的对外服务功能一般只对本层服务控制模块提供服务，最好是只负责接收数据。如果系统实在太大，就只能保持纵向分层，横向保证各模块间数据流依次传输，并在特定模块节点上进行上下层的数据传输。</p><p>　　数据结构与算法重不重要？当然重要，数据结构与算法不过关，面试都过不去 ( ╯□╰ )，工作都没有，还何谈什么设计模式，什么架构。设计模式重不重要？当然也重要，不会合理使用设计模式，写出一堆别人没法维护的垃圾代码（当然，这或许是好事 :p ），改个需求要半天，加个功能要半个月，效率太低，这样即使有好的数据结构与算法作用也不大。但是设计模式也不是万能的，针对不同的需求，同一种设计模式有不同的实现方式，所以书中的设计模式也仅供参考而已，与其说设计模式重要，还不如说书中那几个设计原则更重要些。同时一味的追求设计模式也不见得是件好事，设计模式可以参考，但不能生搬硬套，毕竟人是活的，需求也是活的，固定的模式也需要有所改变，总而言之，能以最小的代价解决问题完成需求的模式就是好模式。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　进入职场一年半以来，Shaun 完全独立从 0 到 1 开发了 1.5 个项目（当然也有参与其它项目，但不是 Shaun 独立从 0 到 1 开发的，没多少控制权，就不谈了），一个网页版的高精地图编辑器，半个地图可视化系统，这里面 Shaun 用了不少设计模式，这篇就谈谈 Shaun 用过的和没用过的一些设计模式。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="thought" scheme="http://cniter.github.io/tags/thought/"/>
    
  </entry>
  
  <entry>
    <title>积分计算</title>
    <link href="http://cniter.github.io/posts/eee1c041.html"/>
    <id>http://cniter.github.io/posts/eee1c041.html</id>
    <published>2020-11-29T10:28:56.000Z</published>
    <updated>2021-12-18T11:54:13.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　最近需要计算一下曲线长度，无法直接得到被积函数的原函数，常规的积分解法牛顿莱布尼茨公式没法使用，所以只能使用数值积分计算积分。</p><span id="more"></span><p>　　下面主要介绍两种数值积分方法：龙贝格积分（Romberg Quadrature） 和 高斯-克朗罗德积分（Gauss-kronrod Quadrature）。 <em>下面附带的代码只做简单测试，不保证正确性，语言使用 Typescript。</em></p><h2 id="romberg-篇">Romberg 篇</h2><p>　　计算积分最简单的当然是使用复化梯形公式，即 <span class="math inline">\(I=\int_a^b{f(x)dx}=\frac{b-a}{2n}[f(a)+f(b)+2\sum\limits_{i=1}^{n-1}f(x_i)]= T_n,　x_i=a+i*h, h=(b-a)/n\)</span> ，若将 n 段每段一分为 2，可得到 <span class="math inline">\(T_{2n}=T_n/2+\frac{b-a}{2n}\sum\limits_{i=0}^{n-1}f(x_{i+1/2})\)</span> 。考虑数列 <span class="math inline">\(T=\{T_1,T_2,T_{2^2},...,T_{2^k}\}\)</span>，显然该数列必收敛，最后收敛为对应积分，当 <span class="math inline">\(|T_{2^k}-T_{2^{k-1}}| &lt; ε\)</span> （<span class="math inline">\(ε\)</span> 为精度）时，可取 <span class="math inline">\(T_{2^k}\)</span> 作为最后的积分结果。但是，直接利用梯形公司求解，收敛很慢，导致计算效率很差，所以需要使用理查德森（Richardson）外推法加速收敛，设 <span class="math inline">\(T_{2^k}^{(m)}\)</span> 为 m 次加速值，当 m 为 0 时，表示没加速，为原梯形公司，则 <span class="math inline">\(T_{2^k}^{(m)} = \frac{4^m}{4^m-1}T_{2^{k+1}}^{(m-1)}-\frac{1}{4^m-1}T_{2^k}^{(m-1)}\)</span>，当 <span class="math inline">\(|T_{2^{k+1}}^{(m)}-T_{2^k}^{(m)}| &lt; ε\)</span> 时，则收敛，并取其中一值作为最终的积分值。未经修饰的代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rombergIntegrator</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, tolerance = <span class="number">1e-8</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> h = b - a;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> preTK = ((f(a) + f(b)) * h) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tkmArray = [];</span><br><span class="line">    <span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">    tkmArray[m] = preTK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        m += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(m, tkmArray[m - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> tk = getTK(f, preTK, n, a, h);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(tk - preTK) &lt; tolerance) <span class="keyword">return</span> tk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> preTKM = tkmArray[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">let</span> preTK1M = tk;</span><br><span class="line">        tkmArray[<span class="number">0</span>] = tk;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> newTKM = getTKM(preTK1M, preTKM, i);</span><br><span class="line">            preTKM = tkmArray[i];</span><br><span class="line">            preTK1M = newTKM;</span><br><span class="line">            tkmArray[i] = newTKM;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (preTKM !== <span class="literal">undefined</span> &amp;&amp; <span class="built_in">Math</span>.abs(preTK1M - preTKM) &lt; tolerance) <span class="keyword">return</span> preTK1M;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        preTK = tk;</span><br><span class="line">        n *= <span class="number">2</span>;</span><br><span class="line">        h /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTK</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, preTK: <span class="built_in">number</span>, n: <span class="built_in">number</span>, a: <span class="built_in">number</span>, h: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> x = a + (i + <span class="number">0.5</span>) * h;</span><br><span class="line">            sum += f(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (preTK + h * sum) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getTKM</span>(<span class="params">preTK1M: <span class="built_in">number</span>, preTKM: <span class="built_in">number</span>, m = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> m4 = <span class="number">1</span> &lt;&lt; (<span class="number">2</span> * m); <span class="comment">// 4 ** m;</span></span><br><span class="line">        <span class="keyword">return</span> (m4 * preTK1M - preTKM) / (m4 - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　由于采用闭型积分规则（积分上下限值参与积分计算），所以以上代码不适合计算两端点值被积函数值无限大的情况（如 1/4 圆弧积分等）。而且该方法不合适求取被积函数在积分区间内导数值变化较大（如被积函数在积分下限附近剧烈波动，在积分上限附近不变化等）的积分，因为该方法是均匀分段，这种情况将导致计算量剧增，这时就需要用到下面的自适应积分。</p><h2 id="自适应篇">自适应篇</h2><p>　　自适应积分主要包括两类：全局自适应积分和局部自适应积分，通常情况下全局自适应积分的会比局部自适应积分的表现要好，全局自适应积分一般通过二分递归实现，当满足一定条件时，递归终止，即通过二分分别计算两边的积分，若一边满足一定条件，则不继续划分，从而减少计算量。全局自适应积分中比较经典的有基于辛普森（Simpson）公式的自适应算法，普通辛普森积分公式为：<span class="math inline">\(I=\int_a^b{f(x)dx}=\frac{b-a}{6}[f(a)+4f(m)+f(b)]= S(a,b),　m=(a+b)/2\)</span>，复化辛普森公式为 <span class="math inline">\(I=\int_a^b{f(x)dx}=\frac{h}{3}[f(a)+4\sum\limits_{i=1}^{n}f(x_{2i-1})+2\sum\limits_{i=1}^{n-1}f(x_{2i})+f(b)]= S(a,b)\)</span>，其中 <span class="math inline">\(x_i=a+i*h　(i=1,2,3,...,2n),h=\frac{b-a}{2n}\)</span>，基于辛普森公式的自适应基本原理如下：令 <span class="math inline">\(S_2(a,b) = S(a,m)+S(m,b)\)</span>，m 为 a,b 中值，若 <span class="math inline">\(|S(a,b) - S_2(a,b)| &lt; 15ε\)</span>，则取 <span class="math inline">\(S_2(a,b)\)</span> 或 <span class="math inline">\(S_2(a,b)+(S(a,b)-S_2(a,b))/15\)</span> 作为该区间的积分值，否则，将区间二分递归，同时因为误差会累积，所以每次递归都需要将精度提高两倍，即 <span class="math inline">\(ε = ε/2\)</span>，如此最后的精度才能达到最初的精度。具体 ts 代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adaptiveSimpsonIntegrator</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, epsilon = <span class="number">1e-8</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> S = complexSimpson(f, a, b);</span><br><span class="line">    <span class="keyword">return</span> adsimp(f, a, b, epsilon, S);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">adsimp</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, epsilon = <span class="number">1e-8</span>, S = <span class="number">0</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> m = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">let</span> LS = complexSimpson(f, a, m);</span><br><span class="line">        <span class="keyword">let</span> RS = complexSimpson(f, m, b);</span><br><span class="line">        <span class="keyword">const</span> S2 = LS + RS;</span><br><span class="line">        <span class="keyword">const</span> tolerance = <span class="number">15</span> * epsilon;</span><br><span class="line">        <span class="keyword">let</span> delta = S - S2;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(delta) &lt; tolerance) <span class="keyword">return</span> S2 + delta / <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> doubleEPS = epsilon / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> adsimp(f, a, m, doubleEPS, LS) + adsimp(f, m, b, doubleEPS, RS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">complexSimpson</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, n = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> n2 = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> h = (b - a) / n2;</span><br><span class="line">        <span class="keyword">let</span> sum = f(a) + f(b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n2; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += <span class="number">4</span> * f(a + i * h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n2 - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            sum += <span class="number">2</span> * f(a + i * h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (sum * h) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　在 D.V. Fedorov 写的「Introduction to Numerical Methods with examples in Javascript」一书中介绍了一种全局自适应方法，即分别使用高阶和低阶的权值分别计算积分，两者之间的差值 <span class="math inline">\(E\)</span> 作为误差估计，设绝对精度为 <span class="math inline">\(\delta\)</span> ，相对精度为 <span class="math inline">\(\epsilon\)</span> ，若 <span class="math inline">\(|E|&lt;\delta+\epsilon*Q\)</span>，Q 为高阶权值计算的积分，则取 Q 作为积分值，否则将积分区间二分，同时使 <span class="math inline">\(\delta/\sqrt{2}\)</span>，<span class="math inline">\(\epsilon\)</span> 保持不变。具体 ts 代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursiveAdaptiveIntegrator</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, accuracy = <span class="number">1e-15</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursiveAdaptiveIntegrate(f, a, b, accuracy);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recursiveAdaptiveIntegrate</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        a: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        b: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        accuracy = <span class="number">1e-15</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        epsilon = <span class="built_in">Number</span>.EPSILON,</span></span></span><br><span class="line"><span class="params"><span class="function">        preFValue?: <span class="built_in">number</span>[],</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> abscissae = [<span class="number">1</span> / <span class="number">6</span>, <span class="number">2</span> / <span class="number">6</span>, <span class="number">4</span> / <span class="number">6</span>, <span class="number">5</span> / <span class="number">6</span>];</span><br><span class="line">        <span class="keyword">const</span> highOrderWeights = [<span class="number">2</span> / <span class="number">6</span>, <span class="number">1</span> / <span class="number">6</span>, <span class="number">1</span> / <span class="number">6</span>, <span class="number">2</span> / <span class="number">6</span>];</span><br><span class="line">        <span class="keyword">const</span> lowOrderWeights = [<span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span> / <span class="number">4</span>, <span class="number">1</span> / <span class="number">4</span>];</span><br><span class="line">        <span class="keyword">const</span> isRecompute = [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">const</span> h = b - a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> fValue: <span class="built_in">number</span>[] = [];</span><br><span class="line">        <span class="keyword">if</span> (preFValue === <span class="literal">undefined</span>) &#123;</span><br><span class="line">            abscissae.forEach(<span class="function">(<span class="params">abscissa</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> x = a + abscissa * h;</span><br><span class="line">                fValue.push(f(x));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; abscissae.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRecompute[i]) fValue.push(f(a + abscissae[i] * h));</span><br><span class="line">                <span class="keyword">else</span> fValue.push(preFValue[k++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> highResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> lowResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; highOrderWeights.length; i++) &#123;</span><br><span class="line">            highResult += highOrderWeights[i] * fValue[i];</span><br><span class="line">            lowResult += lowOrderWeights[i] * fValue[i];</span><br><span class="line">        &#125;</span><br><span class="line">        highResult *= h;</span><br><span class="line">        lowResult *= h;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> tolerance = accuracy + epsilon * <span class="built_in">Math</span>.abs(highResult);</span><br><span class="line">        <span class="keyword">let</span> errorEstimate = <span class="built_in">Math</span>.abs(highResult - lowResult) / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (errorEstimate &lt; tolerance) &#123;</span><br><span class="line">            <span class="keyword">return</span> highResult;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            accuracy /= <span class="built_in">Math</span>.sqrt(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> m = a + h / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">let</span> midIndex = <span class="built_in">Math</span>.trunc(abscissae.length / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">let</span> leftFValue = fValue.slice(<span class="number">0</span>, midIndex);</span><br><span class="line">            <span class="keyword">let</span> rightFValue = fValue.slice(midIndex);</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                recursiveAdaptiveIntegrate(f, a, m, accuracy, epsilon, leftFValue) +</span><br><span class="line">                recursiveAdaptiveIntegrate(f, m, b, accuracy, epsilon, rightFValue)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　该方法很巧妙的设计了一组插值点，使得当前计算的函数值正好可以被下次迭代所使用，从而提高性能，同时该方法可以得到 1/4 圆弧长，虽然精度只能到小数点后 8 位，至于 Shaun 写的其它测试函数，都能得到理想精度。</p><h2 id="gauss-篇">Gauss 篇</h2><p>　　高斯求积法是一种多项式插值积分法，同时由于不计算被积函数在区间两个端点处的值，所以高斯积分法采用的开型积分规则，高斯积分法的衍生方法有很多种，下面主要介绍高斯-勒让德（Gauss-Legendre Quadrature）以及其迭代改良的高斯-克朗罗德法。高斯-勒让德积分法的公式为积分的原始形态，即 <span class="math inline">\(\int_a^bf(x)dx=\sum\limits_{i=1}^{∞}w_if(x_{i})\approx\sum\limits_{i=1}^{n}w_if(x_{i})\)</span> ，只不过 <span class="math inline">\(x_i \in [-1,1]\)</span>，并且 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(w_i\)</span> 都通过勒让德多项式求出，所以其原则上只能用在积分区间为 [-1, 1] 上的积分，但是可以将积分从任意区间通过简单的变形变换到 [-1, 1] 上，即 <span class="math inline">\(\int_a^b{f(x)dx} = \frac{b-a}{2}\int_{-1}^1{f(\frac{b-a}{2}t+\frac{b+a}{2})dt}\)</span> ，从而可以将高斯-勒让德方法扩展到任意积分上。由于每个 n 对应的 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(w_i\)</span> 都可以查表可得，所以具体代码方面就很简单了，以 n = 4，即插值点个数为 4 为例，ts 代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gaussLegendreIntegrate</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, n: <span class="number">4</span> | <span class="number">8</span> = <span class="number">4</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> weightsAndAbscissae = getWeightsAndAbscissae(n);</span><br><span class="line">    <span class="keyword">const</span> weights = weightsAndAbscissae.weights;</span><br><span class="line">    <span class="keyword">const</span> abscissae = weightsAndAbscissae.abscissae;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> halfH = (b - a) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; abscissae.length; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> xi = halfH * abscissae[i] + a + halfH;</span><br><span class="line">        sum += weights[i] * f(xi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum * halfH;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getWeightsAndAbscissae</span>(<span class="params">n: <span class="number">4</span> | <span class="number">8</span> = <span class="number">4</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">weights</span>: [</span><br><span class="line">                        <span class="number">0.362683783378362</span>,</span><br><span class="line">                        <span class="number">0.362683783378362</span>,</span><br><span class="line">                        <span class="number">0.3137066458778873</span>,</span><br><span class="line">                        <span class="number">0.3137066458778873</span>,</span><br><span class="line">                        <span class="number">0.2223810344533745</span>,</span><br><span class="line">                        <span class="number">0.2223810344533745</span>,</span><br><span class="line">                        <span class="number">0.1012285362903763</span>,</span><br><span class="line">                        <span class="number">0.1012285362903763</span>,</span><br><span class="line">                    ],</span><br><span class="line">                    <span class="attr">abscissae</span>: [</span><br><span class="line">                        -<span class="number">0.1834346424956498</span>,</span><br><span class="line">                        <span class="number">0.1834346424956498</span>,</span><br><span class="line">                        -<span class="number">0.525532409916329</span>,</span><br><span class="line">                        <span class="number">0.525532409916329</span>,</span><br><span class="line">                        -<span class="number">0.7966664774136267</span>,</span><br><span class="line">                        <span class="number">0.7966664774136267</span>,</span><br><span class="line">                        -<span class="number">0.9602898564975363</span>,</span><br><span class="line">                        <span class="number">0.9602898564975363</span>,</span><br><span class="line">                    ],</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    <span class="attr">weights</span>: [<span class="number">0.6521451548625461</span>, <span class="number">0.6521451548625461</span>, <span class="number">0.3478548451374538</span>, <span class="number">0.3478548451374538</span>],</span><br><span class="line">                    <span class="attr">abscissae</span>: [-<span class="number">0.3399810435848563</span>, <span class="number">0.3399810435848563</span>, -<span class="number">0.8611363115940526</span>, <span class="number">0.8611363115940526</span>],</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　若要提高高斯-勒让德积分法的精度，可通过增加插值点或分多个区间进行积分来实现，但是由于没有误差估计，所以还是没法精确控制精度，对与某些被积函数积分精度高，但对于其它被积函数，积分精度却有限，当然可以简单的引入一些常用的误差估计法，但一般需要重新计算积分，导致效率很低，而高斯-克朗罗德法为其引入了一种基于 Kronrod 点的误差估计法，可充分利用现有计算值，从而达到有效控制精度的同时，性能没有太大的损失。设 <span class="math inline">\(G(f,n)=\sum\limits_{i=1}^{n}w_if(x_{i})\)</span> 为具有 n 个插值点的高斯-勒让德法计算结果，<span class="math inline">\(GK(f,n) = \sum\limits_{i=1}^{n}w&#39;_if(x_{i})+\sum\limits_{k=n+1}^{2n+1}w&#39;_kf(x_{k})\)</span> 为高斯-克朗罗德法的计算结果，则 <span class="math inline">\(|GK(f,n)-G(f,n)|\)</span> 可作为误差估计，有了误差估计，最后再使用全局自适应策略，即可得到精度可控的高斯积分结果。具体 ts 代码如下，以 n = 7 为例：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gaussKronrodIntegrator</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, accuracy = <span class="number">1e-15</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursiveAdaptiveIntegrate(f, a, b, accuracy);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recursiveAdaptiveIntegrate</span>(<span class="params">f: (x: <span class="built_in">number</span>) =&gt; <span class="built_in">number</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span>, accuracy = <span class="number">1e-12</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> gaussAbscissae = [</span><br><span class="line">            <span class="number">0.0</span>,</span><br><span class="line">            -<span class="number">4.058451513773971669066064120769615e-1</span>,</span><br><span class="line">            <span class="number">4.058451513773971669066064120769615e-1</span>,</span><br><span class="line">            -<span class="number">7.415311855993944398638647732807884e-1</span>,</span><br><span class="line">            <span class="number">7.415311855993944398638647732807884e-1</span>,</span><br><span class="line">            -<span class="number">9.491079123427585245261896840478513e-1</span>,</span><br><span class="line">            <span class="number">9.491079123427585245261896840478513e-1</span>,</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">const</span> gaussWeights = [</span><br><span class="line">            <span class="number">4.179591836734693877551020408163265e-1</span>,</span><br><span class="line">            <span class="number">3.818300505051189449503697754889751e-1</span>,</span><br><span class="line">            <span class="number">3.818300505051189449503697754889751e-1</span>,</span><br><span class="line">            <span class="number">2.797053914892766679014677714237796e-1</span>,</span><br><span class="line">            <span class="number">2.797053914892766679014677714237796e-1</span>,</span><br><span class="line">            <span class="number">1.29484966168869693270611432679082e-1</span>,</span><br><span class="line">            <span class="number">1.29484966168869693270611432679082e-1</span>,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> kronrodAbscissae = gaussAbscissae.concat([</span><br><span class="line">            -<span class="number">2.077849550078984676006894037732449e-1</span>,</span><br><span class="line">            <span class="number">2.077849550078984676006894037732449e-1</span>,</span><br><span class="line">            -<span class="number">5.860872354676911302941448382587296e-1</span>,</span><br><span class="line">            <span class="number">5.860872354676911302941448382587296e-1</span>,</span><br><span class="line">            -<span class="number">8.648644233597690727897127886409262e-1</span>,</span><br><span class="line">            <span class="number">8.648644233597690727897127886409262e-1</span>,</span><br><span class="line">            -<span class="number">9.914553711208126392068546975263285e-1</span>,</span><br><span class="line">            <span class="number">9.914553711208126392068546975263285e-1</span>,</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> kronrodWeights = [</span><br><span class="line">            <span class="number">2.094821410847278280129991748917143e-1</span>,</span><br><span class="line">            <span class="number">1.903505780647854099132564024210137e-1</span>,</span><br><span class="line">            <span class="number">1.903505780647854099132564024210137e-1</span>,</span><br><span class="line">            <span class="number">1.406532597155259187451895905102379e-1</span>,</span><br><span class="line">            <span class="number">1.406532597155259187451895905102379e-1</span>,</span><br><span class="line">            <span class="number">6.309209262997855329070066318920429e-2</span>,</span><br><span class="line">            <span class="number">6.309209262997855329070066318920429e-2</span>,</span><br><span class="line">            <span class="number">2.044329400752988924141619992346491e-1</span>,</span><br><span class="line">            <span class="number">2.044329400752988924141619992346491e-1</span>,</span><br><span class="line">            <span class="number">1.690047266392679028265834265985503e-1</span>,</span><br><span class="line">            <span class="number">1.690047266392679028265834265985503e-1</span>,</span><br><span class="line">            <span class="number">1.04790010322250183839876322541518e-1</span>,</span><br><span class="line">            <span class="number">1.04790010322250183839876322541518e-1</span>,</span><br><span class="line">            <span class="number">2.293532201052922496373200805896959e-2</span>,</span><br><span class="line">            <span class="number">2.293532201052922496373200805896959e-2</span>,</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> halfH = (b - a) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> guassResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> kronrodResult = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; gaussAbscissae.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> xi = halfH * gaussAbscissae[i] + a + halfH;</span><br><span class="line">            <span class="keyword">let</span> yi = f(xi);</span><br><span class="line">            guassResult += gaussWeights[i] * yi;</span><br><span class="line">            kronrodResult += kronrodWeights[i] * yi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = gaussAbscissae.length; i &lt; kronrodAbscissae.length; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> xi = halfH * kronrodAbscissae[i] + a + halfH;</span><br><span class="line">            <span class="keyword">let</span> yi = f(xi);</span><br><span class="line">            kronrodResult += kronrodWeights[i] * yi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(kronrodResult - guassResult) &lt; accuracy / halfH) <span class="keyword">return</span> kronrodResult * halfH;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> m = a + (b - a) / <span class="number">2</span>;</span><br><span class="line">            accuracy /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> recursiveAdaptiveIntegrate(f, a, m, accuracy) + recursiveAdaptiveIntegrate(f, m, b, accuracy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>　　简单测试了一下，Shaun 这里写的 gaussKronrodIntegrator 方法最大精度只能到 1e-15，到 16 位就报错递归深度太大了，圆的 1/4 弧长也没法算出来，当然这些问题可通过设置最大递归深度以及处理异常值来解决，Shaun 这里就不继续写了。</p><h2 id="后记">后记</h2><p>　　数值积分策略非常多，尤其是针对一些特殊的函数，可能只能使用一些特殊的策略才能计算，Shaun 这里只是介绍了一些比较基础常用的积分方法，能解决大部分积分问题，唯一需要注意一点的就是如何追求性能与精度之间的平衡，因为积分常常涉及到迭代求值，通常而言精度越高，迭代越多，求积时，同时也需要注意被积函数的异常值（如无穷大等），这时可能需要拆分或变换积分区间，并且使用开型积分规则的积分方法进行重新计算。</p><h2 id="附录">附录</h2><h3 id="一些常见的积分变换">一些常见的积分变换</h3><p><span class="math display">\[\int_a^bf(x) = \int_0^{b-a}f(a+t)dt \\\int_a^b{f(x)dx} = \frac{b-a}{2}\int_{-1}^1{f(\frac{b-a}{2}t+\frac{b+a}{2})dt} \\\int_{-∞}^{+∞}{f(x)dx} = \int_{-1}^1{f(\frac{t}{1-t^2})\frac{1+t^2}{(1-t^2)^2}dt} \\\int_{a}^{+∞}{f(x)dx} = \int_{0}^1{f(a + \frac{t}{1-t})\frac{1}{(1-t)^2}dt} \\\int_{-∞}^{a}{f(x)dx} = \int_{-1}^0{f(a + \frac{t}{1+t})\frac{-1}{(1+t)^2}dt}\]</span></p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://reference.wolfram.com/language/tutorial/NIntegrateIntegrationStrategies.html#155948475">积分策略</a></p><p>[2] <a href="https://pomax.github.io/bezierinfo/legendre-gauss.html">Gaussian Quadrature Weights and Abscissae</a></p><p>[3] <a href="https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/gauss_kronrod.html">Gauss-Kronrod Quadrature</a></p><p>[4] <a href="https://www.advanpix.com/2011/11/07/gauss-kronrod-quadrature-nodes-weights/">Gauss-Kronrod Quadrature Nodes and Weights</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　最近需要计算一下曲线长度，无法直接得到被积函数的原函数，常规的积分解法牛顿莱布尼茨公式没法使用，所以只能使用数值积分计算积分。&lt;/p&gt;</summary>
    
    
    
    <category term="Mathematics" scheme="http://cniter.github.io/categories/Mathematics/"/>
    
    
    <category term="numerical" scheme="http://cniter.github.io/tags/numerical/"/>
    
    <category term="integration" scheme="http://cniter.github.io/tags/integration/"/>
    
  </entry>
  
  <entry>
    <title>Geometry增量更新</title>
    <link href="http://cniter.github.io/posts/a5661762.html"/>
    <id>http://cniter.github.io/posts/a5661762.html</id>
    <published>2020-11-22T10:26:10.000Z</published>
    <updated>2021-12-18T11:54:13.932Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　优化 DrawCall 是图形学性能优化中老生常谈的问题，而针对 DrawCall 优化有很多方案，大致可分为两种：简化（Simplification）和合并（Consolidation），简化是指减少三角形个数，即将精细的模型变为粗糙的模型以及各种三角形剔除方案（视锥体剔除（Frustum Culling），遮挡剔除（Occlusion Culling）等），而合并自然则是将同一中材质下的多个 geometry 合并成一个 geometry。</p><span id="more"></span><h2 id="需求篇">需求篇</h2><p>　　最近一段时间一直在做高精地图道路的编辑，道路的编辑涉及到很多东西，这篇仅简单谈谈编辑性能的问题。为了能更直白的显示高精地图，不能简单的只使用点和线，还需要使用面将路面和路面上的一些路面标识精确的还原出来。在可视化道路时，主要有两种方案：1、将每条道路作为一个单独的 Mesh，即单独控制每条道路的渲染，一条道路至少产生一次 DrawCall，这样可以更方便的对每条道路进行编辑，但在渲染时要求更高的性能，而且道路一多，将不可避免的引起卡顿；2、将所有道路作为一个 Mesh，即直接渲染出一整个路网，这样显著降低了 DrawCall 次数，使渲染更流畅，但问题在于每编辑一次道路时，都需要重新三角化（Tessellation）整个路网，而且在选中一条道路时，为可视化选中效果，同样需要重新三角化该道路，并生成相应的 Mesh，导致编辑卡顿，每编辑完一次都可能需要等待一会儿。所以为了平衡渲染性能和编辑效率，需要有一种折中的方案，即对整个路网的 Geometry 能做到快速的分离与合并，在编辑时将受影响的道路分离出来，而在编辑之后，又将全部道路合并一下，提高显示性能。下面就谈谈 Shaun 对这种方案的一些思考。</p><h2 id="编辑篇">编辑篇</h2><p>　　Shaun 为平衡渲染性能和编辑效率，想出的一种方案是增量更新 Geometry，即只删除或增加局部的 Geometry，而其它不受影响的 Geometry 保持原样，如此即可达到快速的分离和合并 Geometry。具体做法如下：</p><ol type="1"><li><p>首先将所有道路的三角化结果合并成一个 Geometry，在合并的同时建立好每条道路的顶点索引以及面的索引（js 中可直接使用 object 进行存储）；</p></li><li><p>在选择时，根据顶点索引和面索引重建一个 Geometry，再基于该 Geometry 构建一个新的 Mesh 以指示选择效果；</p></li><li><p>当删除道路时，需要删除面索引对应的所有面，而顶点索引对应的顶点不需要删除，将顶点索引移到一个用来标识该部分顶点已废弃的容器 F 中；</p></li><li><p>当新增道路时，需要先从容器 F 中查找是否有合适的地方放置该道路的顶点，若有，则放置在对应地方，并更新容器 F 中对应元素，若没有，则将该道路的顶点放置在 Geometry 顶点数组的最末尾，放置完顶点之后，同样需要建立该道路的顶点索引和面索引。</p></li></ol><p><strong><em>※注：</em></strong>至于容器 F 使用怎样的数据结构以及其中的元素该怎样排列，针对不同的顶点索引可以有不同的选择；在新增道路时，同样可以不同的策略来决定放置顶点的位置（可参考操作系统内存分配的模式）。</p><p>　　由于新增道路时，可能会在容器 F 中产生一些永远无法删除的元素，导致顶点数组空闲碎片。 为抵抗顶点碎片以及减少顶点数目，需要对顶点数据进行压缩（Compaction），即移除没有使用的顶点，将后面的顶点前移，在前移顶点的同时，别忘了需要同时修改面中相应顶点的索引以及更新构建好的每条道路的顶点索引。</p><h2 id="后记">后记</h2><p>　　Shaun 这里只是提出了一种想法，最终实现起来发现效果也确实能达到基本需求（针对有很多条道路的大地图，显示性能从原来的十几二十帧到现在的 60 帧，同时选择和编辑也没受到影响），虽然在内存上比原来多增加了近 20%（还有优化的余地），但是为了渲染流畅以及编辑舒服，在如今这个内存越来越不值钱的年代，这种牺牲 Shaun 觉得是能接受的。当然或许有更好的方案，但限于 Shaun 目前的认知，只能暂时想到这一方案了，若有大佬有更好的方案，还望不吝赐教 🙏。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　优化 DrawCall 是图形学性能优化中老生常谈的问题，而针对 DrawCall 优化有很多方案，大致可分为两种：简化（Simplification）和合并（Consolidation），简化是指减少三角形个数，即将精细的模型变为粗糙的模型以及各种三角形剔除方案（视锥体剔除（Frustum Culling），遮挡剔除（Occlusion Culling）等），而合并自然则是将同一中材质下的多个 geometry 合并成一个 geometry。&lt;/p&gt;</summary>
    
    
    
    <category term="Image&amp;Graphic" scheme="http://cniter.github.io/categories/Image-Graphic/"/>
    
    
    <category term="algorithm" scheme="http://cniter.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Mapbox显示GeoServer地图</title>
    <link href="http://cniter.github.io/posts/e225d8fd.html"/>
    <id>http://cniter.github.io/posts/e225d8fd.html</id>
    <published>2020-11-08T14:58:07.000Z</published>
    <updated>2021-12-18T11:54:13.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　最近做项目需要用到 Mapbox 这个地图可视化框架，以前也没用过，甲方有自己的地图数据，所以得结合 GeoServer 发布一下，简单记录一下流程。</p><span id="more"></span><h2 id="发布篇">发布篇</h2><h3 id="环境准备">环境准备</h3><p>　　下载 <a href="http://geoserver.org/release/maintain/">GeoServer</a> 以及同页面下的 <a href="http://sourceforge.net/projects/geoserver/files/GeoServer/2.16.5/extensions/geoserver-2.16.5-vectortiles-plugin.zip">Vector Tiles</a> 插件，将插件中所有 jar 包都复制到 GeoServer 中<code>webapps\geoserver\WEB-INF\lib</code>目录下。在 bin 下执行 startup.bat 启动 geoserver，若需要修改端口，可修改 <code>start.ini</code> 文件中的<code>jetty.port=8080</code>，在浏览器中输入 <code>http://localhost:8080/geoserver/web/</code>，geoserver 中默认账号为<code>admin</code>，密码为<code>geoserver</code>，geoserver 中常用的两个坐标系为 <code>EPSG:4326</code>：wgs84坐标，Mercator 投影，<code>EPSG:900913</code>：wgs84 坐标，Web Mercator 投影，即保证投影为正方形，MapBox 中必须使用<code>EPSG:900913</code>坐标系统，900913 和 3857 是一样的坐标系统，在 PostGIS 中对应的 SRID 是 3857。</p><h3 id="设置-tile-caching">设置 Tile Caching</h3><p>　　Tile Layers 中可进行图层和图层组的预览，以及切片，在 seed/truncate 中可以设置切片类型以及自动将切片保存到 <code>\data_dir\gwc</code> 目录中。</p><p>　　Caching Defaults 需要勾选 Enable TMS Service，以及在 Default Tile Image Formats for:中勾选 <code>application/vnd.mapbox-vector-tile</code>，其它默认即可。</p><p>Gridsets 设置新的坐标系统。</p><h3 id="地图发布">地图发布</h3><p>在 数据 栏下：</p><ol type="1"><li>点击工作区，添加新的工作区，命名以及填写 URI，勾选默认工作区。</li><li>点击数据存储，添加新的数据存储，选择数据源，以 Directory of spatial files (shapefiles) 为例，在连接参数下点击 浏览，选择shape文件存放目录，DBF 文件字符集选择 UTF-8 或 GBK。注： shape 文件名中不能有中文。</li><li>点击图层，添加新的资源，添加图层，选择上一步的添加的数据存储名称，点击发布或再次发布，进入发布配置界面，勾选 广告则会在 Layer Preview 中显示，一般不需要勾选，点击<code>Compute from native bounds</code>，GeoServer 会自动计算边框和经纬度信息，然后勾选<code>Linear geometries can contain cicular arcs</code>，使线性几何图形包含环形弧，然后保存。重复当前步骤，直到数据存储中所有图层都发布完毕。</li><li>点击图层组，添加新的图层组，添加图层，然后点击 生成边界，保存，即完成整个地图的发布。</li></ol><p>在 Layer Preview 中点击 openLayers 进行地图预览，随意点击地图，若出现乱码，则需要在数据存储中修改 DBF 文件字符集。</p><h3 id="mapbox-访问-geoserver-地图">Mapbox 访问 GeoServer 地图</h3><p>　　点击 Geoserver 的<code>logo</code>，然后点击 <code>TMS</code> 1.0.0协议，页面跳转后，查找需要访问的外部地址，即对应 TileMap 的 href 属性。MapBox 中访问发布好的切片服务需要在 <code>http://localhost:8080/geoserver/gwc/service/tms/1.0.0/MapBoxTest:Test@EPSG:900913@pbf/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf</code>，即 href 属性值后面加上 <code>/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf</code> ，同时注意 在 MapBox style 下 layers 中 <code>source-layer</code> 的值必须为图层名，这里为 <code>"Test"</code> （若使用图层组，则需要找到 Test 图层组下面的图层，使用对应图层名）。简单示例代码如下：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="TYPESCRIPT"><figure class="highlight hljs typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStyle: mapboxgl.Style = &#123;</span><br><span class="line">  <span class="attr">version</span>: <span class="number">8</span>,</span><br><span class="line">  <span class="attr">sources</span>: &#123;</span><br><span class="line">    <span class="attr">geoserverData</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;vector&#x27;</span>,</span><br><span class="line">      <span class="attr">scheme</span>: <span class="string">&#x27;tms&#x27;</span>,</span><br><span class="line">      <span class="attr">tiles</span>: [<span class="string">&quot;http://localhost:8080/geoserver/gwc/service/tms/1.0.0/MapBoxTest:Test@EPSG:900913@pbf/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 OSM 数据源作为底图</span></span><br><span class="line">    <span class="comment">// OsmTiles: &#123;</span></span><br><span class="line">    <span class="comment">//     type: &quot;raster&quot;,</span></span><br><span class="line">    <span class="comment">//     tiles: [&quot;http://a.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&quot;],</span></span><br><span class="line">    <span class="comment">//     tileSize: 256,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="attr">layers</span>: [</span><br><span class="line">    <span class="comment">// 背景图层</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;background&#x27;</span>,</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;background&#x27;</span>,</span><br><span class="line">      <span class="attr">paint</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;background-color&#x27;</span>: <span class="string">&quot;rgb(0, 0, 0)&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// interactive: true,</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     id: &quot;OsmTiles&quot;,</span></span><br><span class="line">    <span class="comment">//     type: &quot;raster&quot;,</span></span><br><span class="line">    <span class="comment">//     source: &quot;OsmTiles&quot;,</span></span><br><span class="line">    <span class="comment">//     &quot;source-layer&quot;: &quot;osmtiles&quot;,</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 道路</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;road&#x27;</span>,</span><br><span class="line">      <span class="attr">source</span>: <span class="string">&#x27;geoserverData&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;source-layer&#x27;</span>: <span class="string">&#x27;Test&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">      <span class="attr">layout</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;line-cap&#x27;</span>: <span class="string">&#x27;round&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;line-join&#x27;</span>: <span class="string">&#x27;round&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">paint</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;line-width&#x27;</span>: &#123;</span><br><span class="line">          <span class="attr">base</span>: <span class="number">1.5</span>,</span><br><span class="line">          <span class="attr">stops</span>: [</span><br><span class="line">            [<span class="number">5</span>, <span class="number">0.75</span>],</span><br><span class="line">            [<span class="number">18</span>, <span class="number">32</span>],</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;line-color&#x27;</span>: <span class="string">&#x27;rgb(255, 255, 255)&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      <span class="attr">interactive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 地图标注</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;label&#x27;</span>,</span><br><span class="line">      <span class="attr">source</span>: <span class="string">&#x27;geoserverData&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;source-layer&#x27;</span>: <span class="string">&#x27;Test&#x27;</span>,</span><br><span class="line"></span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;symbol&#x27;</span>,</span><br><span class="line">      <span class="attr">layout</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;text-size&#x27;</span>: &#123;</span><br><span class="line">          <span class="attr">base</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">stops</span>: [</span><br><span class="line">            [<span class="number">9</span>, <span class="number">10</span>],</span><br><span class="line">            [<span class="number">20</span>, <span class="number">16</span>],</span><br><span class="line">          ],</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;text-max-angle&#x27;</span>: <span class="number">30</span>,</span><br><span class="line">        <span class="string">&#x27;symbol-spacing&#x27;</span>: <span class="number">250</span>,</span><br><span class="line">        <span class="string">&#x27;text-font&#x27;</span>: [<span class="string">&#x27;Microsoft YaHei&#x27;</span>], <span class="comment">// 标注使用字体</span></span><br><span class="line">        <span class="string">&#x27;symbol-placement&#x27;</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-padding&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;text-rotation-alignment&#x27;</span>: <span class="string">&#x27;map&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-pitch-alignment&#x27;</span>: <span class="string">&#x27;viewport&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-field&#x27;</span>: <span class="string">&#x27;&#123;name&#125;&#x27;</span>, <span class="comment">// 标注显示属性名</span></span><br><span class="line">        <span class="string">&#x27;text-letter-spacing&#x27;</span>: <span class="number">0.01</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">paint</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;text-color&#x27;</span>: <span class="string">&#x27;hsl(0, 0%, 0%)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-halo-color&#x27;</span>: <span class="string">&#x27;hsla(0, 0%, 100%, 0.75)&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;text-halo-width&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;text-halo-blur&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">interactive</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: <span class="string">&quot;map-container&quot;</span>, <span class="comment">// html container id</span></span><br><span class="line">  <span class="comment">// style: &quot;mapbox://styles/mapbox/outdoors-v11&quot;, //hosted style id</span></span><br><span class="line">  <span class="attr">style</span>: mapStyle,</span><br><span class="line">  <span class="attr">center</span>: [<span class="number">0</span>, <span class="number">0</span>], <span class="comment">// starting position [经度, 纬度]</span></span><br><span class="line">  <span class="attr">zoom</span>: <span class="number">1</span>, <span class="comment">// starting zoom</span></span><br><span class="line">  <span class="attr">antialias</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// maxZoom: 24,</span></span><br><span class="line">  <span class="comment">// minZoom: 1,</span></span><br><span class="line">  <span class="comment">// pitch: 0,</span></span><br><span class="line">  <span class="comment">// maxPitch: 60,</span></span><br><span class="line">  <span class="comment">// // minPitch: 0,</span></span><br><span class="line">  <span class="attr">crossSourceCollisions</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div><h3 id="geoserver-跨域问题">GeoServer 跨域问题</h3><p>　　将 lib 目录中的 jetty-servlets 和 jetty-util 两个 jar 包复制到<code>\webapps\geoserver\WEB-INF\lib</code>目录下，将<code>\webapps\geoserver\WEB-INF\web.xml</code>文件中两个 <code>&lt;!-- Uncomment following filter to enable CORS</code> 注释取消，重启 GeoSever。</p><h2 id="后记">后记</h2><p>　　Mapbox 显示的地图可以自定义样式，而且加载速度渲染性能方面也都还可以，最重要的是由于采用前端渲染矢量，所以没有传统瓦片那种缩放模糊的感觉，这点非常好，本来想总结一篇简单的 Mapbox 使用手册，但没时间整理了，还是算了 😅。</p><h2 id="参考资料">参考资料</h2><p><a href="https://www.dazhuanlan.com/2019/10/01/5d92e1fa6d695/">基于geoserver+mapbox的定制化离线地图技术方案</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　最近做项目需要用到 Mapbox 这个地图可视化框架，以前也没用过，甲方有自己的地图数据，所以得结合 GeoServer 发布一下，简单记录一下流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="mapbox" scheme="http://cniter.github.io/tags/mapbox/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用小结</title>
    <link href="http://cniter.github.io/posts/3d8ab974.html"/>
    <id>http://cniter.github.io/posts/3d8ab974.html</id>
    <published>2020-11-01T12:58:09.000Z</published>
    <updated>2021-12-18T11:54:13.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　最近由于项目部署需要，简单学习了 docker 的使用和回顾下 CentOS 中的常用操作。</p><span id="more"></span><h2 id="docker-篇">Docker 篇</h2><p>　　由于 Shaun 此次需要安装的环境有点偏门，没找到有完全符合要求的镜像，同时也趁着这次机会学一下 docker，所以就还是直接从最开始的装起了。</p><p>　　首先使用 <code>docker pull centos:7</code> 拉取 CentOS7 的系统镜像，使用 <code>docker images</code> 查看已有的本地镜像信息，使用 <code>docker ps -a</code> 查看当前已有的容器信息，去掉参数 a ，即显示正运行的容器，<code>docker stop [container id | name]</code> 可关闭指定容器，<code>docker start [container id | name]</code> 可打开指定容器，<code>docker rm [container id | name]</code> 可删除指定容器，<code>docker rmi [image id | name]</code> 可删除指定镜像，再删除镜像之前需要先删除依赖该镜像的所有容器。</p><p>　　使用 <code>docker run -dit -p 80:80 -p 8080:8080 --name CentOS7 centos:7 bash</code> 开启一个新的容器，其中参数的意义为： <strong>-i</strong>: 交互式操作；<strong>-t</strong>: 终端；<strong>-d</strong>: 后台启动；<strong>-p</strong>: 设置主机的端口映射到容器内的端口；<strong>-name</strong>: 指定容器名称；最后的 bash 代表使用 bash 终端。<em>在 windows 中直接使用 docker run 运行镜像时会出现 the input device is not a TTY. If you are using mintty, try prefixing the command with 'winpty' 的错误，前面加上 winpty 即可，即 <code>winpty docker run ...</code></em>。当没有参数 d 时，则直接进入容器，而当存在参数 d 时，由于容器实在后台启动，进入容器时需要执行 <code>docker exec -it [container id | name]  bash</code> 才能进入容器，而退出容器可以输入 <code>exit</code> 命令。</p><p>　　而为了在容器中可以开启后台服务，需要在开启容器时就进行提权，在 Windows 中提权命令为 <code>docker run -dit --privileged=true --name CentOS7 centos:7 init</code>；而在 Linux 中提权命令为 <code>docker run -dit --privileged=true --name CentOS7 centos:7 /usr/sbin/init</code>。</p><p>　　在新开启的容器中添加数据和相应的环境之后，即可使用 <code>docker commit CentOS7 new_image:tag</code> 生成一个新的镜像（生成镜像之前最好关闭容器），该镜像包含已经安装的环境和数据，再使用 <code>docker save -o centos7.tar new_image:tag</code>，可将生成的镜像导出成 tar 包，在其他机器中使用 <code>docker load -i centos7.tar</code> 即可导入该 tar 包，并生成相应的镜像， 从而简单便捷的完成环境和数据迁移部署任务。</p><p>　　容器有时需要和主机之间传输文件，有两种方案，一种是直接采用共享文件夹的方式，设置某个目录为两系统的共享目录，从而实现文件传输；另一种是使用 docker cp 命令，使用 <code>docker cp src_path container:dst_path</code> 将主机的文件拷贝到容器中；使用 <code>docker cp container:src_path dst_path</code> 将容器的文件拷贝到主机中。</p><h2 id="centos-篇">CentOS 篇</h2><h3 id="安装postgresql12">安装PostgreSQL12</h3><p><a href="https://www.cnblogs.com/zhi-leaf/p/11432054.html">CentOS安装PostgreSQL</a></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Install the repository RPM:</span></span><br><span class="line">yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Install PostgreSQL:</span></span><br><span class="line">yum install -y postgresql12-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Optionally initialize the database and <span class="built_in">enable</span> automatic start:</span></span><br><span class="line">/usr/pgsql-12/bin/postgresql-12-setup initdb</span><br><span class="line">systemctl enable postgresql-12</span><br><span class="line">systemctl start postgresql-12</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开启远程访问</span></span><br><span class="line">修改/var/lib/pgsql/10/data/postgresql.conf文件，</span><br><span class="line">取消 listen_addresses 的注释，将参数值改为“*”</span><br><span class="line"></span><br><span class="line">修改/var/lib/pgsql/10/data/pg_hba.conf文件，增加下</span><br><span class="line"><span class="meta">#</span><span class="bash"> IPv4 <span class="built_in">local</span> connections:</span></span><br><span class="line">host all all 127.0.0.1/32 md5</span><br><span class="line">host all all 0.0.0.0/0 md5</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 给数据库postgres用户分配密码 1</span></span><br><span class="line">psql -U postgres</span><br><span class="line">alter user postgres with encrypted password &#x27;1&#x27;;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">systemctl restart postgresql-12</span><br></pre></td></tr></table></figure></div><p>由于需要切换账户，所以最好在第一步安装完之后就使用 <code>passwd [username] XXXXXX</code> 设置 root 和 postgres 两个账户的密码。</p><h3 id="安装postgis">安装postgis</h3><p>（https://yum.postgresql.org/12/redhat/rhel-7-x86_64/repoview/）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解决依赖</span></span><br><span class="line">yum install epel-release </span><br><span class="line"></span><br><span class="line">yum install -y https://yum.postgresql.org/12/redhat/rhel-7-x86_64/postgis30_12-3.0.2-2.rhel7.x86_64.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装pgrouting</span> </span><br><span class="line">yum install -y https://yum.postgresql.org/12/redhat/rhel-7-x86_64/pgrouting_12-3.0.2-1.rhel7.x86_64.rpm</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ogr_fdw</span> </span><br><span class="line">yum search ogr_fdw # 查询</span><br><span class="line">yum install ogr_fdw # 安装</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>postgres 移除扩展 <code>drop extension postgis cascade;</code>。</p><h3 id="安装java">安装Java</h3><p>（https://www.cnblogs.com/bcomll/p/12142747.html）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜素java</span></span><br><span class="line">yum search java | grep -i --color JDK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">yum install java-11-openjdk</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入内容</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.8.10-0.el7_8.x86_64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/dt.jar:$JAVA_HOME/lib/tool.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启环境</span></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></div><h3 id="安装geoserver">安装GeoServer</h3><p>（https://blog.csdn.net/weixin_34205076/article/details/88734828）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">mv /tmp/geoserver-2.13.2 /usr/share/geoserver</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 添加环境变量</span></span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 追加</span></span><br><span class="line">export GEOSERVER_HOME=/usr/share/geoserver</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新加载/etc/profile文件</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 授权</span></span><br><span class="line">chown -R root:root /usr/share/geoserver</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 改造启动脚本</span></span></span><br><span class="line">vim /usr/share/geoserver/bin/startup.sh</span><br><span class="line">     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 在最上面引入环境变量</span></span><br><span class="line">source /etc/profile</span><br><span class="line">     </span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后执行改为nohup，并将日志输入到 var/<span class="built_in">log</span>/geoserver.log</span></span><br><span class="line">nohup &quot;$_RUNJAVA&quot; $JAVA_OPTS $MARLIN_ENABLER -DGEOSERVER_DATA_DIR=&quot;$GEOSERVER_DATA_DIR&quot; -Djava.awt.headless=true -DSTOP.PORT=8079 -DSTOP.KEY=geoserver -jar start.jar 1&gt;/dev/null 2&gt;/var/log/geoserver.log &amp;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 修改停止脚本</span></span></span><br><span class="line">vim /usr/share/geoserver/bin/shutdown.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在最上面引入环境变量</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### 创建服务</span></span></span><br><span class="line">vim /lib/systemd/system/geoserver.service  </span><br><span class="line">     </span><br><span class="line">[Unit]</span><br><span class="line">Description=geoserver service</span><br><span class="line">After=network.target</span><br><span class="line">     </span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">LimitNOFILE=65536</span><br><span class="line">ExecStart=/usr/share/geoserver/bin/startup.sh</span><br><span class="line">ExecReload=</span><br><span class="line">ExecStop=/usr/share/geoserver/bin/shutdown.sh</span><br><span class="line">Restart=on-abort</span><br><span class="line">     </span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开机自启</span></span></span><br><span class="line">systemctl enable geoserver</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开启服务</span></span></span><br><span class="line">systemctl start geoserver</span><br></pre></td></tr></table></figure></div><h3 id="安装-nginx">安装 nginx</h3><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx # 下载并安装nginx</span><br><span class="line"></span><br><span class="line">systemctl start nginx # 启动nginx服务</span><br></pre></td></tr></table></figure></div><p>　　在 /etc/nginx 下可修改 nginx.config 文件，监听端口默认是 80，直接输入本地地址可能并打不开网页，因为直接这样安装的 nginx 的可能“有毒”，在 /usr/share/nginx/html 目录中 index.html 可能并不是一个 html 文件，而只是快捷方式，需要从别的地方拷贝一个真正的 index.html 文件替换该文件才可正常打开网页。</p><h3 id="安装-nodejs">安装 nodejs</h3><p>（https://github.com/nodesource/distributions）</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="SHELL"><figure class="highlight hljs shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://rpm.nodesource.com/setup_10.x | bash -</span><br><span class="line"></span><br><span class="line">yum install -y nodejs</span><br></pre></td></tr></table></figure></div><h2 id="vscode-远程篇">VSCode 远程篇</h2><p>　　需要安装 VSCode 远程开发插件 https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack，包括（Remote - WSL，Remote - Containers，Remote - SSH）。</p><p>在远程资源资源管理器中 切换到 SSH Targes 标签，点击设置设置，在 C:/Users/用户名/.ssh/config 中输入</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="false"data-lang="PLAINTEXT"><figure class="highlight hljs plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host [随便写]</span><br><span class="line">  HostName remote-ip 或 域名</span><br><span class="line">  User 远程服务器用户名</span><br></pre></td></tr></table></figure></div><p>　　配置SSH，通过命令 <code>ssh-keygen -t rsa -b 4096</code> 生成密钥对（在 C:/Users/用户名/.ssh/ 目录中），将公钥内容拷贝到远程服务器<code>/root/.ssh/authorized_keys</code> 中，修改配置文件 <code>/etc/ssh/sshd_config</code>，取消 <code>#PubkeyAuthentication yes</code> 注释，允许使用基于密钥认证的方式登录。重启 sshd 服务 <code>systemctl restart sshd</code>。<em>通过 VSCode ssh 远程连接在结束之后最好将终端全部删除，尤其是最开始的那个 install server 终端。</em></p><p>　　设置好SSH之后，通过在 VSCode 中设置 <code>"docker.host":"ssh://your-remote-user@your-remote-machine-fqdn-or-ip-here"</code>，可以直接连接在远程服务器上的 docker。<strong>该设置最好用于 工作区设置，而不是 用户设置。</strong></p><p>　　VSCode 远程连接 SSH 有时可能会出现无法连接，一直尝试连接的现象，这时需要粗暴的删除 ~/.vscode-server 目录，重新进行连接，不行的话就只能参考: https://stackoverflow.com/questions/56718453/using-remote-ssh-in-vscode-on-a-target-machine-that-only-allows-inbound-ssh-co，先关闭远程服务器上已存在的所有 vscode-server 进程，通过 <code>https://update.code.visualstudio.com/commit:$COMMIT_ID/server-linux-x64/stable</code> 下载 tar 包，使用 <code>tar -xvzf vscode-server-linux-x64.tar.gz --strip-components 1</code> 后再重新连接。</p><h2 id="后记">后记</h2><p>　　据查 docker 依然存在很多缺点，尤其是守护进程，Shaun 这两天在 Windows 中使用 Docker 也时不时的出现 docker 卡死的问题，需要重启 docker 服务， 以后有机会还是使用 Podman 吧。RedHat 系的 yum 也快退休了，以后再需要安装软件可能就直接上毒奶粉（bushi）dnf 了。VSCode 远程开发是真的舒服，文件无缝传输，任意修改，可以尽情享受现代编辑器的方便。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　最近由于项目部署需要，简单学习了 docker 的使用和回顾下 CentOS 中的常用操作。&lt;/p&gt;</summary>
    
    
    
    <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
    <category term="note" scheme="http://cniter.github.io/tags/note/"/>
    
    <category term="container" scheme="http://cniter.github.io/tags/container/"/>
    
    <category term="unix-like" scheme="http://cniter.github.io/tags/unix-like/"/>
    
  </entry>
  
  <entry>
    <title>空间中三角形与三角形相交</title>
    <link href="http://cniter.github.io/posts/6694a214.html"/>
    <id>http://cniter.github.io/posts/6694a214.html</id>
    <published>2020-10-18T15:36:15.000Z</published>
    <updated>2021-12-18T11:54:13.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　一种快速判断空间中三角形与三角形相交的方法，出自论文：<em>Tomas Moller. A Fast Triangle-Triangle Intersection Test. Journal of Graphics Tools, 1997, 2(2):25-30.</em> ，与「快速判断三角形与长方体相交」中那篇论文的作者是同一个人。</p><span id="more"></span><h2 id="相交篇">相交篇</h2><p>　　该论文的理论基础部分来自分离轴理论，论文中三角形与三角形的相交测试主要可分为 3 类：1、沿三角形所在平面法线方向的相交测试；2、沿三角形所在两平面交线方向的相交测试；3、共面时的相交测试。下面来逐步分析这些相交测试。</p><h3 id="沿法线方向相交">沿法线方向相交</h3><p>　　沿法线相交很简单，直接使用分离轴理论分别判断两三角形在对应两条法线上的投影是否相交，若存在一条法线使投影不相交，则可直接判定两三角形不相交，若投影都相交，则存在两种情况，一种是两三角形共面，一种是两三角形相互跨立，判断这两种情况的依据为计算两段投影之间的距离，具体计算方法为：计算三角形 B 上三个点到三角形 A 所在平面的距离，距离计算的方法可参考「<a href="https://cniter.github.io/posts/5315fcfd.html#%E7%82%B9%E5%88%B0%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB">计算几何基础—点到平面的距离</a>」，此距离同时需要保留方向，若三个点的距离都为 0，则两三角形共面；若三个距离都同号，则说明投影不相交，即两三角形不相交；若三个距离存在异号现象，则 B 跨立 A。</p><h3 id="沿交线方向相交">沿交线方向相交</h3><p>　　若两三角形相互跨立，则需要判断两三角形是否在两三角形所在平面交线上存在相交。由于两三角形相互跨立，则两三角形必然都与交线相交，则需要分别计算两三角形与交线的交点，根据交点判断两交线段是否相交，若相交，则可直接判定两三角形相交，若不相交，则同样可直接判定两三角形不相交。</p><p>　　问题的关键现在在于求取两交线段，比较粗暴的方式为：先求出两平面的交线，交线的方向向量为两三角形所在平面法向量的的叉积，交线上的一点通过联立两平面方程进行求取，由于是两个方程求 3 个未知数（x，y，z），所以理论上有无数个解，令交线方向向量绝对值最大的分量对应的未知数为 0，消除一个未知数，还剩两个，可得唯一解，即可求出交线上一点，亦可得到直线参数方程，求两交线段相当于求四个交点，根据直线与线段相交可得到交点，进而得到交线段。</p><p>论文中的方法为：求出交线的方向向量 D 后，设 O 为交线上任意一点（<em>不需要求</em>），则交线方程为 <span class="math inline">\(L= O+tD\)</span>，此时求交线段只需要求出 4 个 t。先求交线与三角形 A 的交线段，设三角形 A（V0，V1，V2）三个顶点到三角形 B 所在平面的距离分别为 <span class="math inline">\(d_0,d_1,d_2\)</span>，设 <span class="math inline">\(d_1\)</span> 与其它两个距离异号，则交线分别与 V0V1 和 V2V1 相交，先求与 V0V1 相交时的 t1，设三角形 B 所在的平面为平面 B，V0 和 V1 在平面 B 上的投影分别为为 K0 和 K1，V0 和 V1 在交线上的投影分别为为 P0 和 P1，交线与 V0V1 的交点为 C1，设 <span class="math inline">\(P0=O+p_0D,P1=O+p_1D,C1=O+t_1D\)</span>，则 <span class="math inline">\(p_0=(V0-O)·D,p_1=(V1-O)·D\)</span>，由论文中图二可知，有两组三角形相似，分别为 V0C1K0和V1C1K1 相似，以及 V0C1P0和V1C1P1 相似，所以 <span class="math display">\[\frac{V0K0}{V1K1} = \frac{V0C1}{V1C1} = \frac{C1P0}{C1P1} \Rightarrow \frac{d_0}{d_1} = \frac{p_0-t_1}{p1-t_1} \Rightarrow t_1 = \frac{d_0p_1-d_1p_0}{d_0-d_1}\]</span> 若点 O 为原点在交线上的投影，则 <span class="math inline">\((V0-O)·D=V0·D=p_0, 　p_1=V1·D\)</span>，若将交线投影到交线方向向量绝对值最大的分量对应的坐标轴上，在该投影交线上进行相交测试与在原交线上进行相交测试是等效的，所以此时 <span class="math inline">\(p_0,p_1\)</span> 即为 V0 和 V1 上对应坐标轴的分量。同理可求出 t2，t3 ，t4，两交线段为 t1t2 和 t3t4。</p><h3 id="共面相交">共面相交</h3><p>　　判断共面相交，相当于判断 2 维中两三角形是否相交，先将三角形投影到 XOY，XOZ，YOZ 平面中投影面积最大的平面（为避免计算面积，可直接令三角形顶点坐标中对应法向向量中绝对值最大的分量为 0，即若法向向量中绝对值最大的分量为 y，则将三角形投影到 XOZ 平面），判断投影后的两三角形是否相交即可，因为此时的两三角形相交，当且仅当其投影三角形相交。2 维中两三角形是否相交，论文中方法是先判断两三角形的边是否相交，即相当于判断 9 组线段是否相交，若存在一组相交，则两三角形相交，若都不相交，则需要判断其中一个三角形是否被另一个三角形包含，具体判断方式取三角形 A 中一顶点，若该顶点在三角形 B 内（判断 2 维中点在多边形内的方法同样可参考「计算几何基础」），则说明三角形 A 在 B 内，同样也需要判断 B 是否在 A 内，若都不在，则两三角形不相交，否则两三角形相交。当然，也可以直接通过分离轴理论来判断两三角形是否相交，毕竟，这就是在 2 维中，而且三角形算是天然的凸多边形。</p><h2 id="后记">后记</h2><p>　　三角形是图形学中组成面的基本单元，图形学中面与面的碰撞检测都可以很粗暴的用三角形相交来实现，只不过直接一个个判断效率有点低就是了，所以一般会借助一些基于的树和包围盒空间加速结构，或者针对某种形状的特殊方法，这又是新的方法系列了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　一种快速判断空间中三角形与三角形相交的方法，出自论文：&lt;em&gt;Tomas Moller. A Fast Triangle-Triangle Intersection Test. Journal of Graphics Tools, 1997, 2(2):25-30.&lt;/em&gt; ，与「快速判断三角形与长方体相交」中那篇论文的作者是同一个人。&lt;/p&gt;</summary>
    
    
    
    <category term="Image&amp;Graphic" scheme="http://cniter.github.io/categories/Image-Graphic/"/>
    
    
    <category term="algorithm" scheme="http://cniter.github.io/tags/algorithm/"/>
    
    <category term="geometry" scheme="http://cniter.github.io/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title>计算几何基础</title>
    <link href="http://cniter.github.io/posts/5315fcfd.html"/>
    <id>http://cniter.github.io/posts/5315fcfd.html</id>
    <published>2020-08-22T00:42:39.000Z</published>
    <updated>2021-12-18T11:54:13.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　由于本篇主要是谈谈基础，所以一些快速运算方法一般不在本篇探讨范围之内，一些特殊的快速手法等后续专门独立开篇再谈。</p><span id="more"></span><h2 id="基础篇">基础篇</h2><p><strong>解线性方程组：</strong>令 <span class="math inline">\(A\)</span> 为 <span class="math inline">\(n×n\)</span> 的矩阵，<span class="math inline">\(α\)</span> 和 <span class="math inline">\(β\)</span> 为 n 维的列向量，设 <span class="math inline">\(A = \begin{bmatrix} \alpha_1 &amp; \alpha_2 &amp; \alpha_3 &amp; ... &amp; \alpha_n \end{bmatrix}\)</span>，对于线性方程组 <span class="math inline">\(Ax = β\)</span>，初等数学中最常规的就是消元法了，但在线性代数中，有两种解法，一种是等式两边同乘 <span class="math inline">\(A\)</span> 的逆阵，得到 <span class="math inline">\(x = A^{-1}β\)</span>；另一种是克莱姆法则，可得 <span class="math inline">\(x_i = |A_i| / |A|\)</span>，其中 <span class="math inline">\(|A|\)</span> 为 矩阵 <span class="math inline">\(A\)</span> 对应的行列式， <span class="math inline">\(|A_i|\)</span> 为将矩阵 <span class="math inline">\(A\)</span> 中第 <span class="math inline">\(i\)</span> 列换成 <span class="math inline">\(β\)</span> 后对应的行列式，如 <span class="math inline">\(x_3 = \left| \begin{array}{cccc} \alpha_1 &amp; \alpha_2 &amp; \beta &amp; ... &amp; \alpha_n \end{array} \right| / |A|\)</span>。</p><p><strong>向量内积：</strong>又称向量点积，向量点乘。设 a，b 为空间中两个 n 维向量 <span class="math inline">\(a=(x_1,x_2,x_3,...,x_n)\)</span>，<span class="math inline">\(b=(y_1,y_2,y_3,...,y_n)\)</span>，则 <span class="math inline">\(a·b=|a|*|b|*cos(α)=\sum\limits_{i=1}^{n}x_iy_i\)</span>，其中<span class="math inline">\(|a|= \sqrt{(x_1)^2+(x_2)^2+(x_3)^2+...+(x_n)^2},\alpha\)</span> 为两向量之间夹角。向量内积一般用来计算投影（令 <span class="math inline">\(|b|=1\)</span>，则 <span class="math inline">\(a \cdot b=|a|cos(α)\)</span>，即为向量 a 在 b 上的投影），和两向量之间角度。</p><p><strong>向量外积：</strong>又称向量叉积，向量叉乘，<span class="math inline">\(|a×b|=||a|*|b|*sin(\alpha)|\)</span>。向量外积一般只针对二维向量和三维向量，对于二维向量，<span class="math inline">\(a×b=a.x*b.y-b.x*a.y\)</span>，可以认为是一个值（其实也是一个向量），对于三维向量 <span class="math inline">\(a×b=(a.y*b.z-b.y*a.z, a.x*b.z-b.x*a.z, a.x*b.y-b.x*a.y)\)</span>，是一个向量，且该向量一定垂直于 a，b 两向量构成的平面，所以三维向量的外积一般可以用来计算平面的法向量。向量外积的几何意义为两向量构成平行四边形的面积，二维向量外积直接取绝对值即为面积，不取绝对值则可以用来判断两向量构成三角形的点是以顺时针排列（小于 0）的还是逆时针排列（大于 0）的，三维向量外积取所得向量的模即为面积。</p><p><strong>向量混合积：</strong> 设 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span> 为空间中三个向量，则其混合积 <span class="math inline">\((a,b,c)= (a×b)·c = -(c×b)·a = -(a×c)·b\)</span>，<span class="math inline">\((a,b,c) = (b,c,a) = (c,a,b)\)</span>。若 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span> 都为 3 维的向量，矩阵 <span class="math inline">\(A = [a, b, c]\)</span>，则 <span class="math inline">\(|A| = (a, b, c)\)</span> ，其中 <span class="math inline">\(a,b,c\)</span> 是列向量或行向量都可以，因为 <span class="math inline">\(|A| = |A^T|\)</span>，该混合积的几何意义为这三个向量组成的平行六面体的体积。</p><p><strong>直线参数方程：</strong>设 P 为直线上任意一点，若 P1 和 P2 为直线上已知两点，则 <span class="math inline">\(P=P1 + (P2-P1)*t, t\in[-∞,+∞]\)</span>。当然直线的参数方程有很多种形式，之所以用两点式，是因为两点式除了能表示直线，同样能表示射线（<span class="math inline">\(t\ge 0\)</span>），也能表示线段（<span class="math inline">\(0\le t\le 1\)</span>）。</p><p><strong>平面方程：</strong>设 P 为平面上任意一点，O 为平面上已知一点，n 为平面法向量，则平面方程为：<span class="math inline">\((P-O)·n=0\)</span> 。</p><p><strong>三角形内的点：</strong>设 P0，P1，P2 为三角形 3 个顶点，若 P 为三角形内一点，同时可认为 (P1-P0) 和 (P2-P0) 为一组基向量，则 P 满足 <span class="math inline">\(P=P0+u*(P1-P0)+v*(P2-P0),u \in [0,1],v \in [0,1],u+v\le 1\)</span>。</p><h2 id="距离篇">距离篇</h2><p>　　一般的距离计算都是向量计算，要么点乘，要么叉乘。</p><h3 id="点到直线的距离">点到直线的距离</h3><p>　　计算点到直线的距离通用的解法是使用向量叉乘，设 P 为直线外一点，Q1 和 Q2 为直线上两点，则可得到两向量 <span class="math inline">\(a=P-Q1, b=Q2-Q1\)</span>，则 P 到直线的距离为 <span class="math inline">\(d=|a×b|/|b|\)</span>，叉乘是面积，而面积又等于底乘高，<span class="math inline">\(|b|\)</span> 为底，<span class="math inline">\(d\)</span> 为高。当然点到直线的距离还有其他的一些方法，如 利用公式，利用点积再使用勾股定理，直接利用点积计算直线法向量上的投影等，这些方法都有一定的局限性。</p><h3 id="点到线段的距离">点到线段的距离</h3><p>　　设 d 为点 P 到线段的距离，表示为点 P 到线段上最近点的距离，设 P1，P2 分别为线段两端点，计算 <span class="math inline">\(a=(P-P1)·(P2-P1) / |P2-P1|\)</span>，若 <span class="math inline">\(0≤a≤1\)</span>，则 d 为点 P 到线段所在直线的距离，若 <span class="math inline">\(a&lt;0\)</span>，则 d 为点 P 到点 P1 的距离，若 <span class="math inline">\(a&gt;1\)</span>，则 d 为点 P 到点 P2 的距离。</p><h3 id="三维中点到三角形的距离">三维中点到三角形的距离</h3><p>　　先计算点 P 到三角形所在平面的投影点 <span class="math inline">\(P&#39;\)</span>，若 <span class="math inline">\(P&#39;\)</span> 在三角形内，则只需要求点 P 到三角形所在平面的距离，否则需要分别求点 P 到三角形三条边的距离（点到线段的距离），取三个距离中最小值即为点到三角形的距离。</p><h3 id="点到平面的距离">点到平面的距离</h3><p>　　直接利用点乘计算，平面外一点与平面内一点构成的向量到平面法向量上的投影，即为点到平面的距离。设 P 为平面外一点，O 为平面内一点，n 为平面法向量，则点 P 到平面的距离为 <span class="math inline">\(d=(P-O) \cdot n\)</span>。</p><h3 id="直线到直线的距离">直线到直线的距离</h3><p>　　设 P1 和 P2 为直线 1 上两点，Q1 和 Q2 为直线 2 上两点，则直线 1 与直线 2 之间的距离计算流程为：</p><ol type="1"><li>先判断两直线是否平行，即 <span class="math inline">\((P2-P1) = k*(Q2-Q1), k \neq 0\)</span> 有解。若平行，则相当于计算点到直线的距离；若不平行，则进行下一步。</li><li>再判断两直线是否共面，即 P1，P2，Q1，Q2 四点共面，先计算 <span class="math inline">\(n=(P2-P1)×(Q2-Q1)\)</span>，再分别计算 <span class="math inline">\(n·(Q1-P1), n·(Q2-P1), n·(Q1-P2), n·(Q2-P2)\)</span>，若这四个值都为 0 ，则两直线共面（之所以需要判断 4 个值，是为防出现 3 点共线情况，当然也可以先判断 3 点共线，再取不共线的一点构成向量与 n 做点积进行判断），若两直线共面，则两直线必然相交；若两直线不共面，则两直线间距离为 <span class="math inline">\(d=(Q1-P1) \cdot n\)</span>。</li></ol><h3 id="直线到平面的距离">直线到平面的距离</h3><p>　　设 P1 和 P2 为直线上两点，n 为平面法向量，则直线与平面之间的距离计算流程为：</p><ol type="1"><li>先判断直线与平面是否平行，即若 <span class="math inline">\((P2-P1) \cdot n = 0\)</span> ，则直线与平面平行，则直线到平面的距离为 点 P1 到平面的距离；</li><li>若直线与平面不平行，则直线与平面必相交。</li></ol><h2 id="相交篇">相交篇</h2><p>　　一般的相交求交点都是联立方程组，但有些只需要做相交测试的，可以利用一些特殊方法快速求出来。有些相交直接求很麻烦或很难，可以反向求不相交的情况，而在实际编程中，一般都有很多条件语句，以便快速返回提高效率。</p><h3 id="直线与直线相交">直线与直线相交</h3><p>　　设直线 1 方程为 <span class="math inline">\(P=P1 + (P2-P1)*t\)</span>，直线 2 方程为 <span class="math inline">\(P=Q1 + (Q2-Q1)*u\)</span>，联立两方程得 <span class="math inline">\(P1 + (P2-P1)*t = Q1 + (Q2-Q1)*u\)</span>，即 <span class="math inline">\(P1-Q1 = (Q2-Q1)*u - (P2-P1)*t\)</span>，设 <span class="math inline">\(v_0=Q2-Q1,v_1=P1-P2,v_2=P1-Q1\)</span>，即 <span class="math inline">\(v_0*u+v_1*t=v_2\)</span>，现在的问题就是解这个方程了，一种是直接把向量分解成单一维度，列方程组；一种是等式两边分别同时点乘 <span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(v_1\)</span>，可得 <span class="math display">\[\begin{cases}     (v_0 \cdot v_0)*u+(v1 \cdot v_0)*t=v_2 \cdot v_0 ,     \\  (v_0 \cdot v_1)*u+(v1 \cdot v_1)*t=v_2 \cdot v_1\end{cases}\]</span> 解得： <span class="math display">\[\begin{cases}     u=((v1·v1)(v2·v0)-(v1·v0)(v2·v1)) / ((v0·v0)(v1·v1) - (v0·v1)(v1·v0)) ,     \\  t = ((v0·v0)(v2·v1)-(v0·v1)(v2·v0)) / ((v0·v0)(v1·v1) - (v0·v1)(v1·v0))\end{cases}\]</span> 若方程有解，则两直线相交，由于两点式方程可以很简单的转换为线段和射线，所以该方法同样可以判断两线段相交，两射线相交，射线与直线与线段相交等。针对二维直线，还有一种解法是将原方程写成矩阵形式，利用克莱姆法则进行求解，不过总的来说，最终的解都是一种形式。</p><h3 id="直线与平面相交">直线与平面相交</h3><p>　　求直线与平面相交，直接联立直线方程和平面方程即可，得 <span class="math inline">\((P1-O+(P2-P1)*t)·n=0\)</span> ，即 <span class="math inline">\(t=(P1-O)·n/((P1-P2)·n)\)</span>。若 t 有解，则直线与平面相交。同样也可以用该方法判断线段或射线与平面相交。</p><h3 id="直线与三角形相交">直线与三角形相交</h3><p>　　二维中判断直线和三角形相交相当于判断直线和线段相交，而在三维中则同样需要联立直线和三角形方程，设直线方程为 <span class="math inline">\(P=P1+(P2-P1)*t\)</span>，三角形方程为 <span class="math inline">\(P=Q1+(Q2-Q1)*u+(Q3-Q1)*v\)</span>， 则联立后方程为 <span class="math inline">\(P1-Q1=(P1-P2)*t+(Q2-Q1)*u+(Q3-Q1)*v\)</span>，令 <span class="math inline">\(V_0=P1-Q1,V_1=P1-P2,V_2=Q2-Q1,V_3=Q3-Q1\)</span>，则 <span class="math inline">\(V_0=V_1*t+V_2*u+V_3*v\)</span>，可以分解向量求解，也可以使用克莱姆法则得： <span class="math display">\[t = \frac{\begin{vmatrix} V_0 &amp; V_2 &amp; V_3 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}}\qquadu = \frac{\begin{vmatrix} V_1 &amp; V_0 &amp; V_3 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}}\qquadv = \frac{\begin{vmatrix} V_1 &amp; V_2 &amp; V_0 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}}\qquad\]</span> 由于三阶行列式也可以用向量混合积来求值，所以 <span class="math display">\[t = \frac{-V_0 × V_3 · V_2 }{V_1 × V_2 · V_3}\qquadu = \frac{V_0 × V_3 · V_1 }{V_1 × V_2 · V_3}\qquadv = \frac{V_1 × V_2 · V_0 }{V_1 × V_2 · V_3}\qquad\]</span> 若方程有解，且满足三角形条件，则相交。</p><h3 id="二维中凸多边形与凸多边形相交">二维中凸多边形与凸多边形相交</h3><p>　　曾在「<a href="https://cniter.github.io/posts/ff29de94.html">快速判断三角形与长方体相交</a>」中写过判断两凸多边形是否相交直接使用分离轴理论（separating axis theorem， AST）即可，简而言之就是，取两多边形任意一条边，计算两多边形在该边法向量上的投影是否相交，若存在一条边，使投影不相交，则两凸多边形不相交。</p><h3 id="二维中点在多边形内">二维中点在多边形内</h3><p>　　判断点在多边形内有很多种方法，利用叉乘，面积等方法虽然思想简单粗暴但一般计算量较大，且有一定的局限性，仅限凸多边形，但有一种相对快速且能应对各种简单多边形的方法——射线法，射线法的本质是判断射线与线段相交，即从已知点处引一条沿 X 轴正向的射线，若射线与多边形边的相交条数为奇数，则该点在多边形内，该法的缺陷在于若点在边上则需要单独判断。判断该射线与多边形的边是否相交也比较简单，设射线起点为 P0，多边形边的两个端点分别为 P1 和 P2，则射线与边相交需满足的条件为：1、<span class="math inline">\(min(P1.y, P2.y)&lt;=P0.y&lt;=max(P1.y, P2.y)\)</span>；2、<span class="math inline">\(P0.x &lt;= (P2.x-P1.x)*(P0.y-P1.y)/(P2.y-P1.y)+P1.x\)</span>。</p><h3 id="圆与三角形相交">圆与三角形相交</h3><p>　　判断圆与三角形相交，即判断圆心到三角形各边的距离是否小于圆的半径，若存在一条边，使圆心到其的距离小于半径，则圆与三角形相交，<em>该距离计算不是点到直线的距离，而是点到线段的距离</em>。</p><h3 id="直线与长方体相交">直线与长方体相交</h3><p>　　判断直线与长方体相交，首先需要将坐标原点平移至长方体中心，再计算过原点且垂直于直线的法向量 n ，随后计算原点到直线的距离 d，若满足 <span class="math inline">\(|d| &lt;= h_x|n_x| + h_y|n_y| + h_z|n_z|\)</span> ，则 直线与长方体相交。法向量 n 的求法为：设 P 为直线上一点，l 为直线方向向量，则 <span class="math inline">\(n=-(P·l)*l+P\)</span>。</p><h3 id="球与-aabb-相交">球与 AABB 相交</h3><p>判断球与 AABB 相交，首先需要将坐标原点平移至球心，设平移后的 AABB 最小顶点为 V1，最大顶点为 V2，球半径为 r。最简单粗暴的当然是若原点不在 AABB 内，则直接求原点到 8 个面的距离，取最小值，若最小值比半径大，则不相交。另一种方法是将这个问题转化为求解不等式，若存在一点 <span class="math inline">\(P(x, y, z)\)</span>，使 P 在球内，同时 P 在 AABB 中，即： <span class="math display">\[\begin{cases}     x^2+y^2+z^2 ≤ r^2 ,     \\  V1.x ≤ x ≤ V2.x ,    \\  V1.y ≤ y ≤ V2.y ,    \\  V1.z ≤ z ≤ V2.z \end{cases}\]</span> 若该不等式有解，则球与 AABB 相交，否则不相交。解该不等式也简单，由于是存在而不是任意，所以只需要求 <span class="math inline">\(min(x^2+y^2+z^2)≤r^2 \Rightarrow min(x^2) + min(y^2)+ min(z^2)≤r^2\)</span>，则若 xyz 分量可以取 0，则对应分量取 0，否则取 <span class="math inline">\(x = min(|V1.x|, |V2.x|), y = min(|V1.y|, |V2.y|),z = min(|V1.z|, |V2.z|)\)</span>，若满足不等式，则相交。</p><p>该方法同样可用来求 OBB 与球相交，只需要先利用坐标系变换将 OBB 转成 AABB。</p><h2 id="反射篇">反射篇</h2><p>　　令入射向量为 <span class="math inline">\(I\)</span>，法向量为 <span class="math inline">\(N\)</span>，反射向量为 <span class="math inline">\(R\)</span>，入射向量与反射向量构成的平面与镜面交线的方向向量为 <span class="math inline">\(T\)</span>，这四个向量都为单位向量。首先以 <span class="math inline">\(I\)</span> 和 <span class="math inline">\(R\)</span> 组成一个菱形，则 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(T\)</span> 则为该菱形对角线的方向向量，若已知 <span class="math inline">\(I\)</span> 和 <span class="math inline">\(R\)</span>，则 <span class="math inline">\(N = (R - I).normalize()\)</span>，<span class="math inline">\(T = (I + R).normalize()\)</span> ，<span class="math inline">\(normalize()\)</span> 指向量归一化；若已知 <span class="math inline">\(I\)</span> 和 <span class="math inline">\(N\)</span>，则 <span class="math inline">\(R = I + 2*|I \cdot N|*N\)</span>，<span class="math inline">\(2*|I \cdot N|*N\)</span> 为菱形 <span class="math inline">\(N\)</span> 方向的对角线向量。</p><p>　　镜面反射公式为 <span class="math inline">\((r&#39;,g&#39;,b&#39;) = (r,g,b) + (1-r,1-g,1-b)*t\)</span>，当 <span class="math inline">\(t\)</span> 越大则越接近白色，表现为越亮；漫反射公式为 <span class="math inline">\((r&#39;,g&#39;,b&#39;) = (r,g,b)*t\)</span>，当 <span class="math inline">\(t\)</span> 越小，则越接近黑色，表现为越暗。 其中 <span class="math inline">\(t\in[0,1]\)</span>，<span class="math inline">\(t\)</span> 为入射向量到平面法向量上的投影，即点积。</p><h2 id="后记">后记</h2><p>　　该篇不出意外的话也会是一个长期支持篇，等以后有碰到其他的一些计算几何知识再持续更新吧。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　由于本篇主要是谈谈基础，所以一些快速运算方法一般不在本篇探讨范围之内，一些特殊的快速手法等后续专门独立开篇再谈。&lt;/p&gt;</summary>
    
    
    
    <category term="Image&amp;Graphic" scheme="http://cniter.github.io/categories/Image-Graphic/"/>
    
    
    <category term="algorithm" scheme="http://cniter.github.io/tags/algorithm/"/>
    
    <category term="geometry" scheme="http://cniter.github.io/tags/geometry/"/>
    
  </entry>
  
  <entry>
    <title>OpenDrive解析小结</title>
    <link href="http://cniter.github.io/posts/b7d79231.html"/>
    <id>http://cniter.github.io/posts/b7d79231.html</id>
    <published>2020-08-09T10:58:09.000Z</published>
    <updated>2021-12-18T11:54:13.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　接触并使用高精地图和 OpenDRIVE 已有一年的时间，简要写写 Shaun 对 OpenDRIVE 的一些认知。</p><span id="more"></span><h2 id="基础篇">基础篇</h2><p>OpenDRIVE 目前最新的版本的 1.6，下面主要结合 1.4，1.5 和1.6 版本一起看。</p><p>　　在 OpenDRIVE 中主要有两种坐标系统，一种是常见的 X/Y/Z 空间坐标系统，另一种是 S/T/H 坐标系统。其中 X/Y/Z 坐标系统常与地理信息的各种坐标系统一起使用，S/T/H 坐标系统是针对 OpenDRIVE 中道路参考线设定的一种局部坐标系统，在 OpenDRIVE 中称前者为 “inertial co-ordinates”，后者为 “track co-ordinates”（1.6 中直接为 Reference Line System）。除此之外，还有个局部坐标系 U/V/Z，该坐标系统系统是相对于 S/T/H 坐标系统平移旋转而来的。</p><p>对于旋转，以逆时针为正，heading 是指绕 z/h 轴旋转，pitch 是指绕 y/t 轴旋转，roll 是指绕 x/s 轴旋转。</p><p>对于曲率，逆时针延申的曲线曲率为正，顺时针延申的曲线曲率为负。</p><p>在 OpenDRIVE 中对于道路和车道的描述，有以下几个重要的概念：</p><ul><li>Reference Line。用来指示一条道路的骨架，是 S/T/H 坐标系统的依据，道路中各车道线需要参考这条线。</li><li>Lanes。用来描述各车道以及各车道所属 Lane Section。</li><li>Lane Offset。其意义在 OpenDRIVE 标准看起来很清除，但实际用起来非常模糊，offset 到底是只能偏移一个车道，或半个车道或多个车道，所属哪个 Lane Section，其意义不明，故下文解析篇将直接忽略该属性。</li><li>Lane Section。可以简单理解为子道路，一个 lane section 中包含多条车道，一条道路包含多个 lane section。一个 lane section 中车道数是一个常数，所以对于存在 m 变 n 车道的一条道路，至少要划分为两个 lane section。</li><li>Superelevation、Crossfall 和 Shape。用来表示路面倾斜程度。Superelevation 是整个路面侧向太高，即路面倾斜程度，<strong>Crossfall 在 1.6 中已被废弃</strong>，原因为 1.6 完善了 Shape，可以完全取代 CrossFall，甚至能做的更好，Shape 主要用来描述路面两侧车道的倾斜程度，通过三次曲线和线性插值可以精确到车道各点倾斜程度。</li><li>Road Linkage。道路之间的连接关系，通过前继（predecessor）和后继（successor）建立道路之间连接关系，若一条路存在多个前继或后继，则其对应前继或后继应该为 Junction ，即目前的标准中暂不支持道路多前后继，1.5 中只支持车道多前后继，道路多前后继依然不支持。</li><li>Junction。交汇处，通俗意义上的路口，主要包含 incomingRoad 和 connectingRoad。</li><li>Junction Group。可以简单理解为交通环岛。</li><li>Neighbors。相邻关系，和 Road Linkage 类似，一个是前后连接关系，一个侧面相邻关系。</li><li>Surface。车道或道路表面材质，有 OpenCRG 则优先使用，没有则由应用程序自定义字符串。</li><li>....... 等等。还有一些冷门的元素暂时没用到，就不介绍了。</li></ul><p>下面就是真正的解析内容了。</p><h2 id="解析篇">解析篇</h2><p>　　一些简单的就不介绍了，就介绍解析时需要注意的一些重点元素。</p><h3 id="road-geometry">Road Geometry</h3><p>　　geometry 信息可以说是 OpenDRIVE 中最重要的信息，没有之一。OpenDRIVE 中最重要的元素为 Road，而 Road 中最重要的是 Reference Line，而 geometry 正是用来描述 Reference Line 几何线条形状的信息。</p><p>　　首先 geometry 标签中共有 5 个属性，分别为 s （该段 geometry 沿参考线起始位置），x（该段 geometry 在 inertial system 下起始横坐标），y（该段 geometry 在 inertial system 下起始纵坐标），hdg（该段 geometry 在 inertial system 下起始弧度），length（该段 geometry 长度）。其次，geometry 共有 5 种线型，分别为 straight lines（直线），spirals（螺线），arcs（圆弧线），cubic polynomials（三次曲线），parametric cubic polynomials（参数化三次曲线），这 5 种线型分别由 geometry 下 5 种标签控制。解析 geometry 的要点在于：<strong>先不用管 geometry 标签中的属性，直接解析对应线型标签，需要满足两点：1、起始点坐标一定为 (0, 0)；2、起始点斜率，即导数也一定为 0。依据这两点正确解析完线型之后，再根据 hdg 旋转线型，根据 (x, y) 将线型平移到正确位置。</strong> 下面就具体看看这 5 种线型：</p><ol type="1"><li>line，直线。没有任何属性，直接根据 geometry 中 (x, y) 和 hdg 就可得到直线方程。</li><li>spiral，螺线。有两个属性 curvStart（起始曲率），curvEnd（结束曲率）。螺线解析的代码已经由 OpenDRIVE 官方直接给出了，里面涉及到的数值计算方法就不详解了，直接看官方提供 API 的输入输出，输入有两个：s（从原点开始，螺线延展的长度），cDot（螺线的曲率关于 s 的一阶导数）；输出有 3 个：x（横坐标），y（纵坐标），t（该点的切线弧度）。解析螺线最大的问题应该就是如何得到这两个输入参数，由螺线的性质可以得到，螺线的曲率一定随着螺线的长度均匀变化的，换句话说，对于一条已知螺线，cDot 一定是常数。则 <span class="math inline">\(cDot = (curvEnd - curvStart) / length\)</span>，其中 length 为 geometry 中的长度属性，下一步需要求出 s，由于已知螺线在原点处的曲率一定为 0，则 (curv - 0) / (s - 0) = cDot，即 s = curv / cDot。由此可得到螺线的各点坐标和切向方向，但由于解析线型需要满足上面说的两点，所以需要将螺线坐标以起始点进行平移和旋转，以满足起始点为原点，起始点切线弧度为 0，最后再将完成平移和旋转后的点根据 geometry 的属性进行旋转和平移以得到真正的坐标点。</li><li>arc，圆弧线。只有一个属性 curvature（曲率），可根据曲率直接得到圆的半径，在根据曲率的正负可得到该曲线是以顺时针延申还是逆时针延申，再根据解析线型需要满足的两点和 geometry 的属性可得到真正的 inertial system 中的点。</li><li>poly3，三次曲线，<strong>在 1.6 中已被废弃</strong>。精度要求低一点可直接插值计算，要求高一点则需要利用 length ，数值计算和二分法直接求出最大的 u，然后插值。</li><li>paramPoly3，参数化三次曲线。最有名的两个参数化三次曲线就是 Bezier 曲线和 Hermite 曲线，为满足解析线型需要满足的两点，一定有 <span class="math inline">\(a_u=0, a_v=0,b_v=0\)</span>，需要注意的是一般参数化曲线的参数取值范围为 <span class="math inline">\([0,1]\)</span>，即该标签最后一个属性 pRange="normalized"，若碰到特殊情况 pRange="arcLength"，则需要将 <span class="math inline">\(a_u,b_u,\dots\)</span> 等属性转化为参数取值范围为 <span class="math inline">\([0,1]\)</span> 时对应的属性。</li></ol><p>最重要的元素 Geometry 的解析就是这样了，下面谈谈 Shaun 对基于三次曲线的一些元素的理解。</p><hr /><p>　　比较重要的基于三次曲线的元素主要有 elevation（控制路面的高度），superelevation（道路侧面抬高弧度），crossfall（路面两侧弧度，<strong>已被废弃</strong>），shape（路面两侧形状，<em>特殊，下文详细介绍</em>），laneOffset（车道偏移量），border 和 width（<em>特殊，下文详细介绍</em>），这些元素所使用的三次曲线一般都基于道路参考线（<em>特殊除外</em>），即该三次曲线的横坐标一般为 s，纵坐标即三次曲线的值则为各元素的信息，这些三次曲线一般是分段描述的，即道路参考线上两个关键点的 s 之间必会生成对应的一段三次曲线，每一段三次曲线的横坐标取值范围都为 <span class="math inline">\([0,poly3Length]\)</span>，其中 ploy3Length 为该段三次曲线的长度。这些三次曲线段全部合起来则构成沿道路参考线的一条三次曲线，根据 s 计算三次曲线的取值得到对应的信息。</p><h3 id="laneoffset">LaneOffset</h3><p>　　laneOffset 用来指示的是所有车道沿参考线法线方向的偏移量，所有车道包括中心车道（centerLane），由于中心车道没有宽度，所以也可以叫道路中心线，这和道路参考线是两个概念，若 laneOffset 都为 0，则道路中心线和道路参考线重合。</p><h3 id="shape">Shape</h3><p>　　路面两侧车道的高度，该元素虽然也是使用三次曲线进行描述的，但是该三次曲线的横坐标为 S/T/H 坐标中的 t，不是 s，不同的 t 得到不同的高度，该元素下可能存在多段三次曲线，这些三次曲线段是独立的，只是描述其属性 s 所在位置横截面的 shape，而没有完全指定 s 的横截面的 shape，则由两临近 s 的 三次曲线计算相同的 t 对应的高度然后线型插值得到（1.6 标准中插值的公式 Shaun 觉得有问题）。</p><h3 id="border-和-width">border 和 width</h3><p>　　之所以把这个两个元素放在一起写，是因为这两个元素描述的本质上是一个东西，都是车道边界所在的位置。同时，Shaun 还是想吐槽一下，作为一个既定的标准，完全不应该把这两个元素同时放出来，只需要放出一个即可，既然为标准就应该做到完全统一，至于具体用哪个是应用程序的事，但是出来的东西必须得唯一。border 是指车道边界到道路中心线在道路参考线法线上的投影，有正负之分，一般左边车道为正，右边车道为负，而 width 是指车道的宽度，这两者完全可以相互转换。虽然描述这两者的三次曲线是基于道路参考线 s 的，但是这个 s 是相对于 laneSection 标签中 s 属性的，即其真正沿道路参考线的 s' 应该为 s' = s + laneSection.s。</p><hr /><p>　　至于Junction 的解析好像没什么需要注意的，就不写了，至于 1.5 中的 Virtual Junction，引入新的道路前后继描述方式，也新加了一个 virtual connection，解析时到也没有需要注意的，唯一需要注意是在应用程序中该如何利用这些信息。</p><hr /><p>　　对于 Signal 和 Object，Shaun 觉得标准中强制规定 s &gt; 0 同样是一件非常不合理的事情，既然能超出道路长度，只准正向超出，不能反向超出，这有点不讲道理。 Signal 和 Object 同样需要注意在应用程序中的用法，至于解析方面，需要注意的应该就是 Object 中 outline 下面的 cornerRoad 和 cornerLocal。</p><h3 id="cornerroad-和-cornerlocal">cornerRoad 和 cornerLocal</h3><p>　　这两个元素描述的本质上也是一个东西，都是面域对象多边形边界上的轮廓点，虽然 1.5 中引入了复杂多边形的概念，即有内轮廓和外轮廓，但 cornerRoad 和 cornerLocal 还是一样的解析。cornerRoad 是直接相对于道路参考线的坐标，即将 X/Y/Z 坐标直接转换为 S/T/H 坐标得到的，所以直接解析转换就可得到该点的真正坐标。而 cornerLocal 的解析则相对要麻烦些，首先根据 object 标签中 s 和 t 属性计算得到 Object 的位置，以道路参考线上 s 所在的位置建立 S/T/H 坐标系统，将该坐标系统平移到 Object 所在位置，即该 S/T/H 系统以Object 的位置为原点，将 cornerLocal 上 u,v,z 属性带入该坐标系统计算出真正的坐标。由于 Object 中的 roll,pitch,hdg 属性，所以还需要对坐标以 Object 的位置为中心进行相应旋转才能得到真正 X/Y/Z 坐标系统中坐标。</p><hr /><p>好了，以上就是 Shaun 觉得在解析 OpenDRIVE 时需要注意的一些地方了。</p><h2 id="后记">后记</h2><p>　　整个地图行业本来就存在很强的壁垒，国内更是如此，而高精地图作为专为自动驾驶服务的地图，国内估计更是少有人接触过。</p><p>　　OpenDRIVE 虽作为一种高精地图标准，但离那种被广泛认可关注的标准还有很长一段距离，虽然它发展了十几年，但奈何整个行业才算是起步阶段，所以之前其一直发展的十分缓慢，之前用 OpenDRIVE 较多的应该是交通仿真领域，这个领域同样存在很强的壁垒，要在这种领域得到整个行业的认可是一件非常困难的事，因为其本来就存在一套自己的格式，而想要应用别人的标准，就势必需要逐渐抛弃自己的格式，这对企业来说需要下很大的决心。</p><p>　　就 Shaun 目前所知，行业内虽然有许多企业使用 OpenDRIVE 标准，但基本都是自己魔改后的标准，原因在于 OpenDRIVE 标准还没做到真正成为标准的地步，虽然其一些基本元素具备，但很有很多元素是完全缺失或不完善的，更重要的是，其可视化程序竟然不开源，在整个计算机领域内，还从没见过一种标准没有其开源实现的东西，没有相应的源码，只靠文字来理解难免会产生歧义，各大厂商自然就会选择实现自己的 OpenDRIVE，很难统一。历史上一些经典的论文和算法，都有其相应的开源实现，没有开源实现的论文和算法基本都淹没在了历史长河之中。所以没有开源实现，在计算机领域内很难真正推广开，就很难成为真正的标准。综上，OpenDRIVE 的发展任重而道远啊！希望现在在 ASAM 手中能发展的更快更完善些吧。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;　　接触并使用高精地图和 OpenDRIVE 已有一年的时间，简要写写 Shaun 对 OpenDRIVE 的一些认知。&lt;/p&gt;</summary>
    
    
    
    <category term="Share" scheme="http://cniter.github.io/categories/Share/"/>
    
    
    <category term="note" scheme="http://cniter.github.io/tags/note/"/>
    
    <category term="opendrive" scheme="http://cniter.github.io/tags/opendrive/"/>
    
  </entry>
  
</feed>
