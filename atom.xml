<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shaun&#39;s Space</title>
  <subtitle>求知！ 视界！ 未来！ ↖(^ω^)↗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cniter.github.io/"/>
  <updated>2018-04-16T00:57:40.711Z</updated>
  <id>http://cniter.github.io/</id>
  
  <author>
    <name>Shaun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中static用法小结</title>
    <link href="http://cniter.github.io/posts/b93d943b.html"/>
    <id>http://cniter.github.io/posts/b93d943b.html</id>
    <published>2018-04-09T08:36:06.000Z</published>
    <updated>2018-04-16T00:57:40.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　static 是 C++ 中很常用的一个关键字，它的用法也很多，时常会将其弄混，索性做个小结，以免以后忘记了或者继续弄混 (｡･ω･｡)。</p><a id="more"></a><h2 id="预备篇">预备篇</h2><p>　　首先要了解程序中数据的存储形式，一般而言数据的存储形式有三种：</p><ul><li>栈区（stack）—— 由编译器自动分配释放，一般用来存放函数的参数值，局部变量的值等；</li><li>堆区（heap）—— 由程序员分配释放，对应于对象的 new 或 malloc 和 delete 或 free，若程序员忘记释放，则在程序完全退出之后由操作系统回收；</li><li>静态存储区（static）—— 在编译时由编译器分配，在程序完全退出时由操作系统回收，一般用来存放全局变量和 static 变量。</li></ul><p>　　一般<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>声明的变量默认（如果变量类型，eg: int, double, … 等，前不加 static 或其它关键字）都是 auto <a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>的，其一般存放在栈区，生存周期就只在包围其的 <code>{ }</code> 内，在包围其的 <code>{ }</code> 外就无法使用该变量。而 static 存放在静态存储区，其生存周期是全局的，它要等整个程序完全退出时才会销毁，<strong><em>在程序运行过程中，每次调用 static 变量都保持上一次调用结束后的值</em></strong>。</p><h2 id="类中篇">类中篇</h2><h3 id="静态成员变量">静态成员变量</h3><p>　　类中的静态成员变量被该类的所有实例共享，也可以不通过类的实例使用，在使用时首先需要对其初始化，也必须对其进行初始化，因为类中的静态成员变量只是声明，而且，类中的静态成员变量和普通静态变量一样是在程序初始化的时候分配的，在程序完全退出时由操作系统回收。具体用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">static</span> <span class="keyword">int</span> s_value;	<span class="comment">// 注意，这里不能初始化！因为其不属于类对象，只属于类作用域，独立于该类的任何实例</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 在cpp中或类定义体外必须对它进行定义和初始化，因为在程序编译时首先执行的就是对其初始化并分配内存：</span></div><div class="line"><span class="keyword">int</span> Test::s_value = <span class="number">0</span>;	<span class="comment">// 注意，这里没有static的修饰！</span></div></pre></td></tr></table></figure><p>总而言之就是：<strong>类中的静态成员变量可以简单理解为一个名为 <code>Test::s_value</code> 的全局变量，被所有该类的实例共用，但独立于该类的任何实例，只属于该类作用域，在类的定义中能且只能被声明，不能在类定义体中进行初始化，必须要在类定义体外被定义和初始化</strong>。</p><h3 id="静态成员函数">静态成员函数</h3><p>　　类中的静态成员函数和类中的静态成员变量有点类似，其在实现时不需要再加 static 修饰，同样能被该类的所有实例复用，同样只属于类作用域中的全局函数，同样不需要类的实例即可调用。类中的静态成员函数不能访问类的普通成员变量，只能访问类的静态成员变量（可以参考 <a href="http://www.cnblogs.com/rickyk/p/4238380.html" target="_blank" rel="external">C++静态成员函数访问非静态成员的几种方法</a> 中的小 trick 访问普通成员变量，但非特殊情况不建议这么做）。具体用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></div><div class="line"><span class="class">&#123;</span>  </div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 静态成员函数调用非静态成员变量方法</span></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticTest</span><span class="params">(Test *t)</span></span></div><div class="line"><span class="function">    </span>&#123;</div><div class="line">        t-&gt;value += <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> value;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 在cpp中可以不通过类的实例进行调用：</span></div><div class="line"><span class="keyword">void</span> Test::func(<span class="keyword">int</span>);</div></pre></td></tr></table></figure><p>总而言之就是：<strong>类中的静态成员函数可以简单理解为一个名为 <code>Test::func(int)</code> 的全局函数，能被该类的所有实例复用，但独立于该类的任何实例，只属于该类作用域，可以不通过类的实例进行调用，也可以像普通成员函数一样通过类的实例进行调用</strong>。</p><h2 id="特定范围篇">特定范围篇</h2><p>　　为了使全局变量或函数只在特定 cpp 文件中起作用，需要在 cpp 文件中相应变量或函数前添加static 修饰，如下表：</p><table><thead><tr class="header"><th style="text-align:center">类型</th><th style="text-align:center">.h 文件</th><th style="text-align:center">.cpp 文件</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">全局变量</td><td style="text-align:center">不使用 static 修饰，使用 extern 修饰</td><td style="text-align:center">使用 static 修饰</td></tr><tr class="even"><td style="text-align:center">全局函数</td><td style="text-align:center">不使用 static 修饰</td><td style="text-align:center">使用 static 修饰</td></tr></tbody></table><ul><li>如果在头文件中声明 static 全局变量，则在包含该头文件的每个 .cpp 文件中都会生成一个独立的同名变量，而这种写法没有任何意义；如果在 .cpp 文件中不使用 static 声明全局变量，则该全局变量可能会被其它 .cpp 文件共享，也可能不会，造成该变量的不确定性；所以如果该全局变量要被所有 .cpp 文件共享，则需要在头文件中声明 extern 全局变量（eg：<code>extern int g_value; // 注意，不要初始化值！</code>），再在每个 .cpp 文件中单独进行定义和初始化（仅一次）（eg：<code>int g_value = 0; // 不要extern修饰！</code>），如此即可在每个 .cpp 文件中共享该全局变量；而若只想在单个 .cpp 文件中使用全局变量，则需要在该 .cpp 文件中全局范围类声明和定义 <code>static int g_value = 0;</code>，如此可保证该变量能且只能被该 .cpp 文件使用。</li><li>如果在 .cpp 文件中不使用 static 声明全局函数，则该全局函数可能会被其它 .cpp 文件共享，也可能不会，这样在别的 .cpp 文件调用同名函数时可能会出现问题；而在头文件中使用 static 声明全局函数同样没有任何意义；所以如果要被多个 .cpp 文件复用，就将其声明移到头文件中，且不需要 static 修饰，而若只想在特定 .cpp 文件中使用该全局函数，则需要在声明时添加 static 修饰。</li></ul><p>最后，若是在 .hpp 文件中，则需要去除全局对象，将全局函数封装为类的静态方法。</p><p>　　<strong><em>PS：</em></strong>若在函数中使用 static 修饰变量，则该函数无法做到线程安全，在程序运行过程中，每次调用该函数，函数内的 static 变量都将保持上一次调用结束后的值，<strong><em>所以在函数中慎用 static 变量，除非需要这个特性</em></strong>。</p><h2 id="后记">后记</h2><p>　　写这篇文章的初衷在于时常需要 static 时老是忘记或弄混它的用法，不得不去网上查找，虽说网上的相关资料也有很多，但在找的时候还是有点麻烦，毕竟有很多不是自己需要的，而且自己总结一下对其理解又更深一些，下次要用时也能马上找到自己所需。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://blog.csdn.net/mznewfacer/article/details/6898005" target="_blank" rel="external">c/c++ static 用法总结（三版本合一）</a></p><p>[2] <a href="http://developer.51cto.com/art/201104/254141.htm" target="_blank" rel="external">C++中static的用法总结</a></p><p>[3] <a href="https://blog.csdn.net/men_wen/article/details/64443040" target="_blank" rel="external">C++ 类中的static成员的初始化和特点</a></p><p>[4] <a href="http://www.cnblogs.com/rickyk/p/4238380.html" target="_blank" rel="external">C++静态成员函数访问非静态成员的几种方法</a></p><section class="footnotes"><hr><ol><li id="fn1"><p>这里的一般是指局部变量，若为全局变量则默认为 extern ，局部变量没有默认初值，其初值不确定，一般需要人为明确的赋初值，而全局变量默认初值为 0 ，一个比较好的编程习惯是声明一个变量就对其进行初始化（赋初值），尽量少用全局变量，全局变量显示声明 extern。<a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p><strong><em>※注：</em></strong>这里的 auto 与 C++11 中的意义不同，这里的 auto 指的是变量的存储形式，而不是 C++11 那种可以当做任意的变量类型，eg: int, double, std::vector&lt;std::vector&lt;double&gt;&gt;, …… ，与其对应的还有 extern 和 register 关键字，其中 register 关键字基本不用 。<a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　static 是 C++ 中很常用的一个关键字，它的用法也很多，时常会将其弄混，索性做个小结，以免以后忘记了或者继续弄混 (｡･ω･｡)。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="c/cpp" scheme="http://cniter.github.io/tags/c-cpp/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列的三种写法</title>
    <link href="http://cniter.github.io/posts/8fb9f004.html"/>
    <id>http://cniter.github.io/posts/8fb9f004.html</id>
    <published>2018-03-23T03:09:58.000Z</published>
    <updated>2018-04-08T03:22:23.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本文预示着本人开始着手准备找工作的事了，初步计划是先把『剑指Offer』上的题先做一遍，对照着 <a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="external">牛客网</a> 上的题进行测试，尽量争取先把书上的题都能 AC 。一般定义的斐波那契数列数列为：0,1,1,2,3,5,8……（对应 <span class="math inline">\(F(0)=0, F(1)=1, F(2)=1, \cdots \cdots\)</span>），用数学公式表示即为：<span class="math inline">\(F(n)=F(n-1)+F(n-2)\)</span>。以下代码均用 C++ 实现，且均通过牛客的测试。</p><a id="more"></a><h2 id="循环写法">循环写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_loop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">int</span> fn = <span class="number">0</span>, f1 = <span class="number">0</span>, f2 = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</div><div class="line">	&#123;</div><div class="line">		fn = f1 + f2;</div><div class="line">		f2 = f1;</div><div class="line">		f1 = fn;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> fn;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="递归写法">递归写法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_recursive</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &amp;n)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">	&#125; </div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> fibonacci_recursive(n - <span class="number">1</span>) + fibonacci_recursive(n - <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　<strong><em>※注：</em></strong>这里本人在牛客上进行测试的时候，如果把 <code>|| n == 2</code> 去掉的话，就没法通过，可见多递归一次花费的时间并不是线性增长的。</p><h2 id="尾递归写法">尾递归写法</h2><p>　　说来惭愧，这个概念还是在一个小学弟那里得知的，后面才逐渐了解并学会使用。</p><p>　　尾递归，简而言之就是最后会且仅会调用函数本身，递归调用函数之后没有其它的语句需要执行。就像上面的递归，它在递归调用之后还会执行加法运算，而尾递归在执行递归调用之后就没有其它的运算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci_tailRecursive</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n, <span class="keyword">unsigned</span> <span class="keyword">int</span> f1 = <span class="number">1</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> fn = <span class="number">0</span>)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> fn;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> fibonacci_tailRecursive(n - <span class="number">1</span>, fn, fn + f1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>　　循环和尾递归花费的时间和空间都差不多，都要比普通的递归要小，普通的递归优势在于便于理解，代码好写，在不强调性能的前提下，用递归写法的代码可读性可能要好些。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://www.cnblogs.com/Anker/archive/2013/03/04/2943498.html" target="_blank" rel="external">递归与尾递归总结</a>（<a href="http://www.cnblogs.com/Anker/category/436371.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/Anker/category/436371.html</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文预示着本人开始着手准备找工作的事了，初步计划是先把『剑指Offer』上的题先做一遍，对照着 &lt;a href=&quot;https://www.nowcoder.com/ta/coding-interviews&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt; 上的题进行测试，尽量争取先把书上的题都能 AC 。一般定义的斐波那契数列数列为：0,1,1,2,3,5,8……（对应 &lt;span class=&quot;math inline&quot;&gt;\(F(0)=0, F(1)=1, F(2)=1, \cdots \cdots\)&lt;/span&gt;），用数学公式表示即为：&lt;span class=&quot;math inline&quot;&gt;\(F(n)=F(n-1)+F(n-2)\)&lt;/span&gt;。以下代码均用 C++ 实现，且均通过牛客的测试。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="c/cpp" scheme="http://cniter.github.io/tags/c-cpp/"/>
    
  </entry>
  
  <entry>
    <title>搜索技巧</title>
    <link href="http://cniter.github.io/posts/982ff584.html"/>
    <id>http://cniter.github.io/posts/982ff584.html</id>
    <published>2018-02-28T08:36:26.000Z</published>
    <updated>2018-03-02T03:30:08.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本人一直以为自己的搜索能力还可以，基本上自己想要的东西都能搜到，但是自从接触到这个世界，才知道自己大概只是个入门的水平（或者说连入门都说不上 /つ∇T)），和网上的一些大神相比还有比较大的差距，此文只是网上一些资料的整理，方便本人熟练使用，提高驾驶技巧，毕竟信息检索能力还是很重要的。</p><a id="more"></a><h2 id="搜索篇">搜索篇</h2><p>Google 可以通过添加一些字符优化搜索结果，如：</p><table><colgroup><col style="width:43%"><col style="width:56%"></colgroup><thead><tr class="header"><th style="text-align:center">搜索需求</th><th style="text-align:center">对应字符</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><strong>搜索社交媒体</strong></td><td style="text-align:center">在用于搜索社交媒体的字词前加上 <code>@</code>。例如：<code>@twitter</code>。</td></tr><tr class="even"><td style="text-align:center"><strong>从搜索结果中排除特定字词</strong></td><td style="text-align:center">在您要排除的字词前加上 <code>-</code>。例如：<code>jaguar speed -car</code></td></tr><tr class="odd"><td style="text-align:center"><strong>搜索完全匹配的结果</strong></td><td style="text-align:center">为字词或短语加上引号。例如：<code>&quot;tallest building&quot;</code>。</td></tr><tr class="even"><td style="text-align:center"><strong>搜索通配符或未知字词</strong></td><td style="text-align:center">在字词或短语中您要放置占位符的地方加上 <code>*</code>。例如：<code>&quot;largest * in the world&quot;</code>。</td></tr><tr class="odd"><td style="text-align:center"><strong>在某个数字范围内执行搜索</strong></td><td style="text-align:center">在两个数字之间加上 <code>..</code>。例如：<code>camera $50..$100</code></td></tr><tr class="even"><td style="text-align:center"><strong>组合搜索</strong></td><td style="text-align:center">在各个搜索查询之间加上“<code>OR</code>”。例如：<code>marathon OR race</code></td></tr><tr class="odd"><td style="text-align:center"><strong>搜索特定网站</strong></td><td style="text-align:center">在相应网站或域名前加上“<code>site:</code>”。例如：<code>site:youtube.com</code>或 <code>site:.gov</code></td></tr><tr class="even"><td style="text-align:center"><strong>搜索相关网站</strong></td><td style="text-align:center">在已知网址前加上“<code>related:</code>”。例如：<code>related:time.com</code></td></tr><tr class="odd"><td style="text-align:center"><strong>查找链接到某个特定网页的网页</strong></td><td style="text-align:center">在已知网址前加上“<code>link:</code>”。例如：<code>link:chongbuluo.com</code>，就能查到哪些网页中包含链接<code>chongbuluo.com</code></td></tr><tr class="even"><td style="text-align:center"><strong>查找在URL地址里有搜索关键词的页面</strong></td><td style="text-align:center">在已知网址前加上“<code>inurl:</code>”。例如：<code>inurl:chongbuluo</code>，就能查到哪些网页 url 中包含链接<code>chongbuluo</code></td></tr><tr class="odd"><td style="text-align:center"><strong>查找在网页标题里有搜索关键词的页面</strong></td><td style="text-align:center">在已知网址前加上“<code>intitle:</code>”。例如：<code>intitle:chongbuluo</code>，就能查到哪些网页标题中包含链接<code>chongbuluo</code></td></tr><tr class="even"><td style="text-align:center"><strong>查找在网页正文里有搜索关键词的页面</strong></td><td style="text-align:center">在已知网址前加上“<code>intext:</code>”。例如：<code>intext:chongbuluo</code>，就能查到哪些网页正文中包含链接<code>chongbuluo</code></td></tr><tr class="odd"><td style="text-align:center"><strong>查找pdf,xml,xls,txt,doc,csv等特定格式的结果</strong></td><td style="text-align:center">在特定文件格式前加上<code>filetype:</code>。例如 <code>filetype:pdf</code></td></tr><tr class="even"><td style="text-align:center"><strong>查找关键词的定义</strong></td><td style="text-align:center">在关键词前加上<code>define:</code>。例如 <code>define:搜索</code></td></tr></tbody></table><p>　　经本人实测，以上大部分字符对百度搜索引擎同样适用。当然，最好的搜索方式是使用高级搜索，高级搜索可以进行一系列设置，比如时间范围，从而使搜索结果更精确，更容易得到想要的结果，不过在不十分确定的时候，不要做太多限制，不然可能会过滤掉关键信息。</p><p>　　Google 和百度对英文字符大小写都不敏感，搜索 <strong>QQ</strong> 与 <strong>qq</strong> 所得到的结果是一样的。搜索是否成功最关键的地方还是在于关键词的选取，关键词的选取这没什么好说的，只能提高搜索熟练度及对问题的把握程度了。</p><p>　　哦，还有一点忘记说了，就是在 Google 中如果要搜索那个的话，必须要在搜索设置里面关闭安全搜索功能，如果简体中文不能关闭安全搜索功能的话，就在搜索设置里将语言更换到繁体中文或英语应该就能关闭安全搜索功能。</p><h2 id="技巧篇">技巧篇</h2><p>　　有时候第一个页面没有想要的结果，于是需要看第二个、第三个页面的结果，是不是觉得翻页很麻烦？（如果不觉得麻烦可以直接跳过🙄），但是设置增加搜索结果条目又会提高显示延迟，这时可以使用 <a href="https://greasyfork.org/zh-CN/scripts/10433-super-preloaderplus-one" target="_blank" rel="external">Super_preloaderPlus_one</a> 脚本（Chrome 中可以使用 <a href="https://chrome.google.com/webstore/detail/autopagerize/igiofjhpmpihnifddepnpngfjhkfenbp?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">AutoPagerize</a> 插件），只需鼠标继续往下滚轮就会自动加载下页搜索结果，无需点击翻页。</p><p>　　当点击网页链接却出现404错误或无法显示页面的错误时，这个时候可以使用搜索引擎的「网页快照」功能，Google的这个功能点击搜索结果页面标题下的 绿色小三角 即可看到，百度的这个叫 百度快照，在搜索结果 url 地址的末端，即结果最后面。快照功能最强大的是 <a href="https://archive.org/" target="_blank" rel="external">互联网档案馆</a>（<strong>Internet Archive</strong>），又叫『网站时光倒流机器』（<strong>Wayback Machine</strong>），在知道链接的情况下，将链接输入到 <strong>Internet Archive</strong> 点击搜索就能查看历史快照了。</p><p>　　如果要查找某个网页出现的关键词，可以利用 Chrome 和 Firefox 的网页搜索功能，一般可以通过 <strong><code>Ctrl + F</code></strong> 去检索。也可以通过 <strong><code>F12</code></strong> 或「鼠标右键」（Firefox 点击「查看元素」，Chrome 点击「检查」，都是右键弹框最后一个选项）进入浏览器控制台开发工具，Chrome 中还要通过 <strong><code>Ctrl + F</code></strong> 才能检索元素，而 Firefox 可以直接搜索 HTML，输入要查找的关键词，回车即可。</p><h2 id="专项篇">专项篇</h2><p>　　<strong>图像搜索：</strong>这个一般用 Google 和百度的以图搜图就可以了，不过也有些特殊的图像搜索引擎，如 <a href="https://www.tineye.com/" target="_blank" rel="external">TinEye</a> 等，当然，图像搜索最好还是安装相应的插件，在 Chrome 中可以安装一个叫 <a href="https://chrome.google.com/webstore/detail/noobox/kidibbfcblfbbafhnlanccjjdehoahep?utm_source=chrome-app-launcher-info-dialog" target="_blank" rel="external">二箱</a> 的插件，在 Firefox 中可以安装一个叫 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/search_by_image/?src=userprofile" target="_blank" rel="external">Search by Image</a> 的插件。</p><p>　　<strong>音乐搜索：</strong>这个如果能听出歌词的话就直接去搜索引擎上搜听到的歌词，如果无法听出歌词的话，可以尝试各大音乐软件的「听歌识曲」功能。</p><p>　　当然更精确的专项搜索一般只存在于特定的网站，这就要看对整个互联网的了解程度了，这里强推「<a href="http://search.chongbuluo.com/" target="_blank" rel="external">虫部落-快搜</a>」，不管是日常搜索需求还是特殊搜索需求基本都能满足。</p><h2 id="后记">后记</h2><p>　　尽量优先使用 Google，百度或许能找到自己想要的，但太浪费时间了，浪费时间就是浪费生命，不过能看到本文的看官，应该也是能熟练使用 Google 的了。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://support.google.com/websearch/answer/134479" target="_blank" rel="external">如何在 Google 中进行搜索</a>(<a href="https://support.google.com/websearch/#topic=3081620" class="uri" target="_blank" rel="external">https://support.google.com/websearch/#topic=3081620</a>)</p><p>[2] <a href="https://support.google.com/websearch/answer/2466433" target="_blank" rel="external">优化网页搜索</a></p><p>[3] <a href="http://www.chongbuluo.com/forum.php?mod=viewthread&amp;tid=3041" target="_blank" rel="external">提高搜索能力的关键技巧（如何查找可靠出处）</a></p><p>[4] <a href="http://www.chongbuluo.com/forum.php?mod=viewthread&amp;tid=1796" target="_blank" rel="external">谷歌搜索技巧：搜索语法+隐藏彩蛋+高级设置</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本人一直以为自己的搜索能力还可以，基本上自己想要的东西都能搜到，但是自从接触到这个世界，才知道自己大概只是个入门的水平（或者说连入门都说不上 /つ∇T)），和网上的一些大神相比还有比较大的差距，此文只是网上一些资料的整理，方便本人熟练使用，提高驾驶技巧，毕竟信息检索能力还是很重要的。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
      <category term="search" scheme="http://cniter.github.io/tags/search/"/>
    
  </entry>
  
  <entry>
    <title>17年走了，18年来了</title>
    <link href="http://cniter.github.io/posts/7cebf0ee.html"/>
    <id>http://cniter.github.io/posts/7cebf0ee.html</id>
    <published>2018-01-26T02:18:32.000Z</published>
    <updated>2018-01-31T12:53:18.878Z</updated>
    
    <content type="html"><![CDATA[<p>　　17 年走了，18 年也过了一个月，从这一个月看，18 年好像并没有对那个傻逼好一点。</p><a id="more"></a><p>　　17 年，也算是本人人生的一个转折点吧，既然是转折点，况且人也这么大了，不能像以前那样浑浑噩噩的过了，所以总要留下点什么东西吧。</p><p>　　17 年，从本科升入研究生，学校变了，所在城市却没变，所接触到的人好像变了，也好像没变，人还是那样的人。虽然早知读研是个坑，但还是转身继续扎入象牙塔中，但此时的象牙塔已不再是四年前的象牙塔，如果说四年前的象牙塔是白色的，那现在的就是黑色的，虽然是黑色的，但总比外面无尽的黑暗要好一点吧（或许有一点光明），至少是个塔，至少还稍微有点保护作用（心里安慰罢了）。黑色象牙塔和白色象牙塔最大的区别在于黑色象牙塔里有 boss，更NB的是 boss 拥有生杀予夺的权利，而且这种权利没人监管，也无法申述（或许是本人不知道？），除非有玉石俱焚的决心，否则很难反抗 。进入这黑色的象牙塔是为了逃避黑暗还是大势所趋，本人认为自己或许两者皆有，在这黑色的象牙塔待两年，一来能在将来真正进入黑暗之前稍微接触一点黑暗，做好心理准备，起到一个缓冲的作用；二来能趁这两年提升一下自己，为自己在将来在黑暗中寻找那 些微光明 提供一点帮助，而且外界的黑暗也对黑色象牙塔中走出来的人好像更重视，这样不管是硬实力，还是软实力都能得到提升，这在黑暗中行走就更有的底气了，而且也更会有后劲，这样的话走进光明是不是更容易些？</p><p>　　17 年，不管是求知方面还是视界方面都得到了一定程度的提升和扩大，或许在外面那无尽的黑暗中能提升的更快，扩大的更多也说不好。要说本人真正进入计算机的世界，应该是在大三上的时候吧，那时候才算是真正入门了，以前只能说是上过计算机的基础课，有什么问题还是没办法解决，还处在混沌阶段，没有方向，只能瞎摸。入门了之后感觉学计算机相关的东西就轻松多了，大多数问题都能找准方向，并一步一步的解决，当然最快的解决方案还是在 Google 上。大四做毕设的时候，从没接触过 OpenCV 的本人，借助网上的资料和书本，花了两个月的时间，还是勉强做了简单的手势识别系统，等以后时间把这个系统还是记录一下吧，好歹这其中基本上把经典计算机视觉中数字图像处理和传统机器学习结合的流程走了一遍，做完这个系统，本人的计算机视觉也算是正式入门了。至于目前火热的深度学习，因为设备的原因，暂时还无法实践，不得不说这是一大憾事。</p><p>　　17年，人或许没接触到更多，但事倒是见得更多了。主要是因为接触到了一些更有趣的世界，或者说圈子，这其中强推 <strong>「Solidot」</strong> ，该站点的资讯确实更新的很及时，科技界的一些大事都能及时公布出来，还有一个就是 <strong>「虫部落」</strong>，其快搜资源的聚合简直无敌了。网络如此之大，不知道还有多少有趣的事物等着本人去发现，每发现这些有趣的东西，就像是找到一个宝藏一样，想想就觉得很开心呢 🙃。</p><p>　　17 年，以一种看客的心态看了很多场戏。番茄界的用户资源之争，人肉的厉害之处，本是同根生，相煎何太急，最后有一人只能黯然退出，不知道是好是坏，毕竟本人也没用过那个工具及其提供的相关服务（或许以后会用到吧），但一家独大总归不是什么好事。在网上看到这样一句话：「鲁迅已逝，阿Q 重生」，『暴走大事件』对时事的调侃虽然很尖锐，但三观基本很正，坚持这样不容易啊，望其能唤醒一些 阿Q 吧。『新浪微博』，可以说是当前中国最大的信息聚合平台了，什么样的东西总能在微博上找到，国内大部分的戏也能在微博上看到，尤其是评论区更是有趣，但其信息和用户太杂了，良莠不齐，信息的价值密度比较低，总而言之，微博这种东西是需要带着脑子去逛的，微博上有些东西，本人无法辨别，但借用鲁迅先生的一句话，「我向来是不惮以最坏的恶意来揣测中国人」。至于『知乎』，『V2EX』等，仁者见仁智者见智吧。</p><p>　　17 年，在网上看到这样一句话：“你可以不关心政治，但政治会来关心你”。政治上的事，无非是民主自由，但出于某些不可描述的原因就不谈了，无知是福 （๑乛◡乛๑）。但知道一些人和政策总是有好处的，虽然暗地里可能会违背，但估计没人敢明目张胆的违背吧，通过知道这些事，总能做点趋利避害的事吧。</p><p>　　17 年，已在实验室待了半年，还好有音乐这种东西可以麻痹一下，不然这两年就难熬喽。17 年，总归还是或知道或学会了很多有趣的东西。世界总的来说还是美好的，但这些美好的东西又有多少人能亲身经历，亲身享受。本人能做的只有向这些美好的东西前进，接近，享受，顺便看看路上的风景，不管是好的还是坏的。</p><div style="text-align:center;font-family:Allura,Consolas,Helvetica,Tahoma,Arial,Microsoft YaHei,微软雅黑,SimSun,宋体,Heiti,黑体,sans-serif;font-size:1.3em;color:#4094c3;font-weight:700;margin:.5em auto">17 年获得技能：<strong><em>视界开拓</em></strong><br>17 年获得成就：<strong><em>打开新世界的大门</em></strong></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　17 年走了，18 年也过了一个月，从这一个月看，18 年好像并没有对那个傻逼好一点。&lt;/p&gt;
    
    </summary>
    
      <category term="Share" scheme="http://cniter.github.io/categories/Share/"/>
    
    
      <category term="thought" scheme="http://cniter.github.io/tags/thought/"/>
    
      <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>矩阵的应用之图像仿射变换</title>
    <link href="http://cniter.github.io/posts/e124baa1.html"/>
    <id>http://cniter.github.io/posts/e124baa1.html</id>
    <published>2018-01-20T13:21:16.000Z</published>
    <updated>2018-04-07T13:42:05.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，本人这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。</p><a id="more"></a><h2 id="预备篇">预备篇</h2><p>　　首先需要了解的是图像中坐标系和数学课本中常用的坐标系略有不同，图像中坐标系是以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴；而数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴。所以由图像中坐标 <span class="math inline">\((x,y)\)</span> 转数学课本中常见的坐标 <span class="math inline">\((x&#39;,y&#39;)\)</span> 的公式为 $x’ = x - C/2; y’ = -y + R/2; $ 其中 <span class="math inline">\(C\)</span> 表示原图像总列数，即原图像宽度，<span class="math inline">\(R\)</span> 表示原图像总行数，即原图像高度。</p><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="346px" height="160px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="62" x2="125" y2="62" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="75" y1="100" x2="75" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="126" y="56" fill="blue">X 轴</text><text x="75" y="20" fill="blue">Y 轴</text><line x1="210" y1="25" x2="310" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="210" y1="25" x2="210" y2="100" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="310" y="42" fill="blue">X 轴</text><text x="215" y="110" fill="blue">Y 轴</text><text x="40" y="150" fill="blue">数学坐标系</text><text x="240" y="150" fill="blue">图像坐标系</text></svg></div><p>　　<font color="#FA8072"><strong>※注：</strong>值得注意的是因为 MATLAB 和 OpenCV 的像素索引坐标形式为 <strong><em>(行坐标，列坐标)</em></strong> ，所以若以本文这样定的图像坐标，则图像中坐标 <span class="math inline">\((x,y)\)</span> 对应的像素值为 <span class="math inline">\(f(y,x)\)</span>。</font></p><h2 id="变换篇">变换篇</h2><p>据 OpenCV 文档所说：</p><blockquote><ol type="1"><li><p>一个任意的仿射变换都能表示为 <em>乘以一个矩阵</em> (线性变换) 接着再 <em>加上一个向量</em> (平移).</p></li><li><p>综上所述, 我们能够用仿射变换来表示:</p><ol type="1"><li>旋转 (线性变换)</li><li>平移 (向量加)</li><li>缩放操作 (线性变换)</li></ol><p>你现在可以知道, 事实上, 仿射变换代表的是两幅图之间的 <strong>关系</strong> .</p></li><li><p>我们通常使用 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/a832b76c4f4a4ec13ac1b557da4fed6006e64d00.png" alt="2 3"> 矩阵来表示仿射变换.</p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/c3fdaa7031379552454b333ff916cd1987107b5c.png" alt="A = -begin{bmatrix} a_{00} &amp; a_{01} \ a_{10} &amp; a_{11} -end{bmatrix}{2 2} B = \begin{bmatrix} b{00} \ b_{10} \end{bmatrix}{2 1} M = -begin{bmatrix} A &amp; B -end{bmatrix} =-begin{bmatrix} a{00} &amp; a_{01} &amp; b_{00} \ a_{10} &amp; a_{11} &amp; b_{10}-end{bmatrix}_{2 3}">　　</p><p>考虑到我们要使用矩阵 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"> 和 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B"> 对二维向量 <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/22671b2dfac15c46b634f068e4ccd644551abd8a.png" alt="X = \begin-{bmatrix}x \ y\end-{bmatrix}"> 做变换, 所以也能表示为下列形式:</p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/7b0b4b830b85f222266aa9c8fc76e1a7ce998c42.png" alt="T = A \begin-{bmatrix}x \ y\end-{bmatrix} + B"> or <img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/f44f98e19b4ee0613633b70414a47259846b2d27.png" alt="T = M ^{T}"></p><p><img src="http://www.opencv.org.cn/opencvdoc/2.3.2/html/_images/math/3295a3e90f963d7a35c1cd910b9258cd92761a8f.png" alt="T=\begin-{bmatrix}a_{00}x + a_{01}y + b_{00} \ a_{10}x + a_{11}y + b_{10}\end-{bmatrix}">　　</p></li></ol></blockquote><p>而在冈萨雷斯的《数字图像处理_第三版》里有：</p><blockquote><p>最常用的空间坐标变换之一是仿射变换，其一般形式如下： <span class="math display">\[ \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \textbf{T} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \begin{bmatrix} t_{11} &amp; t_{12} &amp; 0 \\ t_{21} &amp; t_{22} &amp; 0 \\ t_{31} &amp; t_{32} &amp; 1 \end{bmatrix} \]</span> 其中 <span class="math inline">\((v,w)\)</span> 为原坐标，<span class="math inline">\((x,y)\)</span> 为变换后的坐标，可根据变换矩阵 <span class="math inline">\(\textbf{T}\)</span> 中的元素选择的值，对一组坐标点做尺度、旋转、平移或偏移变换。一些常见的变换矩阵及作用如下表：</p><table><colgroup><col style="width:16%"><col style="width:41%"><col style="width:41%"></colgroup><thead><tr class="header"><th style="text-align:center">变换名称</th><th style="text-align:center">仿射变换矩阵<span class="math inline">\(\textbf{T}\)</span></th><th style="text-align:center">坐标公式</th></tr></thead><tbody><tr class="odd"><td style="text-align:center"><strong>恒等变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v , \\ y=w \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>尺度变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vc_x , \\ y=wc_y \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>旋转变换</strong>（以逆时针为正）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} cos(\theta) &amp; sin(\theta) &amp; 0 \\ -sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vcos(\theta)-wsin(\theta) , \\ y=vsin(\theta)+wcos(\theta) \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>旋转变换</strong>（以顺时针为正）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=vcos(\theta)+wsin(\theta) , \\ y=-vsin(\theta)+wcos(\theta) \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>平移变换</strong></td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v+t_x , \\ y=w+t_y \end{cases}\)</span></td></tr><tr class="even"><td style="text-align:center"><strong>偏移变换</strong>（水平）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_h &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v+ws_h , \\ y=w \end{cases}\)</span></td></tr><tr class="odd"><td style="text-align:center"><strong>偏移变换</strong>（垂直）</td><td style="text-align:center"><span class="math inline">\(\begin{bmatrix} 1 &amp; s_v &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)</span></td><td style="text-align:center"><span class="math inline">\(\begin{cases} x=v , \\ y=vs_v+w \end{cases}\)</span></td></tr></tbody></table><p>仿射变换的实现由两种方式：一种是 <strong><em>前向映射（Forward Mapping）</em></strong>：直接采用利用原图像坐标 <span class="math inline">\((v,w)\)</span> 通过 <span class="math inline">\(\begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}\)</span> 得到变换后的坐标 <span class="math inline">\((x,y)\)</span>，使用前向映射会导致一些问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的花纹状）；更好的一种方式是采用 <strong><em>反向映射（Inverse Mapping）</em></strong>：扫描输出图像的位置 <span class="math inline">\((x,y)\)</span>，通过 <span class="math inline">\(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)</span>（其中 <span class="math inline">\(\textbf{T}^{-1}\)</span> 为 <span class="math inline">\(\textbf{T}\)</span> 的逆矩阵）计算输入图像对应的位置 <span class="math inline">\((v,w)\)</span>，通过插值方法决定输出图像该位置的灰度值。</p></blockquote><p>　　<strong>本文这里采取冈萨雷斯的《数字图像处理_第三版》的变换矩阵方式</strong>，毕竟所学的矩阵论也是将变换矩阵放在后面作为第二个因子。虽然仿射变换都有现成的 API 可以调用，而且速度一般要比自己写的要快，但是知其然终究也要知其所以然。</p><p>　　<strong>下面就以旋转变换为例了</strong>，因为尺度变换和平移变换只需要相应的缩放图像即可，而旋转变换不仅需要更改图像大小，还要确定旋转中心，而旋转中心一般以图像中心为标准。</p><h3 id="旋转变换">旋转变换</h3><p>　　旋转变换首先需要确定旋转中心，若以图像左上角为旋转中心，则只需要像做尺度变换和平移变换那样通过 <span class="math inline">\(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)</span> 做普通的变换即可。而以图像中心为旋转中心，首先需要做坐标变换，将以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴的图像坐标系转换为以图像中心为原点，水平向右为 X 轴，垂直向下为 Y 轴的数学坐标系；再做正常的旋转变换；随后再将数学坐标系转换为图像坐标系，所以图像中心为旋转中心的旋转变换总共需要做三次变换。这里就以图像中心为旋转中心为例，由于有三次变换，所以应该有三个变换矩阵相乘，设 图像坐标系==》数学坐标系的变换矩阵为 T1，旋转变换矩阵为 T2，数学坐标系==》图像坐标系的变换矩阵为 T3，设顺时针旋转角度为 <span class="math inline">\(\theta\)</span> ，原图像宽度为 <span class="math inline">\(C\)</span>，高度为 <span class="math inline">\(R\)</span>，旋转后图像宽度为 <span class="math inline">\(W\)</span>，高度为 <span class="math inline">\(H\)</span>，则： <span class="math display">\[ T1=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ -0.5C &amp; 0.5R &amp; 1 \end{bmatrix}　　 T2=\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}　　 T3=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0.5W &amp; 0.5H &amp; 1 \end{bmatrix} \]</span> 则旋转变换最终形式为：<span class="math inline">\(\begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}=\begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix}T1*T2*T3\)</span>。</p><p><strong><em>※BTW：</em></strong>旋转变换中，旋转后图像宽度 <span class="math inline">\(W\)</span>，高度 <span class="math inline">\(H\)</span> 与 原图像宽度 <span class="math inline">\(C\)</span>，高度 <span class="math inline">\(R\)</span> 的关系为： <span class="math display">\[ \begin{cases} H = |R*cos(\theta)| + |C*sin(\theta)| , \\ W = |C*cos(\theta)| + |R*sin(\theta)| \end{cases} \]</span></p><h2 id="插值篇">插值篇</h2><p>　　因为经过采用<strong>反向映射</strong><font color="#00f"><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></font>方式的仿射变换之后，得到的原图像坐标 <span class="math inline">\((v,w)\)</span> 往往不是整数值，所以无法知道其对应的像素值 <span class="math inline">\(f(w,v)\)</span>，这时需要采取插值的方式近似估计该坐标位置的像素值。</p><p>　　常用的插值方法有最近邻插值（nearest neighbor interpolation）、双线性插值（bilinear interpolation）和双三次插值（bicubic interpolation），其中双三次插值在保持图像细节方面最好，但花费时间也最多，PS 中的消除锯齿和羽化效果好像就采用了双三次插值。</p><p>　　最近邻插值只考虑相邻最近的像素，双线性插值考虑相邻的 4 个像素点，双三次插值则考虑相邻的 16 个像素点。</p><h3 id="最近邻插值">最近邻插值</h3><p>　　最近邻插值最简单，将变换后图像的坐标 <span class="math inline">\((x,y)\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)\)</span> ，直接对 <span class="math inline">\((v,w)\)</span> 进行四舍五入得到相应的整数坐标 <span class="math inline">\((⌊v+0.5⌋,⌊w+0.5⌋)\)</span><font color="#00f"><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></font>，用该整数坐标的像素值近似估计 <span class="math inline">\((v,w)\)</span> 的像素值，令 <span class="math inline">\(f(y,x)=f(⌊w+0.5⌋,⌊v+0.5⌋)\)</span> ，从而得到变换后图像每个像素点的像素值。</p><h3 id="双线性插值">双线性插值</h3><p>　　双线性插值是线性插值方法的一种扩展，它是 X 和 Y 两个方向上线性插值的组合。</p><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="270px" height="230px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="25" x2="225" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="25" y1="25" x2="25" y2="200" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="230" y="42" fill="blue">X 轴</text><text x="30" y="210" fill="blue">Y 轴</text><circle cx="60" cy="60" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="160" cy="60" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="160" cy="160" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="60" cy="160" r="3" stroke="black" stroke-width="1" fill="red"/><text x="36" y="70" fill="blue">P1</text><text x="170" y="70" fill="blue">P2</text><text x="170" y="170" fill="blue">P3</text><text x="36" y="170" fill="blue">P4</text><circle cx="100" cy="60" r="3" stroke="black" stroke-width="1" fill="blue"/><circle cx="100" cy="160" r="3" stroke="black" stroke-width="1" fill="blue"/><text x="110" y="70" fill="blue">Z1</text><text x="110" y="170" fill="blue">Z2</text><circle cx="100" cy="100" r="3" stroke="black" stroke-width="1" fill="green"/><text x="110" y="110" fill="blue">P(v,w)</text><line x1="100" y1="25" x2="100" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="100" x2="100" y2="100" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="60" y1="25" x2="60" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="160" y1="25" x2="160" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="60" x2="160" y2="60" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="160" x2="160" y2="160" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/></svg></div><p>如上图，设变换后图像的坐标 <span class="math inline">\((x,y)\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)\)</span> ，即点 <span class="math inline">\(P\)</span> 正好处于四个像素点 <span class="math inline">\(P1(v_0, w_0)\)</span>、<span class="math inline">\(P2(v_0+1, w_0)\)</span>、<span class="math inline">\(P3(v_0+1, w_0+1)\)</span>、<span class="math inline">\(P4(v_0, w_0+1)\)</span> 的中间，其中 <span class="math inline">\(v_0=⌊v⌋\)</span>，<span class="math inline">\(w_0=⌊w⌋\)</span> ，点 <span class="math inline">\(P\)</span> 对应的像素值为 <span class="math inline">\(f(P)\)</span> 因为双线性插值即在 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 两个方向进行线性插值，首先计算 <span class="math inline">\(X\)</span> 方向的插值： <span class="math display">\[ \begin{cases} \frac{f(P2)-f(P1)}{P2.x-P1.x}=\frac{f(Z1)-f(P1)}{Z1.x-P1.x} , \\ \frac{f(P3)-f(P4)}{P3.x-P4.x}=\frac{f(Z2)-f(P4)}{Z2.x-P4.x} \end{cases} \]</span> 即： <span class="math display">\[ \begin{cases} f(Z1)=\frac{Z1.x-P1.x}{P2.x-P1.x}f(P2)+\frac{P2.x-Z1.x}{P2.x-P1.x}f(P1) =(v-v_0)f(P2)+(v_0+1-v)f(P1), \\ f(Z2)=\frac{Z2.x-P4.x}{P3.x-P4.x}f(P3)+\frac{P3.x-Z2.x}{P3.x-P4.x}f(P4) =(v-v_0)f(P3)+(v_0+1-v)f(P4) \end{cases}\tag{1} \]</span> 然后计算 <span class="math inline">\(Y\)</span> 方向的插值： <span class="math display">\[ \begin{equation} \frac{f(Z2)-f(Z1)}{Z2.y-Z1.y}=\frac{f(P)-f(Z1)}{P.y-Z1.y} \end{equation} \]</span> 即： <span class="math display">\[ \begin{equation} f(P)=\frac{P.y-Z1.y}{Z2.y-Z1.y}f(Z2)+\frac{Z2.y-P.y}{Z2.y-Z1.y}f(Z1) =(w-w_0)f(Z2)+(w_0+1-w)f(Z1) \end{equation}\tag{2} \]</span> 结合式（1）和式（2）可得： <span class="math display">\[ \begin{equation} f(P)=(v_0+1-v)(w_0+1-w)f(P1)+(v-v_0)(w_0+1-w)f(P2)+(v-v_0)(w-w_0)f(P3)+(v_0+1-v)(w-w_0)f(P4) \end{equation} \]</span> 用矩阵形式可表示为： <span class="math display">\[ f(P)=\begin{bmatrix} v_0+1-v &amp; v-v_0 \end{bmatrix} \begin{bmatrix} f(P1) &amp; f(P4) \\ f(P2) &amp; f(P3) \end{bmatrix} \begin{bmatrix} (w_0+1-w) \\ (w-w_0) \end{bmatrix} \]</span> 即： <span class="math display">\[ f(y,x)=f(w,v)=\begin{bmatrix} ⌊v⌋+1-v &amp; v-⌊v⌋ \end{bmatrix} \begin{bmatrix} f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) \\ f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) \end{bmatrix} \begin{bmatrix} (⌊w⌋+1-w) \\ (w-⌊w⌋) \end{bmatrix} \]</span></p><h3 id="双三次插值">双三次插值</h3><div style="text-align:center;font-weight:700;margin:.5em auto"><svg width="270px" height="230px"><defs><marker id="arrow" markerwidth="9" markerheight="6" refx="0" refy="3" orient="auto" markerunits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#000"/></marker></defs><line x1="25" y1="25" x2="225" y2="25" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><line x1="25" y1="25" x2="25" y2="200" stroke="#000" stroke-width="1" marker-end="url(#arrow)"/><text x="230" y="42" fill="blue">X 轴</text><text x="30" y="210" fill="blue">Y 轴</text><line x1="55" y1="25" x2="55" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="85" y1="25" x2="85" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="115" y1="25" x2="115" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="145" y1="25" x2="145" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="175" y1="25" x2="175" y2="176" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="55" x2="175" y2="55" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="85" x2="175" y2="85" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="115" x2="175" y2="115" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="145" x2="175" y2="145" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><line x1="25" y1="175" x2="176" y2="175" style="stroke:#000;stroke-width:1;stroke-dasharray:3"/><circle cx="55" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="55" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="85" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="115" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="55" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="85" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="115" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><circle cx="145" cy="145" r="3" stroke="black" stroke-width="1" fill="red"/><text x="77" y="85" fill="blue">P11</text><circle cx="100" cy="100" r="3" stroke="black" stroke-width="1" fill="green"/><text x="110" y="110" fill="blue">P(v,w)</text></svg></div><p>　　如上图，双三次插值需要考虑相邻16个像素（4×4），用双三次插值重采样的图像更平滑并且更能保留图像细节，在这三种插值算法中，双三次插值效果最好，但处理速度最慢。同样设变换后图像的坐标 <span class="math inline">\((x,y)\)</span> 通过反向映射得到原图像坐标 <span class="math inline">\((v,w)\)</span> ，与其左上角相邻最近的 点P11 坐标则为 <span class="math inline">\((⌊v⌋,⌊w⌋)\)</span> ，该插值方法需要选取一个合适的插值基函数，参照维基百科 <strong>Bicubic interpolation</strong> 的一般为： <span class="math display">\[ W(x) = \begin{cases} (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{for } |x| \leq 1, \\ a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{for } 1 &lt; |x| &lt; 2, \\ 0 &amp; \text{otherwise}, \end{cases} \]</span> 其中 <span class="math inline">\(a\)</span> 一般取 -0.5 、-0.75 或 -1；则：<span class="math inline">\(f(y,x)=f(w,v)=A*B*C\)</span> ，其中： <span class="math display">\[ A=\begin{bmatrix} W( v-(⌊v⌋-1) ) &amp; W(v-⌊v⌋) &amp; W( (⌊v⌋+1)-v ) &amp; W( (⌊v⌋+2)-v ) \end{bmatrix} \\ B=\begin{bmatrix} f(⌊w⌋-1,⌊v⌋-1) &amp; f(⌊w⌋,⌊v⌋-1) &amp; f(⌊w⌋+1,⌊v⌋-1) &amp; f(⌊w⌋+2,⌊v⌋-1) \\ f(⌊w⌋-1,⌊v⌋) &amp; f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) &amp; f(⌊w⌋+2,⌊v⌋) \\ f(⌊w⌋-1,⌊v⌋+1) &amp; f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) &amp; f(⌊w⌋+2,⌊v⌋+1) \\ f(⌊w⌋-1,⌊v⌋+2) &amp; f(⌊w⌋,⌊v⌋+2) &amp; f(⌊w⌋+1,⌊v⌋+2) &amp; f(⌊w⌋+2,⌊v⌋+2) \end{bmatrix} \\ C=\begin{bmatrix} W( w-(⌊w⌋-1) ) \\ W(w-⌊w⌋) \\ W( (⌊w⌋+1)-w ) \\ W( (⌊w⌋+2)-w ) \end{bmatrix} \]</span></p><p>即：<span class="math inline">\(f(y,x)=f(w,v)= \sum\limits_{row=-1}^2\sum\limits_{col=-1}^2f(⌊w⌋+row,⌊v⌋+col)W(row-(w-⌊w⌋))W(col-(v-⌊v⌋))\)</span></p><p><strong>另附：</strong>网上也有人中间那个矩阵 <span class="math inline">\(B\)</span> 是本文中间矩阵 <span class="math inline">\(B\)</span> 的转置，经过下文实践，感觉效果差不多，但从理论上来说，应该本文这样写才是对的吧🤔。</p><h2 id="实践篇">实践篇</h2><p>　　本次实践采用 Matlab R2016b，具体 matlab 实现代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">clc;clear;close all;</div><div class="line"></div><div class="line">img = imread(<span class="string">'lena_gray.jpg'</span>); <span class="comment">% 读取图像</span></div><div class="line">[R, C] = <span class="built_in">size</span>(img); <span class="comment">% 获取图像大小</span></div><div class="line"></div><div class="line">theta = <span class="number">45</span> * <span class="built_in">pi</span> / <span class="number">180.0</span>; <span class="comment">% 旋转角度</span></div><div class="line">H = <span class="built_in">ceil</span>(<span class="built_in">abs</span>(R*<span class="built_in">cos</span>(theta)) + <span class="built_in">abs</span>(C*<span class="built_in">sin</span>(theta)));    <span class="comment">% 变换后图像的高度</span></div><div class="line">W = <span class="built_in">ceil</span>(<span class="built_in">abs</span>(C*<span class="built_in">cos</span>(theta)) + <span class="built_in">abs</span>(R*<span class="built_in">sin</span>(theta)));    <span class="comment">% 变换后图像的宽度</span></div><div class="line">res = <span class="built_in">zeros</span>(H, W);   <span class="comment">% 构造结果矩阵。每个像素点默认初始化为0（黑色）</span></div><div class="line"></div><div class="line">T1 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>; <span class="number">-0.5</span>*C <span class="number">0.5</span>*R <span class="number">1</span>];   <span class="comment">% 将原图像坐标映射到数学笛卡尔坐标</span></div><div class="line">T2 = [cos(theta) -sin(theta) <span class="number">0</span>; sin(theta) cos(theta) <span class="number">0</span>; <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];    <span class="comment">% 数学笛卡尔坐标下顺时针旋转的变换矩阵</span></div><div class="line">T3 = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>; <span class="number">0.5</span>*W <span class="number">0.5</span>*H <span class="number">1</span>];    <span class="comment">% 将数学笛卡尔坐标映射到旋转后的图像坐标</span></div><div class="line">T = T1*T2*T3;</div><div class="line">inv_T = inv(T);    <span class="comment">% 求逆矩阵</span></div><div class="line"><span class="comment">% inv_T = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; -0.5*W*cos(theta)-0.5*H*sin(theta)+0.5*C 0.5*W*sin(theta)-0.5*H*cos(theta)+0.5*R 1];</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> y = <span class="number">1</span> : H   <span class="comment">% 变换后图像的纵坐标，行，高</span></div><div class="line">    <span class="keyword">for</span> x = <span class="number">1</span> : W   <span class="comment">% 变换后图像的横坐标，列，宽</span></div><div class="line">        original_coordinate = [x y <span class="number">1</span>] * inv_T; <span class="comment">% 矩阵乘法</span></div><div class="line">        v = original_coordinate(<span class="number">1</span>);    <span class="comment">% 原图像的横坐标，列，宽</span></div><div class="line">        w = original_coordinate(<span class="number">2</span>);    <span class="comment">% 原图像的纵坐标，行，高</span></div><div class="line">        <span class="comment">% 变换后的位置判断是否越界</span></div><div class="line">        <span class="keyword">if</span> v&gt;=<span class="number">1</span> &amp;&amp; w&gt;=<span class="number">1</span> &amp;&amp; v&lt;=C &amp;&amp; w&lt;=R</div><div class="line">            res(y, x) = img(<span class="built_in">round</span>(w), <span class="built_in">round</span>(v));  <span class="comment">% 用原图像对应坐标的像素值填充变换后的图像（最邻近插值）</span></div><div class="line">            </div><div class="line">            <span class="comment">% ------------- 双线性插值（bilinear interpolation）-----------------</span></div><div class="line">            left = <span class="built_in">floor</span>(v); right = <span class="built_in">ceil</span>(v); top = <span class="built_in">floor</span>(w); bottom = <span class="built_in">ceil</span>(w);</div><div class="line">            dC = v-left;   <span class="comment">% 列偏差</span></div><div class="line">            dR = w-top;    <span class="comment">% 行偏差</span></div><div class="line">            res(y, x) = (<span class="number">1</span>-dC)*(<span class="number">1</span>-dR)*img(top, left) + dC*(<span class="number">1</span>-dR)*img(top,right) + (<span class="number">1</span>-dC)*dR*img(bottom, left) + dC*dR*img(bottom, right); </div><div class="line">            </div><div class="line">            <span class="comment">% ------------- 双三次插值（bicubic interpolation） -------------------------</span></div><div class="line">        <span class="keyword">if</span> left&gt;=<span class="number">2</span> &amp;&amp; top&gt;=<span class="number">2</span> &amp;&amp; left&lt;=(C<span class="number">-2</span>) &amp;&amp; top&lt;=(R<span class="number">-2</span>)</div><div class="line">            img = double(img);</div><div class="line">            MA = [bicubic(<span class="number">1</span>+dC) bicubic(dC) bicubic(<span class="number">1</span>-dC) bicubic(<span class="number">2</span>-dC)];</div><div class="line">            MB = [img(top<span class="number">-1</span>,left<span class="number">-1</span>) img(top,left<span class="number">-1</span>) img(top+<span class="number">1</span>,left<span class="number">-1</span>) img(top+<span class="number">2</span>,left<span class="number">-1</span>);</div><div class="line">                 img(top<span class="number">-1</span>,left) img(top,left) img(top+<span class="number">1</span>,left) img(top+<span class="number">2</span>,left);</div><div class="line">                 img(top<span class="number">-1</span>,left+<span class="number">1</span>) img(top,left+<span class="number">1</span>) img(top+<span class="number">1</span>,left+<span class="number">1</span>) img(top+<span class="number">2</span>,left+<span class="number">1</span>);</div><div class="line">                 img(top<span class="number">-1</span>,left+<span class="number">2</span>) img(top,left+<span class="number">2</span>) img(top+<span class="number">1</span>,left+<span class="number">2</span>) img(top+<span class="number">2</span>,left+<span class="number">2</span>)];</div><div class="line">            <span class="comment">% MB = MB';    % 求转置矩阵</span></div><div class="line">            MC = [bicubic(<span class="number">1</span>+dR); bicubic(dR); bicubic(<span class="number">1</span>-dR); bicubic(<span class="number">2</span>-dR)];</div><div class="line">            res(y, x) = MA*MB*MC;</div><div class="line">        <span class="keyword">end</span></div><div class="line">        <span class="keyword">end</span></div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span>;</div><div class="line"></div><div class="line">figure, imshow(uint8(res)); <span class="comment">% 显示图像</span></div></pre></td></tr></table></figure><p>BiCubic 基函数 Matlab 代码为：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">W</span> = <span class="title">bicubic</span><span class="params">(x)</span></span></div><div class="line"><span class="comment">%bicubic 双三次插值基函数</span></div><div class="line">a = <span class="number">-1</span>; <span class="comment">% 默认取a为-1</span></div><div class="line">x1 = <span class="built_in">abs</span>(x);</div><div class="line">x2 = x1*x1;</div><div class="line">x3 = x1*x2; </div><div class="line"></div><div class="line"><span class="keyword">if</span> x1 &lt;= <span class="number">1</span></div><div class="line">   W = <span class="number">1</span> - (a+<span class="number">3</span>)*x2 + (a+<span class="number">2</span>)*x3;</div><div class="line"><span class="keyword">elseif</span> x1&gt;<span class="number">1</span> &amp;&amp; x1&lt;=<span class="number">2</span></div><div class="line">   W = <span class="number">-4</span>*a + <span class="number">8</span>*a*x1 - <span class="number">5</span>*a*x2 + a*x3;</div><div class="line"><span class="keyword">else</span> </div><div class="line">   W = <span class="number">0</span>;</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure><p>　　旋转变换中感觉插值的作用没体现出来，以肉眼来看感觉三种插值方法的效果差不多，可能是本人选取的示例不好，为了体现插值效果，应该采用尺度变换（缩放变换）的。以上代码改为尺度变换也简单，自定义图像缩放后的宽高，以两倍为例，<code>H = R * 2; W = C * 2;</code>，再将旋转变换矩阵改为尺度变换矩阵，尺度变换矩阵中 <span class="math inline">\(c_x=W/C；c_y=H/R\)</span>。</p><p>为了便于理解，本人对代码就不进行优化了（其实是你懒吧 _(:з」∠)_）。</p><h2 id="后记">后记</h2><p>　　本文算是数字图像处理中最基础的知识了，但本人在写时还是查阅了大量相关的资料，有些地方理解的还不是很透彻，行文思路有点混乱 ╮(╯▽╰)╭。本来是不想使用图片的，但本文不用图片很难理解清楚，又为了不使用外部图，最后只得参考 <a href="http://www.runoob.com/svg/svg-tutorial.html" target="_blank" rel="external">SVG 教程</a> 和 <a href="https://www.w3cplus.com/svg/svg-markers.html" target="_blank" rel="external">如何创建SVG箭头和polymarker——<code>marker</code>元素</a> 采用 SVG 绘制相应图片了。等有时间再把用 OpenCV 实现的 C++ 代码也贴上吧。最后再感叹一下 Matlab 确实是做科研的好工具（°Д°）Ъ，<del>吐槽一下 <em>MathJax</em> 排版好痛苦啊，太多需要转义符<code>\</code>的地方了吧。</del>，搞错了 Σ(ﾟдﾟ;)，这主要和 markdown 渲染有关，hexo 默认的 markdown 渲染插件 hexo-renderer-marked 太普通了，有些东西根本没办法渲染或者渲染有问题 （╯‵□′）╯︵┴─┴，本人最后决定使用 hexo-renderer-pandoc 插件渲染 markdown，这样就完美了 (๑•̀ㅂ•́)و✧ 。</p><h2 id="附录">附录</h2><p>　　挖的坑总是要填的，呐，这就是用 OpenCV 实现的旋转变换，实现语言为 C++ ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M_PI       3.14159265358979323846</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">bicubic</span><span class="params">(<span class="keyword">double</span> x)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// bicubic 双三次插值基函数</span></div><div class="line">	<span class="keyword">int</span> a = <span class="number">-1</span>;	<span class="comment">// 默认取a为 - 1</span></div><div class="line">	<span class="keyword">double</span> x1 = <span class="built_in">fabs</span>(x);</div><div class="line">	<span class="keyword">double</span> x2 = x1*x1;</div><div class="line">	<span class="keyword">double</span> x3 = x1*x2;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (x1 &lt;= <span class="number">1</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">1</span> - (a + <span class="number">3</span>)*x2 + (a + <span class="number">2</span>)*x3;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (x1 &gt; <span class="number">1</span> &amp;&amp; x1 &lt;= <span class="number">2</span>)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-4</span> * a + <span class="number">8</span> * a*x1 - <span class="number">5</span> * a*x2 + a*x3;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat img = cv::imread(<span class="string">"../Data/lena_gray.jpg"</span>, <span class="number">0</span>);	<span class="comment">// 以灰度模式读取图片</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> R = img.rows;	<span class="comment">// 获取原图像高度</span></div><div class="line">	<span class="keyword">int</span> C = img.cols;	<span class="comment">// 获取原图像宽度</span></div><div class="line"></div><div class="line">	<span class="keyword">double</span> theta = <span class="number">45</span> * M_PI / <span class="number">180.0</span>;	<span class="comment">// 旋转角度</span></div><div class="line"></div><div class="line">	<span class="keyword">int</span> H = <span class="built_in">ceil</span>(<span class="built_in">fabs</span>(R*<span class="built_in">cos</span>(theta)) + <span class="built_in">fabs</span>(C*<span class="built_in">sin</span>(theta)));	<span class="comment">// 变换后图像的高度</span></div><div class="line">	<span class="keyword">int</span> W = <span class="built_in">ceil</span>(<span class="built_in">fabs</span>(C*<span class="built_in">cos</span>(theta)) + <span class="built_in">fabs</span>(R*<span class="built_in">sin</span>(theta)));	<span class="comment">// 变换后图像的宽度</span></div><div class="line"></div><div class="line">	cv::Mat res = cv::Mat::zeros(H, W, CV_8UC1);	<span class="comment">// 构造结果矩阵。每个像素点默认初始化为0（黑色）	</span></div><div class="line"></div><div class="line">	cv::Mat T1 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">-0.5</span>*C, <span class="number">0.5</span>*R, <span class="number">1</span>);	<span class="comment">// 将原图像坐标映射到数学笛卡尔坐标</span></div><div class="line">	cv::Mat T2 = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">3</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">cos</span>(theta), -<span class="built_in">sin</span>(theta), <span class="number">0</span>, <span class="built_in">sin</span>(theta), <span class="built_in">cos</span>(theta), <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 数学笛卡尔坐标下顺时针旋转的变换矩阵</span></div><div class="line">	<span class="keyword">double</span> t3[<span class="number">3</span>][<span class="number">3</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span> &#125;, &#123; <span class="number">0.5</span>*W, <span class="number">0.5</span>*H, <span class="number">1</span> &#125; &#125;;	<span class="comment">// 将数学笛卡尔坐标映射到旋转后的图像坐标</span></div><div class="line">	cv::Mat T3 = cv::Mat(<span class="number">3</span>, <span class="number">3</span>, CV_64FC1, t3);</div><div class="line">	cv::Mat T = T1*T2*T3;</div><div class="line">	cv::Mat inv_T = T.inv();	<span class="comment">// 求逆矩阵</span></div><div class="line">	<span class="comment">//cv::Mat inv_T = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, -0.5*W*cos(theta) - 0.5*H*sin(theta) + 0.5*C, 0.5*W*sin(theta) - 0.5*H*cos(theta) + 0.5*R, 1);</span></div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; H; y++)</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; W; x++)</div><div class="line">		&#123;</div><div class="line">			cv::Mat point = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">3</span>) &lt;&lt; x, y, <span class="number">1</span>);</div><div class="line">			cv::Mat original_coordinate = point * inv_T;	<span class="comment">// 矩阵乘法</span></div><div class="line">			<span class="keyword">double</span> v = original_coordinate.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>);	<span class="comment">// 原图像的横坐标，列，宽</span></div><div class="line">			<span class="keyword">double</span> w = original_coordinate.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">1</span>);	<span class="comment">// 原图像的纵坐标，行，高</span></div><div class="line"></div><div class="line">			<span class="comment">// 变换后的位置判断是否越界</span></div><div class="line">			<span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; w &gt;= <span class="number">0</span> &amp;&amp; v &lt;= C - <span class="number">1</span> &amp;&amp; w &lt;= R - <span class="number">1</span>)</div><div class="line">			&#123;</div><div class="line">				res.at&lt;uchar&gt;(y, x) = img.at&lt;uchar&gt;(round(w), round(v));	<span class="comment">// 用原图像对应坐标的像素值填充变换后的图像（最邻近插值）</span></div><div class="line">				</div><div class="line">				<span class="comment">// ------------ - 双线性插值（bilinear interpolation）---------------- -</span></div><div class="line">				<span class="keyword">int</span> left = <span class="built_in">floor</span>(v), right = <span class="built_in">ceil</span>(v), top = <span class="built_in">floor</span>(w), bottom = <span class="built_in">ceil</span>(w);</div><div class="line">				<span class="keyword">double</span> dC = v - left;	<span class="comment">// 列偏差</span></div><div class="line">				<span class="keyword">double</span> dR = w - top;	<span class="comment">// 行偏差</span></div><div class="line">				res.at&lt;uchar&gt;(y, x) = (<span class="number">1</span> - dC)*(<span class="number">1</span> - dR)*img.at&lt;uchar&gt;(top, left) + dC*(<span class="number">1</span> - dR)*img.at&lt;uchar&gt;(top, right) + (<span class="number">1</span> - dC)*dR*img.at&lt;uchar&gt;(bottom, left) + dC*dR*img.at&lt;uchar&gt;(bottom, right);</div><div class="line">			</div><div class="line">				<span class="comment">// ------------ - 双三次插值（bicubic interpolation）------------------------ -</span></div><div class="line">				<span class="keyword">if</span> (left &gt;= <span class="number">1</span> &amp;&amp; top &gt;= <span class="number">1</span> &amp;&amp; left &lt;= (C - <span class="number">3</span>) &amp;&amp; top &lt;= (R - <span class="number">3</span>))</div><div class="line">				&#123;</div><div class="line">					cv::Mat MA = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">1</span>, <span class="number">4</span>) &lt;&lt; bicubic(<span class="number">1</span> + dC), bicubic(dC), bicubic(<span class="number">1</span> - dC), bicubic(<span class="number">2</span> - dC));</div><div class="line">					cv::Mat MB = img(cv::Rect(left - <span class="number">1</span>, top - <span class="number">1</span>, <span class="number">4</span>, <span class="number">4</span>));	<span class="comment">// 提取当前相邻区域16个像素点做插值</span></div><div class="line">					MB.convertTo(MB, CV_64FC1);	<span class="comment">// 变换为浮点型数据</span></div><div class="line">					MB = MB.t();	<span class="comment">// 求转置矩阵</span></div><div class="line">					cv::Mat MC = (cv::Mat_&lt;<span class="keyword">double</span>&gt;(<span class="number">4</span>, <span class="number">1</span>) &lt;&lt; bicubic(<span class="number">1</span> + dR), bicubic(dR), bicubic(<span class="number">1</span> - dR), bicubic(<span class="number">2</span> - dR));</div><div class="line">					cv::Mat result = MA*MB*MC;</div><div class="line">					res.at&lt;uchar&gt;(y, x) = <span class="keyword">static_cast</span>&lt;uchar&gt;(result.at&lt;<span class="keyword">double</span>&gt;(<span class="number">0</span>, <span class="number">0</span>));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	cv::imshow(<span class="string">"result"</span>, res);	<span class="comment">// 显示变换后图像</span></div><div class="line">	cv::waitKey(<span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　以上 C++ 代码在 VS2013 下能完美运行，不管是用 OpenCV-2.4.11 还是 OpenCV-3.2.0。其实完全理解的话，不管用什么工具都能实现，只是看哪个工具方便一点而已，就这个而言，感觉 Matlab 要方便很多，本人就不继续挖 Python 的坑了，毕竟如果要用 Python 实现其实还是用 OpenCV，只是用 OpenCV Python 版的接口而已。</p><h2 id="参考资料">参考资料</h2><p>[１] <a href="https://wenku.baidu.com/view/e94cfa2d336c1eb91a375dab.html" target="_blank" rel="external">第4章 图像几何变换</a></p><p>[２] <a href="http://blog.csdn.net/lkj345/article/details/50555870" target="_blank" rel="external">图像旋转原理及实现</a></p><p>[３] <a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/warp_affine/warp_affine.html#warp-affine" target="_blank" rel="external">仿射变换</a>（<a href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html" class="uri" target="_blank" rel="external">http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html</a>）</p><p>[４] <a href="http://blog.csdn.net/augusdi/article/details/9028365" target="_blank" rel="external">图像处理常用插值方法总结</a></p><p>[５] <a href="https://en.wikipedia.org/wiki/Bilinear_interpolation" target="_blank" rel="external"><strong>Wikipedia Bilinear interpolation</strong></a></p><p>[６] <a href="http://blog.csdn.net/xjz18298268521/article/details/51220576" target="_blank" rel="external">双线性插值算法的详细总结</a></p><p>[７] <a href="https://en.wikipedia.org/wiki/Bicubic_interpolation" target="_blank" rel="external"><strong>Wikipedia Bicubic interpolation</strong></a></p><p>[８] <a href="https://wenku.baidu.com/view/34dea625192e45361166f504.html?qq-pf-to=pcqq.c2c" target="_blank" rel="external">双三次插值(bicubic interpolation)原理及MATLAB源码实现</a></p><p>[９] <a href="https://dailc.github.io/2017/11/01/imageprocess_bicubicinterpolation.html" target="_blank" rel="external">图像缩放】双立方（三次）卷积插值</a>（<a href="https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95" target="_blank" rel="external">https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95</a>）</p><section class="footnotes"><hr><ol><li id="fn1"><p><font color="#FA8072">为啥不说前向映射呢？这是因为若原图像坐标 <span class="math inline">\((v,w)\)</span> 通过前向映射方式得到变换后图像的坐标 <span class="math inline">\((x,y)\)</span> ，而且这个坐标为小数的话，一般采用四舍五入的方式得到变换后图像对应的整数坐标 <span class="math inline">\((⌊x+0.5⌋,⌊y+0.5⌋)\)</span>，令 <span class="math inline">\(f(⌊y+0.5⌋,⌊x+0.5⌋)=f(w,v)\)</span> 。</font><a href="#fnref1" class="footnote-back">↩</a></p></li><li id="fn2"><p><font color="#FA8072"><span class="math inline">\(⌊x⌋\)</span> 表示向下取整，称为 Floor，指的是小于或等于 <span class="math inline">\(x\)</span> 的最大整数；<span class="math inline">\(⌈x⌉\)</span> 表示向上取整，称为 Ceil，指的是大于或等于 <span class="math inline">\(x\)</span> 的最小整数，<span class="math inline">\(eg：⌊5.6⌋ = 5，⌊-5.6⌋ = -6；⌈5.6⌉ = 6，⌈-5.6⌉ = -5。\)</span></font><a href="#fnref2" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，本人这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
      <category term="DigitalImageProcessing" scheme="http://cniter.github.io/categories/Study/DigitalImageProcessing/"/>
    
    
      <category term="matlab" scheme="http://cniter.github.io/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>本人常用小工具安利</title>
    <link href="http://cniter.github.io/posts/aef52be2.html"/>
    <id>http://cniter.github.io/posts/aef52be2.html</id>
    <published>2017-12-17T12:18:50.000Z</published>
    <updated>2018-04-10T08:20:54.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　由于本人目前使用最多的是 Windows 系统，所以以下推荐的软件基本都是 Windows 下的软件，全凭本人主观感觉推荐，也算是个人备份吧。</p><p>　　首先推荐的自然是装机软件 <a href="https://www.ezbsystems.com/ultraiso/download.htm" target="_blank" rel="external"><strong>ULTRAISO</strong></a>，下个绿色版就好，只有 1M 多一点 或者 <a href="https://github.com/pbatard/rufus" target="_blank" rel="external"><strong>Rufus</strong></a> 好像也不错。下载 Windows 镜像的地方推荐为：<a href="https://msdn.itellyou.cn/" target="_blank" rel="external"><strong>MSDN，I Tell You</strong></a>。接下来就是正式的软件推荐篇了：</p><a id="more"></a><h2 id="大众篇">大众篇</h2><p>　　首先推荐浏览器：首选的自然是 <a href="https://www.google.com/chrome/browser/thankyou.html?standalone=1&amp;statcb=1&amp;installdataindex=defaultbrowser" target="_blank" rel="external"><strong>Chrome</strong></a> 和 <a href="http://www.firefox.com.cn/download/#more" target="_blank" rel="external"><strong>Firefox</strong></a>，还有一个比较偏门的是 <a href="https://www.torproject.org/projects/torbrowser.html.en" target="_blank" rel="external"><strong>Tor Browser</strong></a>（如果在一些特殊时段，各种番（fang）茄（qiang）工具都失效的情况下，这个可以临时用用）。推荐完浏览器，自然也要玩浏览器，</p><p>这里极为推荐的是脚本管理插件：<a href="http://tampermonkey.net/" target="_blank" rel="external"><strong>Tampermonkey</strong></a>（支持多种浏览器），有 Tampermonkey 和没 Tampermonkey 是两种浏览体验，会用 Tampermonkey 和没用 Tampermonkey 的是两个世界的人（ᖗ乛◡乛ᖘ），除了 Tampermonkey，使用 <a href="https://userstyles.org/" target="_blank" rel="external">Stylish</a> 插件也还可以，Tampermonkey 是通过 Javascript 改变浏览器，而 Stylish 是通过 CSS 改变浏览器，这两者本人选择 Tampermonkey，所以顺便推荐几个常用的脚本：1、<a href="https://greasyfork.org/zh-CN/scripts/14716-%E6%8A%A4%E7%9C%BC%E8%84%9A%E6%9C%AC" target="_blank" rel="external">护眼脚本</a>；2、<a href="https://greasyfork.org/zh-CN/scripts/10433-super-preloaderplus-one/code" target="_blank" rel="external">Super_preloaderPlus_one</a>；3、<a href="https://greasyfork.org/zh-CN/scripts/17800-%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E4%BA%91%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%99%90%E5%88%B6" target="_blank" rel="external">解除百度云大文件下载限制</a>（这个配合 IDM 食用效果最佳）；4、<a href="https://greasyfork.org/zh-CN/scripts/26992-%E8%B4%B4%E5%90%A7%E5%85%A8%E8%83%BD%E5%8A%A9%E6%89%8B" target="_blank" rel="external">贴吧全能助手</a>；5、<a href="https://greasyfork.org/zh-CN/scripts/36384-%E7%A0%B4%E8%A7%A3vip%E4%BC%9A%E5%91%98%E8%A7%86%E9%A2%91%E9%9B%86%E5%90%88" target="_blank" rel="external">破解VIP会员视频集合</a>；6、<a href="https://greasyfork.org/zh-CN/scripts/27116-cat-mouse-translation" target="_blank" rel="external">Cat Mouse Translation</a>；7、<a href="https://greasyfork.org/zh-CN/scripts/25718-%E8%A7%A3%E9%99%A4b%E7%AB%99%E5%8C%BA%E5%9F%9F%E9%99%90%E5%88%B6" target="_blank" rel="external">解除B站区域限制</a>；8、<a href="https://greasyfork.org/zh-CN/scripts/30879-bye-flash-hello-html5-%E5%86%8D%E8%A7%81flash-%E4%BD%A0%E5%A5%BDhtml5" target="_blank" rel="external">bye-flash-hello-html5 | 再见flash 你好html5</a>；９、<a href="https://greasyfork.org/zh-CN/scripts/28497-remove-web-limits" target="_blank" rel="external">网页限制解除(改)</a>。再顺便说一下这两个浏览器中一些比较好用的插件和好看的主题吧。</p><p>Firefox 最新版的插件本人目前还没发现几个好用的，但是 <a href="https://adblockplus.org/" target="_blank" rel="external">Adblock Plus</a> 绝对是必须要装的，Firefox 的主题本人目前在用为 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/blue-space-2/" target="_blank" rel="external">Blue space 2</a> ；</p><p>而 Chrome 中好用的插件就有很多了，首先自然也是 Adblock Plus，有一个 <a href="http://autopagerize.net/" target="_blank" rel="external">AutoPagerize</a> 插件可以替代 Super_preloaderPlus_one 脚本，还有一个 <a href="https://chrome.google.com/webstore/detail/%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/ikhdkkncnoglghljlkmcimlnlhkeamad?hl=zh-CN" target="_blank" rel="external">划词翻译</a> 可以替换 Cat Mouse Translation 脚本，由于 Chrome 没有撤销关闭的标签按钮，只能通过快捷键 Crtl+Shift+T 操作，对于本人这种习惯用 Firefox 恢复按钮的人来说这很不人性化，所以只能使用 <a href="https://chrome.google.com/webstore/detail/simpleundoclose/emhohdghchmjepmigjojkehidlielknj?hl=zh-CN" target="_blank" rel="external">SimpleUndoClose</a> 插件来代替了，当然番茄之所以推荐使用 Chrome 有很大一部分原因在于 Chrome 中有一代理神器 <a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?hl=zh-CN" target="_blank" rel="external">Proxy SwitchyOmega</a>，好像也正在开发 Firefox 版的 Proxy SwitchyOmega，已经在 Firefox 测试版上使用了，Chrome 的主题本人目前在用的为 <a href="https://chrome.google.com/webstore/detail/blue-space-sunset-chrome/nndfdjfoclbidmgpmbelcieibgjjfdog" target="_blank" rel="external">Blue Space Sunset Chrome Theme</a> ，浏览器相关的东西就推荐到这里了，接下来推荐下载工具吧。</p><p>附浏览器使用小技巧，有时点击链接不会新建标签页，只是在原标签页刷新，这不符合国人的使用习惯，这时可按住 Crtl 键再点击链接，这时会强制使用新标签页打开链接。</p><p>　　下载工具首推的自然是 <a href="https://www.internetdownloadmanager.com/download.html" target="_blank" rel="external"><strong>IDM</strong></a>，全称是：Internet Download Manager；种子和磁力链接的下载工具推荐 <a href="http://www.utorrent.com/intl/zh/" target="_blank" rel="external"><strong>μtorrent</strong></a> 或者 <a href="http://www.bittorrent.com/bittorrent-free" target="_blank" rel="external"><strong>BitTorrent</strong></a>，好像还有一个 <a href="https://www.qbittorrent.org/download.php" target="_blank" rel="external"><strong>qBittorrent</strong></a> ；至于迅雷，勉强推荐个极速版吧，最后一版为 ThunderSpeed1.0.35.366。还有一款免费的下载工具 <a href="https://www.freedownloadmanager.org/" target="_blank" rel="external">Free Download Manager</a> 也还不错，可以一定程度上替代 IDM。</p><p>　　解压缩工具首推的是 <a href="https://www.bandisoft.com/bandizip/cn/" target="_blank" rel="external"><strong>Bandizip</strong></a>（ta家的图片浏览器 <a href="https://www.bandisoft.com/honeyview/" target="_blank" rel="external"><strong>Honeyview</strong></a> 也还不错），其次 <a href="http://www.7-zip.org/" target="_blank" rel="external"><strong>7-Zip</strong></a>，最后是 <a href="https://www.win-rar.com/download.html" target="_blank" rel="external"><strong>WinRAR</strong></a>（主要是最近版本的广告太恼火，好像 5.2 版本没广告），BTW：IDM 下载百度云的大文件可能会造成部分文件损坏，这时可能需要 WinRAR 的修复工具去修复受损的压缩文件（具体操作为用 WinRAR 打开损坏的压缩文件，选中菜单栏的“<strong>工具</strong>”==》“<strong>修复压缩文件</strong>”），才能解压出正常文件。※附：</p><blockquote><p>其实 WinRAR 官方也有无广告版的，只是下载链接被隐藏，这位大佬：<a href="http://blog.sina.com.cn/cuibin903" target="_blank" rel="external"><strong>武文隹山</strong></a>发现了，具体可参考：</p><ol type="1"><li><p><a href="http://blog.sina.com.cn/s/blog_4155bb1d0102x5dh.html" target="_blank" rel="external">WinRAR官方不带弹窗广告的简体中文版</a>，其隐藏的链接为：</p><blockquote><p>WinRAR5.4官方无广告简体中文版64位 <a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exe" target="_blank" rel="external">下载链接</a>：</p><p><a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exe" class="uri" target="_blank" rel="external">http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exe</a></p><p>WinRAR5.4官方无广告简体中文版32位 <a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exe" target="_blank" rel="external">下载链接</a>：</p><p><a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exe" class="uri" target="_blank" rel="external">http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exe</a></p></blockquote></li><li><p><a href="http://blog.sina.com.cn/s/blog_4155bb1d0102xxmr.html" target="_blank" rel="external">WinRAR5.5官方不带弹窗广告的简体中文版</a>，具体链接为：</p><blockquote><p>WinRAR v5.50 简体中文官方版（试用版，注册后没有广告弹窗！）</p><p>32位：<a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/wrar550sc.exe" class="uri" target="_blank" rel="external">http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/wrar550sc.exe</a></p><p>64位：<a href="http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/winrar-x64-550sc.exe" class="uri" target="_blank" rel="external">http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/winrar-x64-550sc.exe</a></p></blockquote><p>列位看官应该从下载链接中发现了其中的规律（๑乛◡乛๑）。</p></li></ol></blockquote><p>　　拼音输入法，本人使用的是 <a href="https://pinyin.sogou.com/zhihui/" target="_blank" rel="external"><strong>搜狗拼音智慧版</strong></a>，搜狗拼音的皮肤本人选择 <a href="https://pinyin.sogou.com/skins/detail/view/info/418138" target="_blank" rel="external">雨后莲色</a>，不过有人说 Win10 自带的微软拼音也还行。</p><p>　　至于清理垃圾的可以用 <a href="https://www.iobit.com/en/advancedsystemcarefree.php" target="_blank" rel="external"><strong>Advanced SystemCare</strong></a>（ASC），也可以用 <a href="https://www.piriform.com/ccleaner/download" target="_blank" rel="external"><strong>CCleaner</strong></a> ，至于 Win10 不需要装杀毒软件，国内的的什么 360 全家桶、百度全家桶、腾讯全家桶（诶，好像就差阿里全家桶了，什么时候阿里再来一个，就装个 BAT 全家桶 （๑乛◡乛๑））可以丢了 （(╯°□°）╯︵ ┻━┻）。</p><p>　　QQ 还是用 <a href="https://tim.qq.com/" target="_blank" rel="external"><strong>TIM</strong></a> 版吧。</p><p>　　播放器推荐的是 <a href="https://potplayer.daum.net/" target="_blank" rel="external"><strong>Potplayer</strong></a>。不过有一款解码工具叫 <a href="https://tieba.baidu.com/f?kw=%E7%BB%88%E6%9E%81%E8%A7%A3%E7%A0%81&amp;ie=utf-8" target="_blank" rel="external"><strong>终极解码</strong></a>，可以充当播放器（很多人确实把它当播放器用，比如本人（๑乛◡乛๑））。</p><p>　　音乐软件本人用 <a href="https://music.163.com/" target="_blank" rel="external">网易云音乐</a>（等升到 10 级就把它卸了，只听本地音乐）。</p><p>　　PDF 阅读器还是推荐 <a href="https://acrobat.adobe.com/cn/zh-Hans/free-trial-download.html" target="_blank" rel="external"><strong>Adobe Acrobat_DC</strong></a>，毕竟能和 Office 联合使用，有时 Word 转 PDF 需要加密就靠它了。</p><p>　　截图工具推荐 <a href="http://www.faststone.org/download.htm" target="_blank" rel="external"><strong>FastStone Capture</strong></a>（<em>FSCapture</em>），国人的 <a href="https://zh.snipaste.com/index.html" target="_blank" rel="external">Snipaste</a> 也非常不错。</p><h2 id="小众篇">小众篇</h2><p>　　远程控制工具当然推荐 <a href="https://www.teamviewer.com/zhCN/" target="_blank" rel="external"><strong>TeamViewer</strong></a>。</p><p>　　文件管理相关强推 搜索工具 <a href="https://www.voidtools.com/downloads/" target="_blank" rel="external"><strong>Everything</strong></a> 和文件资源管理器（即 Windows 快捷键「<strong>Win+E</strong>」打开的「<strong>我的电脑</strong>」）增强工具 <a href="http://www.listary.com/" target="_blank" rel="external"><strong>Listary</strong></a> ，这两个工具有重叠的地方，如果硬要只装一个的话推荐后者。还有一个文件管理器增强工具 <a href="http://qttabbar.wikidot.com/" target="_blank" rel="external">QTTabBar</a> ，可以为文件管理器增加标签页，类似于浏览器标签页那种，当然还有其它一些功能。</p><p><strong><em>再推荐一些程序员的工具吧。</em></strong></p><p>　　首先当然是编辑器（可别和编译器搞混了），本人就不加入 Vim 和 Emacs 的党争了，就直接推荐 <a href="https://code.visualstudio.com/" target="_blank" rel="external"><strong>VS Code</strong></a>吧（巨硬出品，必属精品（^_^））。</p><p>　　Windows 下的命令行没一个好用的，要真矮子里面挑高个的话，只能推荐 <a href="https://git-scm.com/downloads" target="_blank" rel="external"><strong>Git Bash</strong></a> 了，其实以前有个 Babun 也挺好用的，可惜早已停止更新。</p><p>　　Markdown 编辑器推荐的是 <a href="https://typora.io/#download" target="_blank" rel="external"><strong>Typora</strong></a>，不过现在还是 Beta 版，也还能使用，期待正式版，希望到时即使收费的话也能继续推出一个免费版。（推出正式版看看效果怎么样吧，如果真的很不错就去支持一下，如果改进不大的话我还是老老实实继续用 beta 版吧）。</p><p>　　在 VS 下写 C++ 自然少不了 <a href="https://www.wholetomato.com/" target="_blank" rel="external"><strong>Visual Assist X</strong></a> 这款插件，用 OpenCV 的自然少不了 <a href="https://marketplace.visualstudio.com/items?itemName=WolfKienzle.ImageWatch" target="_blank" rel="external"><strong>ImageWatch</strong></a>（ <a href="https://marketplace.visualstudio.com/items?itemName=VisualCPPTeam.ImageWatch2017" target="_blank" rel="external">VS2017版ImageWatch</a> ）这款神器。</p><p>　　编程的字体本人目前在用是 <a href="http://www.vimer.cn/wp-content/uploads/2009/11/arimonnew.ttf" target="_blank" rel="external"><strong>Arial monospaced for SAP(优化版)</strong></a>（<a href="http://www.vimer.cn/archives/396.html/comment-page-1" class="uri" target="_blank" rel="external">http://www.vimer.cn/archives/396.html/comment-page-1</a>），背景颜色使用护眼色：R: 204，B: 207，G: 232。</p><p>　　代理工具：本人使用的是 <a href="https://github.com/XX-net/XX-Net" target="_blank" rel="external"><strong>XX-Net</strong></a> 和 <a href="https://getlantern.org/zh_CN/" target="_blank" rel="external"><strong>Lantern</strong></a>，非特殊情况还是很好用的，还有比较推荐的是 <a href="https://psiphon3.com/zh/download.html" target="_blank" rel="external">赛风</a>。</p><h2 id="偏门篇">偏门篇</h2><p>　　鼠标手势软件 <a href="http://www.yingdev.com/projects/wgestures" target="_blank" rel="external"><strong>WGestures</strong></a>，可以利用鼠标手势做一些前进后退，复制粘贴搜索等简单操作。</p><p>　　<a href="http://www.yingdev.com/projects/tickeys" target="_blank" rel="external"><strong>Tickeys</strong></a>，让打字发出音效。</p><p>　　Windows 系统优（mei）化工具 <a href="http://www.chuyu.me/zh-Hans/index.html" target="_blank" rel="external"><strong>Dism++</strong></a> ，桌面美化工具可以用雨滴桌面 <a href="https://www.rainmeter.net/" target="_blank" rel="external"><strong>Rainmeter</strong></a>，或<a href="http://mofang.ruanmei.com/" target="_blank" rel="external">软媒魔方<strong><em>绿色版</em></strong></a>（<strong>※注：</strong>软媒魔方一定要是绿色版），桌面美化工具需要占用一定的配置，配置不高的老电脑还是别用比较好。</p><h2 id="后记">后记</h2><p>如果以后碰到更多有意思的小东西再和大家分享吧 ↖(^ω^)↗。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　由于本人目前使用最多的是 Windows 系统，所以以下推荐的软件基本都是 Windows 下的软件，全凭本人主观感觉推荐，也算是个人备份吧。&lt;/p&gt;&lt;p&gt;　　首先推荐的自然是装机软件 &lt;a href=&quot;https://www.ezbsystems.com/ultraiso/download.htm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;ULTRAISO&lt;/strong&gt;&lt;/a&gt;，下个绿色版就好，只有 1M 多一点 或者 &lt;a href=&quot;https://github.com/pbatard/rufus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;Rufus&lt;/strong&gt;&lt;/a&gt; 好像也不错。下载 Windows 镜像的地方推荐为：&lt;a href=&quot;https://msdn.itellyou.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;strong&gt;MSDN，I Tell You&lt;/strong&gt;&lt;/a&gt;。接下来就是正式的软件推荐篇了：&lt;/p&gt;
    
    </summary>
    
      <category term="Share" scheme="http://cniter.github.io/categories/Share/"/>
    
    
      <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
  </entry>
  
  <entry>
    <title>解决无法打开某个网页问题</title>
    <link href="http://cniter.github.io/posts/376168c6.html"/>
    <id>http://cniter.github.io/posts/376168c6.html</id>
    <published>2017-12-07T08:06:53.000Z</published>
    <updated>2018-03-18T07:46:47.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本人最近在某台 Win10 的电脑中打开网页 <a href="https://www.typora.io/" class="uri" target="_blank" rel="external">https://www.typora.io/</a> 时出现了问题，一直出现无法连接现象。</p><a id="more"></a><h2 id="问题篇">问题篇</h2><p>Chrome 中出现：</p><blockquote><p><strong>未连接到互联网</strong></p><p>请试试以下办法：</p><ul><li>检查网线、调制解调器和路由器</li><li>重新连接到 Wi-Fi 网络</li><li><a href="javascript:diagnoseErrors()" target="_blank" rel="external">运行 Windows 网络诊断</a></li></ul><p>DNS_PROBE_FINISHED_NO_INTERNET</p></blockquote><p>Firefox 中出现：</p><blockquote><p>我们无法连接至 www.typora.io 的服务器。 如果确定此网址正确，您可以尝试：</p><ul><li>过会儿再重试。</li><li>检查您的网络连接是否正常。</li><li>如果您部署有网络防火墙，请检查 Firefox 是否已被授权访问网络。</li></ul></blockquote><p>手机和其它设备在同一网络下能正常连接，打开 host 文件也没发现域名被劫持的情况，挂代理也能连接上。</p><h2 id="解决方案篇">解决方案篇</h2><p>本人尝试过的方法：</p><ol type="1"><li><p>刷新 DNS 缓存：在命令行界面中输入 <code>ipconfig /flushdns</code>，无效；</p></li><li><p>改 DNS 服务器：把电脑的 dns 修改为首选 8.8.8.8，备用 114.114.114.114，和将首选改成 8.8.4.4 均无效；</p></li><li><p>Disable Path MTU discovery，具体操作方法为：</p><blockquote><p>单击“开始”，单击“运行”，键入 regedit，然后单击“确定”。</p><p>在注册表中找到下面的项： <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters</code></p><p>找到<code>EnablePMTUDiscovery</code>，将其值改为 0，如果没找到，则在“编辑”菜单上，指向“新建”，然后单击“DWORD 值”，键入 EnablePMTUDiscovery，然后按 Enter，在“编辑”菜单上，单击“修改”，在“数值数据”框中，键入 0，然后单击“确定”。</p><p>退出注册表编辑器，然后重新启动计算机。</p></blockquote></li><li><p>设置 MTU 值，将其调小，完美解决。具体操作方法为：以管理员身份运行命令提示符，在命令行界面输入 <code>netsh interface ipv4 show subinterfaces</code>，查看传入字节和传出字节的接口，修改对应接口的 MTU 的值，具体命令为：<code>netsh interface ipv4 set subinterface &quot;对应接口名&quot; mtu=值 store=persistent</code>，其中 <strong>对应接口名</strong> 和 <strong>值</strong> 需要替换成相应修改的东西。</p></li></ol><h2 id="后记">后记</h2><p>　　将 MTU 值调小，可能会造成网速变慢，但本人又无法去改变其它的东西，既然不能改变其它，只能改变自己喽 ╮(╯﹏╰)╭。但本人这里觉得奇怪的是：别人的电脑设置默认 MTU 的值为 1500 也能访问啊，无奈 （╯‵□′）╯︵┴─┴。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://www.zhihu.com/question/23627621" target="_blank" rel="external">电脑上部分网页打不开，但是手机可以，如何解决？</a></p><p>[2] <a href="https://jingyan.baidu.com/article/ad310e80ff9bf81849f49ea9.html" target="_blank" rel="external">mtu值怎样设置才网速最快</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本人最近在某台 Win10 的电脑中打开网页 &lt;a href=&quot;https://www.typora.io/&quot; class=&quot;uri&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.typora.io/&lt;/a&gt; 时出现了问题，一直出现无法连接现象。&lt;/p&gt;
    
    </summary>
    
      <category term="Problems" scheme="http://cniter.github.io/categories/Problems/"/>
    
    
      <category term="network" scheme="http://cniter.github.io/tags/network/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5使用小结</title>
    <link href="http://cniter.github.io/posts/5f54aa2c.html"/>
    <id>http://cniter.github.io/posts/5f54aa2c.html</id>
    <published>2017-11-12T13:10:16.000Z</published>
    <updated>2018-02-27T12:37:25.920Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FA8072">本文所用的 Python 版本为 python-3.6.2，PyQt5 版本为 pyqt5-5.9.1，OpenCV 版本为 opencv-python-3.3.0.10 和 opencv-contrib-python-3.3.0.10，TensorFlow 版本为 tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。</font></p><h2 id="前言">前言</h2><p>　　本文是上一篇（<a href="https://cniter.github.io/posts/82d3b275.html">TensorFlow Object Detection API使用小结</a>）的后续，因为那个 project 还需要一个界面，所以本人使用 PyQt 做了这么个界面，其中借用 OpenCV 的图像数据显示。</p><a id="more"></a><h2 id="准备篇">准备篇</h2><p>　　首先使用 pip 安装所需库，由于上一篇已经安装了 tensorflow，所以本文其实只需要安装 pyqt5 和 opencv-python 就可以了，安装 pyqt5 指令为：<code>pip install pyqt5</code>，相关依赖关系解决办法在上一篇中已提到，这里不再赘述，然后再使用指令 <code>pip install opencv-python</code> 安装 opencv，这里本人发现在 python 中配置 OpenCV 简直不要太轻爽 O(∩_∩)O~~，就一个 pip 就解决了，哪有 C++ 那么麻烦，以后可能还会继续使用 python 版的 opencv，所以就顺便把它 python 版的扩展包也顺便一起装上，安装指令为：<code>pip install opencv-contrib-python</code>。至此所需环境库安装完毕。</p><p>　　<strong>※注</strong>：相对于上文中使用 pip 在线安装的方式，还有另一种使用 pip 进行离线安装的方式，在 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/" target="_blank" rel="external">Unofficial Windows Binaries for Python Extension Packages</a>上下载离线包，即 XXXXXX.whl 文件，文件名一般包含库名称和对应版本、python 版本以及是 64 位还是 32 位的等信息，这里以离线包 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#numpy" target="_blank" rel="external">numpy-1.13+mkl</a> 为例，首先下载适合自己的库版本，适合本人的当然是 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl（这适合 64 位的 python3.6 安装），将命令行目录切换至 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 文件所在目录，输入指令 <code>pip install numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl</code> 即可离线安装 numpy-1.13+mkl 库。相比在线安装，这种离线安装更加灵活，而且能够安装一些在线安装无法安装的库，像上文中的 numpy-1.13+mkl 库只能采取离线安装的方式，在线安装只能安装不带 mkl 的 numpy 库。采用离线安装方式也可以直接安装带扩展包的 opencv-python库：<em>opencv_python‑3.3.1+contrib‑cp36‑cp36m‑win_amd64.whl</em> ，不需要像在线安装那样装两个库。</p><h2 id="实践篇">实践篇</h2><p>　　以前有用过 Qt 的基础，所以这次使用 PyQt5 感觉上手很快，毕竟这里面的语法有很多是相通的，再加上网上的资料也有很多，所以很快就做了个简陋的界面。不过直接用代码控制界面的布局确实很麻烦，每改下布局都要重新运行一下看看，而且启动时间还有点长 ╮(╯﹏╰）╭。网上有种说法是：</p><blockquote><p>可以先通过QtDesigner设计UI，然后通过Qt提供的命令行工具pyuic5将.ui文件转换成python代码，具体用法是：若ui文件名称为firstPyQt5.ui，则在命令行界面中输入指令：<code>pyuic5 -o firstPyQt5.py firstPyQt5.ui</code>，即可将firstPyQt5.ui文件转换成python代码文件firstPyQt5.py</p></blockquote><p>不过本人这里由于界面比较简陋，没有几个控件，所以就直接将其用 python 代码控制了，没去尝试这个命令行工具 pyuic5 了，下次有机会再尝试吧 ↖(^ω^)↗。</p><p>　　本人做的这个小界面实现的功能是：1、可以选择已经训练好的模型来检测选定图片中的目标；2、可以播放选定的视频；3、还有打开摄像头，显示摄像头拍摄的视频。</p><p>其中由于本人电脑无法实时检测目标，所以在视频和摄像头拍摄中就没有添加检测的代码，只有选择图片时才会执行检测功能，有需要的童靴可以自行添加(•̀ᴗ•́)。</p><p>附完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys  </div><div class="line"></div><div class="line"><span class="keyword">from</span> PyQt5.QtCore <span class="keyword">import</span> * </div><div class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> PyQt5.QtGui <span class="keyword">import</span> * </div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> cv2</div><div class="line"></div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</div><div class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detector</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.PATH_TO_CKPT = <span class="string">'./model/hand_model_faster_rcnn_resnet101.pb'</span>   <span class="comment"># 选择模型文件</span></div><div class="line">        self.PATH_TO_LABELS = <span class="string">r'./model/hands_label_map.pbtxt'</span>  <span class="comment"># 选择类别标签文件</span></div><div class="line">        self.NUM_CLASSES = <span class="number">1</span></div><div class="line">        self.detection_graph = self._load_model()   <span class="comment"># 加载模型</span></div><div class="line">        self.category_index = self._load_label_map()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_load_model</span><span class="params">(self)</span>:</span></div><div class="line">        detection_graph = tf.Graph()</div><div class="line">        <span class="keyword">with</span> detection_graph.as_default():</div><div class="line">            od_graph_def = tf.GraphDef()</div><div class="line">            <span class="keyword">with</span> tf.gfile.GFile(self.PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</div><div class="line">                serialized_graph = fid.read()</div><div class="line">                od_graph_def.ParseFromString(serialized_graph)</div><div class="line">                tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</div><div class="line">        <span class="keyword">return</span> detection_graph</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_load_label_map</span><span class="params">(self)</span>:</span></div><div class="line">        label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS)</div><div class="line">        categories = label_map_util.convert_label_map_to_categories(label_map,</div><div class="line">                                                                    max_num_classes=self.NUM_CLASSES,</div><div class="line">                                                                    use_display_name=<span class="keyword">True</span>)</div><div class="line">        category_index = label_map_util.create_category_index(categories)</div><div class="line">        <span class="keyword">return</span> category_index</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(self, image)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.detection_graph.as_default():</div><div class="line">            <span class="keyword">with</span> tf.Session(graph=self.detection_graph) <span class="keyword">as</span> sess:</div><div class="line">                <span class="comment"># Expand dimensions since the model expects images to have shape: [1, None, None, 3]</span></div><div class="line">                image_np_expanded = np.expand_dims(image, axis=<span class="number">0</span>)</div><div class="line">                image_tensor = self.detection_graph.get_tensor_by_name(<span class="string">'image_tensor:0'</span>)</div><div class="line">                boxes = self.detection_graph.get_tensor_by_name(<span class="string">'detection_boxes:0'</span>)</div><div class="line">                scores = self.detection_graph.get_tensor_by_name(<span class="string">'detection_scores:0'</span>)</div><div class="line">                classes = self.detection_graph.get_tensor_by_name(<span class="string">'detection_classes:0'</span>)</div><div class="line">                num_detections = self.detection_graph.get_tensor_by_name(<span class="string">'num_detections:0'</span>)</div><div class="line">                <span class="comment"># Actual detection.</span></div><div class="line">                (boxes, scores, classes, num_detections) = sess.run(</div><div class="line">                    [boxes, scores, classes, num_detections],</div><div class="line">                    feed_dict=&#123;image_tensor: image_np_expanded&#125;)</div><div class="line">                <span class="comment"># Visualization of the results of a detection.</span></div><div class="line">                vis_util.visualize_boxes_and_labels_on_image_array(</div><div class="line">                    image,</div><div class="line">                    np.squeeze(boxes),</div><div class="line">                    np.squeeze(classes).astype(np.int32),</div><div class="line">                    np.squeeze(scores),</div><div class="line">                    self.category_index,</div><div class="line">                    use_normalized_coordinates=<span class="keyword">True</span>,</div><div class="line">                    line_thickness=<span class="number">8</span>)</div><div class="line">                </div><div class="line">        <span class="keyword">return</span> image</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectUI</span><span class="params">(QWidget)</span>:</span></div><div class="line">     </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super().__init__()</div><div class="line">         </div><div class="line">        self.initUI()</div><div class="line">        self.detector = Detector()</div><div class="line">        self.cap = cv2.VideoCapture()</div><div class="line">         </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initUI</span><span class="params">(self)</span>:</span>  </div><div class="line">        self.timer = QTimer(self)   <span class="comment"># 初始化一个定时器</span></div><div class="line">        self.timer.timeout.connect(self.showFrame)  <span class="comment"># 计时结束调用showFrame()方法</span></div><div class="line">        </div><div class="line">        self.show_pic_label = QLabel(self) </div><div class="line">        self.show_pic_label.resize(<span class="number">640</span>, <span class="number">480</span>)</div><div class="line">        self.show_pic_label.move(<span class="number">10</span>, <span class="number">10</span>)</div><div class="line">        self.show_pic_label.setStyleSheet(<span class="string">"border-width: 1px; border-style: solid; border-color: rgb(255, 170, 0);"</span>)            </div><div class="line"></div><div class="line">        self.show_filename_lineEdit = QLineEdit(self) </div><div class="line">        self.show_filename_lineEdit.resize(<span class="number">200</span>, <span class="number">22</span>)</div><div class="line">        self.show_filename_lineEdit.move(<span class="number">10</span>, <span class="number">500</span>) </div><div class="line"></div><div class="line">        self.select_img_btn = QPushButton(<span class="string">'Select File'</span>, self)   </div><div class="line">        self.select_img_btn.clicked.connect(self.selectImg) </div><div class="line">        self.select_img_btn.resize(self.select_img_btn.sizeHint())</div><div class="line">        self.select_img_btn.move(<span class="number">218</span>, <span class="number">500</span>) </div><div class="line"></div><div class="line">        self.open_camera_btn = QPushButton(<span class="string">'Open Camera'</span>, self)   </div><div class="line">        self.open_camera_btn.clicked.connect(self.openCamera) </div><div class="line">        self.open_camera_btn.resize(self.open_camera_btn.sizeHint())</div><div class="line">        self.open_camera_btn.move(<span class="number">292</span>, <span class="number">500</span>)</div><div class="line"></div><div class="line">        self.select_model_btn = QPushButton(<span class="string">'Select Model'</span>, self)   </div><div class="line">        self.select_model_btn.clicked.connect(self.selectModel) </div><div class="line">        self.select_model_btn.resize(self.select_model_btn.sizeHint())</div><div class="line">        self.select_model_btn.move(<span class="number">366</span>, <span class="number">500</span>) </div><div class="line"></div><div class="line">        self.show_modelname_lineEdit = QLineEdit(self) </div><div class="line">        self.show_modelname_lineEdit.setText(<span class="string">'hand_model_faster_rcnn_resnet101.pb'</span>)</div><div class="line">        self.show_modelname_lineEdit.resize(<span class="number">200</span>, <span class="number">22</span>)</div><div class="line">        self.show_modelname_lineEdit.move(<span class="number">450</span>, <span class="number">500</span>) </div><div class="line"></div><div class="line">        self.setGeometry(<span class="number">200</span>, <span class="number">100</span>, <span class="number">660</span>, <span class="number">530</span>)</div><div class="line">        self.setWindowTitle(<span class="string">'Hand Detector'</span>)   </div><div class="line">        self.show()</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showImg</span><span class="params">(self, src_img, qlabel)</span>:</span></div><div class="line">        src_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2RGB)</div><div class="line"></div><div class="line">        <span class="comment"># src_img = self.detector.detect(src_img) # 检测目标</span></div><div class="line"></div><div class="line">        height, width, bytesPerComponent = src_img.shape</div><div class="line">        bytesPerLine = bytesPerComponent * width</div><div class="line">        <span class="comment"># 转为QImage对象</span></div><div class="line">        q_image = QImage(src_img.data, width, height, bytesPerLine, QImage.Format_RGB888)</div><div class="line">        qlabel.setPixmap(QPixmap.fromImage(q_image).scaled(qlabel.width(), qlabel.height())) </div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">showFrame</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span>(self.cap.isOpened()):</div><div class="line">            ret, frame = self.cap.read()</div><div class="line">            <span class="keyword">if</span> ret:</div><div class="line">                self.showImg(frame, self.show_pic_label)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                self.cap.release()</div><div class="line">                self.timer.stop()   <span class="comment"># 停止计时器</span></div><div class="line"></div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectImg</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">if</span> self.cap.isOpened():</div><div class="line">            self.cap.release()</div><div class="line"></div><div class="line">        file_name, file_type = QFileDialog.getOpenFileName(self,  </div><div class="line">                                    <span class="string">"选取文件"</span>,  </div><div class="line">                                    <span class="string">"./"</span>,  </div><div class="line">                                    <span class="string">"Image Files (*.jpg *.png *.bmp *.tif);;Video Files (*.avi *.mp4)"</span>)   <span class="comment">#设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件  </span></div><div class="line">        <span class="comment"># print(file_name,file_type)</span></div><div class="line"></div><div class="line">        <span class="keyword">if</span> file_type.find(<span class="string">"Image"</span>) &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> file_name:</div><div class="line">                self.show_filename_lineEdit.setText(os.path.split(file_name)[<span class="number">1</span>])</div><div class="line">            </div><div class="line">                img = cv2.imread(file_name, cv2.IMREAD_COLOR)</div><div class="line">                cv2.cvtColor(img, cv2.COLOR_BGR2RGB, img)</div><div class="line"></div><div class="line">                img = self.detector.detect(img) <span class="comment"># 检测目标</span></div><div class="line"></div><div class="line">                height, width, bytesPerComponent = img.shape</div><div class="line">                bytesPerLine = bytesPerComponent * width</div><div class="line">                <span class="comment"># 转为QImage对象</span></div><div class="line">                q_image = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888)</div><div class="line">                self.show_pic_label.setPixmap(QPixmap.fromImage(q_image).scaled(self.show_pic_label.width(), self.show_pic_label.height()))</div><div class="line"></div><div class="line">        <span class="keyword">if</span> file_type.find(<span class="string">"Video"</span>) &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> file_name:</div><div class="line">                self.show_filename_lineEdit.setText(os.path.split(file_name)[<span class="number">1</span>])</div><div class="line"></div><div class="line">                self.cap.open(file_name)</div><div class="line">                self.timer.start(<span class="number">30</span>)    <span class="comment"># 设置时间隔30ms并启动</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">openCamera</span><span class="params">(self)</span>:</span></div><div class="line">        self.cap.open(<span class="number">0</span>)    <span class="comment"># 默认打开0号摄像头</span></div><div class="line">        self.timer.start(<span class="number">30</span>)    <span class="comment"># 设置时间隔30ms并启动</span></div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selectModel</span><span class="params">(self)</span>:</span>  </div><div class="line">        model_name, file_type = QFileDialog.getOpenFileName(self,  </div><div class="line">                                    <span class="string">"选取文件"</span>,  </div><div class="line">                                    <span class="string">"./"</span>,  </div><div class="line">                                    <span class="string">"model Files (*.pb);;All Files (*)"</span>)   <span class="comment">#设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件  </span></div><div class="line">               </div><div class="line">        <span class="keyword">if</span> model_name:</div><div class="line">            self.show_modelname_lineEdit.setText(os.path.split(model_name)[<span class="number">1</span>])</div><div class="line">            self.detector.PATH_TO_CKPT = model_name</div><div class="line">            self.detector.detection_graph = self.detector._load_model() <span class="comment"># 重新加载模型</span></div><div class="line">         </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    app = QApplication(sys.argv)</div><div class="line">    dtcui = DetectUI()</div><div class="line">    sys.exit(app.exec_())</div></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>　　初次使用 Python 做一个小东西，其语法确实简洁，不过对于本人这种习惯用 C++ 的人来说确实还有点不太习惯 (˘•ω•˘)。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.csdn.net/m0_37928067/article/details/75883535" target="_blank" rel="external">用PyQt5+Caffe+Opencv搭建一个人脸识别登录界面</a></p><p>[2] <a href="http://blog.csdn.net/a359680405/article/details/45166271" target="_blank" rel="external">PyQt5学习笔记09—-标准文件打开保存框QFileDialog</a></p><p>[3] <a href="http://www.cnblogs.com/archisama/p/5444032.html" target="_blank" rel="external">PyQt5教程——第一个程序（2）</a>（<a href="http://www.cnblogs.com/archisama/tag/PyQt5/" class="uri" target="_blank" rel="external">http://www.cnblogs.com/archisama/tag/PyQt5/</a>）</p><p>[4] <a href="http://www.cnblogs.com/skynet/p/4229556.html" target="_blank" rel="external">PyQt5应用与实践</a></p><p>[5] <a href="http://www.cnblogs.com/tkinter/p/5632245.html" target="_blank" rel="external">PyQt5系列教程(二)利用QtDesigner设计UI界面</a>（<a href="http://www.cnblogs.com/tkinter/tag/pyqt5/" class="uri" target="_blank" rel="external">http://www.cnblogs.com/tkinter/tag/pyqt5/</a>）</p><p>[6] <a href="https://docs.opencv.org/3.2.0/index.html" target="_blank" rel="external">OpenCV 3.2.0</a>/<a href="https://docs.opencv.org/3.2.0/d6/d00/tutorial_py_root.html" target="_blank" rel="external">OpenCV-Python Tutorials</a>/<a href="https://docs.opencv.org/3.2.0/dc/d4d/tutorial_py_table_of_contents_gui.html" target="_blank" rel="external">Gui Features in OpenCV</a>/<a href="https://docs.opencv.org/3.2.0/dc/d2e/tutorial_py_image_display.html" target="_blank" rel="external">Getting Started with Images</a></p><p>[7] <a href="https://docs.opencv.org/3.2.0/index.html" target="_blank" rel="external">OpenCV 3.2.0</a>/<a href="https://docs.opencv.org/3.2.0/d6/d00/tutorial_py_root.html" target="_blank" rel="external">OpenCV-Python Tutorials</a>/<a href="https://docs.opencv.org/3.2.0/dc/d4d/tutorial_py_table_of_contents_gui.html" target="_blank" rel="external">Gui Features in OpenCV</a>/<a href="https://docs.opencv.org/3.2.0/dd/d43/tutorial_py_video_display.html" target="_blank" rel="external">Getting Started with Videos</a></p><p>[8] <a href="http://blog.csdn.net/keenweiwei/article/details/9037757" target="_blank" rel="external">python3.3 分割路径与文件名 小例</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#FA8072&quot;&gt;本文所用的 Python 版本为 python-3.6.2，PyQt5 版本为 pyqt5-5.9.1，OpenCV 版本为 opencv-python-3.3.0.10 和 opencv-contrib-python-3.3.0.10，TensorFlow 版本为 tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。&lt;/font&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文是上一篇（&lt;a href=&quot;https://cniter.github.io/posts/82d3b275.html&quot;&gt;TensorFlow Object Detection API使用小结&lt;/a&gt;）的后续，因为那个 project 还需要一个界面，所以本人使用 PyQt 做了这么个界面，其中借用 OpenCV 的图像数据显示。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
      <category term="python" scheme="http://cniter.github.io/tags/python/"/>
    
      <category term="qt" scheme="http://cniter.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow Object Detection API使用小结</title>
    <link href="http://cniter.github.io/posts/82d3b275.html"/>
    <id>http://cniter.github.io/posts/82d3b275.html</id>
    <published>2017-11-11T13:52:52.000Z</published>
    <updated>2018-01-31T10:45:22.415Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FA8072">本文所用的 Python 版本为 python-3.6.2，TensorFlow 版本为tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。</font></p><h2 id="前言">前言</h2><p>　　很久没写过东西了，主要原因是最近研究生课程开始陆续结课，本人也要忙于应付各种结课时的考试、论文、project 等一堆麻烦事。这不深度学习结课时需要做个 project，本人也顺便将做这个 project 的过程记录下来。</p><a id="more"></a><h2 id="准备篇">准备篇</h2><p>　　该 project 主要利用 TensorFlow 中的 Object Detection API 进行训练和检测。在开始使用该 API 之前需要安装配置 Python 环境。</p><p>　　既然是 Python 首先需要 <a href="https://www.python.org/downloads/" target="_blank" rel="external">下载安装Python</a>，安装完之后，为了顺利使用 pip 需要配置环境变量，在 Windows 系统环境变量中 Path 末尾添加：</p><table><colgroup><col style="width:9%"><col style="width:90%"></colgroup><thead><tr class="header"><th style="text-align:center">变量名</th><th style="text-align:center">变量值</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">Path</td><td style="text-align:center">;C:\Users\admin\AppData\Local\Programs\Python\Python36\; C:\Users\admin\AppData\Local\Programs\Python\Python36\Scripts\</td></tr></tbody></table><p>其中 <code>C:\Users\admin\AppData\Local\Programs\Python\Python36</code> 为 python-3.6.2 默认安装目录。</p><p>　　然后为了方便使用命令行工具，<a href="https://www.git-scm.com/download/" target="_blank" rel="external">下载安装git</a>，安装方式一路默认即可。</p><p>　　接下来利用 pip 安装 TensorFlow，鼠标右键桌面空白处，点击“<strong>Git Bash Here</strong>”，打开 bash 命令行，输入 <code>pip install tensorflow</code>，其中一些依赖关系可能需要手动解决，手动解决的办法就是用 pip install 相关依赖库，这是 CPU 版的 TensorFlow，若要使用 GPU，则需要安装 GPU 版的 TensorFlow，安装命令为：<code>pip install tensorflow-gpu</code>，以同样方式解决依赖关系。由于本人电脑没 N 卡，所以没安装 GPU 版的 TensorFlow，所以如果想使用 GPU 版的 TensorFlow 请另行尝试。</p><p>　　然后安装 TensorFlow Object Detection API 依赖库，在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pip install pillow</div><div class="line">pip install lxml</div><div class="line">pip install jupyter</div><div class="line">pip install matplotlib</div></pre></td></tr></table></figure><p>　　因为 tensorflow 并没有默认自带 Object Detection API，所以该 API 需要自行下载，下载地址为：https://github.com/tensorflow/models ，下载之后解压，本人解压目录为：<code>D:\ProgramFiles\PythonLibs\tensorflow</code>，解压完之后需要配置环境目录，在系统环境目录中添加：</p><table><colgroup><col style="width:20%"><col style="width:80%"></colgroup><thead><tr class="header"><th style="text-align:center">变量名</th><th style="text-align:center">变量值</th></tr></thead><tbody><tr class="odd"><td style="text-align:center">PYTHONPATH</td><td style="text-align:center">D:\ProgramFiles\PythonLibs\tensorflow\models; D:\ProgramFiles\PythonLibs\tensorflow\models\research; D:\ProgramFiles\PythonLibs\tensorflow\models\research\slim;</td></tr></tbody></table><p>　　下载配置 Object Detection API 完之后需要安装 Protoc，进入 <a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">Protoc下载页</a>，下载 <a href="https://github.com/google/protobuf/releases/download/v3.4.0/protoc-3.4.0-win32.zip" target="_blank" rel="external"><strong>protoc-3.4.0-win32.zip</strong></a>，解压之后将 <strong>bin</strong> 文件夹内的 <strong>protoc.exe</strong> 拷贝到 <code>C:\windows\system32</code> 目录下（用于将 protoc.exe 所在的目录配置到环境变量当中）,当然也可以在系统环境变量 Path 中添加该 <strong>bin</strong> 文件夹路径。</p><p>　　最后在命令行中切换目录至：<code>D:\ProgramFiles\PythonLibs\tensorflow\models\research</code> 文件夹，即 object_detection 文件夹所在目录，在命令行中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">protoc object_detection/protos/*.proto --python_out=.</div></pre></td></tr></table></figure><p>编译 <code>object_detection/protos</code> 文件夹下的 proto 文件，生成对应的 python 文件。</p><p>　　至此，Windows 下 TensorFlow中 的 Object Detection API 的使用配置全部完成，至于 Ubuntu 下的配置可参考其<a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/installation.md" target="_blank" rel="external">官方文档</a>。</p><p>　　至于如何验证，可以在命令行中切换目录至 <code>object_detection</code>，输入：<code>jupyter notebook</code>，稍等一会，浏览器将自动打开 <code>http://localhost:8888/tree</code> jupyter 界面，点击 <code>object_detection_tutorial.ipynb</code> 文件，进入打开的新标签，点击“<strong>Cell</strong>”中的“<strong>Run All</strong>”，耐心等待几 ~ 十几分钟（因为它需要下载相应的模型），将会在浏览器下方显示检测结果。</p><p>　　截止本文完成前，该API公开的有以下几个模型：</p><table><thead><tr class="header"><th>Model name</th><th>Speed (ms)</th><th>COCO mAP<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></th><th>Outputs</th></tr></thead><tbody><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_2017_11_08.tar.gz" target="_blank" rel="external">ssd_mobilenet_v1_coco</a></td><td>30</td><td>21</td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/ssd_inception_v2_coco_2017_11_08.tar.gz" target="_blank" rel="external">ssd_inception_v2_coco</a></td><td>42</td><td>24</td><td>Boxes</td></tr><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_inception_v2_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_inception_v2_coco</a></td><td>58</td><td>28</td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_resnet50_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_resnet50_coco</a></td><td>89</td><td>30</td><td>Boxes</td></tr><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_resnet50_lowproposals_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_resnet50_lowproposals_coco</a></td><td>64</td><td></td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/rfcn_resnet101_coco_2017_11_08.tar.gz" target="_blank" rel="external">rfcn_resnet101_coco</a></td><td>92</td><td>30</td><td>Boxes</td></tr><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_resnet101_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_resnet101_coco</a></td><td>106</td><td>32</td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_resnet101_lowproposals_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_resnet101_lowproposals_coco</a></td><td>82</td><td></td><td>Boxes</td></tr><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_inception_resnet_v2_atrous_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_inception_resnet_v2_atrous_coco</a></td><td>620</td><td>37</td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_inception_resnet_v2_atrous_lowproposals_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_inception_resnet_v2_atrous_lowproposals_coco</a></td><td>241</td><td></td><td>Boxes</td></tr><tr class="odd"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_nas_lowproposals_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_nas</a></td><td>1833</td><td>43</td><td>Boxes</td></tr><tr class="even"><td><a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_nas_lowproposals_coco_2017_11_08.tar.gz" target="_blank" rel="external">faster_rcnn_nas_lowproposals_coco</a></td><td>540</td><td></td><td>Boxes</td></tr></tbody></table><p>　　根据上述模型可推知，利用该 API 可能只能训练 Faster-RCNN、R-FCN 和 SSD 三种算法的模型。</p><p>接下来介绍如何使用该 API 来训练自己的模型进行物体检测。</p><h2 id="实践篇">实践篇</h2><h3 id="数据准备篇">数据准备篇</h3><p>　　既然要训练自己的模型，当然要准备相应的数据，而 TensorFlow 有其独特的输入数据格式 <a href="https://www.tensorflow.org/api_guides/python/python_io#tfrecords_format_details" target="_blank" rel="external">TFRecord</a>，所以通常还要将自己的数据转换成 TFRecord 格式以输入 TensorFlow 中进行训练。以 <a href="https://github.com/datitran" target="_blank" rel="external">datitran</a>/<a href="https://github.com/datitran/raccoon_dataset" target="_blank" rel="external"><strong>raccoon_dataset</strong></a> 数据集为例，该作者在 Google image 上收集了 200 张 Raccoon 图片，用 <a href="https://github.com/tzutalin/labelImg" target="_blank" rel="external">LabelImg</a> 对这些图片进行标记，并将标记以 PASCAL VOC 格式保存为 xml 文件。作者在文中也提到了另一个图片标记工具 <a href="https://github.com/christopher5106/FastAnnotationTool" target="_blank" rel="external">FIAT (Fast Image Data Annotation Tool)</a> 。保存为 PASCAL VOC 格式的 xml 文件之后，可以使用 object_detection 文件夹中的 <a href="https://github.com/tensorflow/models/blob/master/research/object_detection/create_pascal_tf_record.py" target="_blank" rel="external">create_pascal_tf_record.py</a> 文件将数据转化为 TFRecord 格式，用法为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">./create_pascal_tf_record --data_dir=/home/user/VOCdevkit \</div><div class="line">        --year=VOC2012 \</div><div class="line">        --output_path=/home/user/pascal.record</div></pre></td></tr></table></figure><p>当然也可以使用 datitran 作者提供的 <a href="https://github.com/datitran/raccoon_dataset/blob/master/xml_to_csv.py" target="_blank" rel="external">xml_to_csv.py</a> 文件将 xml 文件先转化为 csv 文件，再利用 <a href="https://github.com/datitran/raccoon_dataset/blob/master/generate_tfrecord.py" target="_blank" rel="external">generate_tfrecord.py</a> 文件将 csv 文件转化成 TFRecord 格式文件。</p><p>　　注意，使用 xml_to_csv.py 和 generate_tfrecord.py 其文件结构应该是这样的：</p><blockquote><p>.<br>├── annotations<br>├── generate_tfrecord.py<br>├── images<br>└── xml_to_csv.py</p><p>2 directories, 2 files</p></blockquote><p>其中 images 文件夹存的是 jpg 图片，annotations 文件夹存的是 xml 标签文件。generate_tfrecord.py 文件中的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">class_text_to_int</span><span class="params">(row_label)</span>:</span></div><div class="line">    <span class="keyword">if</span> row_label == <span class="string">'raccoon'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line"><span class="keyword">None</span></div></pre></td></tr></table></figure><p>其中的 <code>raccoon</code> 注意要改成自己的类别标签。如此，数据的问题就解决了。</p><h3 id="训练篇">训练篇</h3><p>　　然后就是正式开始训练了，以 Faster-RCNN 算法为例。首先准备相应的数据，本人准备的数据文件结构如下：</p><blockquote><p>TensorFlowObjectDetectionAPITest<br>├── data<br>│ 　├── model.ckpt.data-00000-of-00001<br>│ 　├── model.ckpt.index<br>│ 　├── model.ckpt.meta<br>│ 　├── object_label_map.pbtxt<br>│ 　├── test.record<br>│ 　└── train.record<br>├── eval<br>├── eval.py<br>├── export_inference_graph.py<br>├── faster_rcnn_resnet101_coco.config<br>├── model<br>├── train<br>└── train.py</p><p>4 directories, 10 files</p></blockquote><p>其中，<strong>TensorFlowObjectDetectionAPITest</strong> 为项目文件夹，该 <em>project</em> 在此文件夹下运行；</p><p><strong>data</strong> 文件夹中三个 <strong>model.ckpt</strong> 文件：<strong>model.ckpt.data-00000-of-00001</strong>、<strong>model.ckpt.index</strong> 和 <strong>model.ckpt.meta</strong> 来自 <a href="http://download.tensorflow.org/models/object_detection/faster_rcnn_resnet101_coco_2017_11_08.tar.gz" target="_blank" rel="external"><em>faster_rcnn_resnet101_coco</em></a> 模型，用来初始化网络参数；</p><p><strong>object_label_map.pbtxt</strong> 文件内容如下：</p><blockquote><p>item { ​ id: 1 ​ name: ‘raccoon’ }</p></blockquote><p>将其中的 <code>raccoon</code> 改成自己的类别标签，如果有多个类别标签则可以参考 <code>object_detection\data</code> 文件夹中的 <em><code>pascal_label_map.pbtxt</code></em> 文件格式；</p><p><strong>test.record</strong> 和 <strong>train.record</strong> 是生成的 TFRecord 数据，分别为待输入的测试数据和训练数据；</p><p><strong>eval </strong>文件夹为空文件夹用来输出测试结果；<strong>train</strong> 文件夹为空文件夹用来输出训练结果（包括checkpoint文件和最终的模型文件）；</p><p><strong>faster_rcnn_resnet101_coco.config</strong> 为配置文件，包括各种参数和输入输出数据的配置，其来自 <code>object_detection\samples\configs</code> 文件夹中 <em><code>faster_rcnn_resnet101_coco.config</code></em> 文件，在使用时需对其做如下修改：</p><ol type="1"><li><p>首先是 <strong>num_classes</strong>，这是待检测的类别数目，如果只要检测一种，则将其值改为 1；</p></li><li><p><code>fine_tune_checkpoint: &quot;PATH_TO_BE_CONFIGURED/model.ckpt&quot;</code>，将 <code>PATH_TO_BE_CONFIGURED</code> 改为 <code>./data</code>；</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">train_input_reader: &#123;</div><div class="line">  tf_record_input_reader &#123;</div><div class="line">    input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_train.record&quot;</div><div class="line">  &#125;</div><div class="line">  label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将其中的的 <code>PATH_TO_BE_CONFIGURED/mscoco_train.record</code> 改为 <code>./data/train.record</code>，将其中的 <code>PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt</code> 改为 <code>./data/object_label_map.pbtxt</code>；</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">eval_input_reader: &#123;</div><div class="line">  tf_record_input_reader &#123;</div><div class="line">    input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_val.record&quot;</div><div class="line">  &#125;</div><div class="line">  label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot;</div><div class="line">  shuffle: false</div><div class="line">  num_readers: 1</div><div class="line">  num_epochs: 1</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>将其中的的 <code>PATH_TO_BE_CONFIGURED/mscoco_val.record</code> 改为 <code>./data/test.record</code>，将其中的 <code>PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt</code> 改为 <code>./data/object_label_map.pbtxt</code>；</p></li></ol><p>至于其它的参数可以选择默认，不对其进行修改；</p><p><strong>train.py</strong> 为训练代码，其来自 <code>object_detection/</code> 文件夹中的 <em><code>train.py</code></em>，直接复制出来使用即可，具体用法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python train.py --logtostderr --train_dir=./train --pipeline_config_path=faster_rcnn_resnet101_coco.config</div></pre></td></tr></table></figure><p>其在运行过程中会在 <strong>train</strong> 文件夹生成一系列训练过程文件，比如 checkpoint、model.ckpt-{num}（{num} 代表训练过程保存的第几个网络模型，一般从 0 开始，包括 .index、.meta和 .data 三个文件）等文件。</p><p><strong>eval.py</strong> 为评估代码，其来自 <code>object_detection/</code> 文件夹中的 <em><code>eval.py</code></em>，直接复制出来使用即可，具体用法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python eval.py --logtostderr --checkpoint_dir=./train --eval_dir=./<span class="built_in">eval</span> --pipeline_config_path=./faster_rcnn_resnet101_coco.config</div></pre></td></tr></table></figure><p>其在运行过程中会在 <strong>eval</strong> 文件夹生成一系列评估文件，每个文件对应一个测试 image。</p><p><strong>export_inference_graph.py</strong> 为导出 pb 模型代码，其来自 <code>object_detection/</code> 文件夹中的 <em><code>export_inference_graph.py</code></em>，直接复制出来使用即可，具体用法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python export_inference_graph.py --input_type image_tensor --pipeline_config_path ./faster_rcnn_resnet101_coco.config --trained_checkpoint_prefix ./train/model.ckpt-18298 --output_directory ./model</div></pre></td></tr></table></figure><p>其中 <code>model.ckpt-18298</code> 表示使用第 18298 次保存的网络模型导出 pb 模型文件，导出的模型文件保存在 <strong>model</strong> 文件夹，主要有一下几个文件：</p><blockquote><p>- graph.pbtxt</p><p>- model.ckpt.data-00000-of-00001</p><p>- model.ckpt.info</p><p>- model.ckpt.meta</p><p>- frozen_inference_graph.pb</p></blockquote><p>其中 frozen_inference_graph.pb 就是训练成功用来检测目标的模型。</p><p>　　TensorFlow 训练时可以随时查看训练过程，如损失函数的值下降曲线等，所用命令为：在命令行中切换目录至 project 运行目录，即 train.py 所在文件夹，本人这里即 <em>TensorFlowObjectDetectionAPITest</em> 文件夹，输入：<code>tensorboard --logdir=./</code>，等待片刻，在浏览器地址栏输入：<code>http://localhost:6006/</code>，即可看到训练过程曲线。</p><h3 id="检测篇">检测篇</h3><p>　　检测结果使用 opencv 窗口显示（至于 python 中 opencv 的使用详见下一篇（<a href="https://cniter.github.io/posts/5f54aa2c.html">PyQt5使用小结</a>）），具体调用自己训练的模型进行检测的 Python 代码（该代码为 eli 大佬参考 <code>object_detection</code> 文件夹中的 <em><code>object_detection_tutorial.ipynb</code></em>（该文件可在 jupyter 中查看）改的）为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> cv2</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</div><div class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> vis_util</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Detector</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.PATH_TO_CKPT = <span class="string">r'./model/frozen_inference_graph.pb'</span>    <span class="comment"># 选择模型</span></div><div class="line">        self.PATH_TO_LABELS = <span class="string">r'./data/object_label_map.pbtxt'</span>      <span class="comment"># 选择类别标签文件</span></div><div class="line">        self.NUM_CLASSES = <span class="number">1</span></div><div class="line">        self.detection_graph = self._load_model()</div><div class="line">        self.category_index = self._load_label_map()</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_load_model</span><span class="params">(self)</span>:</span></div><div class="line">        detection_graph = tf.Graph()</div><div class="line">        <span class="keyword">with</span> detection_graph.as_default():</div><div class="line">            od_graph_def = tf.GraphDef()</div><div class="line">            <span class="keyword">with</span> tf.gfile.GFile(self.PATH_TO_CKPT, <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</div><div class="line">                serialized_graph = fid.read()</div><div class="line">                od_graph_def.ParseFromString(serialized_graph)</div><div class="line">                tf.import_graph_def(od_graph_def, name=<span class="string">''</span>)</div><div class="line">        <span class="keyword">return</span> detection_graph</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_load_label_map</span><span class="params">(self)</span>:</span></div><div class="line">        label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS)</div><div class="line">        categories = label_map_util.convert_label_map_to_categories(label_map,</div><div class="line">                                                                    max_num_classes=self.NUM_CLASSES,</div><div class="line">                                                                    use_display_name=<span class="keyword">True</span>)</div><div class="line">        category_index = label_map_util.create_category_index(categories)</div><div class="line">        <span class="keyword">return</span> category_index</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detect</span><span class="params">(self, image)</span>:</span></div><div class="line">        <span class="keyword">with</span> self.detection_graph.as_default():</div><div class="line">            <span class="keyword">with</span> tf.Session(graph=self.detection_graph) <span class="keyword">as</span> sess:</div><div class="line">                <span class="comment"># Expand dimensions since the model expects images to have shape: [1, None, None, 3]</span></div><div class="line">                image_np_expanded = np.expand_dims(image, axis=<span class="number">0</span>)</div><div class="line">                image_tensor = self.detection_graph.get_tensor_by_name(<span class="string">'image_tensor:0'</span>)</div><div class="line">                boxes = self.detection_graph.get_tensor_by_name(<span class="string">'detection_boxes:0'</span>)</div><div class="line">                scores = self.detection_graph.get_tensor_by_name(<span class="string">'detection_scores:0'</span>)</div><div class="line">                classes = self.detection_graph.get_tensor_by_name(<span class="string">'detection_classes:0'</span>)</div><div class="line">                num_detections = self.detection_graph.get_tensor_by_name(<span class="string">'num_detections:0'</span>)</div><div class="line">                <span class="comment"># Actual detection.</span></div><div class="line">                (boxes, scores, classes, num_detections) = sess.run(</div><div class="line">                    [boxes, scores, classes, num_detections],</div><div class="line">                    feed_dict=&#123;image_tensor: image_np_expanded&#125;)</div><div class="line">                <span class="comment"># Visualization of the results of a detection.</span></div><div class="line">                vis_util.visualize_boxes_and_labels_on_image_array(</div><div class="line">                    image,</div><div class="line">                    np.squeeze(boxes),</div><div class="line">                    np.squeeze(classes).astype(np.int32),</div><div class="line">                    np.squeeze(scores),</div><div class="line">                    self.category_index,</div><div class="line">                    use_normalized_coordinates=<span class="keyword">True</span>,</div><div class="line">                    line_thickness=<span class="number">8</span>)</div><div class="line"></div><div class="line">        cv2.namedWindow(<span class="string">"detection"</span>, cv2.WINDOW_NORMAL)</div><div class="line">        cv2.imshow(<span class="string">"detection"</span>, image)</div><div class="line">        cv2.waitKey(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    image = cv2.imread(<span class="string">'./test_img.jpg'</span>) <span class="comment"># 选择待检测的图片</span></div><div class="line">    detector = Detector()</div><div class="line">    detector.detect(image)</div></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>　　经过这次 TensorFlow 训练，感觉深度学习 真tm 吃硬件，费时间，也难怪神经网络理论出来几十年之后才火，当年的硬件根本无法支持这么大的计算量。</p><h2 id="附录">附录</h2><p>最后附上 datitran 作者提供的 xml_to_csv.py 文件源码和 generate_tfrecord.py 文件源码：</p><p><strong>xml_to_csv.py 源码</strong>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> glob</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> ET</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">xml_to_csv</span><span class="params">(path)</span>:</span></div><div class="line">    xml_list = []</div><div class="line">    <span class="keyword">for</span> xml_file <span class="keyword">in</span> glob.glob(path + <span class="string">'/*.xml'</span>):</div><div class="line">        tree = ET.parse(xml_file)</div><div class="line">        root = tree.getroot()</div><div class="line">        <span class="keyword">for</span> member <span class="keyword">in</span> root.findall(<span class="string">'object'</span>):</div><div class="line">            value = (root.find(<span class="string">'filename'</span>).text,</div><div class="line">                     int(root.find(<span class="string">'size'</span>)[<span class="number">0</span>].text),</div><div class="line">                     int(root.find(<span class="string">'size'</span>)[<span class="number">1</span>].text),</div><div class="line">                     member[<span class="number">0</span>].text,</div><div class="line">                     int(member[<span class="number">4</span>][<span class="number">0</span>].text),</div><div class="line">                     int(member[<span class="number">4</span>][<span class="number">1</span>].text),</div><div class="line">                     int(member[<span class="number">4</span>][<span class="number">2</span>].text),</div><div class="line">                     int(member[<span class="number">4</span>][<span class="number">3</span>].text)</div><div class="line">                     )</div><div class="line">            xml_list.append(value)</div><div class="line">    column_name = [<span class="string">'filename'</span>, <span class="string">'width'</span>, <span class="string">'height'</span>, <span class="string">'class'</span>, <span class="string">'xmin'</span>, <span class="string">'ymin'</span>, <span class="string">'xmax'</span>, <span class="string">'ymax'</span>]</div><div class="line">    xml_df = pd.DataFrame(xml_list, columns=column_name)</div><div class="line">    <span class="keyword">return</span> xml_df</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    image_path = os.path.join(os.getcwd(), <span class="string">'annotations'</span>)</div><div class="line">    xml_df = xml_to_csv(image_path)</div><div class="line">    xml_df.to_csv(<span class="string">'raccoon_labels.csv'</span>, index=<span class="keyword">None</span>)</div><div class="line">    print(<span class="string">'Successfully converted xml to csv.'</span>)</div><div class="line"></div><div class="line"></div><div class="line">main()</div></pre></td></tr></table></figure><p><strong>generate_tfrecord.py 文件源码</strong> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="string">"""</span></div><div class="line"><span class="string">Usage:</span></div><div class="line"><span class="string">  # From tensorflow/models/</span></div><div class="line"><span class="string">  # Create train data:</span></div><div class="line"><span class="string">  python generate_tfrecord.py --csv_input=data/train_labels.csv  --output_path=train.record</span></div><div class="line"><span class="string">  # Create test data:</span></div><div class="line"><span class="string">  python generate_tfrecord.py --csv_input=data/test_labels.csv  --output_path=test.record</span></div><div class="line"><span class="string">"""</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> division</div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> io</div><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"></div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> dataset_util</div><div class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple, OrderedDict</div><div class="line"></div><div class="line">flags = tf.app.flags</div><div class="line">flags.DEFINE_string(<span class="string">'csv_input'</span>, <span class="string">''</span>, <span class="string">'Path to the CSV input'</span>)</div><div class="line">flags.DEFINE_string(<span class="string">'output_path'</span>, <span class="string">''</span>, <span class="string">'Path to output TFRecord'</span>)</div><div class="line">FLAGS = flags.FLAGS</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># TO-DO replace this with label map</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">class_text_to_int</span><span class="params">(row_label)</span>:</span></div><div class="line">    <span class="keyword">if</span> row_label == <span class="string">'raccoon'</span>:</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">None</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(df, group)</span>:</span></div><div class="line">    data = namedtuple(<span class="string">'data'</span>, [<span class="string">'filename'</span>, <span class="string">'object'</span>])</div><div class="line">    gb = df.groupby(group)</div><div class="line">    <span class="keyword">return</span> [data(filename, gb.get_group(x)) <span class="keyword">for</span> filename, x <span class="keyword">in</span> zip(gb.groups.keys(), gb.groups)]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_tf_example</span><span class="params">(group, path)</span>:</span></div><div class="line">    <span class="keyword">with</span> tf.gfile.GFile(os.path.join(path, <span class="string">'&#123;&#125;'</span>.format(group.filename)), <span class="string">'rb'</span>) <span class="keyword">as</span> fid:</div><div class="line">        encoded_jpg = fid.read()</div><div class="line">    encoded_jpg_io = io.BytesIO(encoded_jpg)</div><div class="line">    image = Image.open(encoded_jpg_io)</div><div class="line">    width, height = image.size</div><div class="line"></div><div class="line">    filename = group.filename.encode(<span class="string">'utf8'</span>)</div><div class="line">    image_format = <span class="string">b'jpg'</span></div><div class="line">    xmins = []</div><div class="line">    xmaxs = []</div><div class="line">    ymins = []</div><div class="line">    ymaxs = []</div><div class="line">    classes_text = []</div><div class="line">    classes = []</div><div class="line"></div><div class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> group.object.iterrows():</div><div class="line">        xmins.append(row[<span class="string">'xmin'</span>] / width)</div><div class="line">        xmaxs.append(row[<span class="string">'xmax'</span>] / width)</div><div class="line">        ymins.append(row[<span class="string">'ymin'</span>] / height)</div><div class="line">        ymaxs.append(row[<span class="string">'ymax'</span>] / height)</div><div class="line">        classes_text.append(row[<span class="string">'class'</span>].encode(<span class="string">'utf8'</span>))</div><div class="line">        classes.append(class_text_to_int(row[<span class="string">'class'</span>]))</div><div class="line"></div><div class="line">    tf_example = tf.train.Example(features=tf.train.Features(feature=&#123;</div><div class="line">        <span class="string">'image/height'</span>: dataset_util.int64_feature(height),</div><div class="line">        <span class="string">'image/width'</span>: dataset_util.int64_feature(width),</div><div class="line">        <span class="string">'image/filename'</span>: dataset_util.bytes_feature(filename),</div><div class="line">        <span class="string">'image/source_id'</span>: dataset_util.bytes_feature(filename),</div><div class="line">        <span class="string">'image/encoded'</span>: dataset_util.bytes_feature(encoded_jpg),</div><div class="line">        <span class="string">'image/format'</span>: dataset_util.bytes_feature(image_format),</div><div class="line">        <span class="string">'image/object/bbox/xmin'</span>: dataset_util.float_list_feature(xmins),</div><div class="line">        <span class="string">'image/object/bbox/xmax'</span>: dataset_util.float_list_feature(xmaxs),</div><div class="line">        <span class="string">'image/object/bbox/ymin'</span>: dataset_util.float_list_feature(ymins),</div><div class="line">        <span class="string">'image/object/bbox/ymax'</span>: dataset_util.float_list_feature(ymaxs),</div><div class="line">        <span class="string">'image/object/class/text'</span>: dataset_util.bytes_list_feature(classes_text),</div><div class="line">        <span class="string">'image/object/class/label'</span>: dataset_util.int64_list_feature(classes),</div><div class="line">    &#125;))</div><div class="line">    <span class="keyword">return</span> tf_example</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span></div><div class="line">    writer = tf.python_io.TFRecordWriter(FLAGS.output_path)</div><div class="line">    path = os.path.join(os.getcwd(), <span class="string">'images'</span>)</div><div class="line">    examples = pd.read_csv(FLAGS.csv_input)</div><div class="line">    grouped = split(examples, <span class="string">'filename'</span>)</div><div class="line">    <span class="keyword">for</span> group <span class="keyword">in</span> grouped:</div><div class="line">        tf_example = create_tf_example(group, path)</div><div class="line">        writer.write(tf_example.SerializeToString())</div><div class="line"></div><div class="line">    writer.close()</div><div class="line">    output_path = os.path.join(os.getcwd(), FLAGS.output_path)</div><div class="line">    print(<span class="string">'Successfully created the TFRecords: &#123;&#125;'</span>.format(output_path))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    tf.app.run()</div></pre></td></tr></table></figure><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.csdn.net/xiaoxiao123jun/article/details/76605928" target="_blank" rel="external">对于谷歌开源的TensorFlow Object Detection API视频物体识别系统实现教程</a></p><p>[2] <a href="http://blog.csdn.net/c20081052/article/details/77608954" target="_blank" rel="external">TensorFlow学习——Tensorflow Object Detection API（win10，CPU）</a></p><p>[3] <a href="https://towardsdatascience.com/how-to-train-your-own-object-detector-with-tensorflows-object-detector-api-bec72ecfe1d9" target="_blank" rel="external">How to train your own Object Detector with TensorFlow’s Object Detector API</a></p><p>[4] <a href="http://rensanning.iteye.com/blog/2381885" target="_blank" rel="external">TensorFlow 之 物体检测</a>（<a href="http://rensanning.iteye.com/category/374992" class="uri" target="_blank" rel="external">http://rensanning.iteye.com/category/374992</a>）</p><section class="footnotes"><hr><ol><li id="fn1"><p>See <a href="http://cocodataset.org/#detections-eval" target="_blank" rel="external">MSCOCO evaluation protocol</a>.<a href="#fnref1" class="footnote-back">↩</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#FA8072&quot;&gt;本文所用的 Python 版本为 python-3.6.2，TensorFlow 版本为tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。&lt;/font&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　很久没写过东西了，主要原因是最近研究生课程开始陆续结课，本人也要忙于应付各种结课时的考试、论文、project 等一堆麻烦事。这不深度学习结课时需要做个 project，本人也顺便将做这个 project 的过程记录下来。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
      <category term="Deep Learning" scheme="http://cniter.github.io/categories/Study/Deep-Learning/"/>
    
    
      <category term="tensorflow" scheme="http://cniter.github.io/tags/tensorflow/"/>
    
  </entry>
  
  <entry>
    <title>C语言中整型提升问题</title>
    <link href="http://cniter.github.io/posts/2a3d46b0.html"/>
    <id>http://cniter.github.io/posts/2a3d46b0.html</id>
    <published>2017-10-27T11:56:12.000Z</published>
    <updated>2018-01-31T09:18:43.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　今天有人问了本人一个移位的问题，就是下面这段 C 语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> a = <span class="number">0xffff</span>;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%#hx\n"</span>, a &lt;&lt; <span class="number">4</span> &gt;&gt; <span class="number">8</span> &lt;&lt; <span class="number">4</span>);</div></pre></td></tr></table></figure><p>你认为会输出什么结果？ ੧ಡ ⌣ ಡ੭</p><a id="more"></a><h2 id="解答篇">解答篇</h2><p>　　正确答案是：<code>0xfff0</code>。恐怕有一部分会像本人一样觉得答案就是 <code>0xff0</code> 才对，还像模像样的给出对应的说法：看 <code>a</code> 首先向左移四位，即去掉最左边的 <code>f</code>，右边补 4 个 0 变成这样 <code>0xfff0</code>；然后再向右移 8 位，a 将会变成这样 <code>0x00ff</code>；最后向左移四位，得到 <code>0x0ff0</code>，所以应该输出 <code>0xff0</code>。<strong>但是，正确答案终究是正确答案。</strong>之所以会输出正确答案，是因为这里面还有一个<strong>整型提升</strong>。所谓的整型提升就是：</p><blockquote><p>在一个表达式中，如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成unsigned int型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。</p></blockquote><p>　　所以在 <code>a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4</code> 中，会先将 a 提升为 int 型，即 a 会变成 <code>0x0000ffff</code>，接着向左移四位，a 变成 <code>0x000ffff0</code>，再向右移 8 位，变成 <code>0x00000fff</code>，最后向左移 4 位，变成 <code>0x0000fff0</code>，最后为了输出，再做一个隐式的类型转换（由 int 转 unsigned short），得到 <code>0xfff0</code>，所以最后输出 <code>0xfff0</code>。</p><h2 id="后记">后记</h2><p>　　这个问题是一个刚入大学的童靴问本人的，刚问本人时本人还没反应过来，后来才想起有整型提升这么回事 o(╯□╰)o。btw，这位童靴主要是想去掉高 4 位和低 4 位只取中间 8 位的值，其实最简单的办法就是直接 <code>a &amp; 0x0ff0</code>，这样管它有没有整型提升，肯定能得到中间 8 位的值 (╯▽╰)。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.csdn.net/mishifangxiangdefeng/article/details/47981889" target="_blank" rel="external">C语言进阶：整型提升</a>（<a href="http://blog.csdn.net/mishifangxiangdefeng/article/category/1058873" class="uri" target="_blank" rel="external">http://blog.csdn.net/mishifangxiangdefeng/article/category/1058873</a>）</p><p>[2] <a href="http://bbs.csdn.net/topics/390856773" target="_blank" rel="external">对 unsigned char 先左移 后右移 可以出现两种结果</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　今天有人问了本人一个移位的问题，就是下面这段 C 语言代码：&lt;/p&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;short&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;0xffff&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%#hx\n&quot;&lt;/span&gt;, a &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &amp;gt;&amp;gt; &lt;span class=&quot;number&quot;&gt;8&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;你认为会输出什么结果？ ੧ಡ ⌣ ಡ੭&lt;/p&gt;
    
    </summary>
    
      <category term="Problems" scheme="http://cniter.github.io/categories/Problems/"/>
    
    
      <category term="c/cpp" scheme="http://cniter.github.io/tags/c-cpp/"/>
    
  </entry>
  
  <entry>
    <title>TXT数据转OpenCV中的Mat数据</title>
    <link href="http://cniter.github.io/posts/dece8eba.html"/>
    <id>http://cniter.github.io/posts/dece8eba.html</id>
    <published>2017-10-19T09:01:01.000Z</published>
    <updated>2018-01-31T09:15:16.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本文是以前做的一个小东西的处理前奏，当时也记录过，现在把它翻出来重新看看。那个东西需要利用深度图，本人当时还没拿到 Kinect，就在网上下了一些<a href="https://drive.google.com/uc?export=download&amp;confirm=QRhv&amp;id=0B_9saHAqGFITODNmNzU0ZjctMjk0Yi00YjI5LWJmZDMtYTdiYTE2YzM5OTQ4" target="_blank" rel="external">数据</a>（<a href="http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm" class="uri" target="_blank" rel="external">http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm</a>），该数据集包含了彩色图及对应的深度图，但是该数据集没有以图像形式存储深度值，而是用 txt 文本以行列形式存储真正的深度值（单位为 mm），所以并不能直观的看到深度图像，本人需要把这些深度值从 txt 文本提取出来并把它以图像的形式呈现出来，由于需求比较特殊，网上没看到现成的解决的方案，所以本人只有用现成的轮子自己做一个了。</p><a id="more"></a><h2 id="思路篇">思路篇</h2><p>　　程序的基本思路是：先找到目录及子目录下的所有 txt 文件路径；再根据路径分别读取 txt 文件，按行读取之后再进行字符串分割提取其中的深度值；为了便于以图像形式显示，将深度值归一化至 0~255 存入 8 位单通道的 Mat 类型数据中，最后以 png 图像形式保存至各个目录。</p><h2 id="实现篇">实现篇</h2><p>　　因为当时还在用 opencv-2.4.11，所以本文所实现的代码是基于 opencv-2.4.11，不过应该只要在 opencv-2.0 版本及以上只要有 Mat 数据结构的都能用，毕竟本人只用到了 OpenCV 中的 Mat 数据结构。Talk is cheap, show you the code（代码很乱，估计也只用这么一次，所以就没怎么注意了 :-P）。具体 C++ 实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;io.h&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;direct.h&gt;  </span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// ******************************************************************</span></div><div class="line"><span class="comment">// @refer to  [C++文件读写操作（二）逐字符读取文本和逐行读取文本](http://blog.csdn.net/wangshihui512/article/details/8921924)</span></div><div class="line"><span class="comment">//            [字符串分割(C++)](http://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html)</span></div><div class="line"><span class="comment">//            [C++读取文件夹中所有的文件或者是特定后缀的文件](http://blog.csdn.net/adong76/article/details/39432467)</span></div><div class="line"><span class="comment">//            [C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用](http://blog.csdn.net/u012005313/article/details/50688257)</span></div><div class="line"><span class="comment">//            [Split a string in C++?](http://stackoverflow.com/questions/236129/split-a-string-in-c)</span></div><div class="line"><span class="comment">//            [Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取](http://blog.csdn.net/zouxy09/article/details/8151044)</span></div><div class="line"><span class="comment">//            [Depth Map Tutorial](http://www.pages.drexel.edu/~nk752/depthMapTut.html)</span></div><div class="line"><span class="comment">// ******************************************************************</span></div><div class="line"><span class="comment">// ----- 逐个字符读取文件 --------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testByChar</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    fstream testByCharFile;  </div><div class="line">    <span class="keyword">char</span> c;  </div><div class="line">    testByCharFile.open(<span class="string">"./test.txt"</span>,ios::in);  </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!testByCharFile.eof())  </div><div class="line">    &#123;  </div><div class="line">        testByCharFile&gt;&gt;c;  </div><div class="line">        <span class="built_in">cout</span>&lt;&lt;c;  </div><div class="line">    &#125;  </div><div class="line">    testByCharFile.close();  </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// -------- 逐行读取文件 -------------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testByLine</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">256</span>];  </div><div class="line">    fstream outFile;  </div><div class="line">    outFile.open(<span class="string">"./test.txt"</span>,ios::in);  </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!outFile.eof())  </div><div class="line">    &#123;  </div><div class="line">        outFile.getline(buffer, <span class="number">256</span>, <span class="string">'\n'</span>);<span class="comment">//getline(char *,int,char) 表示该行字符达到256个或遇到换行就结束  </span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">endl</span>; </div><div class="line">    &#125;  </div><div class="line">    outFile.close();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">//  ------- 分割字符串 --------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">splitString</span><span class="params">()</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">1280</span>];  </div><div class="line">    fstream outFile;  </div><div class="line">    outFile.open(<span class="string">"./test.txt"</span>,ios::in);  </div><div class="line"></div><div class="line">    <span class="keyword">while</span>(!outFile.eof())  </div><div class="line">    &#123;  </div><div class="line">        outFile.getline(buffer, <span class="number">1280</span>, <span class="string">'\n'</span>);<span class="comment">//getline(char *,int,char) 表示该行字符达到1280个或遇到换行就结束  </span></div><div class="line">        <span class="built_in">cout</span>&lt;&lt;buffer&lt;&lt;<span class="built_in">endl</span>; </div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *d = <span class="string">" ,*"</span>;</div><div class="line">        <span class="keyword">char</span> *p;</div><div class="line">        p = strtok(buffer, d);</div><div class="line">        <span class="keyword">while</span>(p)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, p);</div><div class="line">            p=strtok(<span class="literal">NULL</span>, d);</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    outFile.close();  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// 获取文件夹下指定格式所有文件名</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">getAllFormatFiles</span><span class="params">( <span class="built_in">string</span> path, <span class="built_in">string</span> format, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; files )</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="comment">//文件句柄    </span></div><div class="line">    <span class="keyword">long</span>   hFile   =   <span class="number">0</span>;    </div><div class="line">    <span class="comment">//文件信息    </span></div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">finddata_t</span> <span class="title">fileinfo</span>;</span>    </div><div class="line">    <span class="built_in">string</span> pathName;    </div><div class="line">    <span class="keyword">if</span>((hFile = _findfirst(pathName.assign(path).append(<span class="string">"/*."</span> + format).c_str(),&amp;fileinfo)) !=  <span class="number">-1</span>)    </div><div class="line">    &#123;    </div><div class="line">        <span class="keyword">do</span>    </div><div class="line">        &#123;   </div><div class="line">            <span class="comment">//如果是目录,迭代之  </span></div><div class="line">            <span class="comment">//如果不是,加入列表  </span></div><div class="line">            <span class="keyword">if</span>((fileinfo.attrib &amp;  _A_SUBDIR))    </div><div class="line">            &#123;    </div><div class="line">                <span class="keyword">if</span>(<span class="built_in">strcmp</span>(fileinfo.name,<span class="string">"."</span>) != <span class="number">0</span>  &amp;&amp;  <span class="built_in">strcmp</span>(fileinfo.name,<span class="string">".."</span>) != <span class="number">0</span>)    </div><div class="line">                &#123;  </div><div class="line">                    <span class="comment">//files.push_back(p.assign(path).append("/").append(fileinfo.name) );  </span></div><div class="line">                    getAllFormatFiles( pathName.assign(path).append(<span class="string">"/"</span>).append(fileinfo.name), format, files);   </div><div class="line">                &#125;  </div><div class="line">            &#125;    </div><div class="line">            <span class="keyword">else</span>    </div><div class="line">            &#123;    </div><div class="line">                files.push_back(pathName.assign(path).append(<span class="string">"/"</span>).append(fileinfo.name) );    </div><div class="line">            &#125;    </div><div class="line">        &#125;<span class="keyword">while</span>(_findnext(hFile, &amp;fileinfo) == <span class="number">0</span>);    </div><div class="line"></div><div class="line">        _findclose(hFile);   </div><div class="line">    &#125;   </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="comment">// http://stackoverflow.com/questions/236129/split-a-string-in-c</span></div><div class="line"><span class="comment">// ---- stackoverflow上大神的C++版本分割字符串 --------------------</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; split(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; text, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; delims)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> start = text.find_first_not_of(delims), end = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span>((end = text.find_first_of(delims, start)) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</div><div class="line">    &#123;</div><div class="line">        tokens.push_back(text.substr(start, end - start));</div><div class="line">        start = text.find_first_not_of(delims, end);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(start != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</div><div class="line">        tokens.push_back(text.substr(start));</div><div class="line"></div><div class="line">    <span class="keyword">return</span> tokens;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 创建文件夹及子文件夹</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeDir</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; tokens;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ((end = path.find(<span class="string">'/'</span>, start)) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos) </div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (end != start) </div><div class="line">        &#123;</div><div class="line">            tokens.push_back(path.substr(<span class="number">0</span>, end));</div><div class="line">        &#125;</div><div class="line">        start = end + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (end != start) </div><div class="line">    &#123;</div><div class="line">        tokens.push_back(path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::const_iterator itp = tokens.begin();</div><div class="line">    <span class="keyword">while</span> (itp != tokens.end())</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (access(itp-&gt;c_str(), <span class="number">0</span>) == <span class="number">-1</span>)  <span class="comment">// 判断文件夹是否存在  </span></div><div class="line">        &#123;  </div><div class="line">            <span class="built_in">cout</span>&lt;&lt;*itp&lt;&lt;<span class="string">" is not existing"</span>&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"now make it"</span>&lt;&lt;<span class="built_in">endl</span>;  </div><div class="line">            <span class="keyword">if</span> (mkdir(itp-&gt;c_str()) == <span class="number">0</span>)   <span class="comment">// 不存在则创建，只能一级一级的创建</span></div><div class="line">            &#123;</div><div class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"make successfully"</span>&lt;&lt;<span class="built_in">endl</span>; </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; *itp++ &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Txt文件转opencv Mat（txt文件中存的是以行列形式的深度值）</span></div><div class="line">cv::<span class="function">Mat <span class="title">Txt2DepthMat</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;txtname)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    cv::Mat result(480, 640, CV_8UC1, cv::Scalar(0));</div><div class="line"></div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">12800</span>];     <span class="comment">// 按行读取文件</span></div><div class="line">    fstream outFile;  </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *d = <span class="string">","</span>;    <span class="comment">// 以,为分割点</span></div><div class="line">    <span class="keyword">char</span> *p;    <span class="comment">// 分割出的子串</span></div><div class="line">    outFile.open(txtname, ios::in);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; outFile.getline(buffer, <span class="number">12800</span>, <span class="string">'\n'</span>) != <span class="literal">NULL</span> &amp;&amp; i &lt; result.rows; i++)</div><div class="line">    &#123;</div><div class="line">        p = strtok(buffer, d);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; p &amp;&amp; j &lt; result.cols; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> realDepth = (atoi(p) &amp; <span class="number">0xfff8</span>) &gt;&gt; <span class="number">3</span>; <span class="comment">//提取距离信息，高13位</span></div><div class="line">            <span class="keyword">int</span> depth = (<span class="keyword">int</span>)(<span class="number">256</span> * realDepth / <span class="number">0x0fff</span>); <span class="comment">//因为提取的信息是距离信息，为了便于显示，这里归一化为0-255  </span></div><div class="line">            result.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(depth);</div><div class="line">            p = strtok(<span class="literal">NULL</span>, d);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    outFile.close();  </div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 以颜色表示深度信息，越暖（红色）越近，越冷（蓝色）越远</span></div><div class="line">cv::<span class="function">Mat <span class="title">Depth2Color</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;depth)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    cv::Mat result(depth.size(), CV_8UC3, cv::Scalar::all(0));</div><div class="line">    <span class="keyword">int</span> tempDepth, depthRed, depthGreen, depthBlue;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.rows; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; result.cols; j++)</div><div class="line">        &#123;</div><div class="line">            tempDepth = <span class="number">255</span> - depth.at&lt;uchar&gt;(i, j);</div><div class="line">            <span class="keyword">if</span>(tempDepth &lt; <span class="number">43</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = tempDepth * <span class="number">6</span>;</div><div class="line">                depthGreen = <span class="number">0</span>;</div><div class="line">                depthBlue = tempDepth * <span class="number">6</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">42</span> &amp;&amp; tempDepth &lt; <span class="number">85</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">255</span> - (tempDepth - <span class="number">43</span>) * <span class="number">6</span>;</div><div class="line">                depthGreen = <span class="number">0</span>;</div><div class="line">                depthBlue = <span class="number">255</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">84</span> &amp;&amp; tempDepth &lt; <span class="number">128</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">0</span>;</div><div class="line">                depthGreen = (tempDepth - <span class="number">85</span>) * <span class="number">6</span>;</div><div class="line">                depthBlue = <span class="number">255</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">127</span> &amp;&amp; tempDepth &lt; <span class="number">169</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">0</span>;</div><div class="line">                depthGreen = <span class="number">255</span>;</div><div class="line">                depthBlue = <span class="number">255</span> - (tempDepth - <span class="number">128</span>) * <span class="number">6</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">168</span> &amp;&amp; tempDepth &lt; <span class="number">212</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = (tempDepth - <span class="number">169</span>) * <span class="number">6</span>;</div><div class="line">                depthGreen = <span class="number">255</span>;</div><div class="line">                depthBlue = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">211</span> &amp;&amp; tempDepth &lt; <span class="number">254</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">255</span>;</div><div class="line">                depthGreen = <span class="number">255</span> - (tempDepth - <span class="number">212</span>) * <span class="number">6</span>;</div><div class="line">                depthBlue = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(tempDepth &gt; <span class="number">253</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">255</span>;</div><div class="line">                depthGreen = <span class="number">0</span>;</div><div class="line">                depthBlue = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (tempDepth == <span class="number">255</span>)</div><div class="line">            &#123;</div><div class="line">                depthRed = <span class="number">0</span>;</div><div class="line">                depthGreen = <span class="number">0</span>;</div><div class="line">                depthBlue = <span class="number">0</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            result.at&lt;Vec3b&gt;(i, j)[<span class="number">0</span>] = depthBlue;</div><div class="line">            result.at&lt;Vec3b&gt;(i, j)[<span class="number">1</span>] = depthGreen;</div><div class="line">            result.at&lt;Vec3b&gt;(i, j)[<span class="number">2</span>] = depthRed;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">string</span> filePath = <span class="string">"C:/Users/XXXXXX/Downloads/NTU-Microsoft-Kinect-HandGesture Dataset/Depth"</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; files;  </div><div class="line">    <span class="comment">//读取所有文件  </span></div><div class="line">    <span class="built_in">string</span> format = <span class="string">"*"</span>;  <span class="comment">// 不知道为什么在我电脑读不了特定文件？</span></div><div class="line">    getAllFormatFiles(filePath, format, files);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; files.size(); i++)    </div><div class="line">    &#123;</div><div class="line">        cv::Mat tempMat = Txt2DepthMat(files[i]);</div><div class="line">        files[i].replace(<span class="number">0</span>, <span class="number">66</span>, <span class="string">"../data"</span>);</div><div class="line">        files[i].replace(files[i].find(<span class="string">".txt"</span>), files[i].length() - <span class="number">1</span>, <span class="string">".png"</span>);</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; files[i] &lt;&lt; <span class="built_in">endl</span>; </div><div class="line">        <span class="built_in">string</span> tempString = files[i].substr(<span class="number">0</span>, files[i].find_last_of(<span class="string">"/"</span>));</div><div class="line">        makeDir(tempString);</div><div class="line">        cv::imwrite(files[i], tempMat);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"File Size: "</span> &lt;&lt; files.size() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="comment">//cv::imshow("test", Depth2Color(Txt2DepthMat("./1.txt")));</span></div><div class="line">    cv::waitKey(<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong><em>2018-01-01 BTW：</em></strong>以上代码在 VS2010+Win7 下编译运行通过，在 VS2013+Win10 下 <code>for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++)</code> 会报错，可能需要改成 <code>for (int i = 0; outFile.getline(buffer, 12800, '\n') &amp;&amp; i &lt; result.rows; i++)</code> ，即去掉后面的 <code>!= NULL</code>。</p><h2 id="后记">后记</h2><p>　　正如前言所说，本文是以前记录过的，一些细节也快忘记，这次重写算是回顾一下吧，这段程序可能也确实只用这么一次，但其中用到了不少 C++ 处理字符串和读写文件等相关知识，而这些知识，在以后有极大的可能会再次用到，因此记录 ↖(^ω^)↗。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.csdn.net/wangshihui512/article/details/8921924" target="_blank" rel="external">C++文件读写操作（二）逐字符读取文本和逐行读取文本</a>（<a href="http://blog.csdn.net/shihui512/article/category/1397194" class="uri" target="_blank" rel="external">http://blog.csdn.net/shihui512/article/category/1397194</a>）</p><p>[2] <a href="http://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html" target="_blank" rel="external">字符串分割(C++)</a>（<a href="http://www.cnblogs.com/MikeZhang/category/345894.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/MikeZhang/category/345894.html</a>）</p><p>[3] <a href="http://blog.csdn.net/adong76/article/details/39432467" target="_blank" rel="external">C++读取文件夹中所有的文件或者是特定后缀的文件</a>（<a href="http://blog.csdn.net/adong76/article/category/1632029" class="uri" target="_blank" rel="external">http://blog.csdn.net/adong76/article/category/1632029</a>）</p><p>[4] <a href="http://blog.csdn.net/u012005313/article/details/50688257" target="_blank" rel="external">C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用</a>（<a href="http://blog.csdn.net/u012005313/article/category/5586103" class="uri" target="_blank" rel="external">http://blog.csdn.net/u012005313/article/category/5586103</a>）</p><p>[5] <a href="https://stackoverflow.com/questions/236129/the-most-elegant-way-to-iterate-the-words-of-a-string/7408245#7408245" target="_blank" rel="external">Split a string in C++?</a>（<a href="http://stackoverflow.com/questions/236129/split-a-string-in-c" class="uri" target="_blank" rel="external">http://stackoverflow.com/questions/236129/split-a-string-in-c</a>）</p><p>[6] <a href="http://blog.csdn.net/zouxy09/article/details/8151044" target="_blank" rel="external">Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取</a>（<a href="http://blog.csdn.net/zouxy09/article/category/1273380" class="uri" target="_blank" rel="external">http://blog.csdn.net/zouxy09/article/category/1273380</a>）</p><p>[7] <a href="http://www.pages.drexel.edu/~nk752/depthMapTut.html" target="_blank" rel="external">Depth Map Tutorial</a>（<a href="http://www.pages.drexel.edu/~nk752/depthMapTut.html" class="uri" target="_blank" rel="external">http://www.pages.drexel.edu/~nk752/depthMapTut.html</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文是以前做的一个小东西的处理前奏，当时也记录过，现在把它翻出来重新看看。那个东西需要利用深度图，本人当时还没拿到 Kinect，就在网上下了一些&lt;a href=&quot;https://drive.google.com/uc?export=download&amp;amp;confirm=QRhv&amp;amp;id=0B_9saHAqGFITODNmNzU0ZjctMjk0Yi00YjI5LWJmZDMtYTdiYTE2YzM5OTQ4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;数据&lt;/a&gt;（&lt;a href=&quot;http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm&quot; class=&quot;uri&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm&lt;/a&gt;），该数据集包含了彩色图及对应的深度图，但是该数据集没有以图像形式存储深度值，而是用 txt 文本以行列形式存储真正的深度值（单位为 mm），所以并不能直观的看到深度图像，本人需要把这些深度值从 txt 文本提取出来并把它以图像的形式呈现出来，由于需求比较特殊，网上没看到现成的解决的方案，所以本人只有用现成的轮子自己做一个了。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="c/cpp" scheme="http://cniter.github.io/tags/c-cpp/"/>
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中滑动条和鼠标事件响应操作的使用小结</title>
    <link href="http://cniter.github.io/posts/e8b35736.html"/>
    <id>http://cniter.github.io/posts/e8b35736.html</id>
    <published>2017-10-08T09:06:29.000Z</published>
    <updated>2018-01-31T09:10:02.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　既然在<a href="https://cniter.github.io/posts/b6fb6109.html">上一篇</a>中提到了回调函数，本人就干脆把 OpenCV 中较常使用的两个使用回调函数的函数使用方法也一并记录下来吧。</p><a id="more"></a><h2 id="说明篇">说明篇</h2><p>OpenCV 中使用回调函数的两个函数为：</p><ol type="1"><li><p><strong>鼠标事件响应操作函数：</strong><code>void cv::setMouseCallback(const string&amp; winname, MouseCallback onMouse, void* userdata = 0);</code></p><p><strong><em>参数浅解：</em></strong></p><blockquote><p><code>const string&amp; winname</code>：窗口名称，对名为winname的窗口执行鼠标事件响应操作；</p><p><code>MouseCallback onMouse</code>：鼠标响应事件回调函数，监听鼠标的点击，移动，松开，判断鼠标的操作类型并做出相应处理；</p><p><code>void* userdata</code>：对应回调函数的可选参数，若使用全局变量可以忽略该参数。</p></blockquote><p><em>对应的回调函数声明为：</em><code>typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);</code></p><p><strong><em>参数浅解：</em></strong></p><blockquote><p><code>int event</code>：鼠标滑动（CV_EVENT_MOUSEMOVE）、左键单击（CV_EVENT_LBUTTONDOWN）、右键单击（CV_EVENT_RBUTTONDOWN ）等10种鼠标点击事件的int型代号；</p><p><code>int x, int y</code>：鼠标位于窗口的（x，y）坐标位置，窗口左上角默认为原点，向右为x正轴，向下为y正轴；</p><p><code>int flags</code>：鼠标左键拖拽（CV_EVENT_FLAG_LBUTTON）、右键拖拽（CV_EVENT_FLAG_RBUTTON）等6种鼠标拖拽事件的int型代号；</p><p><code>void* userdata</code>：回调函数的参数，若使用全局变量可以忽略该参数。</p></blockquote></li><li><p><strong>创建滑动条函数：</strong><code>int cv::createTrackbar(const string&amp; trackbarname, const string&amp; winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0);</code></p><p><strong><em>参数浅解：</em></strong></p><blockquote><p><code>const string&amp; trackbarname</code>：创建的滑动条名称；</p><p><code>const string&amp; winname</code>：所在窗口名称，对名为winname的窗口添加滑动条；</p><p><code>int* value</code>：滑块的位置，其初始值对应滑块的初始位置；</p><p><code>int count</code>：滑块可达到的最大位置的值，滑块最小位置的值总为0；</p><p><code>TrackbarCallback onChange</code>：滑动条事件回调函数，当滑动条上位置改变的时，则执行该回调函数；</p><p><code>void* userdata</code>：对应回调函数的可选参数，若使用全局变量可以忽略该参数。</p></blockquote><p><em>对应的回调函数声明为：</em><code>typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);</code></p><p><strong><em>参数浅解：</em></strong></p><blockquote><p><code>int pos</code>：滑动条的位置对应的值；</p><p><code>void* userdata</code>：回调函数的参数，若使用全局变量可以忽略该参数。</p></blockquote></li></ol><p><em>※注：本文的函数说明采用的是 opencv-2.4.11 的函数声明，与 opencv-3.2.0 的函数声明区别在于 <code>string</code> 类型，opencv-3.2.0 采用的是其自己实现的一个 <code>String</code> 类。</em></p><h2 id="实例篇">实例篇</h2><p>Show u the code，具体 C++ 实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt; </span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// ---------------- 鼠标事件回调函数 ---------------------------------</span></div><div class="line"><span class="keyword">static</span> cv::Mat src_img;	<span class="comment">// 原始图像全局变量</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mouseCallback</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span> *)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">bool</span> selected = <span class="literal">false</span>;</div><div class="line">	<span class="keyword">static</span> cv::Point left_top_vertex, right_down_vertex;	<span class="comment">// 左上角顶点和右下角顶点</span></div><div class="line">	<span class="comment">// When the left mouse button is pressed, record its position and save it in corner1  </span></div><div class="line">	<span class="keyword">if</span> (event == CV_EVENT_LBUTTONDOWN)	<span class="comment">// 左键按下</span></div><div class="line">	&#123;</div><div class="line">		left_top_vertex.x = x;</div><div class="line">		left_top_vertex.y = y;</div><div class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Corner 1 recorded at "</span> &lt;&lt; left_top_vertex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// When the left mouse button is released, record its position and save it in corner2  </span></div><div class="line">	<span class="keyword">if</span> (event == cv::EVENT_LBUTTONUP)	<span class="comment">// 左键弹起</span></div><div class="line">	&#123;</div><div class="line">		<span class="comment">// Also check if user selection is bigger than 20 pixels (jut for fun!)  </span></div><div class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(x - left_top_vertex.x) &gt; <span class="number">10</span> &amp;&amp; <span class="built_in">abs</span>(y - left_top_vertex.y) &gt; <span class="number">10</span>)</div><div class="line">		&#123;</div><div class="line">			right_down_vertex.x = x;</div><div class="line">			right_down_vertex.y = y;</div><div class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Corner 2 recorded at "</span> &lt;&lt; right_down_vertex &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">			selected = <span class="literal">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span></div><div class="line">		&#123;</div><div class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please select a bigger region"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Update the box showing the selected region as the user drags the mouse  </span></div><div class="line">	<span class="keyword">if</span> (flags == CV_EVENT_FLAG_LBUTTON)	<span class="comment">// 左键拖拽</span></div><div class="line">	&#123;</div><div class="line">		cv::Point pt;</div><div class="line">		pt.x = x;</div><div class="line">		pt.y = y;</div><div class="line">		cv::Mat local_img = src_img.clone();</div><div class="line">		rectangle(local_img, left_top_vertex, pt, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>));</div><div class="line">		imshow(<span class="string">"Cropping app"</span>, local_img);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// Define ROI and crop it out when both corners have been selected  </span></div><div class="line">	<span class="keyword">if</span> (selected)</div><div class="line">	&#123;</div><div class="line">		cv::Rect box;</div><div class="line">		box.width = <span class="built_in">abs</span>(left_top_vertex.x - right_down_vertex.x);</div><div class="line">		box.height = <span class="built_in">abs</span>(left_top_vertex.y - right_down_vertex.y);</div><div class="line">		box.x = cv::min(left_top_vertex.x, right_down_vertex.x);</div><div class="line">		box.y = cv::min(left_top_vertex.y, right_down_vertex.y);</div><div class="line">		<span class="comment">// Make an image out of just the selected ROI and display it in a new window  </span></div><div class="line">		cv::<span class="function">Mat <span class="title">crop</span><span class="params">(src_img, box)</span></span>;</div><div class="line">		cv::namedWindow(<span class="string">"Crop"</span>);</div><div class="line">		imshow(<span class="string">"Crop"</span>, crop);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ---------- 响应鼠标事件 ------------------------------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setMouseCallbackTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	src_img = cv::imread(<span class="string">"../data/lena.jpg"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);</div><div class="line">	cv::namedWindow(<span class="string">"Cropping app"</span>);</div><div class="line">	imshow(<span class="string">"Cropping app"</span>, src_img);</div><div class="line">	<span class="comment">// Set the mouse event callback function  </span></div><div class="line">	cv::setMouseCallback(<span class="string">"Cropping app"</span>, mouseCallback);</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="keyword">char</span>(cv::waitKey(<span class="number">30</span>)) != <span class="string">'q'</span>) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// -------------- 滑动条回调函数 ------------------------</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">thresholdCallback</span><span class="params">(<span class="keyword">int</span> slider_value, <span class="keyword">void</span>* gray)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">//static_cast&lt;&gt;用于安全转换指针</span></div><div class="line">	cv::Mat *tmp_gray = <span class="keyword">static_cast</span>&lt;cv::Mat *&gt;(gray);</div><div class="line">	cv::Mat tmp = *tmp_gray;</div><div class="line">	cv::Mat dst;</div><div class="line">	threshold(tmp, dst, slider_value, <span class="number">255</span>, CV_THRESH_BINARY);</div><div class="line"></div><div class="line">	<span class="comment">//显示效果图</span></div><div class="line">	cv::imshow(<span class="string">"Trackbar Demo"</span>, dst);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ------------ 创建滑动条 ----------------------------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createTrackbarTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat src_gray = cv::imread(<span class="string">"../data/lena.jpg"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> max_value = <span class="number">255</span>;	<span class="comment">//滑动条的最大值</span></div><div class="line">	<span class="keyword">int</span> slider_value = <span class="number">0</span>;	<span class="comment">// 滑动条的初始值</span></div><div class="line"></div><div class="line">	<span class="keyword">char</span> *window_name = <span class="string">"Trackbar Demo"</span>;</div><div class="line">	<span class="keyword">char</span> *trackbar_name = <span class="string">"Value:"</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个窗口显示图片</span></div><div class="line">	cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE);</div><div class="line">	imshow(window_name, src_gray);</div><div class="line"></div><div class="line">	<span class="comment">// 创建滑动条来控制阈值</span></div><div class="line">	createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_gray);</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="keyword">char</span>(cv::waitKey(<span class="number">30</span>)) != <span class="string">'q'</span>) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// ------- 将两个函数在同一个窗口执行 ------------</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">callbackTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	src_img = cv::imread(<span class="string">"../data/lena.jpg"</span>, <span class="number">0</span>);</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> max_value = <span class="number">255</span>;	<span class="comment">//滑动条的最大值</span></div><div class="line">	<span class="keyword">int</span> slider_value = <span class="number">0</span>;	<span class="comment">// 滑动条的初始值</span></div><div class="line"></div><div class="line">	<span class="keyword">char</span> *window_name = <span class="string">"Callback Demo"</span>;</div><div class="line">	<span class="keyword">char</span> *trackbar_name = <span class="string">"Value:"</span>;</div><div class="line"></div><div class="line">	<span class="comment">// 创建一个窗口显示图片</span></div><div class="line">	cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE);</div><div class="line">	imshow(window_name, src_img);</div><div class="line"></div><div class="line">	<span class="comment">// 创建滑动条来控制阈值</span></div><div class="line">	createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_img);</div><div class="line"></div><div class="line">	<span class="comment">// 鼠标事件响应</span></div><div class="line">	cv::setMouseCallback(window_name, mouseCallback);</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="keyword">char</span>(cv::waitKey(<span class="number">30</span>)) != <span class="string">'q'</span>) &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">//setMouseCallbackTest();</span></div><div class="line">	<span class="comment">//createTrackbarTest();</span></div><div class="line">	callbackTest();</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (<span class="keyword">char</span>(cv::waitKey(<span class="number">30</span>)) != <span class="string">'q'</span>) &#123;&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　经本人测试，上面示例程序在 Win10 的 VS2013 中 opencv-2.4.11 和 opencv-3.2.0 下都能完美运行。</p><h2 id="后记">后记</h2><p>　　本来这两个函数都已经写（chao）好了，但为了更好的体现示例程序，又稍作了修改：添加鼠标左键拖拽事件及不使用全局变量等。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://www.cnblogs.com/lidabo/p/3437587.html" target="_blank" rel="external">opencv2 使用鼠标绘制矩形并截取和保存矩形区域图像</a>（<a href="http://www.cnblogs.com/lidabo/category/516776.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/lidabo/category/516776.html</a>）</p><p>[2] <a href="http://blog.csdn.net/weixin_35738542/article/details/52071963" target="_blank" rel="external">Opencv中添加进度条及回调函数</a>（<a href="http://blog.csdn.net/weixin_35738542/article/category/6337413" class="uri" target="_blank" rel="external">http://blog.csdn.net/weixin_35738542/article/category/6337413</a>）</p><p>[3] <a href="http://blog.csdn.net/u014291399/article/details/47811905" target="_blank" rel="external">OpenCV2中滑动条（Trackbar）回调函数的小发现</a>（<a href="http://blog.csdn.net/u014291399/article/category/3097955" class="uri" target="_blank" rel="external">http://blog.csdn.net/u014291399/article/category/3097955</a>）</p><p>[4] <a href="http://blog.csdn.net/wangyaninglm/article/details/42032825" target="_blank" rel="external">OpenCV GUI基本操作，回调函数，进度条，裁剪图像等</a>（<a href="http://blog.csdn.net/wangyaninglm/article/category/1653815" class="uri" target="_blank" rel="external">http://blog.csdn.net/wangyaninglm/article/category/1653815</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　既然在&lt;a href=&quot;https://cniter.github.io/posts/b6fb6109.html&quot;&gt;上一篇&lt;/a&gt;中提到了回调函数，本人就干脆把 OpenCV 中较常使用的两个使用回调函数的函数使用方法也一并记录下来吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>利用回调函数计算函数运行时间</title>
    <link href="http://cniter.github.io/posts/b6fb6109.html"/>
    <id>http://cniter.github.io/posts/b6fb6109.html</id>
    <published>2017-09-28T07:36:16.000Z</published>
    <updated>2018-01-31T09:02:38.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　曾有一段时间在写一个小程序，由于其对运行时间有要求，所以每写一段代码就要测试一下运行时间，如果超出就需要优化一下代码或换一种方法和算法。但是每次都需要插在某两个位置插两段代码感觉有点烦，也有点浪费时间，毕竟浪费时间就是浪费生命，本着保尔柯察金关于生命的言论，本人不愿虚度年华，所以只得寻找一个方便简洁的方法计算运行时间（说了这么多，说到底其实就是懒吧 */ω\*）。后面就想到了回调函数，将想要计算运行时间的代码段放入一个函数中，并将其作为回调函数，用事先写好的计算时间函数调用它，从而方便计算该代码段的运行时间。</p><a id="more"></a><h2 id="正文">正文</h2><p>Show u the code，具体 C++ 实现代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _CALLED_ printf(<span class="meta-string">"The function %s"</span>, __FUNCTION__);</span></div><div class="line"></div><div class="line"><span class="comment">// 使用回调函数计算一段代码执行时间</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">computeTotalTime</span><span class="params">(<span class="keyword">void</span>(*processingCallback)</span><span class="params">()</span> </span>= <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">	<span class="keyword">clock_t</span> start_time = clock();</div><div class="line">	processingCallback();</div><div class="line">	<span class="keyword">clock_t</span> end_time = clock();</div><div class="line">	<span class="built_in">printf</span>(<span class="string">" takes: %fs.\n"</span>, (<span class="keyword">double</span>)(end_time - start_time) / CLOCKS_PER_SEC);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</div><div class="line">	&#123;</div><div class="line">		<span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</div><div class="line">	&#125;</div><div class="line">	_CALLED_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	computeTotalTime(test);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>以上代码在 Win10 VS2013 中编译运行成功。</em></p><h2 id="后记">后记</h2><p>　　本来是想在网上找一个的，谁知道并没有找到，就只有自己动手实现一个了 ╮(╯_╰)╭。后面使用了一下该函数，发现好像并没有提高生产力 o(╯□╰)o，所以就没人放在网上？-_-!，不过确实从实现过程中学到了一些东西 ↖(^ω^)↗。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://www.cnblogs.com/danshui/archive/2012/01/02/2310114.html" target="_blank" rel="external">C/C++之回调函数</a>（<a href="http://www.cnblogs.com/danshui/category/345046.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/danshui/category/345046.html</a>）</p><p>[2] <a href="http://blog.csdn.net/coder_xia/article/details/6566708" target="_blank" rel="external">c/c++在windows下获取时间和计算时间差的几种方法总结</a>（<a href="http://blog.csdn.net/coder_xia/article/category/837943" class="uri" target="_blank" rel="external">http://blog.csdn.net/coder_xia/article/category/837943</a>）</p><p>[3] <a href="http://www.cnblogs.com/steady/archive/2011/03/08/1977029.html" target="_blank" rel="external">(转)用宏获取函数名</a>（<a href="http://www.cnblogs.com/steady/category/264974.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/steady/category/264974.html</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　曾有一段时间在写一个小程序，由于其对运行时间有要求，所以每写一段代码就要测试一下运行时间，如果超出就需要优化一下代码或换一种方法和算法。但是每次都需要插在某两个位置插两段代码感觉有点烦，也有点浪费时间，毕竟浪费时间就是浪费生命，本着保尔柯察金关于生命的言论，本人不愿虚度年华，所以只得寻找一个方便简洁的方法计算运行时间（说了这么多，说到底其实就是懒吧 */ω\*）。后面就想到了回调函数，将想要计算运行时间的代码段放入一个函数中，并将其作为回调函数，用事先写好的计算时间函数调用它，从而方便计算该代码段的运行时间。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="c/cpp" scheme="http://cniter.github.io/tags/c-cpp/"/>
    
  </entry>
  
  <entry>
    <title>论如何科学的上网</title>
    <link href="http://cniter.github.io/posts/df943c4f.html"/>
    <id>http://cniter.github.io/posts/df943c4f.html</id>
    <published>2017-09-22T07:36:43.000Z</published>
    <updated>2018-03-14T01:22:28.081Z</updated>
    
    <content type="html"><![CDATA[<p>科学式上网推荐组合：Chrome，Proxy SwitchyOmega，Lantern 等代理工具。</p><h2 id="前言">前言</h2><p>　　所谓的科学式上网，懂的自然懂，本人也就不做过多解释了。本来一直在用别人免费提供的 pac 代理，但最近可能别人关掉了，上不了 google 了，就只能另寻他路了。所谓的另寻他路也就是尝试云端框架网站站长 <strong><em>枂下</em></strong> 提供的另外几种科学式上网攻略。本文只是对 <strong><em>枂下</em></strong> 站长的攻略做一下试验记录，若想看原滋原味的攻略，还请移步 <a href="https://cloudfra.com/" target="_blank" rel="external">云端框架</a>。</p><a id="more"></a><h2 id="科学的上网方法">科学的上网方法</h2><p>　　尽量使用 Chrome 进行科学式上网，因为其有一个代理管理插件 Proxy SwitchyOmega，该插件称之为代理切换神器也不为过，网上大量的教程和配置文件也是基于该神器做的。使用 Proxy SwitchyOmega 需要进行配置，这对初学者有一定的难度，这里本人推荐直接使用站长 <strong><em>枂下</em></strong> 提供的配置文件，至于 SwitchyOmega 的配置文件可以去站长的 <a href="https://cloudfra.com/" target="_blank" rel="external">云端框架</a> 网站上去下，也可以联系本人。至于代理工具请看下文，本人目前也只尝试过使用以下几种工具。</p><h3 id="lantern">lantern</h3><p>　　其实本人最先尝试的工具是 XX-NET，但是其配置起来稍显繁琐，而且在第一步的时候必须处在科学式上网环境，而 Lantern 就比较简单了，只要装上之后再稍微动动手脚就可以了，所以就把 lantern 写在第一位了。从站长 <strong><em>枂下</em></strong> 那下载【蓝】灯电脑破解版压缩包，不过本人觉得应该随便在哪里下载个原版 lantern-2.2.5 安装都可以，只要后续的破解方法一样即可。</p><p>　　具体破解方法为：主要是令 lantern 一直保持在 2.2.5 版本不变。但是一般来说 lantern 在安装之后会自动更新到最新版（本人在两台电脑上都安装过 lantern，其中一台安装完之后打开 lantern 安装文件夹发现其已更新，而另一台却没有更新，这就有点玄学了 -_-!），至于判断 lantern 有没有更新的办法是：首先进入 lantern 的安装文件夹：<code>C:\Users\XXX\AppData\Roaming\Lantern</code>（将XXX改成自己的用户名），1、看 lantern.exe 文件的修改日期，如果还是 2016 年的，就说明其还没更新；2、显示隐藏文件，看有没有 .lantern.exe.old 文件，如果没有，则也还没更新。如果已经更新了，参考站长 <strong><em>枂下</em></strong> 的说法：</p><blockquote><p>删除lantern.exe文件，修改.lantern.exe.old为lantern.exe</p></blockquote><p>这样就又可以回退至 lantern-2.2.5 版。如果没更新的话就不用进行删除回退这一步，直接进行下一步。</p><p>　　下一步为修改 lantern-2.2.5.yaml 文件中的更新路径 <code>updateserverurl</code>，使 lantern 永远不再更新，一直维持在 2.2.5 版本不变。具体更改方式为：</p><blockquote><p>将其中的</p><p><code>updateserverurl: https://update.getlantern.org</code></p><p>修改为</p><p><code>updateserverurl: https://pic.black1ce.com</code></p></blockquote><p>修改完之后保存退出。这里本人觉得可以随便将其修改成其它路径即可，毕竟只是让其不更新而已，这个路径应该除了更新就没有其它作用了，这纯属本人拙劣的猜测，有（ai）兴（gao）趣（shi）的童靴可以试试 :-P。</p><p>　　原本以为到这一步就完成了，但是 <strong><em>枂下</em></strong> 站长后来又补发了一步，就是上面几步只是让 lantern 不再更新，而 500M 流量之后限速的问题仍然存在（本人目前还没超过 500M，所以不知道这个问题，但抱着有备无患的心态先把 <strong><em>枂下</em></strong> 站长的攻略记一下 O(∩_∩)O~），所以接下来才是上正菜，破解“限制500M流量”问题的具体方法为：当使用 lantern 流量超过 500M 时，打开 lantern 的安装目录，打开 lantern-2.2.5.yaml 文件，</p><blockquote><p>修改其中第九行的设备号，随意更换一个数字或者字母即可。</p></blockquote><p>按 <strong><em>枂下</em></strong> 站长的说法是 8 位随机字母数字大小写均可，只是为方便起见推荐只改动某位即可。</p><p>eg：本人目前第 9 行为：<code>deviceid: Gu25Sfoz</code>，一旦 500M 流量用完了，本人就只需要将其修改为 <code>deviceid: Gu25Sfoa</code> 即可。</p><p>到这一步 lantern 的破解算是基本完成了吧，如果 <strong><em>枂下</em></strong> 站长有新的更新且被本人看到的话再进行实验更新吧。</p><hr><h3 id="xx-net">XX-NET</h3><p>　　该工具应该是本人尝试配置的首款代理工具，不得不说其配置和 lantern 相比实在是太复杂了，而且其中有一步还必须处在科学式网络环境中，本人还是借助别人的 VPN 上的（当时还没用 lantern，所以没用其 500M 免费不限速的流量 ~~o(&gt;_&lt;)o~~）。本人经过实测 XX-NET 无法在 Firefox 中用 google 搜索，一用 google 搜就会报错：</p><blockquote><p><font size="7" face="黑体"><strong>您的连接并不安全</strong></font></p><p>www.google.com 的网站管理员未正确配置网站。为避免您的信息被窃，Firefox 没有与该网站建立连接。</p><p>此网站采用了 HTTP 严格传输安全（HSTS）机制，要求 Firefox 只能与其建立安全连接。正因如此，您也不能将此证书加入例外列表。</p><blockquote><p>www.google.com 使用了无效的安全证书。 该证书因为其颁发者证书未知而不被信任。 该服务器可能未发送相应的中间证书。 可能需要导入一个额外的根证书。 错误代码: SEC_ERROR_UNKNOWN_ISSUER</p><blockquote><p>https://www.google.com/search?q=test&amp;ie=utf-8&amp;oe=utf-8</p><p>对等端的证书颁发者不受认可。</p><p>HTTP 严格传输安全（HSTS）：false HTTP 公钥钉扎：true</p><p>证书链：</p><p>—–BEGIN CERTIFICATE—– MIIDkzCCAnugAwIBAgIQSu4RvcIwnqiEQE6Z68FlaDANBgkqhkiG9w0BAQsFADBz MQswCQYDVQQGEwJDTjERMA8GA1UECAwISW50ZXJuZXQxDzANBgNVBAcMBkNlcm5l dDEQMA4GA1UECgwHR29BZ2VudDEVMBMGA1UECwwMR29BZ2VudCBSb290MRcwFQYD VQQDDA5Hb0FnZW50IFhYLU5ldDAeFw0xNzA5MTYxNDIzMjRaFw0yNzA5MTQxNDMz MjRaMHgxCzAJBgNVBAYTAkNOMREwDwYDVQQIDAhJbnRlcm5ldDEPMA0GA1UEBwwG Q2VybmV0MRcwFQYDVQQLDA5Hb0FnZW50IEJyYW5jaDEVMBMGA1UEAwwMKi5nb29n bGUuY29tMRUwEwYDVQQKDAwqLmdvb2dsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDL3K1OgwalKOJPtO4urpAiu+lioGNax/EIaYR1D2kH66AJ lpal0pYFhXF6MOYCUNfpZIqP5qAQs7JGuRmFdo7rWaLHZ+3S+TlIHdZkoLvyYBcX ENVBcLQvZ7IL7DDUZObK/R7OOKz82dEoITQnT+q/lecR9wQ7QNdNVNqn0xS0NPt7 bS76irMxkJcO2q7Lu4R56ImCox/G7dUEepjL0Po516l6fLKG3qi5org2z6ap0yl2 Etu8cRfqiqaqhO0HI1Twz+Rbp/8KUdUBgnNkjcod83HE+jJKxIUDmn18+l7J8sBi a0JvWSIYy2ccFXoR8L4lfvIa8PhTuMmpxyDkwDdPAgMBAAGjHjAcMBoGA1UdEQEB /wQQMA6CDCouZ29vZ2xlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEADiM6yWCaGNLn ggirjN0b34j5JmjgYYx3bRaKDe4We2emjlLsdskBo2ztkd/tPBfUa7DWExgFPvVq B2FeEf85Zj72kMmc2JikJBtPF1qK9fa4O1gST4VE0xIF99zGrgkDhGaYd1ocElWS qfBNQfzwsO+nl2OQf99ATMqMSCGacN7z+LJBLn65de+ODzYUkIHzhU5/xJMian3y fQzNFCAgK8OMf16excqRUcX8zfGPfvtAafDrdOYEXcGayLIvt4tGr8T+tii+MtCR O5hXK8/ABMLGI74zgLYloVFjJv21VsLrNCvvD43T5E3c+8d1MENozdEnsyzWkTkp knP4aEiLOQ== —–END CERTIFICATE—–</p></blockquote></blockquote></blockquote><p>本人不知道为什么 (+﹏+)~。所以为了能正常使用科学式网络，还是老老实实的用 Chrome 吧，何况其还有 Switchyomega 神器，并且建议把 Chrome 设置为默认浏览器。具体配置流程如下：</p><p>　　从 <strong><em>枂下</em></strong> 站长那下载 XX-NET（本人其实最先是直接在 GitHub 上下载最新的 XX-NET，但本人由于在 Firefox 上尝试失败了，当时也没在 Chrome 上尝试，以为最新版 XX-NET 有问题，后来用上 <strong><em>枂下</em></strong> 站长那下的 XX-NET 在 Chrome 上试了下可以，而 Firefox 不行，就知道可能是 Firefox 的问题，而既然已经能用了，本人也没用最新的 XX-NET 在 Chrome 上尝试了），直接解压到某个文件夹，然后将 XX-Net-3.3.6 文件夹重命名为 XX-Net，即去掉末尾的版本号，据 <strong><em>枂下</em></strong> 站长说法是为了减少后续 XX-NET 出错（本人这里老老实实的照 <strong><em>枂下</em></strong> 站长说的做了，所以也不知道如果没去掉版本号会有什么后果）。接着以管理员身份运行 XX-Net 目录下的 start.vbs 文件（这里右键是没有“<strong>以管理员身份运行</strong>”选项的，要想以管理员身份运行就只有使用 Windows 命令行了，具体做法就是以管理员身份运行“<strong>命令提示符</strong>”，再在其中运行 start.vbs 文件即可），运行成功后将弹出</p><blockquote><p>已经导入GoAgent证书,请重启浏览器.</p></blockquote><p>点击确定即可。再次启动默认（Chrome）浏览器，将打开 127.0.0.1:8085 页面，即为 XX-NET 的配置界面。将看到 GAEProxy 状态信息（可能是由于 google 取消了公共 APPID，所以本人看到的不是“<strong>您正在使用公共APPID，….</strong>”这条消息，而是另外一条消息（具体什么消息本人忘记了 o(╯□╰)o）），打开显示详细信息（其实也没用，本人并看不懂这么多 -_-|||），先放这里吧，部分信息以后再说，先进入正式配置步骤。</p><ol type="1"><li>首先点击左边的“<strong>高级</strong>”选项，据<strong><em>枂下</em></strong>站长说，将自动调整扫描线程数关掉，最大扫描线程数设为 200，点击提交（可能这样连接速度更快一些）。本人这里这里没有照做，而是保持默认设置，本人只是要求能上就可以了，对速度要求可以稍微放松一点（或许以后会调成站长推荐的配置）。</li><li>接下来点击“<strong>部署服务端</strong>”选项，填写 AppID，点击“<strong>开始部署</strong>”。但是这一步，本人并没有 AppID，所以只能上 google 申请，这样最麻烦的一步就来了。照着 <strong><em>枂下</em></strong> 站长的指引，本人一步步的申请了 AppID。具体申请步骤如下（这一步需要登录 google 账号，必须处于科学式网络环境）：<ol type="1"><li>点击 <a href="https://appengine.google.com" target="_blank" rel="external">打开Appid申请页面</a>，登录 google 账号，创建项目，并在新建项目中修改项目 ID（这就是第一个 AppID ），为方便，建议直接以“项目名-00”的方式按顺序命名 AppID，创建成功后继续点击“<strong>Google Cloud Platform</strong>”旁的一个小三角，点击弹框的“<strong>+</strong>”，按上述方式进行创建新的 AppID，如此重复，本人总共创建 10 个 AppID，10 个之后会提示配额已用完，硬是要创建只会覆盖掉第一个 AppID。</li><li>接下来就是需要选择语言和地区，只有为每个 AppID 选择语言和地区之后，该 AppID 才会生效。语言和地区的选择界面可以从“<strong>App Engine</strong>”界面中进入，也可以直接在添加 AppID 界面的那个弹框中点击相应的 AppID 进入，当然如果是第一个 AppID 选择语言可以直接点击界面上的“<strong>选择一种语言</strong>” 。语言选择 Python，地区选择亚洲（asia-northeast1），选错了后果自负（当然可以覆盖掉该 AppID 重新设置）。其实可以照 <strong><em>枂下</em></strong> 站长那样设置完第一个 AppID 的语言和地区之后直接修改浏览器的地址栏的 url 以快速设置 AppID 的语言和地区。具体修改方法为：将 url 地址末尾的 project 参数的值改为你想要设置的下一个 AppID，eg:本人当前 AppID 为 test-00，对应的浏览器 url 地址末尾的参数为 <code>lang=python&amp;project=test-00</code>，本人想设置的下一个 AppID 为 test-01，则只需将其修改为 <code>lang=python&amp;project=test-01</code> 回车即可快速设置 test-01 的语言和地区。如此重复，就可以设置完全部的 AppID 语言和地区。设置完之后，这些 AppID 就能进行部署了（据说每个 AppID 每天有 1G 的流量可以使用，并于每天下午三点更新，也就是本人每天有 10G 流量，一般是够用了 :-D）。</li></ol></li><li>将上文申请并设置完成的 AppID 放入“<strong>GAE AppID</strong>”文本框中，多个 AppID 可以按这样的格式放入：<code>test-01|test-02|test-03</code>，两个 AppID 以<code>|</code>分隔即可。点击“<strong>开始部署</strong>”，会弹出一个登录 google 账号的标签页，登录并允许即可，等待 2~5 分钟，可发现日志页面出现 <code>Done!</code>和<code>Deploy 10 appid successed.</code> 等字样即表示服务端部署成功。</li><li>点击“<strong>部署</strong>”选项，将上面部署服务端的 AppID 以相同格式输入“<strong>GAE AppID</strong>”文本框中，点击“<strong>保存</strong>”即可。保存完之后，即可在状态信息界面显示详细信息中 Appid 发现当前工作 AppID 就是部署的 AppID ，至于那个配置下的监听代理就是设置代理的地址和端口。</li></ol><p>这样 XX-NET 就算是配置完成了，至于 <strong><em>枂下</em></strong> 站长说的扫描 ip，本人就没做实验了，因为这样配置完就可以科学式上网了。</p><hr><p>　　以上代理工具配置完成后，即可在 Chrome 中畅游 Internet 了，但是正确的科学式上网姿势应该是：国内的网站走本地连接，而国外被屏蔽的网站才走代理。这就需要 Proxy SwitchyOmega 这款插件了，它能按照一定的规则自动选择走本地还是走代理，这样既不会浪费流量，也能使国内的网站联网速度不受影响。导入前文推荐的配置文件后，就可选择对应的代理方式。这里当然是选择自动切换，至于虚拟切换是选择 <strong>Lantern for 8787</strong> 还是 <strong>XXNET for GAE</strong> 就随便个人的喜好了（在走代理的时候别忘了把相应的代理工具开启）；如果直接选择其中一种代理方式就相当于全局代理，这也就失去这款插件的作用，只有自动切换加上虚拟切换才能充分发挥这款神器的真正作用。</p><h2 id="匿名网络">匿名网络</h2><p>　　要想使用匿名网络，当然少不了专用的浏览器：<a href="https://www.torproject.org/" target="_blank" rel="external">Tor Browser</a>，下载并安装（下载时需要身处科学式网络环境，安装时最好改变一下目录，而且路径中最好不要有中文）。接下来就是配置了 Tor 网络了。具体配置流程如下：</p><p>　　首先，它问直接连接 Tor 网络还是配置网桥或代理，这里当然是选择<strong>配置</strong>；其次它问互联网服务提供商( ISP )是否对 Tor 网络连接进行了封锁或审查，这里选<strong>否</strong>，据<strong><em>枂下</em></strong>站长所说因为国内网桥大部分已失效，连接网桥没有意义还会拖慢速度；然后它问是否本地代理访问互联网，这里当然选择<strong>是</strong>；最后填写本地代理配置，这里需要注意，<strong><em>枂下</em></strong>站长提供的部分代理配置是：</p><blockquote><p>SSR/SS Socks5//127.0.0.1 : 1080</p><p>Seed HTTP//127.0.0.1 : 1080</p><p>Lantern Socks5//127.0.0.1 : 8287（2系列），三系列的在Lantern设置页面查看</p><p>Psiphon 可以在配置页面自定义</p></blockquote><p>　　其中经本人实测，上面 Lantern 的代理配置是连接不上的，本人后来参考 SwitchyOmega 配置文件中 Lantern 的代理为 HTTP//127.0.0.1 : 8787，经尝试如此配置可以连接 Tor 网络，所以 Lantern 的正确配置应为：</p><blockquote><p>Lantern HTTP//127.0.0.1 : 8787（2系列），三系列的在Lantern设置页面查看</p></blockquote><p>设置完成后等待片刻就能连上 Tor 网络了，最好就保持原来的 <em>DuckDuckGo</em> 搜索引擎，不要更改，接下来就可随心所欲的畅游 Internet 了。</p><p>　　至于想访问暗网，可以参考<a href="https://github.com/ckjbug/Hacking/blob/master/%E6%95%B4%E7%90%86%E7%9A%84%E6%9A%97%E7%BD%91%E7%BD%91%E5%9D%80Tor.txt" target="_blank" rel="external">Hacking/整理的暗网网址Tor.txt</a>和<a href="https://sites.google.com/site/howtoaccessthedeepnet/working-links-to-the-deep-web" target="_blank" rel="external">Working Links to the Deep Web</a>或者直接用站长<strong><em>枂下</em></strong>给的网址：<code>torlinkbgs6aabns.onion</code>和<code>xmh57jrzrnw6insl.onion</code>。</p><p>据<strong><em>枂下</em></strong>站长回答：</p><blockquote><p>XX-Net可以作tor的前置代理吗？不行的，xx-net是假http协议</p></blockquote><p>所以 XX-NET 不能用作 Tor 的代理配置。</p><p>　　最后再简要记录一下 Chrome 调用 Tor Browser 的代理吧。本人没有像 <strong><em>枂下</em></strong> 站长那样用命令行去实验，只是享受了一下 ta 的试验成果（O(∩_∩)O谢谢）。总而言之，还是利用 SwitchyOmega，代理方式选择 <strong>Tor for 9150</strong>，就可以在 Chrome 中调用 Tor Browser 的代理，畅游 Internet 了。</p><hr><p><strong><em>更新于：2017-11-27</em></strong></p><p>　　时久达期间及之后，lantern 的那种破解方式从时灵时不灵，到完全失效，而 XX-NET 则一开始就失效了，这见证了 Google 和 GFW 的斗智斗勇（๑乛◡乛๑），但很明显，google 失败了，事实证明没有 GFW 封不了的，只是看它想不想封 (๑•ั็ω•็ั๑)。至于 lantern 和 XX-Net 的复活方式请移步 <strong><em>枂下</em></strong> 站长的网站，本人这里就不再赘述了。<strong>这里需要更新的一点是：</strong>Tor 的网桥配置采用“<strong>meet-amazon</strong>”（亚马逊的云计算平台）或者“<strong>meet-azure</strong>”（微软的云计算平台）传输也能实现科学式上网，但速度很慢，仅能浏览网页而已，可以当做备选临时用用。</p><hr><p><strong><em>更新于 2017-12-24：</em></strong>今天使用了下 <a href="https://psiphon.ca/zh/index.html" target="_blank" rel="external">赛风（Psiphon）</a>，其操作完全傻瓜式，简直不要太好用，而且为单个绿色文件，携带也方便，用的时候只要设置一下端口就行。不出意外的话，妈妈再也不用担心本人搞科研了（؏؏☝ᖗ乛◡乛ᖘ☝؏؏）。</p><hr><p><strong><em>更新于 2018-03-14：</em></strong>现在最新版的 Firefox 59.0 也有 <a href="https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega/" target="_blank" rel="external">Proxy SwitchyOmega</a> 插件了，虽然还是测试版，但还是能够正常使用，既然 Firefox 有了这款神器，本人也就有动力将 Firefox 使用 XX-Net 连接 Google 搜索出现的问题解决了，首先进入 Firefox 的 「选项」或设置 ==》「隐私安全」，下滑到最下面的「证书」，点击「查看证书」，在弹框中选中「证书机构」，点击「导入」，添加 <code>XX-Net\data\gae_proxy</code>目录下的 <strong>CA.crt</strong> 证书，在导入中出现的弹框全部选中信任，将会在上方的证书栏中出现 GoAgent XX-Net 证书，这样就能解决上文出现的问题，参考自：<a href="https://www.crifan.com/firefox_can_not_open_https_use_invalid_security_certificate_error_code_sec_error_unknown_issuer/" target="_blank" rel="external">【已解决】Firefox报错：github.com 使用了无效的安全证书。 证书因为未提供证书发行链信而不被信任。 （错误码： sec_error_unknown_issuer）</a></p><hr><h2 id="后记">后记</h2><p>　　最后的匿名网络是本人弄着好玩的，像暗网这种东西本人这种遵纪守法的好公民才不会访问呢 (ಡωಡ)。等以后时机到了再去买个国外 VPS 自己搭建一个科学式上网环境吧。最后感谢 <strong><em>枂下</em></strong> 站长的无私分享。</p><h2 id="附录">附录</h2><p>　　原本还以为本人搭建的 Hexo+GitHub 个人博客站点还是个深网，没想到搞完科学式上网后用 google 搜索竟然能搜到，虽然本人没做什么，但 google 仍然能搜到，google 的蜘蛛还挺厉害的，不过如果百度的蜘蛛没被 GitHub 屏蔽的话百度可能也能搜到（从某些原因上来说，GitHub 把百度屏蔽掉也好 O(∩_∩)O~）。既然已经被 google 收录了，本人也就不去搞那个站点地图了，等以后想搞 SEO 了再去做吧。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="https://cloudfra.com/switchyomega-chrome-firefox.html" target="_blank" rel="external">Switchyomega超详细教程之Chrome与Firefox版本</a></p><p>[2] <a href="https://cloudfra.com/lantern-windows.html" target="_blank" rel="external">【蓝】灯电脑破解版之2系列禁止自动升级最终办法</a></p><p>[3] <a href="https://cloudfra.com/xx-net-important.html" target="_blank" rel="external">XX-NET史上最详细完整教程</a></p><p>[4] <a href="https://cloudfra.com/xx-net-appid-1.html" target="_blank" rel="external">XX-NET史上最详细完整教程之第一部分：Appid创建部分</a></p><p>[5] <a href="https://cloudfra.com/tor-browser-windows.html" target="_blank" rel="external">Tor Browser在国内Windows平台下的超详细教程</a></p><p>[6] <a href="https://cloudfra.com/tor-browser-chrome.html" target="_blank" rel="external">Chrome等其他程序如何完美调用Tor Browser的代理来上网</a></p><p>[7] <a href="https://program-think.blogspot.com/2014/10/gfw-tor-meek.html" target="_blank" rel="external">“如何翻墙”系列：TOR 已复活——meek 流量混淆插件的安装、优化、原理</a>（<a href="https://program-think.blogspot.com/search/label/IT" class="uri" target="_blank" rel="external">https://program-think.blogspot.com/search/label/IT</a>）</p><p>[8] <a href="https://program-think.blogspot.com/2009/05/how-to-break-through-gfw.html" target="_blank" rel="external">如何翻墙？——写在 BlogSpot 被封之后 {2015-08-28}</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;科学式上网推荐组合：Chrome，Proxy SwitchyOmega，Lantern 等代理工具。&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　所谓的科学式上网，懂的自然懂，本人也就不做过多解释了。本来一直在用别人免费提供的 pac 代理，但最近可能别人关掉了，上不了 google 了，就只能另寻他路了。所谓的另寻他路也就是尝试云端框架网站站长 &lt;strong&gt;&lt;em&gt;枂下&lt;/em&gt;&lt;/strong&gt; 提供的另外几种科学式上网攻略。本文只是对 &lt;strong&gt;&lt;em&gt;枂下&lt;/em&gt;&lt;/strong&gt; 站长的攻略做一下试验记录，若想看原滋原味的攻略，还请移步 &lt;a href=&quot;https://cloudfra.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;云端框架&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="record" scheme="http://cniter.github.io/tags/record/"/>
    
      <category term="gfw" scheme="http://cniter.github.io/tags/gfw/"/>
    
  </entry>
  
  <entry>
    <title>Hexo的SPFK主题修改小记</title>
    <link href="http://cniter.github.io/posts/b1e9411b.html"/>
    <id>http://cniter.github.io/posts/b1e9411b.html</id>
    <published>2017-09-16T10:26:23.000Z</published>
    <updated>2018-01-31T08:41:02.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本人一直在对 Hexo 的 SPFK 主题进行持续修改以符合本人自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。</p><a id="more"></a><h2 id="修改篇">修改篇</h2><h3 id="修改-aboutme-排版问题"><font color="#FA8072">1、修改 <strong>aboutme</strong> 排版问题</font></h3><p><strong><em>修改日期：2017-09-16</em></strong></p><p><strong>需求描述：</strong>本人为了使 <strong>aboutme</strong> 排版好看一点，使“<strong>关于我</strong>”的内容更有段落感，本人尝试在主题配置文件中 aboutme 对象的内容添加各种换行转义符号均于事无补，如 <code>\n</code>、<code>\r\n</code>、<code>&amp;#13;</code>、<code>&amp;#10;</code>、<code>&lt;br /&gt;</code> 等，站点不仅不会换行，还会直接将转义符号都显示出来 (╯﹏╰）。</p><p><strong>解决办法：</strong>既然本人基本把所有的换行方法都试过了，还没有任何作用，那就只能是问题出在其它地方了。本人首先找到显示 aboutme 内容的地方，其位于主题文件夹下 <code>\layout\_partial\left-col.ejs</code>，显示 aboutme 内容的代码为 <code>&lt;div id=&quot;js-aboutme&quot;&gt;&lt;%=theme.aboutme%&gt;&lt;/div&gt;</code>，查阅相关资料，具体为 <a href="https://cnodejs.org/topic/5711aec2238ae0ac1e3a6a26" target="_blank" rel="external">与大家分享ejs源码阅读心得</a>，其中有这样一段话：</p><blockquote><p><h><strong>关于ejs模板的五种模式对应几种指令</strong></h></p><p><code>ejs</code>主要提供了如下几种指令:</p><ul><li><code>&lt;%</code>, 该指令主要通过js中的<code>eval</code>来执行js代码, 如上模板代码<code>&lt;% [1,2].forEach(function(v){ %&gt;</code>将通过<code>eval</code>编译成<code>; [1,2].forEach(function(v){</code>即直接可执行的js代码, 并且不会存放到<code>__output</code>函数中输出.</li><li><strong><code>&lt;%=</code>, 该指令主要用于输出变量内容, 如上模板代码<code>&lt;%= v %&gt;</code>将通过<code>escape</code>函数编译成<code>__append(escape(v))</code>, 可以看到该指令用于输出变量内容, 最后将通过<code>__output</code>输出内容.</strong></li><li><strong><code>&lt;%-</code>, 该指令与<code>&lt;%=</code>区别是, <code>&lt;%=</code>指令使用<code>escape</code>函数来对特殊字符进行编码, 如将<code>&gt;</code>转为<code>%3E</code>, <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/escape" target="_blank" rel="external">查看关于escape函数</a>.</strong></li><li><code>&lt;%#</code>, 该指令主要用于模板内注释, 既不会执行也不会输出.</li><li><code>&lt;%%</code>, 主要用于输出字面值<code>%</code>.</li></ul><p>关于以上各个指令对应的解析, 可参考<code>ejs</code>源码根目录<code>lib/ejs.js</code>文件中的<code>scanLine</code>函数.</p></blockquote><p>从中可得知 <code>&lt;%=</code> 指令会将变量内容中一些特殊字符先转义，再原封不动的输出，所以本人无论怎么修改主题配置文件中 aboutme 对象的值，其输出内容都会是原封不动的 aboutme 对象的值。为了让其输出内容可以有相应的特殊格式，就不能让其转义，只能用 <code>&lt;%-</code> 指令，将其修改为 <code>&lt;div id=&quot;js-aboutme&quot;&gt;&lt;%-theme.aboutme%&gt;&lt;/div&gt;</code>，这样就能使输出内容可以自定义特殊格式，本人最后在 aboutme 对象的内容中需要换行的地方添加了 <code>&lt;br /&gt;</code>，实测如此修改后可以换行。</p><h3 id="给左栏添加滚动条"><font color="#FA8072">2、给左栏添加滚动条</font></h3><p><strong><em>修改日期：2017-09-18</em></strong></p><p><strong>需求描述：</strong>SPFK 主题是双栏的主题。因为左栏主要是用来显示一些菜单和头像等内容，这些内容也不多，所以原作者就没有添加滚动条。但是由于本人添加了个本地搜索功能，在刚开始文章少的时候还不受影响，但是随着文章的增多，搜索功能就会影响左栏的布局，这是就必须添加一个滚动条了。本以为添加滚动条很简单，就是添加一个 <code>overflow: auto;</code>，谁知道还没这么简单 ╮(╯﹏╰）╭。</p><p><strong>解决办法：</strong>本人对问题的定位没问题，就是修改主题文件夹下的 <code>\source\css\_partial\main.styl</code> 文件中 <em>.left-col</em> 样式，问题在于怎么修改，本想直接在其中加入 <code>overflow: auto;</code>，按道理说问题就能解决的，但是本人去搜索试试，发现搜索框上方的头像，文字等全部消失了，滚动条没起到作用，而下方的菜单可以通过滚动条看到。于是本人觉得可能是 div 上界没撑开，而超出的地方却隐藏了，但下界为什么能撑开，本人这里还是很不明白 ?_?。既然是这里隐藏了，本人就去看相关标签有没有 <code>overflow: hidden;</code> 属性，谁知道要么是没有，要么是即是关闭了也没有作用，那问题应该不是出在这里。就只能是这些元素所在的子 div 里了，本人找到其子 div 属性 <em>.intrude-less</em>，其中虽有 overflow: auto; 但没设置 height 属性，所以就不能发挥其作用，本人于是给它加上 height 属性，搜索后发现有两个滚动条，这显然不简约，于是本人把 <em>.intrude-less</em> 的 overflow: auto; 属性注释掉，没想到居然能完美解决问题，可能是因为加上高度属性之后就能撑大父元素 div 了吧（来自某业余前端的猜测 (⊙_⊙)）。后面为了更美观，本人把下方菜单区域的 div 样式 <em>.switch-area</em> 高度 min-height 改小了一点，顺便也把主题文件夹下的 <code>\layout\_partial\left-col.ejs</code> 文件中首行注释掉 <code>&lt;!-- &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; --&gt;</code> 。本人也曾想把 height 改为 min-height，谁知道又出现相同的问题，不得不又改回去。虽然这次已经解决了问题，但有些细节问题还是不太明白，只有等以后前端水平上去了再去想了，如有大佬知道还望不吝赐教 (^人^)。</p><h3 id="更换鼠标指针"><font color="#FA8072">3、更换鼠标指针</font></h3><p><strong><em>修改日期：2017-9-26 ~ 2017-9-27</em></strong></p><p><strong>需求描述：</strong>本人在玩《<strong>Ori and the Blind Forest</strong>》这款游戏的时候觉得其鼠标指针很酷炫，于是想把其鼠标指针放在本人的博客站点中 (๑´ڡ`๑) 。</p><p><strong>解决办法：</strong>要想更改指针，首先需要找到对应的指针文件，最终在万能的贴吧得到指引，在 <a href="http://www.rw-designer.com/" target="_blank" rel="external">RealWorld Graphics</a> 上找到两个 ori指针 文件，一个是 <a href="http://www.rw-designer.com/cursor-detail/100439" target="_blank" rel="external">动态的</a> ani指针文件，还有一个是 <a href="http://www.rw-designer.com/cursor-detail/82454" target="_blank" rel="external">静态的</a> cur指针文件（好像该游戏的作者也在 steam 上的评论中提供了游戏中的指针文件，详见：<a href="http://steamcommunity.com/app/261570/discussions/0/617330406652104214/" target="_blank" rel="external">I wanna use this games cursor.</a> ）。既然已经找到了指针文件，就可以开始更换炫酷的鼠标指针 (•̀ᴗ•́)。具体更改方法如下：将下好的指针文件放在主题文件下的 <code>\source\img</code> 文件夹中，在主题配置文件中添加 cursor 属性：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># set cursor | 设置鼠标指针图标</span></div><div class="line"><span class="attr">cursor:</span> </div><div class="line"><span class="attr">  on:</span> <span class="literal">true</span></div><div class="line"><span class="attr">  cursor_0:</span> <span class="string">img/cursor.ani</span>  <span class="comment"># 首选指针 </span></div><div class="line"><span class="attr">  cursor_1:</span> <span class="string">img/cursor.cur</span>  <span class="comment"># 备选指针</span></div></pre></td></tr></table></figure><p>其中 cursor_0 和 cursor_1 代表使用哪个指针，因为 firefox 和 chrome 不支持 ani文件 的指针（好像是 ani 文件有很大的漏洞），所以 ani 动态指针是用不了的，只能用 cur 格式的静态指针，而 IE 是可以加载 ani 格式的动态指针，所以本人这里就将两个指针文件全放上去了，首选加载动态指针；最后增加相应的代码调用 cursor 属性，加载指针文件，在主题文件夹下 /layout/_partial/background.ejs 文件末尾添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;% if (theme.cursor.on)&#123; %&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">        body&#123;</div><div class="line">            background: #3f3f3f;</div><div class="line">            cursor: url(&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_0 %&gt;), url(&quot;&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_1 %&gt;&quot;), auto;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><p>如此更新站点之后即可使用新鼠标指针样式，可能需要先进行 <code>hexo clean</code> 再发布。</p><p><strong>BTW：</strong>这次修改是一个月之前的了，当时不知怎么的忘记记录了，还好本人的 git 提交记录比较详细，对应的提交记录为：<a href="https://github.com/cniter/cniter.github.io/commit/6c4fb2ddb930f739e2040a2b440106d21aebff04" target="_blank" rel="external">add a function – change cursor</a>和<a href="https://github.com/cniter/cniter.github.io/commit/d24d6d4f3292d7719f292599e6eebd54761c15e5" target="_blank" rel="external">update set cursor function</a> 。</p><h3 id="修改打赏问题"><font color="#FA8072">4、修改打赏问题</font></h3><p><strong><em>修改日期：2017-10-13</em></strong></p><p><strong>问题描述：</strong>本人突然想玩一下那个打赏小东西，但照配置文件中指示的那样在文章开头 ymal 格式中加入 <code>reward: true</code> 属性，没有任何作用，于是去主题文件夹搜索 reward 属性相应的代码，结果是“找不到结果”（坑爹了这是，摔！（╯‵□′）╯︵┴─┴ ）。</p><p><strong>解决办法：</strong>既然 reward 属性找不到就只有搜索 reward_type 属性，最终在主题文件夹下 <code>\spfk_c\layout\_partial\article.ejs</code> 文件中找到这样一条语句 <code>&lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index){ %&gt;</code>，其下面就是打赏相关的代码，查看 SPFK 主题原作者介绍信息（<a href="https://luuman.github.io/2015/12/27/Hexo/HexoTheme/" target="_blank" rel="external">Hexo 主题：SPFK</a>）发现 toc 属性是用来显示目录的（一个用来打赏的代码怎么与文章目录相关了 -_-#），所以上面的 toc 应该改成 reward，修改后的代码为 <code>&lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;</code>，这时照配置文件中指示的那样在文章开头 ymal 格式中加入 <code>reward: true</code> 属性就能在相应的文章后面看到一个大大的“<strong>赏</strong>”字。</p><p>本来写到这里应该打赏这玩意应该完结了，但本人无意中在该文件的下面发现这样一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt;</div><div class="line">    &lt;%- partial(&apos;_partial/toc&apos;) %&gt;</div><div class="line">&lt;% &#125; %&gt;</div></pre></td></tr></table></figure><p>这是和 toc（即文章目录）真正相关的代码，功能大概就是判断是否加载文章目录相关的代码，如果在文章开头设置 <code>toc: false</code>，则该文章不会显示目录，但是如果在文章中不加 toc 属性，也会显示文章目录，但上面的打赏却不会显示，看起来 <code>post.toc != false</code> 和 <code>post.toc</code> 应该逻辑差不多，这里是本人感到十分奇怪的一个地方？后面查阅相关资料（<a href="http://www.w3school.com.cn/jsref/jsref_undefined.asp" target="_blank" rel="external">JavaScript undefined 属性</a>）得知:</p><blockquote><p>注释：null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。</p></blockquote><p>而本文这里因为没有在文章开头设置 toc 属性，所以其为 <code>undefined</code>，其既不为 false 也不为 true，只为 undefined，当在 <code>if</code> 语句中做判断，会执行 <code>else</code> 分支，作 <code>!</code> 运算，结果则为：<code>true</code>。所以 <code>if(post.toc)</code> 不能执行其下代码，因为 <code>post.toc</code> 为undefined，不为 true 也不为 false，而 <code>if(post.toc != false)</code> 能执行其下代码，因为 <code>post.toc != false</code> 为真。至于 javascript 中 <code>if(a == ture)</code> 和 <code>if(a)</code> 的区别具体为：前一种是 a 必须为 1 或者 true 才执行；而后一种只要 a 不为 <code>false undefined null 0 -0 NaN &quot;&quot;</code> 这 7 个字符中的其中任何一个都能执行。</p><h3 id="交换内容栏和左侧栏位置"><font color="#FA8072">5、交换内容栏和左侧栏位置</font></h3><p><strong><em>修改日期：2017-11-22 ~ 2017-11-23</em></strong></p><p><strong>需求描述：</strong>本人最近逛网站时发现，好像一些博客网站基本都是把内容放在左侧，百度和 google 的搜索结果也是在左侧，可能是内容在左侧要好一点吧，于是本人略微修改之后，将内容放在左侧，而原来的左侧栏放到最右侧，好像是顺眼了一点（不排除是心理作用 (ಡωಡ)），如果以后还觉得不错的话，再把相关的变量名换掉吧（此次修改仅仅是将 CSS 相关的值改变，div 类名没变）。</p><p><strong>解决办法：</strong>首先当然是定位左侧栏 <code>.left-col</code>，它在主题文件夹下 source/css/_partial/main.styl 文件中，为其添加 <code>right: 0px;</code> 属性，使左侧栏靠右侧停放；在定位内容栏 <code>.mid-col</code> ，将 <code>right:0;</code> 改成 <code>left:0;</code>，将 <code>left: 300px;</code> 改成 <code>right: left-col-width;</code>，使内容栏靠左侧停放，同时使其距离右侧有左侧栏的宽度。最后就是再修改其他一些小东西（比如目录按钮和目录内容 div 等）的 css 值，关于这个本人就细述了，反正也就是更改 left、right、bottom 以及 top 属性及其值，具体修改了哪些内容可以见本人 github 提交记录。</p><p><strong>BTW：</strong>诶呀呀！昨天忘记测试手机端，今天用手机打开一看，手机端页面也距右边 left-col-width 宽度，这使得内容全挤在一起了，完全没法看 ರ_ರ …。所以不得不添加手机端样式，定位手机端 .mid-col，它在主题文件夹下 /source/css/_partial/mobile.styl 文件中，为其添加 <code>right: 0;</code> 属性值；后面看见回到顶部、回到底部的导航栏也有点问题，就在该文件中 <code>/*导航*/</code> 下面 <code>.scroll</code> 上面添加：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#scroll</span>&#123;</div><div class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>使得该导航栏靠右停靠。</p><h3 id="更新站点部分-css-文件和代码结构"><font color="#FA8072">6、更新站点部分 CSS 文件和代码结构</font></h3><p><strong><em>修改日期：2017-12-04 ~ 2017-12-06</em></strong></p><p><strong>更新日志：</strong></p><ol type="1"><li><p>本人将 left-col 相关的东西（比如 css 样式和 ejs 文件）全部重名为 right-col，毕竟经过几天的适应，感觉放在右侧还不错，就干脆也将其重命名算了，所以原左侧栏 left-col 从现在开始就完全变成右侧栏 right-col 了；</p></li><li><p>原来的本地搜索框有两个 .search 样式，本次修改将两个 .search 样式合并了，删除重复的样式，只留下一个合并后的 .search 样式；本人同时还优化了一下本地搜索功能的结构，将原来主题配置文件中的 search_box 属性删掉，给 search 属性添加一个 on 的属性来代替 search_box 属性，这样让结构不那么混乱，只由一个 search 属性决定本地搜索功能的开启和关闭及功能的实现，而不是像以前那样由 search_box 属性决定右侧栏搜索框的显示，而 search 属性决定本地搜索功能的实现；</p></li><li><p>更改右侧栏 right-col 的 overflow 样式，原来是右侧栏 right-col 垂直超出滚动，水平超出隐藏，这样在屏幕比较窄的情况在右侧会出现两条滚动条，很不美观。现在本人将 overflow 样式改成 <code>&amp;:hover {overflow-y: auto; overflow-x: hidden;}</code> ，这样只有在鼠标指针悬浮在右侧栏 right-col 上时才会再右侧栏出现滚动条，这样虽然不能从根本上解决问题，但稍微缓解了一下，等以后再看能不能彻底解决滚动条的问题 ರ_ರ …；</p></li><li><p>本人以前添加 RevolverMaps 这个小部件的时候只是简单粗暴的添加 div 及对应的样式，完全没考虑到主题的扩展性和易修改性。于是本人将其改成配置文件的形式，在主题配置文件中添加 <code>visual_visitor</code> 属性，只要将其值设置为 <a href="http://www.revolvermaps.com/" target="_blank" rel="external">RevolverMaps官网</a> 获取的那串 script code，eg：</p><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;//ra.revolvermaps.com/0/0/8.js?i=0lpycb5p234&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</code>，即可在右侧栏菜单下的访问情况中看到一个 3D 地球实时显示访客的位置信息，本人为了优化异步访问信息，将其中的 <code>async=&quot;async&quot;</code> 改成 <code>defer=&quot;defer&quot;</code>，这样好像能优化加载次序。这两者的区别可参考 <a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="external">defer和async的区别</a>，好像是都能异步加载，只是 async 是该 script 加载完立即执行，而 defer 是该 script 加载完之后在整个页面结束加载之前执行，也就是最后执行的；</p></li><li><p>最后还修改了 MathJax 的 CDN 地址及配置属性。MathJax 的配置属性可参考 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/configuration.html#id3" target="_blank" rel="external">加载和配置MathJax</a>，具体如下：</p><blockquote><p>第一种配置Mahtjax的方法就是使用配置文件。MathJax附带了很多种预制配置文件。它们存储在<code>MathJax/config</code> 目录。主要有其中以下几个：</p><ul><li><code>default.js</code>：这个文件包含了所有MathJax可用的配置选项，并附有注释和说明，你可以编辑它们来满足你的需要。</li><li><code>TeX-AMS-MML_HTMLorMML.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-tex" target="_blank" rel="external"><em>TeX</em></a>, <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-latex" target="_blank" rel="external"><em>LaTeX</em></a>, 或者<a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-mathml" target="_blank" rel="external"><em>MathML</em></a> 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。</li><li><code>TeX-AMS_HTML.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-tex" target="_blank" rel="external"><em>TeX</em></a> 或者 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-latex" target="_blank" rel="external"><em>LaTeX</em></a> 符号书写公式。使用Html和Css渲染。</li><li><code>MML_HTMLorMML.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-mathml" target="_blank" rel="external"><em>MathML</em></a> 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。</li><li><code>AM_HTMLorMML.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-asciimath" target="_blank" rel="external"><em>AsciiMath</em></a> 符号书写。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。</li><li><code>TeX-AMS-MML_SVG.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-tex" target="_blank" rel="external"><em>TeX</em></a>, <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-latex" target="_blank" rel="external"><em>LaTeX</em></a>, 或者<a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-mathml" target="_blank" rel="external"><em>MathML</em></a> 符号书写公式。使用SVG产生输出。</li><li><code>TeX-MML-AM_HTMLorMML.js</code>：允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-tex" target="_blank" rel="external"><em>TeX</em></a>, <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-latex" target="_blank" rel="external"><em>LaTeX</em></a>,<a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-mathml" target="_blank" rel="external"><em>MathML</em></a>,或者 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-asciimath" target="_blank" rel="external"><em>AsciiMath</em></a> 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。</li></ul><p>第一个文件是提供给你修改的。它基本上包含了MathJax的所有配置选项，同时有注释解释。其他的文件就是我们联合配置文件。它们不仅仅配置Mathjax,还预加载了一些配置所需的文件。这些文件内容在 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/common-configurations" target="_blank" rel="external">联合配置</a> 中有详细的解释。</p></blockquote><p>原来的 CDN 地址 <strong><em>cdn.mathjax.org</em></strong> 已经在 2017-04-30 日关闭，所以必须更新 CDN 地址，其推荐的 CDN 地址为 <strong><em>cdnjs.cloudflare.com/ajax/libs/mathjax</em></strong>，而新的 MathJax 也提供一种一种新的配置文件 <code>TeX-MML-AM_CHTML</code>（允许使用 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-tex" target="_blank" rel="external"><em>TeX</em></a>, <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-latex" target="_blank" rel="external"><em>LaTeX</em></a>,<a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-mathml" target="_blank" rel="external"><em>MathML</em></a>或者 <a href="http://mathjax-chinese-doc.readthedocs.io/en/latest/glossary.html#term-asciimath" target="_blank" rel="external"><em>AsciiMath</em></a> 符号书写公式，使用 CommonHTML 产生输出），新的 MathJax 推荐使用的就是这种配置文件，因为它计划在 V3.0 将 HTML-CSS 输出格式丢弃，只留下 CommonHTML 和 SVG 这两种输出格式。而且新的 CDN 地址不支持 <code>/latest/MathJax.js</code> 这种格式，必须指定一个确定的版本，截止本人此次修改日期之前，最新的版本为 2.7.2，所以比较推荐的一种加载格式为：</p><p><code>&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;</code> 。</p></li></ol><h3 id="添加-404-页面和一些插件等"><font color="#FA8072">7、添加 404 页面和一些插件等</font></h3><p><strong><em>修改日期：2017-12-09 ~ 2017-12-10</em></strong></p><p><strong>更新日志：</strong></p><ol type="1"><li><p>修改文章内 a 标签的高度，即 .article-entry p a 中 padding 的上下边距。文章内的 a 标签在外面加个虚线框本来就很突出了，还设置上下 padding 为 8px，这就显得有点浮夸了 :) 。最后将其上下边距设为 0px；</p></li><li><p>添加 404 页面，具体参考自：<a href="http://moxfive.xyz/2015/10/16/hexo-404-page/" target="_blank" rel="external">在 Hexo 中创建匹配主题的404页面</a>，</p><blockquote><blockquote><ol type="1"><li>启动 Git Bash，进入 Hexo 所在文件夹，输入 <code>hexo new page 404</code> ；</li><li>打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 <code>/source/404/index.md</code>；</li><li>在顶部插入一行，写上<code>permalink: /404</code>，这表示指定该页固定链接为 <code>http://&quot;主页&quot;/404.html</code></li></ol></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">title:</span> <span class="number">404</span> <span class="string">Not</span> <span class="string">Found：该页面无法显示</span></div><div class="line"><span class="attr">toc:</span> <span class="literal">false</span></div><div class="line"><span class="attr">comments:</span> <span class="literal">false</span></div><div class="line"><span class="attr">permalink:</span> <span class="string">/404</span></div><div class="line"><span class="meta">---</span></div></pre></td></tr></table></figure></blockquote></li><li><p>添加 hexo-abbrlink 插件，使文章生成唯一永久链接。这个插件最好是在建站之初就加上，不然写了很多文章之后又都得重新生成链接，搜索引擎需要再次抓取新链接，不利于 SEO，本人这里也就只有等 Google 慢慢抓取更新，还好写的不多，不算太迟。安装完之后本人在站点配置文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span> <span class="comment"># 需安装hexo-abbrlink插件</span></div><div class="line"><span class="attr">abbrlink:</span></div><div class="line"><span class="attr">  alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></div><div class="line"><span class="attr">  rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></div></pre></td></tr></table></figure><p><strong><em>※BTW：</em></strong>需要将原来的 permalink 注释掉或直接删除。</p><p>更多设置可参考 <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="external"><strong>hexo-abbrlink</strong></a> 。</p></li><li><p>添加 hexo-all-minifier 插件，快速压缩代码，分别对 html、css、js、images 进行优化。本人这里就直接使用推荐的配置了，直接在站点配置文件中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">all_minifier:</span> <span class="literal">true</span>  <span class="comment"># 需安装hexo-all-minifier插件</span></div></pre></td></tr></table></figure><p>更多设置可参考 <a href="https://github.com/chenzhutian/hexo-all-minifier" target="_blank" rel="external"><strong>hexo-all-minifier</strong></a> 。</p></li><li><p>原来文章标题不可点击，反而日期可点击，这有点奇怪 ◔ ‸◔?。本次修改之后，点击文章标题即为刷新页面。</p></li></ol><h4 id="更新日期2017-12-19-2017-12-19"><strong><em>更新日期：2017-12-19 ~ 2017-12-19</em></strong></h4><p><strong>具体修改内容：</strong>主要更新了 404 页面上面的动图，个人偏好喜欢一些星系漩涡之内的动图，偶然发现这个东西（<a href="http://www.jb51.net/jiaoben/576717.html" target="_blank" rel="external">HTML5+Three.js实现的3D可拖拽银河星系旋转动画特效源码</a>），于是将它的源码略作修改放进本人的 404 页面，将相关的 js 文件放入主题文件夹中 <code>\source\js</code> 文件夹里，最初时是将相关 js 文件引入路径当成相对路径引入，没想到这样造成有的 404 页面会显示旋转动图，而有的 404 页面则不会显示，后面参考网上资料（<a href="https://segmentfault.com/a/1190000007491687" target="_blank" rel="external">解惑页面中的相对路径和绝对路径</a>）了解到：</p><blockquote><ol type="1"><li><code>html</code> 中引入的资源（包括<code>js</code>、<code>css</code>、<code>img</code>）<ul><li>相对路径：相对的是 <strong>网页本身的 URL</strong> ；</li><li>绝对路径：相对的是 <strong>网页 URL 的根路径</strong> ；</li></ul></li><li><code>css</code> 中引入的资源<ul><li>相对路径：相对的是 <strong>css 文件本身的 URL</strong> ；</li><li>绝对路径：相对的是 <strong>网页 URL 的根路径</strong>；</li></ul></li></ol><p><strong>结论：</strong> <code>html</code> 中引入资源的相对路径与 <strong>网页的 URL </strong>有关，而<code>css</code>中则与 <strong>css 资源本身 URL </strong>有关。但使用绝对路径时，不管是在 <code>html</code>中，还是<code>css</code>中，都只与 <strong>网页 URL的根路径</strong>有关。</p></blockquote><p>将相对路径改为绝对路径，即可在本人博客域名下所有 404 页面正常显示旋转动图。</p><h3 id="添加-gitalk-评论系统"><font color="#FA8072">8、添加 Gitalk 评论系统</font></h3><p><strong><em>修改日期：2017-12-16</em></strong></p><p>　　Gitalk 是一款类似 gitment 的评论系统，本人先是照着它提供的配置添加之后，发现居然与 spfk 主题中的 require-2.1.6,jquery-1.9.1.min.js 冲突，显示不了 Gitalk，本人以为是 bug，所以就去提了个 <a href="https://github.com/gitalk/gitalk/issues/80" target="_blank" rel="external">issue</a>，作者 <strong>booxood</strong> 还是挺认真负责的（°Д°）Ъ，耐心的解决本人的问题，原来是本人的引用方式有问题，需要用 require 方式引用，大佬就是大佬 <strong>○|￣|_</strong>，小白还是小白，萌新完全没见过还有这种操作，也算是开眼界了 ✪ω✪。由于大佬解决完问题之后就直接把 issue 关闭了，所以本人就只有在这里表示感谢了 /つ∇T)。本人最后添加 gitalk 的 ejs 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;comments&quot; class=&quot;gitalk&quot;&gt;</div><div class="line">    &lt;div id=&quot;gitalk-container&quot; class=&quot;article article-inner article-entry&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        require([&apos;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&apos;], function (Gitalk) &#123;</div><div class="line">            var gitalk = new Gitalk(&#123;</div><div class="line">                clientID: &apos;&lt;%= theme.gitalk.client_id%&gt;&apos;,</div><div class="line">                clientSecret: &apos;&lt;%= theme.gitalk.client_secret%&gt;&apos;,</div><div class="line">                id: window.location.pathname,</div><div class="line">                repo: &apos;&lt;%= theme.gitalk.repo%&gt;&apos;,</div><div class="line">                owner: &apos;&lt;%= theme.gitalk.owner%&gt;&apos;,</div><div class="line">                admin: &apos;&lt;%= theme.gitalk.admin%&gt;&apos;,</div><div class="line">                // facebook-like distraction free mode</div><div class="line">                distractionFreeMode: true</div><div class="line">            &#125;)</div><div class="line">            gitalk.render(&apos;gitalk-container&apos;)</div><div class="line">        &#125;) </div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure><p>还有其它的一些修改也是仿照 gitment 的代码添加的，我这上面没有添加 css 文件是因为 gitalk 原有的 css 文件与本人的主题不相符，所以就稍微修改了一下。</p><p><strong>※BTW：</strong>上次修改文章内a标签的高度后突然发现打赏的“<strong>赏</strong>”字背景圆形变成椭圆了 o(╯□╰)o，后面发现原来它也继承文章内 a 标签的属性，没有自己的 padding，后面只有给 <code>.dashang</code> 添加个独立的 <code>padding: 8px;</code>。</p><h3 id="fix-bugs"><font color="#FA8072">9、Fix Bugs</font></h3><h4 id="修改日期2017-12-20"><strong><em>修改日期：2017-12-20</em></strong></h4><p><strong>修复bug：</strong>鼠标悬浮 a 标签之上会出现显示 a 标签 title 内容的气泡，当 title 内容过多时，会造成气泡位置下调，从而遮住相应 a 标签内容的 bug。</p><p><strong>解决方案为：</strong>定位气泡文件为主题文件夹下 <code>\layout\_partial\post\TipTitle.ejs</code> 文件，将其中气泡出现的位置改变，原来气泡的位置确定由 top 和 left 决定，现改为 bottom 和 left，毕竟气泡是出现在 a 标签上方，如果将 top 确定，则 title 内容过多时，其只能向下扩张，造成气泡位置下移现象，从而遮住原来的 a 标签内容，改为 bottom 确定之后，气泡只会向上扩张，气泡位置相对稳定，不会遮住原来的 a 标签内容。具体修改内容为，将 <code>top: offset.top - a.outerHeight() - 15</code> 替换为 <code>bottom: window.innerHeight - offset.top + 10</code> ，其它内容保持不变。</p><h4 id="修改日期2017-12-26"><strong><em>修改日期：2017-12-26</em></strong></h4><p><strong>BUG描述：</strong>由于 spfk 主题启用的是百度分享，而原作者没有为其添加邮件分享，本人为了好玩就添加个邮件分享，但是在添加过程中，本人发现了个 BUG，就是为其添加的 title 属性没有作用，它会自动更改 title 内容，而 spfk 主题有显示 title 的气泡 TipTitle，所以不需要用默认的东西显示 title 内容，但是，这个百度分享还是强制默认显示，TipTitle 并不能消除其 title 内容。</p><p><strong>解决方案：</strong>定位百度分享强制添加 title 的代码，其位于主题文件夹下<code>\source\static\api\js\view\share_view.js</code> 中，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i=e.partners,s=i[n]?<span class="string">"\u5206\u4eab\u5230"</span>+i[n].name:<span class="string">""</span>;</div><div class="line">  !r(t).attr(<span class="string">"title"</span>)&amp;&amp;s&amp;&amp;r(t).attr(<span class="string">"title"</span>,s)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>因为 TipTitle 会首先将 title 去掉，所以这里会强制添加百度分享自己的 title，所以需要将其注释掉，具体注释代码为：<code>/*&amp;&amp;r(t).attr(&quot;title&quot;,s)*/</code>。本来这样就可以了，但是本人发现添加邮件分享之后，布局又不对，所以定位主题文件夹下 <code>\source\css\_partial\baidushare.styl</code> 文件，发现它的居中布局居然是有宽度决定的，于是本人为其添加 <code>text-align: center;</code> 谁知还是没变，不能自动居中，后来在主题文件夹下找到 <code>\source\static\api\css\share_style2_24.css</code> 文件，发现 .bdshare-button-style2-24 a 设置了浮动样式，难怪（⊙﹏⊙），最后将其注释掉就能自动居中了。最后还需要更改移动端 <code>\source\css\_partial\mobile.styl</code> 中 .bdshare-button-style2-24 的样式设置为自动居中就可以了。</p><h3 id="使文章目录可折叠"><font color="#FA8072">10、使文章目录可折叠</font></h3><p><strong><em>修改日期：2017-12-28</em></strong></p><p>首先声明，本次修改完全参考：<a href="http://moxfive.xyz/2016/06/13/hexo-collapsible-toc/" target="_blank" rel="external">为 Hexo 添加可折叠的文章目录</a>，所用代码也来自其文（本人只是做了点微不足道的修改），在此表示感谢 <a href="https://github.com/MOxFIVE/hexo-theme-yelee/" target="_blank" rel="external">Yelee</a> 主题的作者 <a href="http://moxfive.xyz/" target="_blank" rel="external">MOxFIVE</a> 👍 。</p><p>具体修改如下：首先在主题文件夹下 <code>\layout\_partial\toc.ejs</code> 中添加 js 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 折叠目录 --&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    // -------------添加小图标--------------</div><div class="line">    var $itemHasChild = $(&quot;#toc .toc-item:has(&gt; .toc-child)&quot;);</div><div class="line">    var $titleHasChild = $itemHasChild.children(&quot;.toc-link&quot;);</div><div class="line">    $itemHasChild.prepend(&quot;&lt;i class=&apos;fa fa-caret-down&apos;&gt;&lt;/i&gt;&lt;i class=&apos;fa fa-caret-right&apos;&gt;&lt;/i&gt;&quot;);</div><div class="line"></div><div class="line">    var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;);</div><div class="line">    var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;);</div><div class="line">    $iconToExpand.addClass(&quot;hide&quot;);</div><div class="line"></div><div class="line">    // --------------点击小图标--------------</div><div class="line">    var clickIcon = function () &#123;</div><div class="line">        $(&quot;#toc .toc-item &gt; i&quot;).click(function () &#123;</div><div class="line">            $(this).siblings(&quot;.toc-child&quot;).slideToggle(100);</div><div class="line">            $(this).toggleClass(&quot;hide&quot;);</div><div class="line">            $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;);</div><div class="line">        &#125;)</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    // 默认展开目录，所以隐藏掉表示“目录已展开”的图标（向下的小三角）</div><div class="line">    var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;);</div><div class="line">    $iconToExpand.addClass(&quot;hide&quot;);</div><div class="line"></div><div class="line">    // ------------点击大标题-----------------</div><div class="line">    var clickTitle = function () &#123;</div><div class="line">        $titleHasChild.dblclick(function () &#123;</div><div class="line">            $(this).siblings(&quot;.toc-child&quot;).hide(100);</div><div class="line">            $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;);</div><div class="line">        &#125;)</div><div class="line">        // After dblclick enent</div><div class="line">        $titleHasChild.click(function () &#123;</div><div class="line">            var $curentTocChild = $(this).siblings(&quot;.toc-child&quot;);</div><div class="line">            if ($curentTocChild.is(&quot;:hidden&quot;)) &#123;</div><div class="line">                $curentTocChild.show(100);</div><div class="line">                $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;()</div><div class="line"></div><div class="line">    // ---------点击总标题-----------------</div><div class="line">    var clickTocTitle = function () &#123;</div><div class="line">        var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;);</div><div class="line">        var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;);</div><div class="line">        var $subToc = $titleHasChild.next(&quot;.toc-child&quot;);</div><div class="line"></div><div class="line">        var $tocTitle = $(&quot;#toc .toc-title&quot;);</div><div class="line"></div><div class="line">        // 当包含多级目录时再执行</div><div class="line">        if ($titleHasChild.length) &#123;</div><div class="line">            $tocTitle.addClass(&quot;clickable&quot;);</div><div class="line">            $tocTitle.click(function () &#123;</div><div class="line">                if ($subToc.is(&quot;:hidden&quot;)) &#123;</div><div class="line">                    $subToc.show(150);</div><div class="line">                    $iconToExpand.removeClass(&quot;hide&quot;);</div><div class="line">                    $iconToFold.addClass(&quot;hide&quot;);</div><div class="line">                &#125; else &#123;</div><div class="line">                    $subToc.hide(100);</div><div class="line">                    $iconToExpand.addClass(&quot;hide&quot;);</div><div class="line">                    $iconToFold.removeClass(&quot;hide&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;</div><div class="line">    &#125;()</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure><p>然后添加相应的 css 样式，在主题文件夹下 <code>\source\css\_partial\article.styl</code> 中 <strong>#toc</strong> 样式里添加 css 样式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ol</span><span class="selector-class">.toc</span> <span class="selector-tag">li</span><span class="selector-class">.toc-item</span> <span class="selector-tag">i</span> &#123;</div><div class="line">   <span class="attribute">display</span>: inline-block;</div><div class="line">   <span class="attribute">margin-left</span>: -<span class="number">0.9em</span>;</div><div class="line">   <span class="attribute">width</span>: <span class="number">0.9em</span>;</div><div class="line">   <span class="attribute">color</span>: <span class="number">#b3b3b3</span>;</div><div class="line">   <span class="attribute">font-weight</span>: bold;</div><div class="line">   <span class="attribute">cursor</span>: pointer;</div><div class="line"></div><div class="line">   &amp;:hover &#123;</div><div class="line">       <span class="attribute">color</span>: <span class="number">#000</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   &amp;<span class="selector-class">.hide</span> &#123;</div><div class="line">       <span class="attribute">display</span>: none;</div><div class="line">   &#125;</div><div class="line">&#125;  </div><div class="line"><span class="selector-class">.toc-title</span><span class="selector-class">.clickable</span> &#123;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line"></div><div class="line">    &amp;:hover &#123;</div><div class="line">        <span class="attribute">color</span>: <span class="number">#88acdb</span>;</div><div class="line">    &#125;</div><div class="line">    &amp;:active &#123;</div><div class="line">        <span class="attribute">color</span>: <span class="number">#d3d3d3</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>以上两步做完之后，点击目录前的小三角符号或双击目录名就能折叠相应目录，点击“<strong>文章目录</strong>”就能折叠所有目录。</p><hr><p>待续。。。</p><h2 id="后记">后记</h2><p>　　先就写到这里，如后续修改中发现问题再继续记录吧 ↖(^ω^)↗。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本人一直在对 Hexo 的 SPFK 主题进行持续修改以符合本人自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。&lt;/p&gt;
    
    </summary>
    
      <category term="建站小记" scheme="http://cniter.github.io/categories/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://cniter.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题</title>
    <link href="http://cniter.github.io/posts/22c3daf1.html"/>
    <id>http://cniter.github.io/posts/22c3daf1.html</id>
    <published>2017-09-16T08:16:08.000Z</published>
    <updated>2018-01-31T08:03:19.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　曾写过一个程序，需要有一个界面，但本人不想使用 MFC，因缘巧合，在网上看到 Qt，就尝试用了一下，遂有此文。本人的 Qt 版本为 qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的 Qt 可以通过 Visual Studio 2013 开发 Qt 程序（各位看官猜的没错，本人并没有直接使用 Qt Creator 开发 Qt 程序，而是通过 VS 开发 Qt 程序的 \(^o^)/），一来是熟悉 VS 开发，对 Qt Creator 完全没用过；二来是已经在 VS 配好全套的开发环境了（画外音：说白了就是懒嘛 ╭(╯^╰)╮）。但是在 VS 中开发 Qt 程序还需要一些其它的配置。</p><a id="more"></a><h2 id="准备篇">准备篇</h2><p>　　在 VS 中开发 Qt 程序首先需要安装一个 addin 外接程序，下载并安装 <a href="http://download.qt.io/archive/vsaddin/qt-vs-addin-1.2.5.exe" target="_blank" rel="external">qt-vs-addin-1.2.5.exe</a>（<a href="http://download.qt.io/archive/vsaddin/" class="uri" target="_blank" rel="external">http://download.qt.io/archive/vsaddin/</a>），（网上说该程序已不支持 VS2013 及以上版本的 VS，原因是 VS2013 及其以上版本的 VS 都不支持该种类型的插件，新版本的 VS 需要安装新型插件 <a href="http://download.qt.io/archive/vsaddin/qt-vs-tools-msvc2013-2.1.1.vsix" target="_blank" rel="external">qt-vs-tools-msvc2013-2.1.1.vsix</a> 或 <a href="http://download.qt.io/archive/vsaddin/qt-vs-tools-msvc2015-2.1.1.vsix" target="_blank" rel="external">qt-vs-tools-msvc2015-2.1.1.vsix</a>），但是经本人实测，本人的 VS2013-update5 英文旗舰版通过 qt-vs-addin-1.2.5 编写 Qt 程序完全没问题，不过 VS2015 就不知道了，可能真需要安装新型插件。下载安装好相应的软件之后需要在 VS 中配置 Qt 环境，虽然不配置也能正常编译，但是会在 Qt 相关的语句下面出现红色波浪线，本人轻微强迫症表示不能忍 ╭(╯^╰)╮。具体配置如下：</p><p>选中“<strong>VC++目录</strong>”，在“<strong>包含目录</strong>”中添加：</p><blockquote><p>C:\Qt\Qt5.6.2\5.6\msvc2013\include</p></blockquote><p>在“<strong>库目录</strong>”中添加：</p><blockquote><p>C:\Qt\Qt5.6.2\5.6\msvc2013\lib</p></blockquote><p>配置完成之后即可发现红色波浪线已消失。</p><h2 id="使用篇">使用篇</h2><p>　　VS 中如何开发 Qt 程序请详见参考资料，懒癌发作，不想写了 =_=（其实是因为要写的话只能贴图了，本人表示不想使用图片 (╯﹏╰) ）。</p><h2 id="问题篇">问题篇</h2><p><strong>问题描述：</strong>本人在用 Qt 显示 OpenCV 的 Mat 数据图像时，有时会发生扭曲现象（图像从对角线分开，两边颠倒，扭曲），有时却不会，为了撤了解决问题，查阅了相关资料，终于发现症结所在，原来是图片数据格式不符合 Qt 的图片数据格式。</p><p><strong>解决办法：</strong>正文来喽 ~\(≧▽≦)/~，就不说废话了，“Talk is cheap. Show you the code”，具体完整正确显示C++代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMatWithQtQlabel</span><span class="params">(<span class="keyword">const</span> cv::Mat &amp;img, QLabel *label)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// [Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决](http://lovelittlebean.blog.163.com/blog/static/11658218620125208212189/)</span></div><div class="line">	QImage q_img;  </div><div class="line">	<span class="keyword">if</span>(img.channels() == <span class="number">3</span>)    <span class="comment">// RGB image  </span></div><div class="line">	&#123;  </div><div class="line">		q_img = QImage((<span class="keyword">const</span> uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB888).rgbSwapped();  </div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (img.channels() == <span class="number">4</span>)	<span class="comment">// RGBA image  </span></div><div class="line">	&#123;</div><div class="line">		q_img = QImage((<span class="keyword">const</span> uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB32);  </div><div class="line">	&#125;<span class="keyword">else</span>              <span class="comment">// gray image  </span></div><div class="line">	&#123;  </div><div class="line">		q_img = QImage((<span class="keyword">const</span> uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_Indexed8);  </div><div class="line">	&#125;  </div><div class="line"></div><div class="line">	<span class="comment">// -------------- 图片自适应label -------------------</span></div><div class="line">	QImage q_label_img = q_img.scaled(label-&gt;size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); <span class="comment">// 图片自适应label大小	</span></div><div class="line">	label-&gt;setPixmap(QPixmap::fromImage(q_label_img));  <span class="comment">// 将图片显示到label上 </span></div><div class="line"></div><div class="line">	<span class="comment">// -------------- label自适应图片 -------------------</span></div><div class="line">	<span class="comment">/*label-&gt;setPixmap(QPixmap::fromImage(q_img));  // 显示在label中</span></div><div class="line"><span class="comment">	label-&gt;resize(label-&gt;pixmap()-&gt;size());  // 改变label的尺寸以自适应图像</span></div><div class="line"><span class="comment">	label-&gt;show();  */</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　rgbSwapped() 函数是为了使 Qt 中显示图形颜色更自然，因为 OpenCV 的 Mat 数据 RGB 图像是以 BGR 的顺序排列，而 Qt 中是以 RGB 的顺序排列，所以需要 rgbSwapped() 交换一下颜色通道排列顺序。</p><h2 id="附录">附录</h2><h3 id="摄像头数据采集问题">1、摄像头数据采集问题</h3><p>注意：如果是从摄像头实时采集显示图像，在显示时需先判断图像有没有数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (image.data)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 执行显示操作</span></div><div class="line">  showMatWithQtQlabel(mat, ui.label);</div><div class="line">  </div><div class="line">  <span class="comment">// 执行其它操作...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!image.empty())</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 执行显示操作</span></div><div class="line">  showMatWithQtQlabel(mat, ui.label);</div><div class="line">  </div><div class="line">  <span class="comment">// 执行其它操作...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>具体原因可参考本人的一篇文章 <a href="https://cniter.github.io/posts/509ee93b.html">解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题</a> 。</p><h3 id="信号与槽的连接函数问题">2、信号与槽的连接函数问题</h3><p>Qt4 中信号与槽的连接函数语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(&amp;theTimer,SIGNAL(timeout()),<span class="keyword">this</span>,SLOT(getFrame()));	<span class="comment">// 超时就去取下一帧</span></div></pre></td></tr></table></figure><p>而 Qt5 中信号与槽的连接函数新语法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">connect(&amp;theTimer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;QtTest::getFrame);	<span class="comment">//超时就去取下一帧</span></div></pre></td></tr></table></figure><p>推荐使用 Qt5 新语法，具体原因可参考 <a href="http://www.cnblogs.com/mushroom/p/5701330.html" target="_blank" rel="external">qt5中信号和槽的新语法</a> 。</p><p><strong>个人粗浅理解：</strong>信号函数一般是 Qt 中控件的库函数，比如按钮控件 QButton 的 <code>QButton::clicked ()</code> 函数，定时器 QTimer 的 <code>QTimer::timeout ()</code> 等函数；而槽函数是响应函数，一般由用户自己编写，也可以使用 Qt 中库函数。</p><p>　　使用 Qt 中可能会遇到的一些错误请参考 <a href="http://www.cnblogs.com/csuftzzk/p/VS_Qt_Experience.html" target="_blank" rel="external">使用VS2010开发Qt程序的一点经验</a>（<a href="http://www.cnblogs.com/csuftzzk/category/445772.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/csuftzzk/category/445772.html</a>）。</p><h2 id="后记">后记</h2><p>　　本来其实就想把问题篇写出来的，毕竟主要就是想记录一下那个显示函数，但是感觉有点没头没尾，就把 VS 集成 Qt 开发环境也稍微写了一下，而使用篇确实是因为参考资料已经写的很详细了，所以就直接一笔带过了。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.csdn.net/llh318724/article/details/7007661" target="_blank" rel="external">QT +openCV 实现摄像头采集以及拍照功能</a>（<a href="http://blog.csdn.net/llh318724/article/category/930663" class="uri" target="_blank" rel="external">http://blog.csdn.net/llh318724/article/category/930663</a>）</p><p>[2] <a href="http://blog.csdn.net/qqmindyourwill/article/details/50280233" target="_blank" rel="external">VS2010 + QT5.2+ QT-VS-Addin1.2.2开发环境配置</a>（<a href="http://blog.csdn.net/qqmindyourwill/article/category/5990841" class="uri" target="_blank" rel="external">http://blog.csdn.net/qqmindyourwill/article/category/5990841</a>）</p><p>[3] <a href="http://blog.csdn.net/fm0517/article/details/7476430" target="_blank" rel="external">Qt+OpenCV界面</a>（<a href="http://blog.csdn.net/fm0517/article/category/1110960" class="uri" target="_blank" rel="external">http://blog.csdn.net/fm0517/article/category/1110960</a>）</p><p>[4] <a href="http://blog.csdn.net/loveaborn/article/details/7680834" target="_blank" rel="external">Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决</a>（<a href="http://blog.csdn.net/loveaborn/article/category/1164072" class="uri" target="_blank" rel="external">http://blog.csdn.net/loveaborn/article/category/1164072</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　曾写过一个程序，需要有一个界面，但本人不想使用 MFC，因缘巧合，在网上看到 Qt，就尝试用了一下，遂有此文。本人的 Qt 版本为 qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的 Qt 可以通过 Visual Studio 2013 开发 Qt 程序（各位看官猜的没错，本人并没有直接使用 Qt Creator 开发 Qt 程序，而是通过 VS 开发 Qt 程序的 \(^o^)/），一来是熟悉 VS 开发，对 Qt Creator 完全没用过；二来是已经在 VS 配好全套的开发环境了（画外音：说白了就是懒嘛 ╭(╯^╰)╮）。但是在 VS 中开发 Qt 程序还需要一些其它的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Problems" scheme="http://cniter.github.io/categories/Problems/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
      <category term="qt" scheme="http://cniter.github.io/tags/qt/"/>
    
  </entry>
  
  <entry>
    <title>解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题</title>
    <link href="http://cniter.github.io/posts/509ee93b.html"/>
    <id>http://cniter.github.io/posts/509ee93b.html</id>
    <published>2017-09-16T07:56:16.000Z</published>
    <updated>2018-01-31T07:50:50.372Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FA8072">本文所用的 OpenCV 版本为 opencv-2.4.11，编程语言为 C++。</font></p><h2 id="前言">前言</h2><p>　　本文其实是以前在刚学 OpenCV 时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。</p><a id="more"></a><h2 id="问题篇">问题篇</h2><p><strong>问题描述：</strong>使用 OpenCV-2.4.11 调用摄像头显示拍摄视频时报 <font color="#FA8072">runtime error</font>，控制台窗口出现 <font color="#FA8072">OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file ……...cpp, line 261</font>。</p><p><strong>解决办法：</strong>在显示图片时先判断是否有图像数据，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!image.empty()) </div><div class="line">&#123;</div><div class="line">    imshow(<span class="string">"window"</span>, image);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (image.data) </div><div class="line">&#123;</div><div class="line">    imshow(<span class="string">"window"</span>, image);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>原因可能是：</strong>用 imshow() 显示图像时，其 image 必须有数据，如果它为空则程序会报错，而一般打开摄像头会有一定时间的延迟，这时程序已经启动，而摄像头由于启动延迟，不一定能及时获取图像，造成要显示的 image 为空，因此报错。个人粗浅理解，板砖轻拍 ⊙﹏⊙b。</p><p>而网上有人也认为：</p><blockquote><ol type="1"><li>我也是遇到这个问题，不过看到一个帖子写得不错（英文的），里面给出了一个可能的理由，就是我们用 opencv 打开视频的时候，会自动先监测摄像头有没有读到帧，如果没有，就会报错，然后再执行你的程序，加一个if判断就是跳过系统自己的判断，直接执行我们的程序。来自：<a href="https://zhidao.baidu.com/question/1831122325089024420.html" class="uri" target="_blank" rel="external">https://zhidao.baidu.com/question/1831122325089024420.html</a></li><li>有人说的原因是在 VideoCapture 刚开始获取摄像头视频流的过程不返回信号，所以判断 Mat 是否为空，并不断循环去获取 Mat。来自：<a href="http://www.cnblogs.com/tiny656/p/3538115.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/tiny656/p/3538115.html</a></li></ol></blockquote><p>附最终完整示例程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;  </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// 调用摄像头</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">videoCaptureTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//cv::VideoCapture cap(0);  // 打开默认摄像头，参数0代表默认摄像头的ID</span></div><div class="line">    cv::VideoCapture cap;</div><div class="line">    cap.open(<span class="number">0</span>);</div><div class="line">    <span class="comment">// 设置摄像头</span></div><div class="line">    cap.<span class="built_in">set</span>(CV_CAP_PROP_FRAME_WIDTH,<span class="number">640</span>);</div><div class="line">    cap.<span class="built_in">set</span>(CV_CAP_PROP_FRAME_HEIGHT,<span class="number">480</span>);</div><div class="line">    <span class="comment">// 确认是否成功打开摄像头</span></div><div class="line">    <span class="keyword">if</span> (!cap.isOpened())</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"打开摄像头失败，退出！\n"</span>);</div><div class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    cv::namedWindow(<span class="string">"Capture"</span>, CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO);</div><div class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        cv::Mat frame;</div><div class="line">        cap &gt;&gt; frame;   <span class="comment">// 获取帧</span></div><div class="line"></div><div class="line">        <span class="comment">// 对摄像头获取的帧进行各种处理</span></div><div class="line">        <span class="keyword">if</span> (!frame.empty()) <span class="comment">// 最好加上该判断，并在该判断中对帧进行处理</span></div><div class="line">        &#123;</div><div class="line">            cv::imshow(<span class="string">"Capture"</span>, frame);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(cv::waitKey(<span class="number">30</span>) &gt;= <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 每30ms取一帧</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    videoCaptureTest();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>　　其实也可以通过在获取帧时，反复获取帧，直到取到的帧有数据为止，这样就不需要判断语句了，直接显示即可，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span></div><div class="line">&#123;</div><div class="line">    cap &gt;&gt; frame;</div><div class="line">&#125;<span class="keyword">while</span>(frame.empty());</div><div class="line"></div><div class="line">cv::imshow(<span class="string">"Capture"</span>, frame);</div></pre></td></tr></table></figure><p>参考自：<a href="https://stackoverflow.com/a/9285151" class="uri" target="_blank" rel="external">https://stackoverflow.com/a/9285151</a> 。</p><h2 id="后记">后记</h2><p>　　本文还是当初在国内某平台写博客时写的，但现在再回头看，又稍微有了点新的思路，温故确实能知新 (*^__^*) 嘻嘻……。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://blog.sina.com.cn/s/blog_a3e7ccd6010105yn.html" target="_blank" rel="external">OpenCV2.3使用摄像头和视频</a>（<a href="http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html" class="uri" target="_blank" rel="external">http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html</a>）</p><p>[2] <a href="http://zhidao.baidu.com/link?url=pIM9Hr0-Yalk-uj8cm5ml0y91X92jJmPAXMKQ-1h7FXSPsrwTiD6_9Ngfq72hmxbVDjNE0aYTOmXCCVEryZvhNBJGW6FbsqjO6dbjVLEZt3" target="_blank" rel="external">OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, fi 这个问题怎么办？</a></p><p>[3] <a href="http://blog.csdn.net/czl389/article/details/51031100" target="_blank" rel="external">OpenCV打开摄像头出现运行错误OpenCV Error：Assertion failed (size.width&gt;0&amp;&amp;size.height&gt;0)in cv::imshow，……</a>（<a href="http://blog.csdn.net/czl389/article/category/6381887" class="uri" target="_blank" rel="external">http://blog.csdn.net/czl389/article/category/6381887</a>）</p><p>[4] <a href="http://www.cnblogs.com/tiny656/p/3538115.html" target="_blank" rel="external">[OpenCV]获取摄像头视频</a>（<a href="http://www.cnblogs.com/tiny656/category/550972.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/tiny656/category/550972.html</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#FA8072&quot;&gt;本文所用的 OpenCV 版本为 opencv-2.4.11，编程语言为 C++。&lt;/font&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本文其实是以前在刚学 OpenCV 时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Problems" scheme="http://cniter.github.io/categories/Problems/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加各种小部件</title>
    <link href="http://cniter.github.io/posts/3bc0decc.html"/>
    <id>http://cniter.github.io/posts/3bc0decc.html</id>
    <published>2017-09-15T12:23:05.000Z</published>
    <updated>2018-01-31T07:42:03.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>　　本人目前还在使用对 Hexo 的主题 <strong>SPFK</strong> 自行魔改的那个主题（所谓的魔改也就是对照着 <strong>black-blue</strong> 主题修改了部分 CSS，然后又添加了一个站内搜索功能 (&gt;^ω^&lt;)），主题 SPFK 主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。</p><a id="more"></a><h2 id="添加-qq-邮箱联系">添加 QQ 邮箱联系</h2><p><strong><em>添加日期：2017-9-15</em></strong></p><p>　　进入 <a href="http://openmail.qq.com/" target="_blank" rel="external">QQ邮箱开放平台</a>，点击“<strong>获取邮我按钮</strong>”，登录 QQ 之后继续点击该按钮，因为本人不需要其样式，只需要其链接即可，所以就默认样式，直接点击“<strong>获取代码</strong>”即可，本人默认的“<strong>HTML代码</strong>”为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ"</span> <span class="attr">style</span>=<span class="string">"text-decoration:none;"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_01.png"</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p>提取其中的 href，即<code>http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ</code>，将该链接添加到 <strong>主题配置文件</strong> 中，具体如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">subnav:</span></div><div class="line"><span class="attr">  mail:</span> <span class="string">"http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ"</span></div></pre></td></tr></table></figure><p>重新部署站点即可发现对应的邮箱图标，点击该图标可直接给本人发邮件。</p><h2 id="添加-qq-交谈链接">添加 QQ 交谈链接</h2><p><strong><em>添加日期：2017-9-15</em></strong></p><p>　　进入 <a href="http://shang.qq.com/v3/widget.html" target="_blank" rel="external">QQ推广</a>，点击上方的“<strong>推广工具</strong>”，若没登录 QQ 则先登录 QQ，组件样式同样默认即可，这里需要注意的是，需要点击左边的“<strong>设置</strong>”，下滚页面，找到“<strong>安全级别设置</strong>”，如下</p><blockquote><p><h><strong>安全级别设置</strong></h></p><p><input name="qq_security" type="radio">完全公开（推荐商家，客服等用户使用，代码中显示QQ号码，易于推广）</p><p><input name="qq_security" type="radio">安全加密（推荐博主，论坛用户等使用，代码中不显示QQ号码）</p></blockquote><p>选中“<strong>安全加密</strong>”，不然该选项默认的为完全公开，这样 QQ 号码就直接会显示在代码中，不利于隐私保护，选中之后，点击“<strong>保存</strong>”。保存之后，再次点击“<strong>推广工具</strong>”，即可发现下方的复制代码区域的 HTML 代码已看不到明码显示的 QQ 号，（若还是能看到 QQ 号，没有任何变化，可关闭该界面，重启浏览器重新进入该界面），本人的“<strong>复制这段代码并将其粘贴到您的网页上</strong>”下方区域的默认的代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">border</span>=<span class="string">"0"</span>  <span class="attr">src</span>=<span class="string">"http://wpa.qq.com/imgd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422&amp;pic=52"</span> <span class="attr">alt</span>=<span class="string">"点击这里给我发消息"</span> <span class="attr">title</span>=<span class="string">"点击这里给我发消息"</span>/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure><p>提取其中的 href，即<code>http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422</code>，将该链接添加到 <strong>主题配置文件</strong> 中，具体如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attr">subnav:</span></div><div class="line"><span class="attr">  QQ:</span> <span class="string">"http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12"</span></div></pre></td></tr></table></figure><p>重新部署站点即可发现对应的 QQ 图标，点击该图标可直接给本人发临时 QQ 消息。</p><h2 id="添加用户访问统计信息小工具-revolvermaps">添加用户访问统计信息小工具 —— RevolverMaps</h2><p><strong><em>添加日期：2017-10-12</em></strong></p><p>　　由于本人暂时不想搞 SEO，所以就没有搞站点地图，更没有将本人的站点提交到百度和 Google 的站长平台上。但本人又想查看用户访问信息（是不是很矛盾 o(╯□╰)o），而正好本人看到有个很酷炫的 3D地球 能满足本人的需求（其实很酷炫才是主要原因 O(∩_∩)O~），所以本人决定将其加入本人的站点中（当做一部分装饰品 ๑乛◡乛๑）。该插件的名称为 <a href="http://www.revolvermaps.com/?target=gallery" target="_blank" rel="external">RevolverMaps</a>，具体样式可以去其官网看，本人就不贴图了。设置完前三步之后，第四步让用户复制代码到自己的站点上，注意第四步会让你选“<strong>new map</strong>”还是“<strong>update</strong>”，由于本人是初次使用，当然是选择默认的“<strong>new map</strong>”，如果是以前使用过，就选择“<strong>update</strong>”，并将原来使用的 script 代码输入出现的文本框并提交，这样就只是更改 3D 地球样式而不会丢失用户访问信息数据。 　　具体添加方法为：将复制的 script 代码放入想显示的某个 div 中。本人得到的 script 代码为：</p><blockquote><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</code></p></blockquote><p>　　由于本人的博客是双栏的，本人当然是把 RevolverMaps 放入左栏中，本人刚开始是把得到的 script 代码放入主题文件夹下 <code>\layout\_partial\left-col.ejs</code> 文件末尾的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;/<span class="name">header</span>&gt;</span>                </div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p><code>&lt;/header&gt;</code> 标签之前（即在 header 的最下端显示 RevolverMaps ），但实际用起来有点不好看；本人又想干脆另外创造一个 div 放置地球，具体思路为：在 birdhouse 图标旁创建一个新的地球图标，再做一个像 birdhouse 图标一样的动画，鼠标移到地球图标时，出现一个 div，该 div 用来放置 RevolverMaps，这一步做到一半（即将一个新的地球图标并排放在 birdhouse 图标旁）发现这个效果感觉更不好看了，如果要改就需要大改了，有点麻烦 o(︶︿︶)o唉；于是本人看到鼠标放在 birdhouse 图标出现的菜单栏上，想到何不如将该菜单栏在添加一栏，创建一个 div 用来显示 RevolverMaps？事不宜迟，马上就动手添加该 div，具体添加步骤如下：</p><ol type="1"><li><p>首先当然是添加一个“<strong>访问情况</strong>”的列表名称，在主题文件夹下 <code>\layout\_partial\left-col.ejs</code> 文件中 <code>&lt;ul class=&quot;tips-inner&quot;&gt;</code> 下最后一个 <code>&lt;li&gt;</code> 后即 <code>&lt;/ul&gt;</code> 前添加 <code>&lt;li&gt;访问情况&lt;/li&gt;</code>；</p></li><li><p>接着像其它的列表一样（点击该列表 birdhouse 图标就会改变成相应的图标），点击“<strong>访问情况</strong>”会将 birdhouse 图标改变成一个地球小图标，经查阅相应的 css 文件，其它的列表对应的图标好像是利用 div 的边框属性画出来的（某业余前端的猜测+_+），本人目前还没有这样的才能，就只有投机的采用 Font Awesome 中的 <a href="http://fontawesome.io/icon/globe/" target="_blank" rel="external">globe</a> 图标了。在主题文件夹下 <code>\layout\_partial\left-col.ejs</code> 文件中 <code>&lt;div class=&quot;icon-ctn&quot;&gt;</code> 下最末尾即其对应的 <code>&lt;/div&gt;</code> 前添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icon-wrap icon-globe hide"</span> <span class="attr">data-idx</span>=<span class="string">"4"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"fa fa-globe fa-spin fa-2x"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><p>这样点击“<strong>访问情况</strong>”会将 birdhouse 图标变成一个旋转的地球小图标了；</p></li><li><p>接下来就需要创建“<strong>访问情况</strong>”对应的 div 了，在主题文件夹下 <code>\layout\_partial\left-col.ejs</code> 文件中 <code>&lt;div class=&quot;switch-wrap&quot;&gt;</code> 下最末尾即其对应的 <code>&lt;/div&gt;</code> 前添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"switch-part switch-part5"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49"</span> <span class="attr">async</span>=<span class="string">"async"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></div></pre></td></tr></table></figure><p>这样点击“<strong>访问情况</strong>”就能出现酷炫的 3D 地球了，才怪 :p。这样只能让 3D 地球出现在菜单界面，还需要添加修改相应的 css；</p></li><li><p>最后就是改 css 样式了，本以为这一步很简单，没想到这一步花费本人最多时间 ╮(╯_╰)╭，修改的样式位于主题文件夹下 <code>\source\css_partial\main.styl</code> 文件中，首先为 switch-part5 添加对应的样式，在 .switch-part4 样式后添加：</p><p></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.switch-part5&#123;</div><div class="line">        left: 400%;</div><div class="line">        width: 100%;</div><div class="line">    	//height: 200px;</div><div class="line">        //margin-left: 47px;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p></p><p>做完这一步会发现 3D 地球显示不完全，下面会缺一点，所以还需要继续修改，修改过程如下：本人曾将该 width 减小（如上面代码中的注释），这样确实能让 3D 地球显示完全，但有点小，不是很好看；后面想到没显示完全可能是上层 div（.switch-area）太小且设置了 <code>overflow: hidden;</code>，于是这里本人首先增加了 .switch-area 的高度，这样确实能解决问题，但会使左栏的滚动条显示出来；所以本人接着尝试将 .switch-area 的 <code>overflow: hidden;</code> 注释掉，谁想注释掉之后出现了横向滚动条，这样更不好了，于是本人又更改为 <code>overflow-x: hidden;</code> ，谁想 .switch-area 又出现了竖直滚动条（感觉像拆东墙补西墙 -_-|||），查阅相关资料（<a href="http://blog.csdn.net/qiqingjin/article/details/50413691" target="_blank" rel="external">CSS-overflow特性及总结</a>）得知若 overflow-x 为 hidden，overflow-y 不为 hidden，则 overflow-y 将会自动重置为 auto，所以这里不能这样改，但 <code>overflow: hidden;</code> 还是得注释掉，不然上层 div 撑不开，而且不增加高度的话，还是不能完全显示 3D 地球，因为超出就隐藏了嘛；因为注释掉之后会出现横向滚动条，而又不能修改 .switch-area 的 overflow-x，所以就只能改更上层的 div，这里本人突然想起上次给左栏添加滚动条时，在 .left-col 下添加了 <code>overflow: auto;</code>，这次不如还修改这里，毕竟本人只想要竖直滚动条（其实不要滚动条却能滚动最好，但本人目前还没找到好的解决方案 (╯﹏╰)b），不要横向滚动条，于是将其修改为：</p><p></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">overflow-y</span>: <span class="selector-tag">auto</span>;</div><div class="line"><span class="selector-tag">overflow-x</span>: <span class="selector-tag">hidden</span>;</div></pre></td></tr></table></figure><p></p><p>没想到这样也能解决问题，虽然还是会在左栏出现滚动条，但这样感觉比增加 .switch-area 的高度要好（嗯，应该要好吧 (～ o ～)Y）。看以后能不能改成点击“<strong>访问情况</strong>”时才出现滚动条，点击其它列表则不出现滚动条（其实把滚动条隐藏最好，但网上那个两个 div 嵌套的方法本人尝试过会出现一些奇怪的问题，等以后再试试吧 ↖((^ω^)↗）。</p></li></ol><hr><p>待续。。。</p><h2 id="后记">后记</h2><p>　　目前就添加这些小组件，以后应该会陆续添加一些其它的小东西 ↖(^ω^)↗。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://jingyan.baidu.com/article/dca1fa6fb5b637f1a44052b4.html" target="_blank" rel="external">如何在自己网站上或者博客上放置QQ邮箱联系反馈</a>（<a href="http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1" target="_blank" rel="external">http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1</a>）</p><p>[2] <a href="http://www.29mo.com/wltg/363.html" target="_blank" rel="external">如何在自己的博客添加QQ组件</a>（<a href="http://www.29mo.com/category/wltg" class="uri" target="_blank" rel="external">http://www.29mo.com/category/wltg</a>）</p><p>[3] <a href="http://www.feizl.com/html/29610.htm" target="_blank" rel="external">一步一步教你给自己博客添加QQ在线</a>（<a href="http://www.feizl.com/feizhuliu/QQbaodian/" class="uri" target="_blank" rel="external">http://www.feizl.com/feizhuliu/QQbaodian/</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　本人目前还在使用对 Hexo 的主题 &lt;strong&gt;SPFK&lt;/strong&gt; 自行魔改的那个主题（所谓的魔改也就是对照着 &lt;strong&gt;black-blue&lt;/strong&gt; 主题修改了部分 CSS，然后又添加了一个站内搜索功能 (&amp;gt;^ω^&amp;lt;)），主题 SPFK 主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。&lt;/p&gt;
    
    </summary>
    
      <category term="建站小记" scheme="http://cniter.github.io/categories/%E5%BB%BA%E7%AB%99%E5%B0%8F%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://cniter.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中显著性检测算法的使用</title>
    <link href="http://cniter.github.io/posts/fd0f8195.html"/>
    <id>http://cniter.github.io/posts/fd0f8195.html</id>
    <published>2017-09-12T10:36:26.000Z</published>
    <updated>2018-01-31T07:29:34.287Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FA8072">本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。</font></p><h2 id="前言">前言</h2><p>　　OpenCV 中实现了两种显著性检测算法，分别为 Spectral Residual 算法,出自 <strong>Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In <em>Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on</em>, pages 1–8. IEEE, 2007.</strong> 和 Fine Grained Saliency 算法,出自 <strong>Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In <em>Image and Vision Computing, Vol. 28 Issue 3</em>, pages 391–402. Elsevier, 2010.</strong>。这两种算法同样是在扩展包 opencv_contrib-3.2.0 中，也是由于 opencv <a href="https://github.com/opencv/opencv_contrib/blob/master/modules/saliency/samples/computeSaliency.cpp" target="_blank" rel="external">官方示例程序</a>对初学者不友好（主要是本人境界不够 o(╯□╰)o），所以本人对照其<a href="http://docs.opencv.org/3.2.0/d8/d65/group__saliency.html" target="_blank" rel="external">官方文档</a>重新整理了一下。</p><a id="more"></a><h2 id="说明篇">说明篇</h2><p>　　<strong>使用 OpenCV 中实现的显著性检测算法进行显著性检测十分方便简洁，利用以下三个函数就可以：</strong></p><p>创建 Spectral Residual 算法显著性检测对象：<code>static Ptr&lt;StaticSaliencySpectralResidual&gt; cv::saliency::StaticSaliencySpectralResidual::create();</code></p><p>Spectral Residual 算法计算显著性图：<code>bool cv::saliency::StaticSaliencySpectralResidual::computeSaliency(InputArray image, OutputArray saliencyMap);</code></p><p>Fine Grained Saliency 算法显著性检测对应的函数声明同 Spectral Residual 算法类似。</p><p>计算显著性图的二值图：<code>bool cv::saliency::StaticSaliency::computeBinaryMap(InputArray _saliencyMap, OutputArray _binaryMap) ;</code></p><p>具体使用方法可参考实例篇。</p><h2 id="实例篇">实例篇</h2><p>　　使用 OpenCV 中的显著性检测算法需要包含头文件<code>#include &lt;opencv2/saliency.hpp&gt;</code>，具体示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/saliency.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">//******************************************************</span></div><div class="line"><span class="comment">// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)</span></div><div class="line"><span class="comment">//&#123;</span></div><div class="line"><span class="comment">//	if (saliencyType == "SPECTRAL_RESIDUAL")</span></div><div class="line"><span class="comment">//		return makePtr&lt;StaticSaliencySpectralResidual&gt;();  //computeSaliency返回的是32FC1</span></div><div class="line"><span class="comment">//	else if (saliencyType == "FINE_GRAINED")</span></div><div class="line"><span class="comment">//		return makePtr&lt;StaticSaliencyFineGrained&gt;();	 //computeSaliency返回的是8UC1</span></div><div class="line"><span class="comment">//	else if (saliencyType == "BING")</span></div><div class="line"><span class="comment">//		return makePtr&lt;ObjectnessBING&gt;();</span></div><div class="line"><span class="comment">//	else if (saliencyType == "BinWangApr2014")</span></div><div class="line"><span class="comment">//		return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();</span></div><div class="line"><span class="comment">//	return Ptr&lt;Saliency&gt;();</span></div><div class="line"><span class="comment">//&#125;</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)</span></div><div class="line"><span class="comment">//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）</span></div><div class="line"><span class="comment">//*****************************************************</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">spectralResidualTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat src_img = cv::imread(<span class="string">"../data/true.png"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);	<span class="comment">// 载入最真实的原始图像</span></div><div class="line">	cv::namedWindow(<span class="string">"src_img"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"src_img"</span>, src_img);</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687)</span></div><div class="line">	<span class="keyword">if</span> (src_img.empty())</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">if</span> (src_img.channels() == <span class="number">3</span>)</div><div class="line">		cv::cvtColor(src_img, src_img, CV_BGR2GRAY);</div><div class="line">	cv::Mat planes[] = &#123; cv::Mat_&lt;<span class="keyword">float</span>&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;;</div><div class="line">	cv::Mat complex_img; <span class="comment">//复数矩阵</span></div><div class="line">	merge(planes, <span class="number">2</span>, complex_img); <span class="comment">//把单通道矩阵组合成复数形式的双通道矩阵</span></div><div class="line">	dft(complex_img, complex_img);  <span class="comment">// 使用离散傅立叶变换</span></div><div class="line"></div><div class="line">	<span class="comment">//对复数矩阵进行处理，方法为谱残差</span></div><div class="line">	cv::Mat magnitude, phase_angle, mag_mean;</div><div class="line">	cv::Mat real_part, imaginary_part;</div><div class="line">	split(complex_img, planes); <span class="comment">//分离复数到实部和虚部</span></div><div class="line">	real_part = planes[<span class="number">0</span>]; <span class="comment">//实部</span></div><div class="line">	imaginary_part = planes[<span class="number">1</span>]; <span class="comment">//虚部</span></div><div class="line">	cv::magnitude(real_part, imaginary_part, magnitude); <span class="comment">//计算幅值</span></div><div class="line">	phase(real_part, imaginary_part, phase_angle); <span class="comment">//计算相角</span></div><div class="line"></div><div class="line">	<span class="keyword">float</span> *pre, *pim, *pm, *pp;</div><div class="line">	<span class="comment">//对幅值进行对数化</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magnitude.rows; i++)</div><div class="line">	&#123;</div><div class="line">		pm = magnitude.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; magnitude.cols; j++)</div><div class="line">		&#123;</div><div class="line">			*pm = <span class="built_in">log</span>(*pm);</div><div class="line">			pm++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	blur(magnitude, mag_mean, cv::Size(<span class="number">5</span>, <span class="number">5</span>)); <span class="comment">//对数谱的均值滤波</span></div><div class="line">	magnitude = magnitude - mag_mean; <span class="comment">//求取对数频谱残差</span></div><div class="line">	<span class="comment">//把对数谱残差的幅值和相角划归到复数形式</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magnitude.rows; i++)</div><div class="line">	&#123;</div><div class="line">		pre = real_part.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		pim = imaginary_part.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		pm = magnitude.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		pp = phase_angle.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; magnitude.cols; j++)</div><div class="line">		&#123;</div><div class="line">			*pm = <span class="built_in">exp</span>(*pm);</div><div class="line">			*pre = *pm * <span class="built_in">cos</span>(*pp);</div><div class="line">			*pim = *pm * <span class="built_in">sin</span>(*pp);</div><div class="line">			pre++;</div><div class="line">			pim++;</div><div class="line">			pm++;</div><div class="line">			pp++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	cv::Mat planes1[] = &#123; cv::Mat_&lt;<span class="keyword">float</span>&gt;(real_part), cv::Mat_&lt;<span class="keyword">float</span>&gt;(imaginary_part) &#125;;</div><div class="line"></div><div class="line">	merge(planes1, <span class="number">2</span>, complex_img); <span class="comment">//重新整合实部和虚部组成双通道形式的复数矩阵</span></div><div class="line">	idft(complex_img, complex_img, cv::DFT_SCALE); <span class="comment">// 傅立叶反变换</span></div><div class="line">	split(complex_img, planes); <span class="comment">//分离复数到实部和虚部</span></div><div class="line">	real_part = planes[<span class="number">0</span>];</div><div class="line">	imaginary_part = planes[<span class="number">1</span>];</div><div class="line">	cv::magnitude(real_part, imaginary_part, magnitude); <span class="comment">//计算幅值和相角</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; magnitude.rows; i++)</div><div class="line">	&#123;</div><div class="line">		pm = magnitude.ptr&lt;<span class="keyword">float</span>&gt;(i);</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; magnitude.cols; j++)</div><div class="line">		&#123;</div><div class="line">			*pm = (*pm) * (*pm);</div><div class="line">			pm++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	GaussianBlur(magnitude, magnitude, cv::Size(<span class="number">7</span>, <span class="number">7</span>), <span class="number">2.5</span>, <span class="number">2.5</span>);</div><div class="line">	cv::Mat invDFT, invDFTcvt;</div><div class="line">	normalize(magnitude, invDFT, <span class="number">0</span>, <span class="number">255</span>, cv::NORM_MINMAX); <span class="comment">//归一化到[0,255]供显示</span></div><div class="line">	invDFT.convertTo(invDFTcvt, CV_8U); <span class="comment">//转化成CV_8U型</span></div><div class="line">	cv::namedWindow(<span class="string">"SpectualResidual"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"SpectualResidual"</span>, invDFTcvt);</div><div class="line"></div><div class="line">	cv::Mat thresholded;</div><div class="line">	cv::threshold(invDFTcvt, thresholded, <span class="number">0</span>, <span class="number">255</span>, CV_THRESH_OTSU);</div><div class="line">	cv::namedWindow(<span class="string">"Thresholded Image"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"Thresholded Image"</span>, thresholded);</div><div class="line"></div><div class="line">	cv::Mat eroded;</div><div class="line">	<span class="comment">// 纵向腐蚀</span></div><div class="line">	cv::erode(thresholded, eroded, cv::Mat(<span class="number">5</span>, <span class="number">1</span>, CV_8UC1, cv::Scalar(<span class="number">1</span>)), cv::Point(<span class="number">-1</span>, <span class="number">-1</span>), <span class="number">3</span>);	<span class="comment">// cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心</span></div><div class="line">	cv::namedWindow(<span class="string">"eroded Image"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"eroded Image"</span>, eroded);</div><div class="line"></div><div class="line">	<span class="comment">//cv::Mat thresholded;</span></div><div class="line">	cv::threshold(eroded, thresholded, <span class="number">60</span>, <span class="number">255</span>, CV_THRESH_BINARY);</div><div class="line">	cv::namedWindow(<span class="string">"Thresholded eroded Image"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"Thresholded eroded Image"</span>, thresholded);</div><div class="line">&#125;</div><div class="line"></div><div class="line"> <span class="comment">// 显著性检测算法基类</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">saliencyTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat src_img = cv::imread(<span class="string">"../data/true.png"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);</div><div class="line">	cv::namedWindow(<span class="string">"src_img"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"src_img"</span>, src_img);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (src_img.empty())</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">if</span> (src_img.channels() == <span class="number">3</span>)</div><div class="line">		cv::cvtColor(src_img, src_img, CV_BGR2GRAY);</div><div class="line"></div><div class="line">	cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create(<span class="string">"SPECTRAL_RESIDUAL"</span>);	<span class="comment">// FINE_GRAINED为Fine Grained Saliency算法</span></div><div class="line">	cv::Mat saliency_map;</div><div class="line">	<span class="keyword">if</span> (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map))	<span class="comment">// 计算显著性图</span></div><div class="line">	&#123;</div><div class="line">		cv::namedWindow(<span class="string">"SR saliency map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">		cv::imshow(<span class="string">"SR saliency map"</span>, saliency_map);</div><div class="line"></div><div class="line">		cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1);</div><div class="line">		normalize(saliency_map, saliency_map_show, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX); <span class="comment">//归一化到[0,255]供显示</span></div><div class="line">		saliency_map_show.convertTo(saliency_map_show, CV_8U); <span class="comment">//转化成CV_8U型</span></div><div class="line">		cv::namedWindow(<span class="string">"saliency_map_show"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">		cv::imshow(<span class="string">"saliency_map_show"</span>, saliency_map_show);</div><div class="line"></div><div class="line">		cv::Mat binary_map;</div><div class="line">		cv::saliency::StaticSaliencySpectralResidual spec;</div><div class="line">		<span class="keyword">if</span> (spec.computeBinaryMap(saliency_map, binary_map))	<span class="comment">// 对显著性图进行二值化</span></div><div class="line">		&#123;</div><div class="line">			cv::namedWindow(<span class="string">"binary map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">			cv::imshow(<span class="string">"binary map"</span>, binary_map);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Fine Grained Saliency算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">FGSTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat src_img = cv::imread(<span class="string">"../data/true.png"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);</div><div class="line">	cv::namedWindow(<span class="string">"src_img"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"src_img"</span>, src_img);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (src_img.empty())</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">if</span> (src_img.channels() == <span class="number">3</span>)</div><div class="line">		cv::cvtColor(src_img, src_img, CV_BGR2GRAY);</div><div class="line"></div><div class="line">	cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create();</div><div class="line">	cv::Mat fgs_saliency_map;</div><div class="line">	fgs-&gt;computeSaliency(src_img, fgs_saliency_map);</div><div class="line">	cv::namedWindow(<span class="string">"FGS saliency map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"FGS saliency map"</span>, fgs_saliency_map);</div><div class="line">	<span class="comment">//cv::imwrite("../data/T_S.png", fgs_saliency_map);</span></div><div class="line"></div><div class="line">	cv::Mat binary_map;</div><div class="line">	cv::threshold(fgs_saliency_map, binary_map, <span class="number">0</span>, <span class="number">255</span>, CV_THRESH_OTSU);</div><div class="line">	cv::namedWindow(<span class="string">"binary map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"binary map"</span>, binary_map);</div><div class="line">	<span class="comment">//cv::imwrite("../data/T_S_B.png", binary_map);</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Spectral Residual算法</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SRTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	cv::Mat src_img = cv::imread(<span class="string">"../data/true.png"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);</div><div class="line">	cv::namedWindow(<span class="string">"src_img"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"src_img"</span>, src_img);</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (src_img.empty())</div><div class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">	<span class="keyword">if</span> (src_img.channels() == <span class="number">3</span>)</div><div class="line">		cv::cvtColor(src_img, src_img, CV_BGR2GRAY);</div><div class="line"></div><div class="line">	cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create();</div><div class="line">	cv::Mat sr_saliency_map;</div><div class="line">	sr-&gt;computeSaliency(src_img, sr_saliency_map);</div><div class="line">	cv::namedWindow(<span class="string">"SR saliency map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"SR saliency map"</span>, sr_saliency_map);</div><div class="line"></div><div class="line">	cv::Mat binary_map;</div><div class="line">	sr-&gt;computeBinaryMap(sr_saliency_map, binary_map);</div><div class="line">	cv::namedWindow(<span class="string">"binary map"</span>, CV_WND_PROP_ASPECTRATIO);</div><div class="line">	cv::imshow(<span class="string">"binary map"</span>, binary_map);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">//spectralResidualTest();</span></div><div class="line">	<span class="comment">//saliencyTest();</span></div><div class="line">	<span class="comment">//FGSTest();</span></div><div class="line">	SRTest();</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (cv::waitKey(<span class="number">0</span>) != <span class="number">27</span>) &#123; &#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>以上代码在 Win10 VS2013 中编译运行成功。</em></p><p>　　这里面有个小东西需要注意，就是 <code>computeBinaryMap()</code> 函数，看其文档描述其中使用 <em>K-means</em> 算法和 <em>Otsu</em> 算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV 中 Spectral Residual 算法 computeSaliency() 返回的结果为浮点数，而 Fine Grained Saliency 算法 computeSaliency() 返回的结果却是整型数据，所以这一点需要注意 Fine Grained Saliency 算法返回的结果不能直接使用 computeBinaryMap() 函数，一般对其结果直接使用 OTSU 算法进行阈值分割即可。</p><h2 id="后记">后记</h2><p>　　本文使用的这两种算法在本人的电脑上运行时间都较长，基本不可能用来处理视频流，而且在本人的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过 OpenCV 中也有用来处理视频流的显著性检测算法，其为 BING 算法,出自<strong>Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In <em>IEEE CVPR</em>, 2014.</strong>，实际上这是一种快速提取目标候选框的算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#FA8072&quot;&gt;本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。&lt;/font&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　OpenCV 中实现了两种显著性检测算法，分别为 Spectral Residual 算法,出自 &lt;strong&gt;Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In &lt;em&gt;Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on&lt;/em&gt;, pages 1–8. IEEE, 2007.&lt;/strong&gt; 和 Fine Grained Saliency 算法,出自 &lt;strong&gt;Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In &lt;em&gt;Image and Vision Computing, Vol. 28 Issue 3&lt;/em&gt;, pages 391–402. Elsevier, 2010.&lt;/strong&gt;。这两种算法同样是在扩展包 opencv_contrib-3.2.0 中，也是由于 opencv &lt;a href=&quot;https://github.com/opencv/opencv_contrib/blob/master/modules/saliency/samples/computeSaliency.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方示例程序&lt;/a&gt;对初学者不友好（主要是本人境界不够 o(╯□╰)o），所以本人对照其&lt;a href=&quot;http://docs.opencv.org/3.2.0/d8/d65/group__saliency.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;重新整理了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV中Selective Search算法的使用</title>
    <link href="http://cniter.github.io/posts/35132cb7.html"/>
    <id>http://cniter.github.io/posts/35132cb7.html</id>
    <published>2017-09-10T12:31:03.000Z</published>
    <updated>2018-01-31T07:26:56.772Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FA8072">本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。</font></p><h2 id="前言">前言</h2><p>　　OpenCV-3.2 中的 Selective Search 算法是在其扩展包中，所以要想使用该算法需自行编译 opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（本人编程水平有限，粗浅评价，勿怪 (*^__^ *) 嘻嘻……），所以本人参考其<a href="http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html" target="_blank" rel="external">官方文档</a>及其<a href="https://github.com/opencv/opencv_contrib/blob/master/modules/ximgproc/samples/selectivesearchsegmentation_demo.cpp" target="_blank" rel="external">官方示例程序</a>写下此文。</p><a id="more"></a><h2 id="说明篇">说明篇</h2><p>　　该算法是选取 region proposal（一般翻译成候选区域 / 区域建议）领域中当时的 <em>state-of-the-art</em>。其算法具体思想出自 <strong>Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. <em>International journal of computer vision</em>, 104(2):154–171, 2013.</strong>，若英文水平不够，还想了解其中文思想请参考文末参考资料。</p><p>　　<strong>OpenCV中实现的相应函数：</strong></p><p><code>void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addGraphSegmentation(Ptr&lt;GraphSegmentation&gt; g);</code>：添加相应的图割算法；</p><p><code>void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addImage(InputArray img) ;</code> ：添加待处理的图片；</p><p><code>void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addStrategy(Ptr&lt;SelectiveSearchSegmentationStrategy&gt; s);</code> ：添加相应的策略（颜色相似度、纹理相似度、尺寸相似度和填充相似度）；</p><p><code>void cv::ximgproc::segmentation::SelectiveSearchSegmentation::process(std::vector&lt;Rect&gt; &amp;rects);</code>：结合图割算法和相应策略进行处理，返回候选框。</p><h2 id="实例篇">实例篇</h2><p>　　使用 Selective Search 算法需包含<code>#include &lt;opencv2/ximgproc.hpp&gt;</code>，完整示例程序如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/ximgproc.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSTest</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="comment">// [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) </span></div><div class="line"></div><div class="line">	cv::Mat src_img = cv::imread(<span class="string">"../data/true.png"</span>, CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR);	<span class="comment">// 载入原始图像</span></div><div class="line">	cv::namedWindow(<span class="string">"src_img"</span>, CV_WINDOW_KEEPRATIO);</div><div class="line">	cv::imshow(<span class="string">"src_img"</span>, src_img);</div><div class="line"></div><div class="line">	<span class="comment">//// 转换为灰度图</span></div><div class="line">	<span class="comment">//cv::Mat gray_img;</span></div><div class="line">	<span class="comment">//cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY);</span></div><div class="line"></div><div class="line">	<span class="comment">// 图割算法</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation();</div><div class="line">	cv::Mat graph_segmented;</div><div class="line">	gs-&gt;processImage(src_img, graph_segmented);</div><div class="line">	normalize(graph_segmented, graph_segmented, <span class="number">0</span>, <span class="number">255</span>, CV_MINMAX); <span class="comment">// 归一化到[0,255]供显示</span></div><div class="line">	graph_segmented.convertTo(graph_segmented, CV_8U); <span class="comment">// 数据类型转化成CV_8U型</span></div><div class="line">	<span class="comment">// cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR);</span></div><div class="line">	cv::namedWindow(<span class="string">"graph_segmented"</span>, CV_WINDOW_KEEPRATIO);</div><div class="line">	imshow(<span class="string">"graph_segmented"</span>, graph_segmented);</div><div class="line"></div><div class="line">	<span class="comment">// 为selective search算法添加图割算法处理结果</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation();</div><div class="line">	ss-&gt;addGraphSegmentation(gs);</div><div class="line"></div><div class="line">	ss-&gt;addImage(src_img);	<span class="comment">// 添加待处理的图片</span></div><div class="line"></div><div class="line">	<span class="comment">// 自定义策略</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor();	<span class="comment">// 颜色相似度策略</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture();	<span class="comment">// 纹理相似度策略</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize();	<span class="comment">// 尺寸相似度策略</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill();	<span class="comment">// 填充相似度策略</span></div><div class="line">	<span class="comment">// 添加策略</span></div><div class="line">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill);	<span class="comment">// 合并以上4种策略</span></div><div class="line">	ss-&gt;addStrategy(sss);</div><div class="line"></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Rect&gt; regions;</div><div class="line">	ss-&gt;process(regions);	<span class="comment">// 处理结果</span></div><div class="line"></div><div class="line">	<span class="comment">// 显示结果</span></div><div class="line">	cv::Mat show_img = src_img.clone();</div><div class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r)</div><div class="line">	&#123;</div><div class="line">		cv::rectangle(show_img, *it_r, cv::Scalar(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>);</div><div class="line">	&#125;</div><div class="line">	cv::namedWindow(<span class="string">"show_img"</span>, CV_WINDOW_KEEPRATIO);</div><div class="line">	imshow(<span class="string">"show_img"</span>, show_img);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// -------忽略上述步骤，直接采用方便算法提取候选区域------------------------</span></div><div class="line">	<span class="comment">/***************************************************************************</span></div><div class="line"><span class="comment">	cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation();</span></div><div class="line"><span class="comment">	ss-&gt;setBaseImage(src_img);	// 采用switch* functions提取候选区域</span></div><div class="line"><span class="comment">	ss-&gt;switchToSelectiveSearchFast();	// 快速提取区域</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	std::vector&lt;cv::Rect&gt; rects;</span></div><div class="line"><span class="comment">	ss-&gt;process(rects);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	int nb_rects = 10;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	char c = (char)cv::waitKey();</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">	while (c != 'q')</span></div><div class="line"><span class="comment">	&#123;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		cv::Mat wimg = src_img.clone();</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		int i = 0;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it)</span></div><div class="line"><span class="comment">		&#123;</span></div><div class="line"><span class="comment">			if (i++ &lt; nb_rects)</span></div><div class="line"><span class="comment">			&#123;</span></div><div class="line"><span class="comment">				cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3);</span></div><div class="line"><span class="comment">			&#125;</span></div><div class="line"><span class="comment">		&#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		cv::namedWindow("Output", CV_WINDOW_KEEPRATIO);</span></div><div class="line"><span class="comment">		imshow("Output", wimg);</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		c = (char)cv::waitKey();</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		if (c == 'd')</span></div><div class="line"><span class="comment">		&#123;</span></div><div class="line"><span class="comment">			nb_rects += 10;</span></div><div class="line"><span class="comment">		&#125;</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">		if (c == 'a' &amp;&amp; nb_rects &gt; 10)</span></div><div class="line"><span class="comment">		&#123;</span></div><div class="line"><span class="comment">			nb_rects -= 10;</span></div><div class="line"><span class="comment">		&#125;</span></div><div class="line"><span class="comment">	&#125;</span></div><div class="line"><span class="comment">	********************************************************/</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	SSTest();</div><div class="line"></div><div class="line">	<span class="keyword">while</span> (cv::waitKey(<span class="number">0</span>) != <span class="number">27</span>) &#123;&#125;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><em>以上代码在 Win10 VS2013 中编译运行成功。</em></p><h2 id="后记">后记</h2><p>　　使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法 <code>switchToSelectiveSearchFast()</code> 的参数。本人的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在本人电脑上略显长。GitHub 上也有大神自己用 opencv 实现了该算法，参考 <a href="https://github.com/watanika/selective-search-cpp" target="_blank" rel="external">watanika/selective-search-cpp</a>，该算法的参数感觉比 OpenCV 自带的 Selective Search 算法要好调一些，但优化效果没有 opencv 好，其运行时间在本人电脑上更长，毕竟 OpenCV 是 Intel 的亲儿子，Intel 肯定针对处理器对 OpenCV 底层做了一定的优化。</p><h2 id="参考资料">参考资料</h2><p>[1] <a href="http://jermmy.xyz/2017/05/04/2017-5-4-paper-notes-selective-search/" target="_blank" rel="external">论文笔记：Selective Search for Object Recognition</a>（<a href="http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" target="_blank" rel="external">http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/</a>）</p><p>[2] <a href="http://blog.csdn.net/langb2014/article/details/52575507" target="_blank" rel="external">Selective Search for Object Recognition(阅读)</a>（<a href="http://blog.csdn.net/langb2014/article/category/5772811" class="uri" target="_blank" rel="external">http://blog.csdn.net/langb2014/article/category/5772811</a>）</p><p>[3] <a href="http://blog.csdn.net/csyhhb/article/details/50425114" target="_blank" rel="external">论文笔记 《Selective Search for Object Recognition》</a>（<a href="http://blog.csdn.net/csyhhb/article/category/6048588" class="uri" target="_blank" rel="external">http://blog.csdn.net/csyhhb/article/category/6048588</a>）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;font color=&quot;#FA8072&quot;&gt;本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。&lt;/font&gt;&lt;/p&gt;&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;&lt;p&gt;　　OpenCV-3.2 中的 Selective Search 算法是在其扩展包中，所以要想使用该算法需自行编译 opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（本人编程水平有限，粗浅评价，勿怪 (*^__^ *) 嘻嘻……），所以本人参考其&lt;a href=&quot;http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档&lt;/a&gt;及其&lt;a href=&quot;https://github.com/opencv/opencv_contrib/blob/master/modules/ximgproc/samples/selectivesearchsegmentation_demo.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方示例程序&lt;/a&gt;写下此文。&lt;/p&gt;
    
    </summary>
    
      <category term="Study" scheme="http://cniter.github.io/categories/Study/"/>
    
    
      <category term="opencv" scheme="http://cniter.github.io/tags/opencv/"/>
    
  </entry>
  
</feed>
