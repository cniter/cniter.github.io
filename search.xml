<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo的SPFK主题修改小记]]></title>
    <url>%2F2017%2F09%2F16%2FHexo%E7%9A%84SPFK%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 本人一直在对Hexo的SPFK主题进行持续修改以符合本人自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。 修改篇1、修改aboutme排版问题。需求描述：本人为了使aboutme排版好看一点，使“关于我”的内容更有段落感，本人尝试在主题配置文件中aboutme对象的内容添加各种换行转义符号均于事无补，如\n、\r\n、&amp;#13;、&amp;#10;、&lt;br /&gt;等，站点不仅不会换行，还会直接将转义符号都显示出来(╯﹏╰）。 解决办法：既然本人基本把所有的换行方法都试过了，还没有任何作用，那就只能是问题出在其它地方了。本人首先找到显示aboutme内容的地方，其位于主题文件夹下\layout\_partial\left-col.ejs，显示aboutme内容的代码为&lt;div id=&quot;js-aboutme&quot;&gt;&lt;%=theme.aboutme%&gt;&lt;/div&gt;，查阅相关资料，具体为与大家分享ejs源码阅读心得，其中有这样一段话： 关于ejs模板的五种模式对应几种指令 ejs主要提供了如下几种指令: &lt;%, 该指令主要通过js中的eval来执行js代码, 如上模板代码&lt;% [1,2].forEach(function(v){ %&gt;将通过eval编译成; [1,2].forEach(function(v){即直接可执行的js代码, 并且不会存放到__output函数中输出. &lt;%=, 该指令主要用于输出变量内容, 如上模板代码&lt;%= v %&gt;将通过escape函数编译成__append(escape(v)), 可以看到该指令用于输出变量内容, 最后将通过__output输出内容. &lt;%-, 该指令与&lt;%=区别是, &lt;%=指令使用escape函数来对特殊字符进行编码, 如将&gt;转为%3E, 查看关于escape函数. &lt;%#, 该指令主要用于模板内注释, 既不会执行也不会输出. &lt;%%, 主要用于输出字面值%. 关于以上各个指令对应的解析, 可参考ejs源码根目录lib/ejs.js文件中的scanLine函数. 从中可得知&lt;%=指令会将变量内容中一些特殊字符先转义，再原封不动的输出，所以本人无论怎么修改主题配置文件中aboutme对象的值，其输出内容都会是原封不动的aboutme对象的值。为了让其输出内容可以有相应的特殊格式，就不能让其转义，只能用&lt;%-指令，将其修改为&lt;div id=&quot;js-aboutme&quot;&gt;&lt;%-theme.aboutme%&gt;&lt;/div&gt;，这样就能使输出内容可以自定义特殊格式，本人最后在aboutme对象的内容中需要换行的地方添加了&lt;br /&gt;，实测如此修改后可以换行。 2、给左栏添加滚动条。需求描述：SPFK主题是双栏的主题。因为左栏主要是用来显示一些菜单和头像等内容，这些内容也不多，所以原作者就没有添加滚动条。但是由于本人添加了个本地搜索功能，在刚开始文章少的时候还不受影响，但是随着文章的增多，搜索功能就会影响左栏的布局，这是就必须添加一个滚动条了。本以为添加滚动条很简单，就是添加一个overflow: auto;，谁知道还没这么简单╮(╯﹏╰）╭。 解决办法：本人对问题的定位没问题，就是修改主题文件夹下的\source\css\_partial\main.styl文件中.left-col样式，问题在于怎么修改，本想直接在其中加入overflow: auto;，按道理说问题就能解决的，但是本人去搜索试试，发现搜索框上方的头像，文字等全部消失了，滚动条没起到作用，而下方的菜单可以通过滚动条看到。于是本人觉得可能是div上界没撑开，而超出的地方却隐藏了，但下界为什么能撑开，本人这里还是很不明白?_?。既然是这里隐藏了，本人就去看相关标签有没有overflow: hidden;属性，谁知道要么是没有，要么是即是关闭了也没有作用，那问题应该不是出在这里。就只能是这些元素所在的子div里了，本人找到其子div属性.intrude-less，其中虽有overflow: auto;但没设置height属性，所以就不能发挥其作用，本人于是给它加上height属性，搜索后发现有两个滚动条，这显然不简约，于是本人把.intrude-less的overflow: auto;属性注释掉，没想到居然能完美解决问题，可能是因为加上高度属性之后就能撑大父元素div了吧（来自某业余前端的猜测(⊙_⊙)）。后面为了更美观，本人把下方菜单区域的div样式.switch-area高度min-height改小了一点，顺便也把主题文件夹下的\layout\_partial\left-col.ejs文件中首行注释掉&lt;!-- &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; --&gt;。本人也曾想把height改为min-height，谁知道又出现相同的问题，不得不又改回去。虽然这次已经解决了问题，但有些细节问题还是不太明白，只有等以后前端水平上去了再去想了，如有大佬知道还望不吝赐教(&#94;人&#94;)。 待续。。。 后记 先就写到这里，如后续修改中发现问题再继续记录吧↖(&#94;ω&#94;)↗。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%A7%A3%E5%86%B3Qt%E4%B8%ADQlabel%E6%98%BE%E7%A4%BAOpenCV%E7%9A%84Mat%E6%95%B0%E6%8D%AE%E5%9B%BE%E5%83%8F%E4%BA%A7%E7%94%9F%E6%89%AD%E6%9B%B2%E7%8E%B0%E8%B1%A1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言 曾写过一个程序，需要有一个界面，但本人不想使用MFC，因缘巧合，在网上看到Qt，就尝试用了一下，遂有此文。本人的Qt版本为qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的Qt可以通过Visual Studio 2013开发Qt程序（各位看官猜的没错，本人并没有直接使用Qt Creator开发Qt程序，而是通过VS开发Qt程序的\(&#94;o&#94;)/），一来是熟悉VS开发，对Qt Creator完全没用过；二来是已经在VS配好全套的开发环境了（画外音：说白了就是懒嘛╭(╯^╰)╮）。但是在VS中开发Qt程序还需要一些其它的配置。 准备篇 在VS中开发Qt程序首先需要安装一个addin外接程序，下载并安装qt-vs-addin-1.2.5.exe（http://download.qt.io/archive/vsaddin/ ），（网上说该程序已不支持VS2013及以上版本的VS，原因是VS2013及其以上版本的VS都不支持该种类型的插件，新版本的VS需要安装新型插件qt-vs-tools-msvc2013-2.1.1.vsix或 qt-vs-tools-msvc2015-2.1.1.vsix），但是经本人实测，本人的VS2013-update5 英文旗舰版通过qt-vs-addin-1.2.5编写Qt程序完全没问题，不过VS2015就不知道了，可能真需要安装新型插件。下载安装好相应的软件之后需要在VS中配置Qt环境，虽然不配置也能正常编译，但是会在Qt相关的语句下面出现红色波浪线，本人轻微强迫症表示不能忍╭(╯^╰)╮。具体配置如下： 选中“VC++目录”，在“包含目录”中添加： C:\Qt\Qt5.6.2\5.6\msvc2013\include 在“库目录”中添加： C:\Qt\Qt5.6.2\5.6\msvc2013\lib 配置完成之后即可发现红色波浪线已消失。 使用篇 VS中如何开发Qt程序请详见参考资料，懒癌发作，不想写了=_=（其实是因为要写的话只能贴图了，本人表示不想使用图片(╯﹏╰) ）。 问题篇问题描述：本人在用Qt显示OpenCV的Mat数据图像时，有时会发生扭曲现象（图像从对角线分开，两边颠倒，扭曲），有时却不会，为了撤了解决问题，查阅了相关资料，终于发现症结所在，原来是图片数据格式不符合Qt的图片数据格式。 解决办法：正文来喽~(≧▽≦)/~，就不说废话了，“Talk is cheap. Show you the code”，具体完整正确显示代码为： 123456789101112131415161718192021222324void showMatWithQtQlabel(const cv::Mat &amp;img, QLabel *label)&#123; // [Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决](http://lovelittlebean.blog.163.com/blog/static/11658218620125208212189/) QImage q_img; if(img.channels() == 3) // RGB image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB888).rgbSwapped(); &#125;else if (img.channels() == 4) // RGBA image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB32); &#125;else // gray image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_Indexed8); &#125; // -------------- 图片自适应label ------------------- QImage q_label_img = q_img.scaled(label-&gt;size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 图片自适应label大小 label-&gt;setPixmap(QPixmap::fromImage(q_label_img)); // 将图片显示到label上 // -------------- label自适应图片 ------------------- /*label-&gt;setPixmap(QPixmap::fromImage(q_img)); // 显示在label中 label-&gt;resize(label-&gt;pixmap()-&gt;size()); // 改变label的尺寸以自适应图像 label-&gt;show(); */&#125; rgbSwapped()函数是为了使Qt中显示图形颜色更自然，因为OpenCV的Mat数据RGB图像是以BGR的顺序排列，而Qt中是以RGB的顺序排列，所以需要rgbSwapped()交换一下颜色通道排列顺序。 附录1、摄像头数据采集问题注意：如果是从摄像头实时采集显示图像，在显示时需先判断图像有没有数据 1234567if (image.data)&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125; 或 1234567if (!image.empty())&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125; 具体原因可参考本人的一篇文章解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题。 2、信号与槽的连接函数问题Qt4中信号与槽的连接函数语法为： 1connect(&amp;theTimer,SIGNAL(timeout()),this,SLOT(getFrame())); // 超时就去取下一帧 而Qt5中信号与槽的连接函数新语法为： 1connect(&amp;theTimer, &amp;QTimer::timeout, this, &amp;QtTest::getFrame); //超时就去取下一帧 推荐使用Qt5新语法，具体原因可参考qt5中信号和槽的新语法 。 个人粗浅理解：信号函数一般是Qt中控件的库函数，比如按钮控件QButton的QButton::clicked ()函数，定时器QTimer的QTimer::timeout ()等函数；而槽函数是响应函数，一般由用户自己编写，也可以使用Qt中库函数。 使用Qt中可能会遇到的一些错误请参考使用VS2010开发Qt程序的一点经验（http://www.cnblogs.com/csuftzzk/category/445772.html ）。 后记 本来其实就想把问题篇写出来的，毕竟主要就是想记录一下那个显示函数，但是感觉有点没头没尾，就把VS集成Qt开发环境也稍微写了一下，而使用篇确实是因为参考资料已经写的很详细了，所以就直接一笔带过了。 参考资料[1] QT +openCV 实现摄像头采集以及拍照功能（http://blog.csdn.net/llh318724/article/category/930663 ） [2] VS2010 + QT5.2+ QT-VS-Addin1.2.2开发环境配置（http://blog.csdn.net/qqmindyourwill/article/category/5990841 ） [3] Qt+OpenCV界面（http://blog.csdn.net/fm0517/article/category/1110960 ） [4] Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决（http://blog.csdn.net/loveaborn/article/category/1164072 ）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题]]></title>
    <url>%2F2017%2F09%2F16%2F%E8%A7%A3%E5%86%B3OpenCV-2.4.11%E8%B0%83%E7%94%A8%E6%91%84%E5%83%8F%E5%A4%B4%E6%98%BE%E7%A4%BA%E6%8B%8D%E6%91%84%E8%A7%86%E9%A2%91%E5%87%BA%E9%94%99%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[本文所用的OpenCV版本为opencv-2.4.11，编程语言为C++。 前言 本文其实是以前在刚学OpenCV时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。 问题篇问题描述：使用OpenCV-2.4.11调用摄像头显示拍摄视频时报runtime error，控制台窗口出现OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file ……..\opencv\modules\highgui\src\window.cpp, line 261。 解决办法：在显示图片时先判断是否有图像数据，如下： 1234if (!image.empty()) &#123; imshow("window", image);&#125; 或 1234if (image.data) &#123; imshow("window", image);&#125; 原因可能是：用imshow()显示图像时，其image必须有数据，如果它为空则程序会报错，而一般打开摄像头会有一定时间的延迟，这时程序已经启动，而摄像头由于启动延迟，不一定能及时获取图像，造成要显示的image为空，因此报错。个人粗浅理解，板砖轻拍⊙﹏⊙b。 而网上有人也认为： 我也是遇到这个问题，不过看到一个帖子写得不错（英文的），里面给出了一个可能的理由，就是我们用opencv打开视频的时候，会自动先监测摄像头有没有读到帧，如果没有，就会报错，然后再执行你的程序，加一个if判断就是跳过系统自己的判断，直接执行我们的程序。来自：https://zhidao.baidu.com/question/1831122325089024420.html 有人说的原因是在VideoCapture刚开始获取摄像头视频流的过程不返回信号，所以判断Mat是否为空，并不断循环去获取Mat。来自：http://www.cnblogs.com/tiny656/p/3538115.html 附最终完整示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;// 调用摄像头void videoCaptureTest()&#123; //cv::VideoCapture cap(0); // 打开默认摄像头，参数0代表默认摄像头的ID cv::VideoCapture cap; cap.open(0); // 设置摄像头 cap.set(CV_CAP_PROP_FRAME_WIDTH,640); cap.set(CV_CAP_PROP_FRAME_HEIGHT,480); // 确认是否成功打开摄像头 if (!cap.isOpened()) &#123; printf("打开摄像头失败，退出！\n"); exit(-1); &#125; cv::namedWindow("Capture", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO); while (1) &#123; cv::Mat frame; cap &gt;&gt; frame; // 获取帧 // 对摄像头获取的帧进行各种处理 if (!frame.empty()) // 最好加上该判断，并在该判断中对帧进行处理 &#123; cv::imshow("Capture", frame); &#125; if(cv::waitKey(30) &gt;= 0) break; // 每30ms取一帧 &#125;&#125;int main(int argc, char *argv[])&#123; videoCaptureTest(); return 0;&#125; 其实也可以通过在获取帧时，反复获取帧，直到取到的帧有数据为止，这样就不需要判断语句了，直接显示即可，具体代码如下： 123456do&#123; cap &gt;&gt; frame;&#125;while(frame.empty());cv::imshow("Capture", frame); 参考自：https://stackoverflow.com/a/9285151 。 后记 本文还是当初在国内某平台写博客时写的，但现在再回头看，又稍微有了点新的思路，温故确实能知新(*&#94;__&#94;*) 嘻嘻……。 参考资料[1] OpenCV2.3使用摄像头和视频（http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html ） [2] OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, fi 这个问题怎么办？ [3] OpenCV打开摄像头出现运行错误OpenCV Error：Assertion failed (size.width&gt;0&amp;&amp;size.height&gt;0)in cv::imshow，…… （http://blog.csdn.net/czl389/article/category/6381887 ） [4] [OpenCV]获取摄像头视频（http://www.cnblogs.com/tiny656/category/550972.html ）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加各种小部件]]></title>
    <url>%2F2017%2F09%2F15%2FHexo%E6%B7%BB%E5%8A%A0%E5%90%84%E7%A7%8D%E5%B0%8F%E9%83%A8%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 本人目前还在使用对Hexo的主题SPFK自行魔改的那个主题（所谓的魔改也就是对照着black-blue主题修改了部分CSS，然后又添加了一个站内搜索功能(&gt;&#94;ω&#94;&lt;)），主题SPFK主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。 添加QQ邮箱联系 进入QQ邮箱开放平台，点击“获取邮我按钮”，登录QQ之后继续点击该按钮，因为本人不需要其样式，只需要其链接即可，所以就默认样式，直接点击“获取代码”即可，本人默认的“HTML代码”为： 1&lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" style="text-decoration:none;"&gt;&lt;img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_01.png"/&gt;&lt;/a&gt; 提取其中的href，即http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ，将该链接添加到主题配置文件中，具体如下： 12subnav: mail: "http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" 重新部署站点即可发现对应的邮箱图标，点击该图标可直接给本人发邮件。 添加QQ交谈链接 进入QQ推广，点击上方的“推广工具”，若没登录QQ则先登录QQ，组件样式同样默认即可，这里需要注意的是，需要点击左边的“设置”，下滚页面，找到“安全级别设置”，如下 安全级别设置 完全公开（推荐商家，客服等用户使用，代码中显示QQ号码，易于推广） 安全加密（推荐博主，论坛用户等使用，代码中不显示QQ号码） 选中“安全加密”，不然该选项默认的为完全公开，这样QQ号码就直接会显示在代码中，不利于隐私保护，选中之后，点击“保存”。保存之后，再次点击“推广工具”，即可发现下方的复制代码区域的HTML代码已看不到明码显示的QQ号，（若还是能看到QQ号，没有任何变化，可关闭该界面，重启浏览器重新进入该界面），本人的“复制这段代码并将其粘贴到您的网页上”下方区域的默认的代码为： 1&lt;a target="_blank" href="http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422"&gt;&lt;img border="0" src="http://wpa.qq.com/imgd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422&amp;pic=52" alt="点击这里给我发消息" title="点击这里给我发消息"/&gt;&lt;/a&gt; 提取其中的href，即http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422，将该链接添加到主题配置文件中，具体如下： 12subnav: QQ: "http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12" 重新部署站点即可发现对应的QQ图标，点击该图标可直接给本人发临时QQ消息。 待续。。。 后记 目前就添加这些小组件，以后应该会陆续添加一些其它的小东西↖(&#94;ω&#94;)↗。 参考资料[1] 如何在自己网站上或者博客上放置QQ邮箱联系反馈（http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1 ） [2] 如何在自己的博客添加QQ组件（http://www.29mo.com/category/wltg ） [3] 一步一步教你给自己博客添加QQ在线（http://www.feizl.com/feizhuliu/QQbaodian/ ）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中显著性检测算法的使用]]></title>
    <url>%2F2017%2F09%2F12%2FOpenCV%E4%B8%AD%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文所用的OpenCV版本为opencv-3.2.0，编程语言为C++。 前言 OpenCV中实现了两种显著性检测算法，分别为Spectral Residual算法,出自Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on, pages 1–8. IEEE, 2007. 和 Fine Grained Saliency算法,出自Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In Image and Vision Computing, Vol. 28 Issue 3, pages 391–402. Elsevier, 2010.。这两种算法同样是在扩展包opencv_contrib-3.2.0中，也是由于opencv官方示例程序对初学者不友好（主要是本人境界不够o(╯□╰)o），所以本人对照其官方文档重新整理了一下。 代码篇 使用OpenCV中的显著性检测算法需要包含头文件#include &lt;opencv2/saliency.hpp&gt;，具体示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/saliency.hpp&gt;//******************************************************// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)////Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)//&#123;// if (saliencyType == "SPECTRAL_RESIDUAL")// return makePtr&lt;StaticSaliencySpectralResidual&gt;(); //computeSaliency返回的是32FC1// else if (saliencyType == "FINE_GRAINED")// return makePtr&lt;StaticSaliencyFineGrained&gt;(); //computeSaliency返回的是8UC1// else if (saliencyType == "BING")// return makePtr&lt;ObjectnessBING&gt;();// else if (saliencyType == "BinWangApr2014")// return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();// return Ptr&lt;Saliency&gt;();//&#125;//// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）//*****************************************************void spectralResidualTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入最真实的原始图像 cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); // [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687) if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Mat planes[] = &#123; cv::Mat_&lt;float&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;; cv::Mat complex_img; //复数矩阵 merge(planes, 2, complex_img); //把单通道矩阵组合成复数形式的双通道矩阵 dft(complex_img, complex_img); // 使用离散傅立叶变换 //对复数矩阵进行处理，方法为谱残差 cv::Mat magnitude, phase_angle, mag_mean; cv::Mat real_part, imaginary_part; split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; //实部 imaginary_part = planes[1]; //虚部 cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值 phase(real_part, imaginary_part, phase_angle); //计算相角 float *pre, *pim, *pm, *pp; //对幅值进行对数化 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = log(*pm); pm++; &#125; &#125; blur(magnitude, mag_mean, cv::Size(5, 5)); //对数谱的均值滤波 magnitude = magnitude - mag_mean; //求取对数频谱残差 //把对数谱残差的幅值和相角划归到复数形式 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pre = real_part.ptr&lt;float&gt;(i); pim = imaginary_part.ptr&lt;float&gt;(i); pm = magnitude.ptr&lt;float&gt;(i); pp = phase_angle.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = exp(*pm); *pre = *pm * cos(*pp); *pim = *pm * sin(*pp); pre++; pim++; pm++; pp++; &#125; &#125; cv::Mat planes1[] = &#123; cv::Mat_&lt;float&gt;(real_part), cv::Mat_&lt;float&gt;(imaginary_part) &#125;; merge(planes1, 2, complex_img); //重新整合实部和虚部组成双通道形式的复数矩阵 idft(complex_img, complex_img, cv::DFT_SCALE); // 傅立叶反变换 split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; imaginary_part = planes[1]; cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值和相角 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = (*pm) * (*pm); pm++; &#125; &#125; GaussianBlur(magnitude, magnitude, cv::Size(7, 7), 2.5, 2.5); cv::Mat invDFT, invDFTcvt; normalize(magnitude, invDFT, 0, 255, cv::NORM_MINMAX); //归一化到[0,255]供显示 invDFT.convertTo(invDFTcvt, CV_8U); //转化成CV_8U型 cv::namedWindow("SpectualResidual", CV_WND_PROP_ASPECTRATIO); cv::imshow("SpectualResidual", invDFTcvt); cv::Mat thresholded; cv::threshold(invDFTcvt, thresholded, 0, 255, CV_THRESH_OTSU); cv::namedWindow("Thresholded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded Image", thresholded); cv::Mat eroded; // 纵向腐蚀 cv::erode(thresholded, eroded, cv::Mat(5, 1, CV_8UC1, cv::Scalar(1)), cv::Point(-1, -1), 3); // cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心 cv::namedWindow("eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("eroded Image", eroded); //cv::Mat thresholded; cv::threshold(eroded, thresholded, 60, 255, CV_THRESH_BINARY); cv::namedWindow("Thresholded eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded eroded Image", thresholded);&#125;void saliencyTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create("SPECTRAL_RESIDUAL"); // FINE_GRAINED为Fine Grained Saliency算法 cv::Mat saliency_map; if (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map)) &#123; cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", saliency_map); cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1); normalize(saliency_map, saliency_map_show, 0, 255, CV_MINMAX); //归一化到[0,255]供显示 saliency_map_show.convertTo(saliency_map_show, CV_8U); //转化成CV_8U型 cv::namedWindow("saliency_map_show", CV_WND_PROP_ASPECTRATIO); cv::imshow("saliency_map_show", saliency_map_show); cv::Mat binary_map; cv::saliency::StaticSaliencySpectralResidual spec; if (spec.computeBinaryMap(saliency_map, binary_map)) &#123; cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); &#125; &#125;&#125;// Fine Grained Saliency算法void FGSTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create(); cv::Mat fgs_saliency_map; fgs-&gt;computeSaliency(src_img, fgs_saliency_map); cv::namedWindow("FGS saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("FGS saliency map", fgs_saliency_map); //cv::imwrite("../data/T_S.png", fgs_saliency_map); cv::Mat binary_map; cv::threshold(fgs_saliency_map, binary_map, 0, 255, CV_THRESH_OTSU); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); //cv::imwrite("../data/T_S_B.png", binary_map);&#125;// Spectral Residual算法void SRTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create(); cv::Mat sr_saliency_map; sr-&gt;computeSaliency(src_img, sr_saliency_map); cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", sr_saliency_map); cv::Mat binary_map; sr-&gt;computeBinaryMap(sr_saliency_map, binary_map); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map);&#125;int main(int argc, char *argv[])&#123; //spectralResidualTest(); //saliencyTest(); //FGSTest(); SRTest(); while (cv::waitKey(0) != 27) &#123; &#125; return 0;&#125; 这里面有个小东西需要注意，就是computeBinaryMap()函数，看其文档描述其中使用K-means算法和Otsu算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV中Spectral Residual算法computeSaliency()返回的结果为浮点数，而Fine Grained Saliency算法computeSaliency()返回的结果却是整型数据，所以这一点需要注意Fine Grained Saliency算法返回的结果不能直接使用computeBinaryMap()函数，一般对其结果直接使用OTSU算法进行阈值分割即可。 后记 本文使用的这两种算法在本人的电脑上运行时间都较长，基本不可能用来处理视频流，而且在本人的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过OpenCV中也有用来处理视频流的显著性检测算法，其为BING算法,出自Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In IEEE CVPR, 2014.，实际上这是一种快速提取目标候选框的算法。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中Selective Search算法的使用]]></title>
    <url>%2F2017%2F09%2F10%2FOpenCV%E4%B8%ADSelective-Search%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文所用的OpenCV版本为opencv-3.2.0，编程语言为C++。 前言 OpenCV-3.2中的Selective Search算法是在其扩展包中，所以要想使用该算法需自行编译opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（本人编程水平有限，粗浅评价，勿怪(*&#94;__&#94; *) 嘻嘻……），所以本人参考其官方文档及其官方示例程序写下此文。 Selective Search算法 该算法是选取region proposal（一般翻译成候选区域 / 区域建议）领域中的state-of-the-art。其算法具体思想出自Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154–171, 2013.，若英文水平不够，还想了解其中文思想请参考文末参考资料。 代码篇 使用Selective Search算法需包含#include &lt;opencv2/ximgproc.hpp&gt;，完整示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/ximgproc.hpp&gt;void SSTest()&#123; // [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入原始图像 cv::namedWindow("src_img", CV_WINDOW_KEEPRATIO); cv::imshow("src_img", src_img); //// 转换为灰度图 //cv::Mat gray_img; //cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY); // 图割算法 cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation(); cv::Mat graph_segmented; gs-&gt;processImage(src_img, graph_segmented); normalize(graph_segmented, graph_segmented, 0, 255, CV_MINMAX); // 归一化到[0,255]供显示 graph_segmented.convertTo(graph_segmented, CV_8U); // 数据类型转化成CV_8U型 // cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR); cv::namedWindow("graph_segmented", CV_WINDOW_KEEPRATIO); imshow("graph_segmented", graph_segmented); // 为selective search算法添加图割算法处理结果 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;addGraphSegmentation(gs); ss-&gt;addImage(src_img); // 添加待处理的图片 // 自定义策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(); // 颜色相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(); // 纹理相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(); // 尺寸相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(); // 填充相似度策略 // 添加策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill); // 合并以上4种策略 ss-&gt;addStrategy(sss); std::vector&lt;cv::Rect&gt; regions; ss-&gt;process(regions); // 处理结果 // 显示结果 cv::Mat show_img = src_img.clone(); for (std::vector&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r) &#123; cv::rectangle(show_img, *it_r, cv::Scalar(0, 0, 255), 3); &#125; cv::namedWindow("show_img", CV_WINDOW_KEEPRATIO); imshow("show_img", show_img); // -------忽略上述步骤，直接采用方便算法提取候选区域------------------------ /*************************************************************************** cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;setBaseImage(src_img); // 采用switch* functions提取候选区域 ss-&gt;switchToSelectiveSearchFast(); // 快速提取区域 std::vector&lt;cv::Rect&gt; rects; ss-&gt;process(rects); int nb_rects = 10; char c = (char)cv::waitKey(); while (c != 'q') &#123; cv::Mat wimg = src_img.clone(); int i = 0; for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it) &#123; if (i++ &lt; nb_rects) &#123; cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3); &#125; &#125; cv::namedWindow("Output", CV_WINDOW_KEEPRATIO); imshow("Output", wimg); c = (char)cv::waitKey(); if (c == 'd') &#123; nb_rects += 10; &#125; if (c == 'a' &amp;&amp; nb_rects &gt; 10) &#123; nb_rects -= 10; &#125; &#125; ********************************************************/&#125;int main(int argc, char *argv[])&#123; SSTest(); while (cv::waitKey(0) != 27) &#123;&#125; return 0;&#125; 后记 使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法switchToSelectiveSearchFast()的参数。本人的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在本人电脑上略显长。GitHub上也有大神自己用opencv实现了该算法，参考watanika/selective-search-cpp，该算法的参数感觉比OpenCV自带的Selective Search算法要好调一些，但优化效果没有opencv好，其运行时间在本人电脑上更长。 参考资料[1] 论文笔记：Selective Search for Object Recognition（http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/） [2] Selective Search for Object Recognition(阅读)（http://blog.csdn.net/langb2014/article/category/5772811） [3] 论文笔记 《Selective Search for Object Recognition》（http://blog.csdn.net/csyhhb/article/category/6048588）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10以树形结构显示文件目录结构]]></title>
    <url>%2F2017%2F09%2F05%2FWin10%E4%BB%A5%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 本文其实可以算是标题党，Windows本身并不能以树形结构显示文件目录结构，一般需要借助第三方工具（后面去网上搜索了一下，发现Windows居然也有一个tree命令o(╯□╰)o），Windows虽然能用命令行显示树形结构文件目录，但不像Linux那样可以输入一些参数控制其输出。Win10有个特殊的功能，就是可以使用Ubuntu的bash，只需要开启这个有趣的功能，就可以将Win10当Ubuntu使用，从而像Linux那样只输入相关命令即可显示树形结构文件目录。 *注：值得注意的是Win10中的bash目前不支持中文输入，只能切换到英文输入才能正常输入。 准备篇首先需要在Win10下开启bash功能。具体开启方法为： 打开 Win图标 ==》 设置 ==》 更新和安全 ==》 针对开发人员（左侧），选中开发人员模式， 打开 Win图标 ==》 设置 ==》 应用 ==》 应用和功能（左侧） ==》 程序和功能（最下面的相关设置中） ==》 启用或关闭Windows功能（左侧），选中适用于Linux的Windows子系统(Beta)后点击确定。 重启计算机。打开bash，打开bash的方法很多，这里列出三种：1、直接在微软小娜中输入关键字”bash“搜索Bash on Ubuntu on Windows；2、Win键+R，输入bash，点击确定即可打开bash；3、Win键+R，输入cmd，在cmd中输入bash，回车即可打开bash。打开bash后将会提示你是否下载安装Ubuntu on Windows，输入y继续，稍等片刻即可完成下载安装。 设置篇 安装完成后系统将会提示你设置用户名和密码。（如果这一步设置成功可以直接跳过设置篇直接看使用篇）。不知道怎的，本人这一步没有完成，每次系统都是直接以root用户登录，而且没有密码，为了安全考虑，也幸好登录时是root用户，可以自由对系统修改。所以本人需要对root密码进行修改，并创建新的用户。具体过程需执行以下命令： root用户下，修改用户密码： 1passwd 用户名 (修改密码) 由于本人需要修改root密码，所以该用户名即为root，执行之后需要输入新密码（在*nix哲学中，密码是不会显示在输入屏幕中的，所以如果在输入密码时发现屏幕没有任何变化是没关系的，只管输入即可↖(&#94;ω&#94;)↗），两次输入完成后会显示密码更新成功。 接下来需要创建新的普通用户，在root用户下执行： 1adduser xxx # 这样的命令会在home目录下添加一个帐号 或者 1useradd xxx #仅仅是添加用户，不会在home目录添加帐号 推荐使用前者，这样可以很明确已经成功创建新用户，而且如果用户需要存放一些文件也更安全和方便。 在*nix中，绝对不推荐直接使用root用户对系统执行各种命令，毕竟其权限太大，一旦误操作将造成无法挽回的后果。有些命令普通用户可能没有权限执行，这时需要提高其权限，普通用户临时获取root权限的方法为：在需要执行的命令前添加sudo，像上文中如果普通用户需要创建新用户xxx则需要执行sudo adduser xxx，执行以上命令后同样需要输入新用户的密码。 使用篇 先切换至普通用户，执行su xxx切换用户，即可发现shell提示符由#变为$，前面的用户名由root变为xxx；执行cd ~切换至用户目录。由于Ubuntu系统中本身没有tree这个命令，需要执行以下命令安装tree命令工具： 1sudo apt install tree 直接输入tree命令，系统将会自动以树形结构列出当前目录中所有文件及文件夹；执行tree -L N 命令，以树形结构查看当前N级的目录和文件，eg：以树形结构查看当前目录二级文件结构，则执行tree -L 2。若想将输出的2级文件结构保存至上一层文件的tree.txt文件中，可执行tree -L 2 &gt; ../tree.txt，进入上一层目录cd ..，打开tree.txt即可发现该目录的文件结构。 后记 遇事还是需要多查证一下啊，想当然果然是会出问题的，文章开头差点就犯错误了~(≧▽≦)/~。本文其实是在写Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0时，为了方便显示输出文件结构而查找的相关资料。 参考资料[1]linux tree命令以树形结构显示文件目录结构（http://jingyan.baidu.com/tag?tagName=linux ） [2] win tree命令 tree导出目录 tree显示树形结构（http://jingyan.baidu.com/tag?tagName=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F ） [3] win10下linux系统的安装（开启）和使用 [4] Ubuntu建立和删除用户 [5] linux修改root密码和linux忘记root密码后找回密码的方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加站内本地搜索]]></title>
    <url>%2F2017%2F09%2F01%2FHexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前言 虽然本人博客目前数量不多，质量也不高，但抱着搞事的心态，先弄它一个站内本地搜索再说。 准备篇 要想使用本地搜索功能，首先需要安装相应的搜索插件hexo-generator-searchdb，网上可能大多数用的是hexo-generator-search这个插件，也有都装的，但本人就只安装这一个了，好像hexo-generator-searchdb更完善一点，由于本人前端接触的极少，所以就没有一一对比了，网上也没查到具体对比情况，有兴趣的童靴可以试试(╯▽╰)。至于具体安装如下，在站点根目录执行： 1npm install hexo-generator-searchdb --save 安装完之后重新生成页面，将会发现public文件夹下多出一个search.xml文件。然后在配置文件_config.yml中添加： 1234# 站点本地搜索search: path: search.xml field: all 其中： path - 指定生成的索引数据的文件名。默认为 search.xml 。 field - 指定索引数据的生成范围。可选值包括： post - 只生成博客文章（post）的索引（默认）； page - 只生成其他页面（page）的索引； all - 生成所有文章和页面的索引。 至于是在主题配置文件，还是在站点配置文件中添加，个人觉得都没关系，附：本人是在主题配置文件中添加的。 接下来就需要修改原主题的代码了。 改码篇 由于本人博客主题是基于SPFK对照着black-blue进行修改的，而且因为black-blue是有搜索的（本人不知道black-blue主题的作者是如何完成的，借助了什么技术），所以本人就看black-blue的搜索功能是修改了SPFK哪个地方，再将相应的代码添加至SPFK中（其中相应的代码来自让 Hexo 博客支持本地站内搜索），从而逐渐完成本次搜索功能。 首先找到spfk主题下的left-col.ejs文件，对其修改如下： 123456789101112&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot;&gt; &lt;/form&gt; --&gt; &lt;form id=&quot;search-form&quot;&gt; &lt;!-- 搜索框相关 --&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;Search...&quot; class=&quot;search form-control&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot;/&gt; &lt;i class=&quot;fa fa-times&quot; onclick=&quot;resetSearch()&quot;&gt;&lt;/i&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;/form&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;p class=&apos;no-result&apos;&gt;No results found &lt;/p&gt; &lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt; &lt;%&#125;%&gt; 其次找到spfk主题下的after-footer.ejs文件，将其修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125; &lt;/script&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 激活搜索框时才搜索 var inputArea = document.querySelector(&quot;#local-search-input&quot;); var getSearchFile = function()&#123; // 调用搜索函数 var search_path = &quot;&lt;%- config.search.path %&gt;&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;&lt;%- config.root %&gt;&quot; + search_path; searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;); &#125; inputArea.onfocus = function()&#123; getSearchFile() &#125; // 搜索重置 var $resetButton = $(&quot;#search-form .fa-times&quot;); var $resultArea = $(&quot;#local-search-result&quot;); inputArea.oninput = function()&#123; $resetButton.show(); &#125; resetSearch = function()&#123; $resultArea.html(&quot;&quot;); document.querySelector(&quot;#search-form&quot;).reset(); $resetButton.hide(); $(&quot;.no-result&quot;).hide(); &#125; // 屏蔽回车 inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125; // 无搜索结果 $resultArea.bind(&quot;DOMNodeRemoved DOMNodeInserted&quot;, function(e) &#123; if (!$(e.target).text()) &#123; $(&quot;.no-result&quot;).show(200); &#125; else &#123; $(&quot;.no-result&quot;).hide(); &#125; &#125;) // 搜索函数 var searchFunc = function(path, search_id, content_id) &#123; &apos;use strict&apos;; $.ajax(&#123; url: path, dataType: &quot;xml&quot;, success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( &quot;entry&quot;, xmlResponse ).map(function() &#123; return &#123; title: $( &quot;title&quot;, this ).text(), content: $(&quot;content&quot;,this).text(), url: $( &quot;url&quot; , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function()&#123; var str=&apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;/&quot;+ data_url +&quot;&apos; class=&apos;search-result-title&apos; target=&apos;_blank&apos;&gt;&quot;+ &quot;&gt; &quot; + data_title +&quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace(regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot;+keyword+&quot;&lt;/em&gt;&quot;); &#125;) str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content +&quot;...&lt;/p&gt;&quot; &#125; &#125; &#125;) $resultContent.innerHTML = str; &#125;) &#125; &#125;) &#125; &lt;/script&gt;&lt;%&#125;%&gt; 最后找到spfk主题下的main.styl文件，在其末尾添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*搜索框*/.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid #d3d3d3; border-radius: 2px; opacity: 0.65; background: none;&#125;.search:hover &#123; border: 2px solid #d3d3d3; opacity: 1; box-shadow: 0 0 10px rgba(0,0,0,0.3);&#125;/*搜索重置按钮*/#search-form .fa-times &#123; display: none; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0,0,0,0.15); cursor: pointer; color: #4094c7;&#125;#search-form .fa-times:active &#123; background: #d3d3d3;&#125;#search-form .fa-times:hover &#123; zoom: 1.1; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0,0,0,0.25);&#125;/*搜索结果区*/#local-search-result &#123; //margin: auto -12% auto -6%; margin: 0; font-size: 0.9em; text-align: left; word-break: break-all; box-shadow: 4px 4px 6px rgba(0,0,0,0.46);&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*单条搜索结果*/#local-search-result li &#123; margin: 0.5em auto; border-bottom: 2px solid #d3d3d3;&#125;#local-search-result .search-result-list li:hover &#123; background: rgba(47,46,46,0.8); box-shadow: 0 0 5px rgba(0,0,0,0.2);&#125;/*匹配的标题*/#local-search-result a.search-result-title &#123; line-height: 1.2; font-weight: bold; color: #4094c7;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; line-height: 1.2em; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #ffffffb3;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 1em;&#125;/*无匹配搜索结果时显示*/p.no-result &#123; display: none; margin: 2em 0 2em 6%; padding-bottom: 0.5em; text-align: left; color: #808080; font-family: font-serif serif; border-bottom: 2px solid #d3d3d3;&#125; 这里请注意，当对main.styl文件做以上修改时，可能会发现有两个.search样式，而且相差不大，这时，不要对其原有的.search进行修改，更不要去注释掉它，只做上述修改就不用管了，不然可能会发生一些奇怪的事o(&gt;﹏&lt;)o。本人当时做以上修改时，将其原有的.search样式注释掉之后，整个页面的css布局全部都乱了(╯﹏╰)，不知道为什么(⊙_⊙?)，这两个同名样式看起来明明差不多的，最后只能维持现状了，等以后有机会再看看吧，业余前端伤不起啊!╮(╯_╰)╭。 至此整个站内本地搜索功能基本完成，勉强可以使用站内搜索功能了。 问题篇 *注：以下问题目前都没解决╮(╯▽╰)╭。 1、搜索函数返回的url地址有问题。 问题描述：当点击搜索结果时，新弹出的标签页地址栏中url地址会有部分乱码情况；当鼠标移到搜索的结果列表上时，浏览器左下角显示的url地址虽然没有乱码情况，但其中有一个重复的/符号。所幸这两个问题并没有造成浏览器解析错误，浏览器还是可以正常显示页面的。 2、搜索结果区布局有问题。 问题描述：当显示搜索结果时，搜索结果区会上下扩张，从而将其上下本来存在的一些布局挤开，造成布局混乱。这其实不算是一个spfk主题或者新添加的搜索功能的问题，而是新添加的一个东西又没有相应的和原本布局结合的布局文件，那就极大可能会有布局混乱的问题，至于这个要和原本布局契合的搜索结果区布局文件就只有等本人以后有机会有时间再完善去喽╮(╯▽╰)╭。 3、搜索框激活问题。 问题描述：搜索框激活延迟很大，有时过很久或者需要切换站内页面它才能激活，给人的感觉就是好像没有搜索功能似的。添加搜索框激活功能据作者MOxFIVE所说是为了不让索引文件影响页面加载速度，MOxFIVE同时也在文末指出了一些不足之处，如果索引文件太大，可能还是会造成一些问题，但本人的博客数量又不多，所以估计还是本人的代码混合问题，而且MOxFIVE的博客搜索功能好像没这个问题（至少本人目前没发现）。这个问题同样只有等以后再说了(*&#94;__&#94;*) 嘻嘻……。 后记 本文添加的本地搜索还很粗糙，还有很多地方需要以后去完善。但这好歹是一个好的开始，搜索功能至少勉强能够正常使用，总比以前是个空壳要好，以后有机会再慢慢去去完善吧↖(&#94;ω&#94;)↗。 参考资料[1] jQuery-based Local Search Engine for Hexo（http://www.hahack.com/categories/codes/ ） [2] 让 Hexo 博客支持本地站内搜索（http://moxfive.xyz/tags/Hexo/ ） [3] Hexo博客添加站内搜索（https://www.ezlippi.com/categories/hexo/ ） [4] Hexo本地搜索及部分SEO优化 （https://www.oyohyee.com/categories/Note/ ）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用OpenCV显示OpenGL图形]]></title>
    <url>%2F2017%2F08%2F31%2F%E7%94%A8OpenCV%E6%98%BE%E7%A4%BAOpenGL%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[前言 本文就是一个小实验，试验OpenCV到底能不能支持OpenGL图形显示。 正文 如果在OpenCV用CMake编译时勾选WITH_OPENGL且编译一切顺利的话，编译和配置的具体步骤和情况可以看本人写的一篇文档：Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 ，那么就可以用OpenCV窗口显示OpenGL图形。 在VS下使用Windows原有的OpenGL函数需要包含以下头文件和库文件： 123456#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib") 在OpenCV中显示OpenGL图形需要cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL)，在namedWindow函数中添加cv::WINDOW_OPENGL参数说明该窗口支持OpenGL图形。 附示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;opencv.hpp&gt;#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib")static const float vertex_list[][3] =&#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;;// 将要使用的顶点的序号保存到一个数组里面 static const GLint index_list[][2] =&#123; &#123; 0, 1 &#125;, &#123; 2, 3 &#125;, &#123; 4, 5 &#125;, &#123; 6, 7 &#125;, &#123; 0, 2 &#125;, &#123; 1, 3 &#125;, &#123; 4, 6 &#125;, &#123; 5, 7 &#125;, &#123; 0, 4 &#125;, &#123; 1, 5 &#125;, &#123; 7, 3 &#125;, &#123; 2, 6 &#125;&#125;;static float rotate = 0;static int times = 0;GLint windowWidth = 800;GLint windowHeight = 800;GLfloat xRotAngle = -75.0f;GLfloat yRotAngle = 0.0f;GLfloat zRotAngle = -135.0f;float MIN_X = -200;float MAX_X = 200;float MIN_Y = -200;float MAX_Y = 200;float MIN_Z = -200;float MAX_Z = 200;GLfloat coordinatesize = 200.0f;GLfloat ratio = 1;void drawLine(float x1, float y1, float z1, float x2, float y2, float z2)&#123; glBegin(GL_LINES); glVertex3f(x1, y1, z1); glVertex3f(x2, y2, z2); glEnd(); glFlush();&#125;// 绘制立方体void DrawCube(void)&#123; int i, j; glBegin(GL_LINES); for (i = 0; i &lt; 12; ++i) // 12 条线段 &#123; for (j = 0; j &lt; 2; ++j) // 每条线段 2个顶点 &#123; glVertex3fv(vertex_list[index_list[i][j]]); &#125; &#125; glEnd(); glFlush();&#125;void reshapeOperate()&#123; glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (ratio &lt; 1) glOrtho(-coordinatesize, coordinatesize, -coordinatesize / ratio, coordinatesize / ratio, -coordinatesize, coordinatesize); else glOrtho(-coordinatesize*ratio, coordinatesize*ratio, -coordinatesize, coordinatesize, -coordinatesize, coordinatesize); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void reshape(int w, int h) &#123; if ((w == 0) || (h == 0)) return; glViewport(0, 0, w, h); ratio = (GLfloat)w / (GLfloat)h; reshapeOperate();&#125;GLfloat AngleX = 45.0f;GLfloat AngleY = 315.0f;void reshape1(int w, int h)&#123; GLfloat aspect = (GLfloat)w / (GLfloat)h; GLfloat nRange = 100.0f; glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式 glLoadIdentity(); //设置三维投影区 if (w &lt;= h) &#123; glOrtho(-nRange, nRange, -nRange * aspect, nRange * aspect, -nRange, nRange); &#125; else &#123; glOrtho(-nRange, nRange, -nRange / aspect, nRange / aspect, -nRange, nRange); &#125;&#125;void onDraw(void*)&#123; // Draw something using OpenGL here //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清除所有的像素 //glMatrixMode(GL_MODELVIEW); //glLoadIdentity(); //glPushMatrix(); ////glTranslatef(-0.2, 0, 0); // 平移 ////glScalef(2, 1, 1); // 缩放 //glRotatef(xRotAngle, 1.0f, 0.0f, 0.0f); //glRotatef(yRotAngle, 0.0f, 1.0f, 0.0f); //glRotatef(zRotAngle, 0.0f, 0.0f, 1.0f); //glColor3f(1, 0, 0); //drawLine(0, 0, 0, MAX_X, 0, 0); //x轴 //glColor3f(0, 1, 0); //drawLine(0, 0, 0, 0, MAX_Y, 0); //y轴 //glColor3f(0, 0, 1); //drawLine(0, 0, 0, 0, 0, MAX_Z); //z轴 //times++; //if (times &gt; 1) //&#123; // times = 0; //&#125; //if (times % 1 == 0) //&#123; // rotate += 0.3; //&#125; //glRotatef(rotate, 0, 1, 0); //glRotatef(rotate, 1, 0, 0); //glColor3f(0, 1, 1); //DrawCube(); //glPopMatrix(); reshape1(windowWidth, windowHeight); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); AngleX++; AngleY++; glPushMatrix(); &#123; glRotatef(AngleX, 1.0f, 0.0f, 0.0f); glRotatef(AngleY, 0.0f, 1.0f, 0.0f); glBegin(GL_POLYGON); //前表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)0);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)255);//颜色设置为白色 glVertex3f(-50.0f, 50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //后表面 glColor3f(0.0f, 1.0f, 1.0f);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3f(0.0f, 1.0f, 0.0f);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //上表面 glColor3d(0.0, 1.0, 1.0);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3d(1.0, 1.0, 1.0);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3d(1.0, 0.0, 1.0);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3d(0.0, 0.0, 1.0);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //下表面 glColor3ub(0u, 255u, 0u);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub(255u, 255u, 0u);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub(255u, 0u, 0u);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub(0u, 0u, 0u);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //左表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)255);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)0);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //右表面 glColor3f(1.0f, 0.0f, 1.0f);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(1.0f, 0.0f, 0.0f);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glEnd(); &#125; glPopMatrix();&#125;void opencvWithOpenGLTest()&#123; std::string openGLWindowName = "OpenGL Test"; cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL); cv::resizeWindow(openGLWindowName, windowWidth, windowHeight); cv::setOpenGlContext(openGLWindowName); cv::setOpenGlDrawCallback(openGLWindowName, onDraw, NULL); while (cv::waitKey(30) != 27) &#123; cv::updateWindow(openGLWindowName); // when needed &#125;&#125;int main(int argc, char *argv[])&#123; opencvWithOpenGLTest(); return 0;&#125; 运行成功后可看到一个旋转的彩色立方体。 结论 从实验结果来看，OpenCV确实能支持OpenGL图形的显示，但其不足之处也很明显：没有提供鼠标和键盘的交互操作（可能是本人还没发现，毕竟只是尝试一下看它能不能显示），仅仅只是提供一个显示窗口。如果真想用OpenGL做一些好玩的东西，还是用glut和glew吧，不过glut已经停止更新许久，glew在调试时可能会出现一些莫名其妙的错误，所以网上有人用freeglut代替glut，glee代替glew，具体的东西本人也没试过，本人目前还没做过OpenGL相关的事，这次用OpenCV显示OpenGL图形纯粹是为了好玩(*&#94;__&#94; *) 嘻嘻……。 后记 本篇文档也是上次编译配置完OpenCV-3.2后做的一次小实验，但当时并没有记录，所以还有一些参考资料也已经不知道了:-(。 参考资料[1] OpenCV学习笔记（六十一）——建立支持OpenGL的OpenCV工程“Master OpenCV”chp.3（http://blog.csdn.net/yang_xian521/article/category/910716 ） [2] 几个opengl立方体绘制案例（http://blog.csdn.net/bcbobo21cn/article/category/3104565 ）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0]]></title>
    <url>%2F2017%2F08%2F28%2FWin10%EF%BC%8BVS2013%EF%BC%8BCMake-gui%E7%BC%96%E8%AF%91%E5%92%8C%E9%85%8D%E7%BD%AEOpenCV-3-2-0%2F</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64 英文企业版；VS2013-update5 英文旗舰版；CMake-3.6.3-win64-x64 免安装版；Qt-opensource-windows-x86-msvc2013-5.6.2。 *注：本人写的这篇文档主要用来编译x86版的动态debug库，想编译其它类型的库请自行参考其它资料，做相关改变。（其实如果想编译x64版的可以在用VS2013编译时将上方的Win32平台选择x64平台；想编译release版的可以在用VS2013编译时将上方的Debug模式选择Release模式；想编译静态库的可以在用CMake生成时取消勾选BUILD_SHARED_LIBS选项即可。:-P） 前言 因为OpenCV-3.2官方的release版只有支持VS2015的库，而且不包括扩展包（opencv_contrib）中的库，而由于某些历史原因，本人目前使用的编译器还是VS2013，又想用用扩展包中一些有趣的算法，在加上上个月opencv-3.3还没有正式release，所以上个月本人就利用VS2013对opencv-3.2进行编译。具体编译过程如下： 准备篇 先在GitHub上下载对应的opencv源码包：opencv-3.2.0和opencv_contrib-3.2.0（https://github.com/opencv ），扩展包版本一定要和opencv版本相同。本人为了添加Qt后端显示支持（为了好看和方便:-P），所以还下载安装了支持VS2013的Qt-5.6.2（http://download.qt.io/archive/qt/ ）。再下载CMake-3.6.3-win64-x64 免安装版（https://cmake.org/files/ ）。至于微软的东西，推荐直接去MSDN 我告诉你去下载。 由于网上有的资料（具体是哪篇文章本人忘记了o(╯□╰)o）说编译时的文件结构可能会影响编译是否成功，再加上为了方便编译管理，本人的编译时的文件结构为： opencv-3.2.0_build├── build└── sources​ ├── opencv-3.2.0​ └── opencv_contrib-3.2.0 4 directories, 0 files 其中opencv-3.2.0用来装opencv-3.2.0.zip解压后的源码；opencv_contrib-3.2.0用来装opencv_contrib-3.2.0.zip解压后的源码；build用来装CMake编译完成后的文件。 编译篇 打开/cmake-3.6.3-win64-x64/bin/cmake-gui.exe，在Where is the source code文本框中选择/opencv-3.2.0_build/sources/opencv-3.2.0；在Where to build the binaris文本框中选择/opencv-3.2.0_build/build，点击Configure，在弹出的编译器选择框中选择Visual Studio 12 2013，一直Configure直到红色的条变白。 网上有人在这一步可能会出现ffmpeg not downloaded和“ippicv_windows_20151201.zip”not downloaded这两个问题，本人没出现这两个问题，所以没有机会验证cmake-gui和vs2013编译opencv和opencv_contrib源码中的解决办法是否正确。 接下来就是添加扩展包，在白色条中找到OPENCV_EXTRA_MODULES_PATH文本框，在其中选择opencv_contrib源码中modeles所在路径：/opencv-3.2.0_build/sources/opencv_contrib-3.2.0/modules。 至于想要支持OpenGL和Qt就需要勾选WITH_OPENGL和WITH_QT并Configure后选择好Qt的安装目录，如果配置好Qt的环境变量Cmake将会自动选择好Qt所在路径。 随后再次反复Configure直到界面不再出现红色背景，之后单击Generate。不出意外的话，你会看到Configure done和Generate done。 本人在这一步出现了VS2013_CMake_opencv3.1动态库与静态库的配置与编译中的问题，原因是同时勾选了同时勾选了BUILD_opencv_world和BUILD_opencv_contirb_world，本人的解决办法是将它们全部取消勾选，再次Configure和Generate。 如果上面一切顺利的话就可以进行下一步了：使用VS2013编译OpenCV。打开/opencv-3.2.0_build/build目录，将会看到一大堆文件和文件夹，双击/opencv-3.2.0_build/build目录下的OpenCV.sln，用VS2013打开。找到CMakeTargets中的INSTALL，然后右键选择“Project Only”–&gt;“Build Only INSTALL”。 漫长的等待。。。。。。(╯﹏╰)b 本人在这一步出现了一个问题，具体问题和解决方法详见问题篇。 一切顺利的话，应该会比本人下面的库多两个，本人最后生成的Debug库为： opencv_aruco320d.lib opencv_bgsegm320d.lib opencv_bioinspired320d.lib opencv_calib3d320d.lib opencv_ccalib320d.lib opencv_core320d.lib opencv_datasets320d.lib opencv_dnn320d.lib opencv_dpm320d.lib opencv_face320d.lib opencv_features2d320d.lib opencv_flann320d.lib opencv_fuzzy320d.lib opencv_highgui320d.lib opencv_imgcodecs320d.lib opencv_imgproc320d.lib opencv_line_descriptor320d.lib opencv_ml320d.lib opencv_objdetect320d.lib opencv_optflow320d.lib opencv_phase_unwrapping320d.lib opencv_photo320d.lib opencv_plot320d.lib opencv_reg320d.lib opencv_rgbd320d.lib opencv_saliency320d.lib opencv_shape320d.lib opencv_stereo320d.lib opencv_stitching320d.lib opencv_structured_light320d.lib opencv_superres320d.lib opencv_surface_matching320d.lib opencv_text320d.lib opencv_tracking320d.lib opencv_video320d.lib opencv_videoio320d.lib opencv_videostab320d.lib opencv_xfeatures2d320d.lib opencv_ximgproc320d.lib opencv_xobjdetect320d.lib opencv_xphoto320d.lib 共41个。 配置篇 因为本人只编译了x86版动态debug库，所以以下环境配置都只针对x86版动态debug库。（其实要配置x64的库就只需将x86换成x64即可；要配置release模式的库就只需在添加附加依赖项中的库文件选择release模式的库（即数字后没有d的lib）；若要配置静态库就需要选择静态库文件夹以及在附加依赖项中添加相应的静态库文件。:-P） 首先把/opencv-3.2.0_build/build/install中的文件都提取出来，这和OpenCV官方release的opencv文件结构差不多，具体两层结构如下 .├── bin│ &ensp;└── opencv_waldboost_detectord.exe├── etc│ &ensp;├── haarcascades│ &ensp;└── lbpcascades├── include│ &ensp;├── opencv│ &ensp;└── opencv2├── LICENSE├── OpenCVConfig.cmake├── OpenCVConfig-version.cmake└── x86​ └── vc12 9 directories, 4 files x86文件夹就是VS2013生成的对应VS版本32位的各种库，include文件夹就是opencv的各项模块。本人将其中提取出的文件全部放入了C:\Program Files\OpenCV\3.2.0\build文件夹中。 首先配置环境变量，系统（或用户）环境变量如下： 变量名 变量值 Path C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin OPENCV C:\Program Files\OpenCV\3.2.0\build 不然可能会报错：程序“XXXXXX”已退出，返回值为 -1073741701 (0xc000007b)。其中下面那行可以选择不要添加。 然后在VS中配置环境。新建工程，然后在“属性管理器”中对应项目下Debug | Win32文件夹右键“添加新项目属性表”。（方便一次配置，多次使用，以后再使用只要在相应项目下右键“添加现有属性表”即可），本人新项目属性表取名为：opencv-3.2.0_msvc2013_x86d.props。 接下来就是真正的VS环境配置了： 双击打开刚才新建的属性表，选中“VC++目录”，注意在进行以下配置时建议都勾选左下角的“从父级或项目默认设置继承” “可执行文件目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin “包含目录”中添加： C:\Program Files\OpenCV\3.2.0\build\include C:\Program Files\OpenCV\3.2.0\build\include\opencv C:\Program Files\OpenCV\3.2.0\build\include\opencv2 “库目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib 选中“链接器” –&gt; “常规”，“附加库目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib “链接器” –&gt; “输入”，“附加依赖项”中添加C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib中数字后带d的库文件，即编译篇中本人最后生成的41个库文件。 配置完之后不要忘了右键该属性表进行保存处理，以便下个项目直接使用，不需要再重复进行配置。 最后附示例程序： 1234567891011#include &lt;opencv2/opencv.hpp&gt; int main(int argc, char *argv[])&#123; cv::Mat lena = cv::imread("lena.jpg"); //载入图像到Mat，jpg文件和该cpp在同一文件夹 cv::namedWindow("lena"); //创建一个名为 "lean"的窗口 cv::imshow("lena", lena); //显示名为 "lena"的窗口 cv::waitKey(5000); // 只对窗口机制起作用（显示5000ms，随后返回-1，即窗口关闭），若在此期间有按键按下，则马上返回按键的ASCII码。 //system("pause"); return 0;&#125; 这里必须在imshow后加入waitkey，因为WaitKey不止是Wait Key 而已，它其实还涉及到消息响应，有这个函数cv内部的WndProc函数才能起作用，才会更新窗口。 最后程序运行成功并显示lena图，则说明编译和配置没问题。 问题篇1、用VS2013编译OpenCV在漫长的等待阶段出现的问题。 问题描述：CVV模块报错，TS模块编译不出来，好在这两个模块都不是很重要，可以忽略，本人强迫症也没到这种程度O(∩_∩)O~。 解决办法： 在CVV模块报错后可在CMake（不知道具体是INSTALL下的CMake Rules中的INSTALL_force.rule，还是ALL_BUILD下的CMakeLists.txt，忘记了o(╯□╰)o）中添加-DBUILD_opencv_cvv=OFF忽略CVV模块，从而正常编译其它模块。参考errors on build opencv with cvv module and qt5 #577。如果实在不行的话就在CMake生成的时候取消勾选出错模块，若是用CMake重新生成的话不要忘了先把/opencv-3.2.0_build/build目录下的文件全部删除干净。 后记 这是以前写的两篇文档，现在再来整理成一篇。 附录 既然能看到这里，说明是想在VS下使用OpenCV，这里推荐一款VS下OpenCV开发调试神器：Image Watch，效果谁用谁知道。Image Watch是VS的一个插件，不过它只支持VS2012及以上版本。使用方法为先设置断点（F9），随后在调试（F5）模式下，鼠标指针悬停在cv::Mat类型变量上，即可出现，点击查看图标即可显示相应图像。 参考资料[1] cmake-gui和vs2013编译opencv和opencv_contrib源码（http://livezingy.com/category/opencv/ ） [2] VS2013_CMake_opencv3.1动态库与静态库的配置与编译（http://livezingy.com/category/opencv/ ） [3] 使用VS2015编译以及静态编译opencv3记录 [4] errors on build opencv with cvv module and qt5 #577 [5] VS2013中Image Watch插件的使用(OpenCV)（http://blog.csdn.net/fengbingchun/article/category/721609 ）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决写上篇文档“GitHub+Hexo搭建个人博客”遇到的问题]]></title>
    <url>%2F2017%2F08%2F26%2F%E8%A7%A3%E5%86%B3%E5%86%99%E4%B8%8A%E7%AF%87%E6%96%87%E6%A1%A3%E2%80%9CGitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%9D%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[超链接网址问题 问题描述：使用正常的markdown超链接格式[]()没问题，然而当直接将一个网址链接放入该文档时，它会将该链接后面的文字也当成是该链接的一部分，直接点击链接时，会将后面的文字也放入浏览器地址栏，从而出现网页404错误：404: Page could not be found。 解决办法：在网址链接后输入一个空格以隔开网址链接和后面的文字。 超链接样式问题 问题描述：本人使用的hexo主题是基于spfk主题稍微修改过的，spfk主题能自动修改超链接原有的样式，挺好看的:D，但是当本人在markdown中数字编号列表，即有序列表中添加超链接时，其样式并没有修改，还是普通的超链接样式。 解决办法：没有解决。最后只是跳过了这个问题，就用中文的序号表示列表。 文本段落问题 问题描述：为了使文本有段落感，一般都会在段落首字前空两格，但是在markdown中空两格，用hexo发布后并没有空两格，这使得文档没有段落感，阅读体验有点差。 解决办法：将中文输入法由半角切换至全角，在段落首字前输入两个空格即可。 显示英文尖括号问题 问题描述：由于上篇文档需要在文档中显示&lt;youname&gt;，但由于Hexo可能将其当做一个xml标签处理了，所以发布之后的文档没有显示该文字。 解决办法：首先本人尝试了转义字符\，谁曾想它只出现了一个转义字符，该文字还是没显示，本人差点又要跳过这个问题，将其用另一种表示法了。后来本人想到这最后不是会转为html吗，本人就直接用html中尖括号的表示法不就行啦:p，于是参考HTML语言中括号(尖括号)的字符编码，用&amp;lt;代替&lt;，用&amp;gt;代替&gt;，最后该文字终于出来了。 给文字添加颜色问题 问题描述：本人想给注意事项上的需要注意的问题添加醒目的颜色，但markdown本身不支持给文字添加颜色。 解决办法：由于Hexo最后会将markdown文档转换为html文档发布，所以直接将html标签写进markdown文档，最后自然会出现html样式，本人这里参考CSDN-markdown编辑器语法——字体、字号与颜色，给想要变色的文字添加&lt;font color=#FA8072&gt;&lt;/font&gt;标签。 参考资料[1] HTML语言中括号(尖括号)的字符编码（http://liuxufei.com/weblog/jishu ） [2] CSDN-markdown编辑器语法——字体、字号与颜色（http://blog.csdn.net/testcs_dn ）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>%2F2017%2F08%2F26%2FHexo-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64。 前言 本来是想在国内某网站上继续写的，毕竟完全不需要自己管理，只需要负责写好文档就可以了，但某一天，该网站由于响应国家的号召，要实名验证，本来实名验证也没什么，就输入手机号，并填写验证码即可，但该网站实名验证的方式给人的感觉特别不爽，于是就决定自己搭建博客，这样虽然有点麻烦，但由于完全是自己管理，自己完全拥有该文档的所有权，也不用担心哪天别的网站突然出现的各种破问题，相比这种完全自由支配、无比爽快的感觉，管理这种麻烦就是小事了。 GitHub+Hexo个人博客搭建准备篇在GitHub上搭建博客的要求： 1、要有GitHub账号。（没有怎么办，没有就去注册啊） 使用Hexo框架的要求： 1、需要安装node.js。（电脑上没有安装怎么办，没有安装就去下载（https://nodejs.org/en/download/ ）安装啊） 2、需要安装git。（没有安装就去下载安装，附git学习教程） GitHub篇 满足上文的要求之后，就可以开始搭建了，首先在GitHub中新建一个仓库（New repository），在Repository name下填写&lt;yourname&gt;.github.io，其它可默认，点击Create repository。 新建仓库完成后，点击Create new file新建一个README.md文件，随便写点什么，比如“It&#39;s my blog website”。 点击上方横条选项中的Settings，查看GitHub Pages里的设置，上方应该有绿色框，框中“Your site is published at https://&lt;yourname&gt;.github.io”，该网址即为博客主页，Source应该是master branch，自此GitHub上的设置可以算是完成了，但为了方便和防止误删，一般把Hexo文件也放入GitHub中，为方便管理，可以新建另一分支专门放Hexo文件。 在仓库code界面中点击Branch：master，在出现的框中输入hexo新建hexo分支，在branches中Change default branch设置hexo为默认分支。 Hexo篇 将刚才新建的仓库克隆到本地：git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git当前在hexo分支。 在&lt;yourname&gt;.github.io文件夹下执行 12345npm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --save 按这样一连串执行，如果没出问题的话就会在&lt;yourname&gt;.github.io文件夹里生成一个blog文件夹，该文件夹有一大堆Hexo有关的文件。 配置Hexo Hexo的配置文件为blog文件夹中的_config.yml文件。 修改配置文件不要使用windows自带的记事本，本人使用的VS Code，或者Notepad++和Sublime Text 2等编辑器都可以，以防文件编码改变，具体修改如下： 123456789101112131415# Sitetitle: &lt;你的blog名&gt;author: &lt;作者名称&gt;language: zh-CN&lt;网站所用语言，中国大陆选择zh-CN即可&gt;# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://&lt;yourname&gt;.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git branch: master 其它的默认即可，具体参数信息详见Hexo官方文档。 配置git用户信息12git config --global user.name "&lt;yourname&gt;"git config --global user.email "&lt;yourname&gt;@xxxxxx.com" 如果是个人电脑的话推荐加上–global全局参数，因为这样更加方便，如果不加的话，还要在\&lt;yourname&gt;.github.io\blog\.deploy_git\.git中config里加入git用户信息，不然可能提交会出问题，稍显麻烦。 部署Hexo在blog文件夹下执行： 123hexo g #generate 生成静态文件hexo d #deploy 部署网站.部署网站前,需要预先生成静态文件hexo s #server 启动服务器 或者执行： 1hexo g -d 快速部署个人blog。 在浏览器中输入http://localhost:4000/，将会出现Hexo的Hello World界面，更多Hexo命令详见Hexo官方文档。 最后将Hexo文件提交到GitHub远程仓库，具体提交命令为： 123git add .git commitgit push origin hexo 在浏览器中输入https://&lt;yourname&gt;.github.io同样会出现Hexo的Hello World界面，自此整个个人blog的框架已经完全搭好了。 其它篇主题选择 主题可以去官网上的主题界面去找，目前比较受欢迎主题有next和yilia，去别人GitHub上的主题仓库上去下载或clone均可，本人目前用的主题为black-blue，这个主题本人在用的时候还有些问题，或许会换，或许会自己魔改。最后由于术业有专攻，实在不知道该改哪里，所以决定换black-blue的原版主题SPFK ，对照着black-blue对spfk进行修改。具体换主题的方法为： 先将下载好的主题整个放在\blog\themes文件夹中，再修改blog文件夹中的配置文件_config.yml： 12# theme: landscapetheme: black-blue black-blue为打包主题文件并放入\blog\themes文件夹中的文件夹名，并不是原主题名，只是本人恰好将其重命名为主题名。 文章发布发布文章需要在blog文件夹中执行： 1hexo new "test" 将会在\blog\source_posts\文件夹中生成test.md文件，随后编辑test.md文件即可，本人使用的Markdown编辑器为Typora。 至于给文章打标签和分类什么的，请参考Hexo官方文档。 写完文章之后推送到GitHub中，需要执行： 123git add .git commit -m "add test.md"git push origin hexo Hexo文件配置同样需要同步一下： 123hexo ghexo cleanhexo d 插件添加以RSS订阅插件为例。首先安装hexo-generator-feed： 12## rss插件npm install hexo-generator-feed --save 安装成功后，修改blog文件夹中的配置文件_config.yml： 1234# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed #RSS订阅 最后，修改当前主题文件夹中的配置文件_config.yml，添加RSS订阅链接即可： 12subnav: rss: "/atom.xml" 修改完成后，执行 123hexo cleanhexo ghexo d 将会在页面中看到RSS图标。 注意事项1、提交至远程仓库时可能会出现错误。 原因可能是因为没有将SSH Key添加到GitHub中。 查看当前用户主目录下的.ssh文件夹中（windows是C:\Users\&lt;username&gt;\.ssh）是否有id_rsa（私钥）和id_rsa.pub（公钥）这两个文件，若没有，则执行 1ssh-keygen -t rsa -C "youremail@example.com" 在GitHub中添加SSH Key的具体方法为：点击GitHub用户头像下的Settings，选中SSH and GPG keys，点击New SSH key，将id_rsa.pub中的内容复制粘贴到Key文本框中。 2、Hexo生成和部署命令都执行失败。 原因可能是修改配置文件_config.yml出错。 将修改的配置文件_config.yml复原试试。 3、Hexo部署之后网页没变化。 可能需要执行 1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。 后记 以后就在这上面写blog了，顺便把以前写的一些文档也放上来。 参考资料[1] 利用github+hexo搭建自己的博客（http://blog.csdn.net/u012150360/article/category/6765461 ） [2] Hexo官方文档（https://hexo.io/zh-cn/ ） [3] GITHUB+HEXO博客轻松更换主题外观（http://www.jianshu.com/nb/10649566 ） [4] Hexo—正确添加RSS订阅（http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/ ）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
