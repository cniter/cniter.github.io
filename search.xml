<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenCV中显著性检测算法的使用]]></title>
    <url>%2F2017%2F09%2F12%2FOpenCV%E4%B8%AD%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E6%B5%8B%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文所用的OpenCV版本为opencv-3.2.0，编程语言为C++。 前言 OpenCV中实现了两种显著性检测算法，分别为Spectral Residual算法,出自Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on, pages 1–8. IEEE, 2007. 和 Fine Grained Saliency算法,出自Sebastian Montabone and Alvaro Soto. Human detection using a mobileplatform and novel features derived from a visual saliency mechanism. In Image and Vision Computing, Vol. 28 Issue 3, pages 391–402. Elsevier, 2010.。这两种算法同样是在扩展包opencv_contrib-3.2.0中，也是由于opencv官方示例程序对初学者不友好，所以本人对照其官方文档重新整理了一下。 代码篇 使用OpenCV中的显著性检测算法需要包含头文件#include &lt;opencv2/saliency.hpp&gt;，具体示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/saliency.hpp&gt;//******************************************************// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)////Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)//&#123;// if (saliencyType == "SPECTRAL_RESIDUAL")// return makePtr&lt;StaticSaliencySpectralResidual&gt;(); //computeSaliency返回的是32FC1// else if (saliencyType == "FINE_GRAINED")// return makePtr&lt;StaticSaliencyFineGrained&gt;(); //computeSaliency返回的是8UC1// else if (saliencyType == "BING")// return makePtr&lt;ObjectnessBING&gt;();// else if (saliencyType == "BinWangApr2014")// return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();// return Ptr&lt;Saliency&gt;();//&#125;//// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）//*****************************************************void spectralResidualTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); // [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687) if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Mat planes[] = &#123; cv::Mat_&lt;float&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;; cv::Mat complex_img; //复数矩阵 merge(planes, 2, complex_img); //把单通道矩阵组合成复数形式的双通道矩阵 dft(complex_img, complex_img); // 使用离散傅立叶变换 //对复数矩阵进行处理，方法为谱残差 cv::Mat magnitude, phase_angle, mag_mean; cv::Mat real_part, imaginary_part; split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; //实部 imaginary_part = planes[1]; //虚部 cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值 phase(real_part, imaginary_part, phase_angle); //计算相角 float *pre, *pim, *pm, *pp; //对幅值进行对数化 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = log(*pm); pm++; &#125; &#125; blur(magnitude, mag_mean, cv::Size(5, 5)); //对数谱的均值滤波 magnitude = magnitude - mag_mean; //求取对数频谱残差 //把对数谱残差的幅值和相角划归到复数形式 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pre = real_part.ptr&lt;float&gt;(i); pim = imaginary_part.ptr&lt;float&gt;(i); pm = magnitude.ptr&lt;float&gt;(i); pp = phase_angle.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = exp(*pm); *pre = *pm * cos(*pp); *pim = *pm * sin(*pp); pre++; pim++; pm++; pp++; &#125; &#125; cv::Mat planes1[] = &#123; cv::Mat_&lt;float&gt;(real_part), cv::Mat_&lt;float&gt;(imaginary_part) &#125;; merge(planes1, 2, complex_img); //重新整合实部和虚部组成双通道形式的复数矩阵 idft(complex_img, complex_img, cv::DFT_SCALE); // 傅立叶反变换 split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; imaginary_part = planes[1]; cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值和相角 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = (*pm) * (*pm); pm++; &#125; &#125; GaussianBlur(magnitude, magnitude, cv::Size(7, 7), 2.5, 2.5); cv::Mat invDFT, invDFTcvt; normalize(magnitude, invDFT, 0, 255, cv::NORM_MINMAX); //归一化到[0,255]供显示 invDFT.convertTo(invDFTcvt, CV_8U); //转化成CV_8U型 cv::namedWindow("SpectualResidual", CV_WND_PROP_ASPECTRATIO); cv::imshow("SpectualResidual", invDFTcvt); cv::Mat thresholded; cv::threshold(invDFTcvt, thresholded, 0, 255, CV_THRESH_OTSU); cv::namedWindow("Thresholded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded Image", thresholded); cv::Mat eroded; // 纵向腐蚀 cv::erode(thresholded, eroded, cv::Mat(5, 1, CV_8UC1, cv::Scalar(1)), cv::Point(-1, -1), 3); // cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心 cv::namedWindow("eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("eroded Image", eroded); //cv::Mat thresholded; cv::threshold(eroded, thresholded, 60, 255, CV_THRESH_BINARY); cv::namedWindow("Thresholded eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded eroded Image", thresholded);&#125;void saliencyTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create("SPECTRAL_RESIDUAL"); // FINE_GRAINED为Fine Grained Saliency算法 cv::Mat saliency_map; if (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map)) &#123; cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", saliency_map); cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1); normalize(saliency_map, saliency_map_show, 0, 255, CV_MINMAX); //归一化到[0,255]供显示 saliency_map_show.convertTo(saliency_map_show, CV_8U); //转化成CV_8U型 cv::namedWindow("saliency_map_show", CV_WND_PROP_ASPECTRATIO); cv::imshow("saliency_map_show", saliency_map_show); cv::Mat binary_map; cv::saliency::StaticSaliencySpectralResidual spec; if (spec.computeBinaryMap(saliency_map, binary_map)) &#123; cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); &#125; &#125;&#125;// Fine Grained Saliency算法void FGSTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create(); cv::Mat fgs_saliency_map; fgs-&gt;computeSaliency(src_img, fgs_saliency_map); cv::namedWindow("FGS saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("FGS saliency map", fgs_saliency_map); //cv::imwrite("../data/T_S.png", fgs_saliency_map); cv::Mat binary_map; cv::threshold(fgs_saliency_map, binary_map, 0, 255, CV_THRESH_OTSU); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); //cv::imwrite("../data/T_S_B.png", binary_map);&#125;// Spectral Residual算法void SRTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create(); cv::Mat sr_saliency_map; sr-&gt;computeSaliency(src_img, sr_saliency_map); cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", sr_saliency_map); cv::Mat binary_map; sr-&gt;computeBinaryMap(sr_saliency_map, binary_map); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map);&#125;int main(int argc, char *argv[])&#123; //spectralResidualTest(); //saliencyTest(); //FGSTest(); SRTest(); while (cv::waitKey(0) != 27) &#123; &#125; return 0;&#125; 这里面有个小东西需要注意，就是computeBinaryMap()函数，看其文档描述其中使用K-means算法和Otsu算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV中Spectral Residual算法computeSaliency()返回的结果为浮点数，而Fine Grained Saliency算法computeSaliency()返回的结果却是整型数据。 后记 本文使用的这两种算法在本人的电脑上运行时间都较长，基本不可能用来处理视频流，而且在本人的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过OpenCV中也有用来处理视频流的显著性检测算法，其为BING算法,出自Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In IEEE CVPR, 2014.，实际上这是一种快速提取目标候选框的算法。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中Selective Search算法的使用]]></title>
    <url>%2F2017%2F09%2F10%2FOpenCV%E4%B8%ADSelective-Search%E7%AE%97%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[本文所用的OpenCV版本为opencv-3.2.0，编程语言为C++。 前言 OpenCV-3.2中的Selective Search算法是在其扩展包中，所以要想使用该算法需自行编译opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好，所以本人参考其官方文档及其官方示例程序写下此文。 Selective Search算法 该算法是选取region proposal（一般翻译成候选区域 / 区域建议）领域中的state-of-the-art。其算法具体思想出自Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154–171, 2013.，若英文水平不够，还想了解其中文思想请参考文末参考资料。 代码篇 使用Selective Search算法需包含#include &lt;opencv2/ximgproc.hpp&gt;，完整示例程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/ximgproc.hpp&gt;void SSTest()&#123; // [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入原始图像 cv::namedWindow("src_img", CV_WINDOW_KEEPRATIO); cv::imshow("src_img", src_img); //// 转换为灰度图 //cv::Mat gray_img; //cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY); // 图割算法 cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation(); cv::Mat graph_segmented; gs-&gt;processImage(src_img, graph_segmented); normalize(graph_segmented, graph_segmented, 0, 255, CV_MINMAX); // 归一化到[0,255]供显示 graph_segmented.convertTo(graph_segmented, CV_8U); // 数据类型转化成CV_8U型 // cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR); cv::namedWindow("graph_segmented", CV_WINDOW_KEEPRATIO); imshow("graph_segmented", graph_segmented); // 为selective search算法添加图割算法处理结果 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;addGraphSegmentation(gs); ss-&gt;addImage(src_img); // 添加待处理的图片 // 自定义策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(); // 颜色相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(); // 纹理相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(); // 尺寸相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(); // 填充相似度策略 // 添加策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill); // 合并以上4种策略 ss-&gt;addStrategy(sss); std::vector&lt;cv::Rect&gt; regions; ss-&gt;process(regions); // 处理结果 // 显示结果 cv::Mat show_img = src_img.clone(); for (std::vector&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r) &#123; cv::rectangle(show_img, *it_r, cv::Scalar(0, 0, 255), 3); &#125; cv::namedWindow("show_img", CV_WINDOW_KEEPRATIO); imshow("show_img", show_img); // -------忽略上述步骤，直接采用方便算法提取候选区域------------------------ /*************************************************************************** cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;setBaseImage(src_img); // 采用switch* functions提取候选区域 ss-&gt;switchToSelectiveSearchFast(); // 快速提取区域 std::vector&lt;cv::Rect&gt; rects; ss-&gt;process(rects); int nb_rects = 10; char c = (char)cv::waitKey(); while (c != 'q') &#123; cv::Mat wimg = src_img.clone(); int i = 0; for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it) &#123; if (i++ &lt; nb_rects) &#123; cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3); &#125; &#125; cv::namedWindow("Output", CV_WINDOW_KEEPRATIO); imshow("Output", wimg); c = (char)cv::waitKey(); if (c == 'd') &#123; nb_rects += 10; &#125; if (c == 'a' &amp;&amp; nb_rects &gt; 10) &#123; nb_rects -= 10; &#125; &#125; ********************************************************/&#125;int main(int argc, char *argv[])&#123; SSTest(); while (cv::waitKey(0) != 27) &#123;&#125; return 0;&#125; 后记 使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法switchToSelectiveSearchFast()的参数。本人的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在本人电脑上略显长。GitHub上也有大神自己用opencv实现了该算法，参考watanika/selective-search-cpp，该算法的参数感觉比OpenCV自带的Selective Search算法要好调一些，但优化效果没有opencv好，其运行时间在本人电脑上更长。 参考资料[1] 论文笔记：Selective Search for Object Recognition（http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/） [2] Selective Search for Object Recognition(阅读)（http://blog.csdn.net/langb2014/article/category/5772811） [3] 论文笔记 《Selective Search for Object Recognition》（http://blog.csdn.net/csyhhb/article/category/6048588）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10以树形结构显示文件目录结构]]></title>
    <url>%2F2017%2F09%2F05%2FWin10%E4%BB%A5%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 本文其实可以算是标题党，Windows本身并不能以树形结构显示文件目录结构，一般需要借助第三方工具（后面去网上搜索了一下，发现Windows居然也有一个tree命令o(╯□╰)o），Windows虽然能用命令行显示树形结构文件目录，但不像Linux那样可以输入一些参数控制其输出。Win10有个特殊的功能，就是可以使用Ubuntu的bash，只需要开启这个有趣的功能，就可以将Win10当Ubuntu使用，从而像Linux那样只输入相关命令即可显示树形结构文件目录。 *注：值得注意的是Win10中的bash目前不支持中文输入，只能切换到英文输入才能正常输入。 准备篇首先需要在Win10下开启bash功能。具体开启方法为： 打开 Win图标 ==》 设置 ==》 更新和安全 ==》 针对开发人员（左侧），选中开发人员模式， 打开 Win图标 ==》 设置 ==》 应用 ==》 应用和功能（左侧） ==》 程序和功能（最下面的相关设置中） ==》 启用或关闭Windows功能（左侧），选中适用于Linux的Windows子系统(Beta)后点击确定。 重启计算机。打开bash，打开bash的方法很多，这里列出三种：1、直接在微软小娜中输入关键字”bash“搜索Bash on Ubuntu on Windows；2、Win键+R，输入bash，点击确定即可打开bash；3、Win键+R，输入cmd，在cmd中输入bash，回车即可打开bash。打开bash后将会提示你是否下载安装Ubuntu on Windows，输入y继续，稍等片刻即可完成下载安装。 设置篇 安装完成后系统将会提示你设置用户名和密码。（如果这一步设置成功可以直接跳过设置篇直接看使用篇）。不知道怎的，本人这一步没有完成，每次系统都是直接以root用户登录，而且没有密码，为了安全考虑，也幸好登录时是root用户，可以自由对系统修改。所以本人需要对root密码进行修改，并创建新的用户。具体过程需执行以下命令： root用户下，修改用户密码： 1passwd 用户名 (修改密码) 由于本人需要修改root密码，所以该用户名即为root，执行之后需要输入新密码（在*nix哲学中，密码是不会显示在输入屏幕中的，所以如果在输入密码时发现屏幕没有任何变化是没关系的，只管输入即可↖(&#94;ω&#94;)↗），两次输入完成后会显示密码更新成功。 接下来需要创建新的普通用户，在root用户下执行： 1adduser xxx # 这样的命令会在home目录下添加一个帐号 或者 1useradd xxx #仅仅是添加用户，不会在home目录添加帐号 推荐使用前者，这样可以很明确已经成功创建新用户，而且如果用户需要存放一些文件也更安全和方便。 在*nix中，绝对不推荐直接使用root用户对系统执行各种命令，毕竟其权限太大，一旦误操作将造成无法挽回的后果。有些命令普通用户可能没有权限执行，这时需要提高其权限，普通用户临时获取root权限的方法为：在需要执行的命令前添加sudo，像上文中如果普通用户需要创建新用户xxx则需要执行sudo adduser xxx，执行以上命令后同样需要输入新用户的密码。 使用篇 先切换至普通用户，执行su xxx切换用户，即可发现shell提示符由#变为$，前面的用户名由root变为xxx；执行cd ~切换至用户目录。由于Ubuntu系统中本身没有tree这个命令，需要执行以下命令安装tree命令工具： 1sudo apt install tree 直接输入tree命令，系统将会自动以树形结构列出当前目录中所有文件及文件夹；执行tree -L N 命令，以树形结构查看当前N级的目录和文件，eg：以树形结构查看当前目录二级文件结构，则执行tree -L 2。若想将输出的2级文件结构保存至上一层文件的tree.txt文件中，可执行tree -L 2 &gt; ../tree.txt，进入上一层目录cd ..，打开tree.txt即可发现该目录的文件结构。 后记 遇事还是需要多查证一下啊，想当然果然是会出问题的，文章开头差点就犯错误了~(≧▽≦)/~。本文其实是在写Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0时，为了方便显示输出文件结构而查找的相关资料。 参考资料[1]linux tree命令以树形结构显示文件目录结构（http://jingyan.baidu.com/tag?tagName=linux ） [2] win tree命令 tree导出目录 tree显示树形结构（http://jingyan.baidu.com/tag?tagName=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F ） [3] win10下linux系统的安装（开启）和使用 [4] Ubuntu建立和删除用户 [5] linux修改root密码和linux忘记root密码后找回密码的方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加站内本地搜索]]></title>
    <url>%2F2017%2F09%2F01%2FHexo%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%9C%AC%E5%9C%B0%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[前言 虽然本人博客目前数量不多，质量也不高，但抱着搞事的心态，先弄它一个站内本地搜索再说。 准备篇 要想使用本地搜索功能，首先需要安装相应的搜索插件hexo-generator-searchdb，网上可能大多数用的是hexo-generator-search这个插件，也有都装的，但本人就只安装这一个了，好像hexo-generator-searchdb更完善一点，由于本人前端接触的极少，所以就没有一一对比了，网上也没查到具体对比情况，有兴趣的童靴可以试试(╯▽╰)。至于具体安装如下，在站点根目录执行： 1npm install hexo-generator-searchdb --save 安装完之后重新生成页面，将会发现public文件夹下多出一个search.xml文件。然后在配置文件_config.yml中添加： 1234# 站点本地搜索search: path: search.xml field: all 其中： path - 指定生成的索引数据的文件名。默认为 search.xml 。 field - 指定索引数据的生成范围。可选值包括： post - 只生成博客文章（post）的索引（默认）； page - 只生成其他页面（page）的索引； all - 生成所有文章和页面的索引。 至于是在主题配置文件，还是在站点配置文件中添加，个人觉得都没关系，附：本人是在主题配置文件中添加的。 接下来就需要修改原主题的代码了。 改码篇 由于本人博客主题是基于SPFK对照着black-blue进行修改的，而且因为black-blue是有搜索的（本人不知道black-blue主题的作者是如何完成的，借助了什么技术），所以本人就看black-blue的搜索功能是修改了SPFK哪个地方，再将相应的代码添加至SPFK中（其中相应的代码来自让 Hexo 博客支持本地站内搜索），从而逐渐完成本次搜索功能。 首先找到spfk主题下的left-col.ejs文件，对其修改如下： 123456789101112&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot;&gt; &lt;/form&gt; --&gt; &lt;form id=&quot;search-form&quot;&gt; &lt;!-- 搜索框相关 --&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;Search...&quot; class=&quot;search form-control&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot;/&gt; &lt;i class=&quot;fa fa-times&quot; onclick=&quot;resetSearch()&quot;&gt;&lt;/i&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;/form&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;p class=&apos;no-result&apos;&gt;No results found &lt;/p&gt; &lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt; &lt;%&#125;%&gt; 其次找到spfk主题下的after-footer.ejs文件，将其修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125; &lt;/script&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 激活搜索框时才搜索 var inputArea = document.querySelector(&quot;#local-search-input&quot;); var getSearchFile = function()&#123; // 调用搜索函数 var search_path = &quot;&lt;%- config.search.path %&gt;&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;&lt;%- config.root %&gt;&quot; + search_path; searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;); &#125; inputArea.onfocus = function()&#123; getSearchFile() &#125; // 搜索重置 var $resetButton = $(&quot;#search-form .fa-times&quot;); var $resultArea = $(&quot;#local-search-result&quot;); inputArea.oninput = function()&#123; $resetButton.show(); &#125; resetSearch = function()&#123; $resultArea.html(&quot;&quot;); document.querySelector(&quot;#search-form&quot;).reset(); $resetButton.hide(); $(&quot;.no-result&quot;).hide(); &#125; // 屏蔽回车 inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125; // 无搜索结果 $resultArea.bind(&quot;DOMNodeRemoved DOMNodeInserted&quot;, function(e) &#123; if (!$(e.target).text()) &#123; $(&quot;.no-result&quot;).show(200); &#125; else &#123; $(&quot;.no-result&quot;).hide(); &#125; &#125;) // 搜索函数 var searchFunc = function(path, search_id, content_id) &#123; &apos;use strict&apos;; $.ajax(&#123; url: path, dataType: &quot;xml&quot;, success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( &quot;entry&quot;, xmlResponse ).map(function() &#123; return &#123; title: $( &quot;title&quot;, this ).text(), content: $(&quot;content&quot;,this).text(), url: $( &quot;url&quot; , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function()&#123; var str=&apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;/&quot;+ data_url +&quot;&apos; class=&apos;search-result-title&apos; target=&apos;_blank&apos;&gt;&quot;+ &quot;&gt; &quot; + data_title +&quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace(regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot;+keyword+&quot;&lt;/em&gt;&quot;); &#125;) str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content +&quot;...&lt;/p&gt;&quot; &#125; &#125; &#125;) $resultContent.innerHTML = str; &#125;) &#125; &#125;) &#125; &lt;/script&gt;&lt;%&#125;%&gt; 最后找到spfk主题下的main.styl文件，在其末尾添加： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*搜索框*/.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid #d3d3d3; border-radius: 2px; opacity: 0.65; background: none;&#125;.search:hover &#123; border: 2px solid #d3d3d3; opacity: 1; box-shadow: 0 0 10px rgba(0,0,0,0.3);&#125;/*搜索重置按钮*/#search-form .fa-times &#123; display: none; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0,0,0,0.15); cursor: pointer; color: #4094c7;&#125;#search-form .fa-times:active &#123; background: #d3d3d3;&#125;#search-form .fa-times:hover &#123; zoom: 1.1; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0,0,0,0.25);&#125;/*搜索结果区*/#local-search-result &#123; //margin: auto -12% auto -6%; margin: 0; font-size: 0.9em; text-align: left; word-break: break-all; box-shadow: 4px 4px 6px rgba(0,0,0,0.46);&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*单条搜索结果*/#local-search-result li &#123; margin: 0.5em auto; border-bottom: 2px solid #d3d3d3;&#125;#local-search-result .search-result-list li:hover &#123; background: rgba(47,46,46,0.8); box-shadow: 0 0 5px rgba(0,0,0,0.2);&#125;/*匹配的标题*/#local-search-result a.search-result-title &#123; line-height: 1.2; font-weight: bold; color: #4094c7;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; line-height: 1.2em; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #ffffffb3;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 1em;&#125;/*无匹配搜索结果时显示*/p.no-result &#123; display: none; margin: 2em 0 2em 6%; padding-bottom: 0.5em; text-align: left; color: #808080; font-family: font-serif serif; border-bottom: 2px solid #d3d3d3;&#125; 这里请注意，当对main.styl文件做以上修改时，可能会发现有两个.search样式，而且相差不大，这时，不要对其原有的.search进行修改，更不要去注释掉它，只做上述修改就不用管了，不然可能会发生一些奇怪的事o(&gt;﹏&lt;)o。本人当时做以上修改时，将其原有的.search样式注释掉之后，整个页面的css布局全部都乱了(╯﹏╰)，不知道为什么(⊙_⊙?)，这两个同名样式看起来明明差不多的，最后只能维持现状了，等以后有机会再看看吧，业余前端伤不起啊!╮(╯_╰)╭。 至此整个站内本地搜索功能基本完成，勉强可以使用站内搜索功能了。 问题篇 *注：以下问题目前都没解决╮(╯▽╰)╭。 1、搜索函数返回的url地址有问题。 问题描述：当点击搜索结果时，新弹出的标签页地址栏中url地址会有部分乱码情况；当鼠标移到搜索的结果列表上时，浏览器左下角显示的url地址虽然没有乱码情况，但其中有一个重复的/符号。所幸这两个问题并没有造成浏览器解析错误，浏览器还是可以正常显示页面的。 2、搜索结果区布局有问题。 问题描述：当显示搜索结果时，搜索结果区会上下扩张，从而将其上下本来存在的一些布局挤开，造成布局混乱。这其实不算是一个spfk主题或者新添加的搜索功能的问题，而是新添加的一个东西又没有相应的和原本布局结合的布局文件，那就极大可能会有布局混乱的问题，至于这个要和原本布局契合的搜索结果区布局文件就只有等本人以后有机会有时间再完善去喽╮(╯▽╰)╭。 3、搜索框激活问题。 问题描述：搜索框激活延迟很大，有时过很久或者需要切换站内页面它才能激活，给人的感觉就是好像没有搜索功能似的。添加搜索框激活功能据作者MOxFIVE所说是为了不让索引文件影响页面加载速度，MOxFIVE同时也在文末指出了一些不足之处，如果索引文件太大，可能还是会造成一些问题，但本人的博客数量又不多，所以估计还是本人的代码混合问题，而且MOxFIVE的博客搜索功能好像没这个问题（至少本人目前没发现）。这个问题同样只有等以后再说了(*&#94;__&#94;*) 嘻嘻……。 后记 本文添加的本地搜索还很粗糙，还有很多地方需要以后去完善。但这好歹是一个好的开始，搜索功能至少勉强能够正常使用，总比以前是个空壳要好，以后有机会再慢慢去去完善吧↖(&#94;ω&#94;)↗。 参考资料[1] jQuery-based Local Search Engine for Hexo（http://www.hahack.com/categories/codes/ ） [2] 让 Hexo 博客支持本地站内搜索（http://moxfive.xyz/tags/Hexo/ ） [3] Hexo博客添加站内搜索（https://www.ezlippi.com/categories/hexo/ ） [4] Hexo本地搜索及部分SEO优化 （https://www.oyohyee.com/categories/Note/ ）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用OpenCV显示OpenGL图形]]></title>
    <url>%2F2017%2F08%2F31%2F%E7%94%A8OpenCV%E6%98%BE%E7%A4%BAOpenGL%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[前言 本文就是一个小实验，试验OpenCV到底能不能支持OpenGL图形显示。 正文 如果在OpenCV用CMake编译时勾选WITH_OPENGL且编译一切顺利的话，编译和配置的具体步骤和情况可以看本人写的一篇文档：Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 ，那么就可以用OpenCV窗口显示OpenGL图形。 在VS下使用Windows原有的OpenGL函数需要包含以下头文件和库文件： 123456#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib") 在OpenCV中显示OpenGL图形需要cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL)，在namedWindow函数中添加cv::WINDOW_OPENGL参数说明该窗口支持OpenGL图形。 附示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;opencv.hpp&gt;#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib")static const float vertex_list[][3] =&#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;;// 将要使用的顶点的序号保存到一个数组里面 static const GLint index_list[][2] =&#123; &#123; 0, 1 &#125;, &#123; 2, 3 &#125;, &#123; 4, 5 &#125;, &#123; 6, 7 &#125;, &#123; 0, 2 &#125;, &#123; 1, 3 &#125;, &#123; 4, 6 &#125;, &#123; 5, 7 &#125;, &#123; 0, 4 &#125;, &#123; 1, 5 &#125;, &#123; 7, 3 &#125;, &#123; 2, 6 &#125;&#125;;static float rotate = 0;static int times = 0;GLint windowWidth = 800;GLint windowHeight = 800;GLfloat xRotAngle = -75.0f;GLfloat yRotAngle = 0.0f;GLfloat zRotAngle = -135.0f;float MIN_X = -200;float MAX_X = 200;float MIN_Y = -200;float MAX_Y = 200;float MIN_Z = -200;float MAX_Z = 200;GLfloat coordinatesize = 200.0f;GLfloat ratio = 1;void drawLine(float x1, float y1, float z1, float x2, float y2, float z2)&#123; glBegin(GL_LINES); glVertex3f(x1, y1, z1); glVertex3f(x2, y2, z2); glEnd(); glFlush();&#125;// 绘制立方体void DrawCube(void)&#123; int i, j; glBegin(GL_LINES); for (i = 0; i &lt; 12; ++i) // 12 条线段 &#123; for (j = 0; j &lt; 2; ++j) // 每条线段 2个顶点 &#123; glVertex3fv(vertex_list[index_list[i][j]]); &#125; &#125; glEnd(); glFlush();&#125;void reshapeOperate()&#123; glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (ratio &lt; 1) glOrtho(-coordinatesize, coordinatesize, -coordinatesize / ratio, coordinatesize / ratio, -coordinatesize, coordinatesize); else glOrtho(-coordinatesize*ratio, coordinatesize*ratio, -coordinatesize, coordinatesize, -coordinatesize, coordinatesize); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void reshape(int w, int h) &#123; if ((w == 0) || (h == 0)) return; glViewport(0, 0, w, h); ratio = (GLfloat)w / (GLfloat)h; reshapeOperate();&#125;GLfloat AngleX = 45.0f;GLfloat AngleY = 315.0f;void reshape1(int w, int h)&#123; GLfloat aspect = (GLfloat)w / (GLfloat)h; GLfloat nRange = 100.0f; glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式 glLoadIdentity(); //设置三维投影区 if (w &lt;= h) &#123; glOrtho(-nRange, nRange, -nRange * aspect, nRange * aspect, -nRange, nRange); &#125; else &#123; glOrtho(-nRange, nRange, -nRange / aspect, nRange / aspect, -nRange, nRange); &#125;&#125;void onDraw(void*)&#123; // Draw something using OpenGL here //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清除所有的像素 //glMatrixMode(GL_MODELVIEW); //glLoadIdentity(); //glPushMatrix(); ////glTranslatef(-0.2, 0, 0); // 平移 ////glScalef(2, 1, 1); // 缩放 //glRotatef(xRotAngle, 1.0f, 0.0f, 0.0f); //glRotatef(yRotAngle, 0.0f, 1.0f, 0.0f); //glRotatef(zRotAngle, 0.0f, 0.0f, 1.0f); //glColor3f(1, 0, 0); //drawLine(0, 0, 0, MAX_X, 0, 0); //x轴 //glColor3f(0, 1, 0); //drawLine(0, 0, 0, 0, MAX_Y, 0); //y轴 //glColor3f(0, 0, 1); //drawLine(0, 0, 0, 0, 0, MAX_Z); //z轴 //times++; //if (times &gt; 1) //&#123; // times = 0; //&#125; //if (times % 1 == 0) //&#123; // rotate += 0.3; //&#125; //glRotatef(rotate, 0, 1, 0); //glRotatef(rotate, 1, 0, 0); //glColor3f(0, 1, 1); //DrawCube(); //glPopMatrix(); reshape1(windowWidth, windowHeight); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); AngleX++; AngleY++; glPushMatrix(); &#123; glRotatef(AngleX, 1.0f, 0.0f, 0.0f); glRotatef(AngleY, 0.0f, 1.0f, 0.0f); glBegin(GL_POLYGON); //前表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)0);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)255);//颜色设置为白色 glVertex3f(-50.0f, 50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //后表面 glColor3f(0.0f, 1.0f, 1.0f);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3f(0.0f, 1.0f, 0.0f);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //上表面 glColor3d(0.0, 1.0, 1.0);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3d(1.0, 1.0, 1.0);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3d(1.0, 0.0, 1.0);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3d(0.0, 0.0, 1.0);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //下表面 glColor3ub(0u, 255u, 0u);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub(255u, 255u, 0u);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub(255u, 0u, 0u);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub(0u, 0u, 0u);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //左表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)255);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)0);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //右表面 glColor3f(1.0f, 0.0f, 1.0f);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(1.0f, 0.0f, 0.0f);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glEnd(); &#125; glPopMatrix();&#125;void opencvWithOpenGLTest()&#123; std::string openGLWindowName = "OpenGL Test"; cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL); cv::resizeWindow(openGLWindowName, windowWidth, windowHeight); cv::setOpenGlContext(openGLWindowName); cv::setOpenGlDrawCallback(openGLWindowName, onDraw, NULL); while (cv::waitKey(30) != 27) &#123; cv::updateWindow(openGLWindowName); // when needed &#125;&#125;int main(int argc, char *argv[])&#123; opencvWithOpenGLTest(); return 0;&#125; 运行成功后可看到一个旋转的彩色立方体。 结论 从实验结果来看，OpenCV确实能支持OpenGL图形的显示，但其不足之处也很明显：没有提供鼠标和键盘的交互操作（可能是本人还没发现，毕竟只是尝试一下看它能不能显示），仅仅只是提供一个显示窗口。如果真想用OpenGL做一些好玩的东西，还是用glut和glew吧，不过glut已经停止更新许久，glew在调试时可能会出现一些莫名其妙的错误，所以网上有人用freeglut代替glut，glee代替glew，具体的东西本人也没试过，本人目前还没做过OpenGL相关的事，这次用OpenCV显示OpenGL图形纯粹是为了好玩(*&#94;__&#94; *) 嘻嘻……。 后记 本篇文档也是上次编译配置完OpenCV-3.2后做的一次小实验，但当时并没有记录，所以还有一些参考资料也已经不知道了:-(。 参考资料[1] OpenCV学习笔记（六十一）——建立支持OpenGL的OpenCV工程“Master OpenCV”chp.3（http://blog.csdn.net/yang_xian521/article/category/910716 ） [2] 几个opengl立方体绘制案例（http://blog.csdn.net/bcbobo21cn/article/category/3104565 ）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0]]></title>
    <url>%2F2017%2F08%2F28%2FWin10%EF%BC%8BVS2013%EF%BC%8BCMake-gui%E7%BC%96%E8%AF%91%E5%92%8C%E9%85%8D%E7%BD%AEOpenCV-3-2-0%2F</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64 英文企业版；VS2013-update5 英文旗舰版；CMake-3.6.3-win64-x64 免安装版；Qt-opensource-windows-x86-msvc2013-5.6.2。 *注：本人写的这篇文档主要用来编译x86版的动态debug库，想编译其它类型的库请自行参考其它资料，做相关改变。（其实如果想编译x64版的可以在用VS2013编译时将上方的Win32平台选择x64平台；想编译release版的可以在用VS2013编译时将上方的Debug模式选择Release模式；想编译静态库的可以在用CMake生成时取消勾选BUILD_SHARED_LIBS选项即可。:-P） 前言 因为OpenCV-3.2官方的release版只有支持VS2015的库，而且不包括扩展包（opencv_contrib）中的库，而由于某些历史原因，本人目前使用的编译器还是VS2013，又想用用扩展包中一些有趣的算法，在加上上个月opencv-3.3还没有正式release，所以上个月本人就利用VS2013对opencv-3.2进行编译。具体编译过程如下： 准备篇 先在GitHub上下载对应的opencv源码包：opencv-3.2.0和opencv_contrib-3.2.0（https://github.com/opencv ），扩展包版本一定要和opencv版本相同。本人为了添加Qt后端显示支持（为了好看和方便:-P），所以还下载安装了支持VS2013的Qt-5.6.2（http://download.qt.io/archive/qt/ ）。再下载CMake-3.6.3-win64-x64 免安装版（https://cmake.org/files/ ）。至于微软的东西，推荐直接去MSDN 我告诉你去下载。 由于网上有的资料（具体是哪篇文章本人忘记了o(╯□╰)o）说编译时的文件结构可能会影响编译是否成功，再加上为了方便编译管理，本人的编译时的文件结构为： opencv-3.2.0_build├── build└── sources​ ├── opencv-3.2.0​ └── opencv_contrib-3.2.0 4 directories, 0 files 其中opencv-3.2.0用来装opencv-3.2.0.zip解压后的源码；opencv_contrib-3.2.0用来装opencv_contrib-3.2.0.zip解压后的源码；build用来装CMake编译完成后的文件。 编译篇 打开/cmake-3.6.3-win64-x64/bin/cmake-gui.exe，在Where is the source code文本框中选择/opencv-3.2.0_build/sources/opencv-3.2.0；在Where to build the binaris文本框中选择/opencv-3.2.0_build/build，点击Configure，在弹出的编译器选择框中选择Visual Studio 12 2013，一直Configure直到红色的条变白。 网上有人在这一步可能会出现ffmpeg not downloaded和“ippicv_windows_20151201.zip”not downloaded这两个问题，本人没出现这两个问题，所以没有机会验证cmake-gui和vs2013编译opencv和opencv_contrib源码中的解决办法是否正确。 接下来就是添加扩展包，在白色条中找到OPENCV_EXTRA_MODULES_PATH文本框，在其中选择opencv_contrib源码中modeles所在路径：/opencv-3.2.0_build/sources/opencv_contrib-3.2.0/modules。 至于想要支持OpenGL和Qt就需要勾选WITH_OPENGL和WITH_QT并Configure后选择好Qt的安装目录，如果配置好Qt的环境变量Cmake将会自动选择好Qt所在路径。 随后再次反复Configure直到界面不再出现红色背景，之后单击Generate。不出意外的话，你会看到Configure done和Generate done。 本人在这一步出现了VS2013_CMake_opencv3.1动态库与静态库的配置与编译中的问题，原因是同时勾选了同时勾选了BUILD_opencv_world和BUILD_opencv_contirb_world，本人的解决办法是将它们全部取消勾选，再次Configure和Generate。 如果上面一切顺利的话就可以进行下一步了：使用VS2013编译OpenCV。打开/opencv-3.2.0_build/build目录，将会看到一大堆文件和文件夹，双击/opencv-3.2.0_build/build目录下的OpenCV.sln，用VS2013打开。找到CMakeTargets中的INSTALL，然后右键选择“Project Only”–&gt;“Build Only INSTALL”。 漫长的等待。。。。。。(╯﹏╰)b 本人在这一步出现了一个问题，具体问题和解决方法详见问题篇。 一切顺利的话，应该会比本人下面的库多两个，本人最后生成的Debug库为： opencv_aruco320d.lib opencv_bgsegm320d.lib opencv_bioinspired320d.lib opencv_calib3d320d.lib opencv_ccalib320d.lib opencv_core320d.lib opencv_datasets320d.lib opencv_dnn320d.lib opencv_dpm320d.lib opencv_face320d.lib opencv_features2d320d.lib opencv_flann320d.lib opencv_fuzzy320d.lib opencv_highgui320d.lib opencv_imgcodecs320d.lib opencv_imgproc320d.lib opencv_line_descriptor320d.lib opencv_ml320d.lib opencv_objdetect320d.lib opencv_optflow320d.lib opencv_phase_unwrapping320d.lib opencv_photo320d.lib opencv_plot320d.lib opencv_reg320d.lib opencv_rgbd320d.lib opencv_saliency320d.lib opencv_shape320d.lib opencv_stereo320d.lib opencv_stitching320d.lib opencv_structured_light320d.lib opencv_superres320d.lib opencv_surface_matching320d.lib opencv_text320d.lib opencv_tracking320d.lib opencv_video320d.lib opencv_videoio320d.lib opencv_videostab320d.lib opencv_xfeatures2d320d.lib opencv_ximgproc320d.lib opencv_xobjdetect320d.lib opencv_xphoto320d.lib 共41个。 配置篇 因为本人只编译了x86版动态debug库，所以以下环境配置都只针对x86版动态debug库。（其实要配置x64的库就只需将x86换成x64即可；要配置release模式的库就只需在添加附加依赖项中的库文件选择release模式的库（即数字后没有d的lib）；若要配置静态库就需要选择静态库文件夹以及在附加依赖项中添加相应的静态库文件。:-P） 首先把/opencv-3.2.0_build/build/install中的文件都提取出来，这和OpenCV官方release的opencv文件结构差不多，具体两层结构如下 .├── bin│ &ensp;└── opencv_waldboost_detectord.exe├── etc│ &ensp;├── haarcascades│ &ensp;└── lbpcascades├── include│ &ensp;├── opencv│ &ensp;└── opencv2├── LICENSE├── OpenCVConfig.cmake├── OpenCVConfig-version.cmake└── x86​ └── vc12 9 directories, 4 files x86文件夹就是VS2013生成的对应VS版本32位的各种库，include文件夹就是opencv的各项模块。本人将其中提取出的文件全部放入了C:\Program Files\OpenCV\3.2.0\build文件夹中。 首先配置环境变量，系统（或用户）环境变量如下： 变量名 变量值 Path C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin OPENCV C:\Program Files\OpenCV\3.2.0\build 不然可能会报错：程序“XXXXXX”已退出，返回值为 -1073741701 (0xc000007b)。其中下面那行可以选择不要添加。 然后在VS中配置环境。新建工程，然后在“属性管理器”中对应项目下Debug | Win32文件夹右键“添加新项目属性表”。（方便一次配置，多次使用，以后再使用只要在相应项目下右键“添加现有属性表”即可），本人新项目属性表取名为：opencv-3.2.0_msvc2013_x86d.props。 接下来就是真正的VS环境配置了： 双击打开刚才新建的属性表，选中“VC++目录”，注意在进行以下配置时建议都勾选左下角的“从父级或项目默认设置继承” “可执行文件目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin “包含目录”中添加： C:\Program Files\OpenCV\3.2.0\build\include C:\Program Files\OpenCV\3.2.0\build\include\opencv C:\Program Files\OpenCV\3.2.0\build\include\opencv2 “库目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib 选中“链接器” –&gt; “常规”，“附加库目录”中添加： C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib “链接器” –&gt; “输入”，“附加依赖项”中添加C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib中数字后带d的库文件，即编译篇中本人最后生成的41个库文件。 配置完之后不要忘了右键该属性表进行保存处理，以便下个项目直接使用，不需要再重复进行配置。 最后附示例程序： 1234567891011#include &lt;opencv2/opencv.hpp&gt; int main(int argc, char *argv[])&#123; cv::Mat lena = cv::imread("lena.jpg"); //载入图像到Mat，jpg文件和该cpp在同一文件夹 cv::namedWindow("lena"); //创建一个名为 "lean"的窗口 cv::imshow("lena", lena); //显示名为 "lena"的窗口 cv::waitKey(5000); // 只对窗口机制起作用（显示5000ms，随后返回-1，即窗口关闭），若在此期间有按键按下，则马上返回按键的ASCII码。 //system("pause"); return 0;&#125; 这里必须在imshow后加入waitkey，因为WaitKey不止是Wait Key 而已，它其实还涉及到消息响应，有这个函数cv内部的WndProc函数才能起作用，才会更新窗口。 最后程序运行成功并显示lena图，则说明编译和配置没问题。 问题篇1、用VS2013编译OpenCV在漫长的等待阶段出现的问题。 问题描述：CVV模块报错，TS模块编译不出来，好在这两个模块都不是很重要，可以忽略，本人强迫症也没到这种程度O(∩_∩)O~。 解决办法： 在CVV模块报错后可在CMake（不知道具体是INSTALL下的CMake Rules中的INSTALL_force.rule，还是ALL_BUILD下的CMakeLists.txt，忘记了o(╯□╰)o）中添加-DBUILD_opencv_cvv=OFF忽略CVV模块，从而正常编译其它模块。参考errors on build opencv with cvv module and qt5 #577。如果实在不行的话就在CMake生成的时候取消勾选出错模块，若是用CMake重新生成的话不要忘了先把/opencv-3.2.0_build/build目录下的文件全部删除干净。 后记 这是以前写的两篇文档，现在再来整理成一篇。 附录 既然能看到这里，说明是想在VS下使用OpenCV，这里推荐一款VS下OpenCV开发调试神器：Image Watch，效果谁用谁知道。Image Watch是VS的一个插件，不过它只支持VS2012及以上版本。使用方法为先设置断点（F9），随后在调试（F5）模式下，鼠标指针悬停在cv::Mat类型变量上，即可出现，点击查看图标即可显示相应图像。 参考资料[1] cmake-gui和vs2013编译opencv和opencv_contrib源码（http://livezingy.com/category/opencv/ ） [2] VS2013_CMake_opencv3.1动态库与静态库的配置与编译（http://livezingy.com/category/opencv/ ） [3] 使用VS2015编译以及静态编译opencv3记录 [4] errors on build opencv with cvv module and qt5 #577 [5] VS2013中Image Watch插件的使用(OpenCV)（http://blog.csdn.net/fengbingchun/article/category/721609 ）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写上篇文档“GitHub+Hexo搭建个人博客”遇到的问题]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%86%99%E4%B8%8A%E7%AF%87%E6%96%87%E6%A1%A3%E2%80%9CGitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E2%80%9D%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[超链接网址问题 问题描述：使用正常的markdown超链接格式[]()没问题，然而当直接将一个网址链接放入该文档时，它会将该链接后面的文字也当成是该链接的一部分，直接点击链接时，会将后面的文字也放入浏览器地址栏，从而出现网页404错误：404: Page could not be found。 解决办法：在网址链接后输入一个空格以隔开网址链接和后面的文字。 超链接样式问题 问题描述：本人使用的hexo主题是基于spfk主题稍微修改过的，spfk主题能自动修改超链接原有的样式，挺好看的:D，但是当本人在markdown中数字编号列表，即有序列表中添加超链接时，其样式并没有修改，还是普通的超链接样式。 解决办法：没有解决。最后只是跳过了这个问题，就用中文的序号表示列表。 文本段落问题 问题描述：为了使文本有段落感，一般都会在段落首字前空两格，但是在markdown中空两格，用hexo发布后并没有空两格，这使得文档没有段落感，阅读体验有点差。 解决办法：将中文输入法由半角切换至全角，在段落首字前输入两个空格即可。 显示英文尖括号问题 问题描述：由于上篇文档需要在文档中显示&lt;youname&gt;，但由于Hexo可能将其当做一个xml标签处理了，所以发布之后的文档没有显示该文字。 解决办法：首先本人尝试了转义字符\，谁曾想它只出现了一个转义字符，该文字还是没显示，本人差点又要跳过这个问题，将其用另一种表示法了。后来本人想到这最后不是会转为html吗，本人就直接用html中尖括号的表示法不就行啦:p，于是参考HTML语言中括号(尖括号)的字符编码，用&amp;lt;代替&lt;，用&amp;gt;代替&gt;，最后该文字终于出来了。 给文字添加颜色问题 问题描述：本人想给注意事项上的需要注意的问题添加醒目的颜色，但markdown本身不支持给文字添加颜色。 解决办法：由于Hexo最后会将markdown文档转换为html文档发布，所以直接将html标签写进markdown文档，最后自然会出现html样式，本人这里参考CSDN-markdown编辑器语法——字体、字号与颜色，给想要变色的文字添加&lt;font color=#FA8072&gt;&lt;/font&gt;标签。 参考资料[1] HTML语言中括号(尖括号)的字符编码（http://liuxufei.com/weblog/jishu ） [2] CSDN-markdown编辑器语法——字体、字号与颜色（http://blog.csdn.net/testcs_dn ）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub+Hexo搭建个人博客]]></title>
    <url>%2F2017%2F08%2F26%2FGitHub-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64。 前言 本来是想在国内某网站上继续写的，毕竟完全不需要自己管理，只需要负责写好文档就可以了，但某一天，该网站由于响应国家的号召，要实名验证，本来实名验证也没什么，就输入手机号，并填写验证码即可，但该网站实名验证的方式给人的感觉特别不爽，于是就决定自己搭建博客，这样虽然有点麻烦，但由于完全是自己管理，自己完全拥有该文档的所有权，也不用担心哪天别的网站突然出现的各种破问题，相比这种完全自由支配、无比爽快的感觉，管理这种麻烦就是小事了。 GitHub+Hexo个人博客搭建准备篇在GitHub上搭建博客的要求： 1、要有GitHub账号。（没有怎么办，没有就去注册啊） 使用Hexo框架的要求： 1、需要安装node.js。（电脑上没有安装怎么办，没有安装就去下载（https://nodejs.org/en/download/ ）安装啊） 2、需要安装git。（没有安装就去下载安装，附git学习教程） GitHub篇 满足上文的要求之后，就可以开始搭建了，首先在GitHub中新建一个仓库（New repository），在Repository name下填写&lt;yourname&gt;.github.io，其它可默认，点击Create repository。 新建仓库完成后，点击Create new file新建一个README.md文件，随便写点什么，比如“It&#39;s my blog website”。 点击上方横条选项中的Settings，查看GitHub Pages里的设置，上方应该有绿色框，框中“Your site is published at https://&lt;yourname&gt;.github.io”，该网址即为博客主页，Source应该是master branch，自此GitHub上的设置可以算是完成了，但为了方便和防止误删，一般把Hexo文件也放入GitHub中，为方便管理，可以新建另一分支专门放Hexo文件。 在仓库code界面中点击Branch：master，在出现的框中输入hexo新建hexo分支，在branches中Change default branch设置hexo为默认分支。 Hexo篇 将刚才新建的仓库克隆到本地：git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git当前在hexo分支。 在&lt;yourname&gt;.github.io文件夹下执行 12345npm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --save 按这样一连串执行，如果没出问题的话就会在&lt;yourname&gt;.github.io文件夹里生成一个blog文件夹，该文件夹有一大堆Hexo有关的文件。 配置Hexo Hexo的配置文件为blog文件夹中的_config.yml文件。 修改配置文件不要使用windows自带的记事本，本人使用的VS Code，或者Notepad++和Sublime Text 2等编辑器都可以，以防文件编码改变，具体修改如下： 123456789101112131415# Sitetitle: &lt;你的blog名&gt;author: &lt;作者名称&gt;language: zh-CN&lt;网站所用语言，中国大陆选择zh-CN即可&gt;# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://&lt;yourname&gt;.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git branch: master 其它的默认即可，具体参数信息详见Hexo官方文档。 配置git用户信息12git config --global user.name "&lt;yourname&gt;"git config --global user.email "&lt;yourname&gt;@xxxxxx.com" 如果是个人电脑的话推荐加上–global全局参数，因为这样更加方便，如果不加的话，还要在\&lt;yourname&gt;.github.io\blog\.deploy_git\.git中config里加入git用户信息，不然可能提交会出问题，稍显麻烦。 部署Hexo在blog文件夹下执行： 123hexo g #generate 生成静态文件hexo d #deploy 部署网站.部署网站前,需要预先生成静态文件hexo s #server 启动服务器 或者执行： 1hexo g -d 快速部署个人blog。 在浏览器中输入http://localhost:4000/，将会出现Hexo的Hello World界面，更多Hexo命令详见Hexo官方文档。 最后将Hexo文件提交到GitHub远程仓库，具体提交命令为： 123git add .git commitgit push origin hexo 在浏览器中输入https://&lt;yourname&gt;.github.io同样会出现Hexo的Hello World界面，自此整个个人blog的框架已经完全搭好了。 其它篇主题选择 主题可以去官网上的主题界面去找，目前比较受欢迎主题有next和yilia，去别人GitHub上的主题仓库上去下载或clone均可，本人目前用的主题为black-blue，这个主题本人在用的时候还有些问题，或许会换，或许会自己魔改。最后由于术业有专攻，实在不知道该改哪里，所以决定换black-blue的原版主题SPFK ，对照着black-blue对spfk进行修改。具体换主题的方法为： 先将下载好的主题整个放在\blog\themes文件夹中，再修改blog文件夹中的配置文件_config.yml： 12# theme: landscapetheme: black-blue black-blue为打包主题文件并放入\blog\themes文件夹中的文件夹名，并不是原主题名，只是本人恰好将其重命名为主题名。 文章发布发布文章需要在blog文件夹中执行： 1hexo new "test" 将会在\blog\source_posts\文件夹中生成test.md文件，随后编辑test.md文件即可，本人使用的Markdown编辑器为Typora。 至于给文章打标签和分类什么的，请参考Hexo官方文档。 写完文章之后推送到GitHub中，需要执行： 123git add .git commit -m "add test.md"git push origin hexo Hexo文件配置同样需要同步一下： 123hexo ghexo cleanhexo d 插件添加以RSS订阅插件为例。首先安装hexo-generator-feed： 12## rss插件npm install hexo-generator-feed --save 安装成功后，修改blog文件夹中的配置文件_config.yml： 1234# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed #RSS订阅 最后，修改当前主题文件夹中的配置文件_config.yml，添加RSS订阅链接即可： 12subnav: rss: "/atom.xml" 修改完成后，执行 123hexo cleanhexo ghexo d 将会在页面中看到RSS图标。 注意事项1、提交至远程仓库时可能会出现错误。 原因可能是因为没有将SSH Key添加到GitHub中。 查看当前用户主目录下的.ssh文件夹中（windows是C:\Users\&lt;username&gt;\.ssh）是否有id_rsa（私钥）和id_rsa.pub（公钥）这两个文件，若没有，则执行 1ssh-keygen -t rsa -C "youremail@example.com" 在GitHub中添加SSH Key的具体方法为：点击GitHub用户头像下的Settings，选中SSH and GPG keys，点击New SSH key，将id_rsa.pub中的内容复制粘贴到Key文本框中。 2、Hexo生成和部署命令都执行失败。 原因可能是修改配置文件_config.yml出错。 将修改的配置文件_config.yml复原试试。 3、Hexo部署之后网页没变化。 可能需要执行 1hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。 后记 以后就在这上面写blog了，顺便把以前写的一些文档也放上来。 参考资料[1] 利用github+hexo搭建自己的博客（http://blog.csdn.net/u012150360/article/category/6765461 ） [2] Hexo官方文档（https://hexo.io/zh-cn/ ） [3] GITHUB+HEXO博客轻松更换主题外观（http://www.jianshu.com/nb/10649566 ） [4] Hexo—正确添加RSS订阅（http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/ ）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F08%2F26%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
