<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[解决VSCode使用Cmder作为默认终端问题]]></title>
    <url>posts/fd823bf9.html</url>
    <content type="text"><![CDATA[前言 本人最近想换换新口味，想尝试用 Cmder 作为 VSCode 下的默认终端，不想再继续使用 git-bash 了，因为 git-bash 有时会出现一些乱码问题。但是在用 VSCode 集成 Cmder 时出现了几个问题。问题篇 如果在 VSCode 用户设置文件中直接添加 Cmder.exe 及其路径，那么在使用 VSCode 终端时会重新打开一个 Cmder 窗口，而不是直接显示在 VSCode 的「终端」里。本人想要的是 Cmder 就是 VSCode 的终端，就在 VSCode 里，就和原有cmd 终端一样，在 VSCode 下的终端可以直接输入相关命令，而不是另外弹出一个命令行窗口。解决方案篇方法一将 Cmder 放进一个文件夹中，文件夹名不带空格，比如本人所有的绿色软件全部放在 D:\ProgramFiles 下，在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k D:\\ProgramFiles\\Cmder\\vendor\\init.bat"],方法二一部分用户可能有点强迫症 ๑乛◡乛๑，硬是要把绿色软件还放入系统盘中的 Program Files 文件夹里，这样在 VSCode 里配置 Cmder 作为默认终端时就会出现问题。主要是因为 Program Files 文件夹名中有空格（这里吐槽一下带空格的文件名真鸡儿坑爹，命令行中根本无法访问，这应该是巨硬的历史遗留问题了， 特立独行的支持带空格的路径名，想显摆一下自己，但以目前的情况看，这种支持简直无力吐槽，造成了一堆问题，和 Windows 路径名中的 \ 有的一拼，都是逼死现代程序员的设计 _(´ཀ`」 ∠)_）。好了，吐槽的话也就说到这里了，如果配置路径里无法避免 Program Files 文件夹，这里有三种解决方案：Windows 在支持带空格的长文件名的同时，也会分配一个短名称，可以称为该文件夹的别名，通过这个别名就可以在命令行中访问该文件夹，获取这个别名的方法有：在命令行中输入 dir /X ，即可在文件夹名之前的一列的看到该别名，若没有别名则为空白，若要添加别名则需要加入 /N 参数。本人这里显示别名如下：123456789101112$ dir /X 驱动器 C 中的卷是 System 卷的序列号是 XXXX-XXXX C:\ 的目录.........2018/05/16 19:21 &lt;DIR&gt; PROGRA~1 Program Files2018/05/17 15:14 &lt;DIR&gt; PROGRA~2 Program Files (x86)..........由上面可知 Program Files 文件夹的别名为 PROGRA~1，而 Program Files (x86) 文件夹的别名为 PROGRA~2，在配置路径时只需要用别名替换相应的文件夹名即可，如下：123456&#123; "terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe", "terminal.integrated.shellArgs.windows": [ "/k C:\\PROGRA~1\\Cmder\\vendor\\init.bat" ]&#125;通过转义符添加 &quot; &quot; 使 Program Files 作为一个整体，如下：12"terminal.integrated.shell.windows": "cmd.exe","terminal.integrated.shellArgs.windows": ["/k", "C:\\\"Program Files\"\\Cmder\\vendor\\init.bat"],直接在系统环境变量中新建一个变量，将 Cmder 的根目录加进去，如下：变量名变量值CMDER_ROOTC:\Program Files再在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\system32\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k %CMDER_ROOT%\\vendor\\init.bat"]通过以上几种方法（推荐直接使用方法一），就能成功在 VSCode 中集成 Cmder，可以直接在 VSCode 的终端里享受 Cmder 了。后记 没有什么好说的了，该吐槽也已经吐槽完了。方法二本人没试过，只是感觉应该可行，有问题的小伙伴可以在下方留言（这是不可能的，这辈子都不会有人留言的，反正也没人会看到的 ╮(╯▽╰)╭）。以上解决方案全部来自网络，本人只是做个总结记录，万一以后碰到类似问题至少有多种方案可以尝试。参考资料[1] How to use Cmder in Visual Studio Code?[2] Setting Cmder.exe as integrated shell still opens in separate window[3] IntelliJ idea webstrom Visual Studio Code vscode 设置cmder为默认终端 Terminal]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中static用法小结]]></title>
    <url>posts/b93d943b.html</url>
    <content type="text"><![CDATA[前言 static 是 C++ 中很常用的一个关键字，它的用法也很多，时常会将其弄混，索性做个小结，以免以后忘记了或者继续弄混 (｡･ω･｡)。预备篇 首先要了解程序中数据的存储形式，一般而言数据的存储形式有三种：栈区（stack）—— 由编译器自动分配释放，一般用来存放函数的参数值，局部变量的值等；堆区（heap）—— 由程序员分配释放，对应于对象的 new 或 malloc 和 delete 或 free，若程序员忘记释放，则在程序完全退出之后由操作系统回收；静态存储区（static）—— 在编译时由编译器分配，在程序完全退出时由操作系统回收，一般用来存放全局变量和 static 变量。 一般1声明的变量默认（如果变量类型，eg: int, double, … 等，前不加 static 或其它关键字）都是 auto 2的，其一般存放在栈区，生存周期就只在包围其的 { } 内，在包围其的 { } 外就无法使用该变量。而 static 存放在静态存储区，其生存周期是全局的，它要等整个程序完全退出时才会销毁，在程序运行过程中，每次调用 static 变量都保持上一次调用结束后的值。类中篇静态成员变量 类中的静态成员变量被该类的所有实例共享，也可以不通过类的实例使用，在使用时首先需要对其初始化，也必须对其进行初始化，因为类中的静态成员变量只是声明，而且，类中的静态成员变量和普通静态变量一样是在程序初始化的时候分配的，在程序完全退出时由操作系统回收。具体用法如下：12345678class Test&#123;private: static int s_value; // 注意，这里不能初始化！因为其不属于类对象，只属于类作用域，独立于该类的任何实例&#125;;// 在cpp中或类定义体外必须对它进行定义和初始化，因为在程序编译时首先执行的就是对其初始化并分配内存：int Test::s_value = 0; // 注意，这里没有static的修饰！总而言之就是：类中的静态成员变量可以简单理解为一个名为 Test::s_value 的全局变量，被所有该类的实例共用，但独立于该类的任何实例，只属于该类作用域，在类的定义中能且只能被声明，不能在类定义体中进行初始化，必须要在类定义体外被定义和初始化。静态成员函数 类中的静态成员函数和类中的静态成员变量有点类似，其在实现时不需要再加 static 修饰，同样能被该类的所有实例复用，同样只属于类作用域中的全局函数，同样不需要类的实例即可调用。类中的静态成员函数不能访问类的普通成员变量，只能访问类的静态成员变量（可以参考 C++静态成员函数访问非静态成员的几种方法 中的小 trick 访问普通成员变量，但非特殊情况不建议这么做）。具体用法如下：12345678910111213141516class Test&#123; private: static void func(int i); // 静态成员函数调用非静态成员变量方法 static void staticTest(Test *t) &#123; t-&gt;value += 1; &#125;private: int value;&#125;;// 在cpp中可以不通过类的实例进行调用：void Test::func(int);总而言之就是：类中的静态成员函数可以简单理解为一个名为 Test::func(int) 的全局函数，能被该类的所有实例复用，但独立于该类的任何实例，只属于该类作用域，可以不通过类的实例进行调用，也可以像普通成员函数一样通过类的实例进行调用。特定范围篇 为了使全局变量或函数只在特定 cpp 文件中起作用，需要在 cpp 文件中相应变量或函数前添加static 修饰，如下表：类型.h 文件.cpp 文件全局变量不使用 static 修饰，使用 extern 修饰使用 static 修饰全局函数不使用 static 修饰使用 static 修饰如果在头文件中声明 static 全局变量，则在包含该头文件的每个 .cpp 文件中都会生成一个独立的同名变量，而这种写法没有任何意义；如果在 .cpp 文件中不使用 static 声明全局变量，则该全局变量可能会被其它 .cpp 文件共享，也可能不会，造成该变量的不确定性；所以如果该全局变量要被所有 .cpp 文件共享，则需要在头文件中声明 extern 全局变量（eg：extern int g_value; // 注意，不要初始化值！），再在每个 .cpp 文件中单独进行定义和初始化（仅一次）（eg：int g_value = 0; // 不要extern修饰！），如此即可在每个 .cpp 文件中共享该全局变量；而若只想在单个 .cpp 文件中使用全局变量，则需要在该 .cpp 文件中全局范围类声明和定义 static int g_value = 0;，如此可保证该变量能且只能被该 .cpp 文件使用。如果在 .cpp 文件中不使用 static 声明全局函数，则该全局函数可能会被其它 .cpp 文件共享，也可能不会，这样在别的 .cpp 文件调用同名函数时可能会出现问题；而在头文件中使用 static 声明全局函数同样没有任何意义；所以如果要被多个 .cpp 文件复用，就将其声明移到头文件中，且不需要 static 修饰，而若只想在特定 .cpp 文件中使用该全局函数，则需要在声明时添加 static 修饰。最后，若是在 .hpp 文件中，则需要去除全局对象，将全局函数封装为类的静态方法。 PS：若在函数中使用 static 修饰变量，则该函数无法做到线程安全，在程序运行过程中，每次调用该函数，函数内的 static 变量都将保持上一次调用结束后的值，所以在函数中慎用 static 变量，除非需要这个特性。后记 写这篇文章的初衷在于时常需要 static 时老是忘记或弄混它的用法，不得不去网上查找，虽说网上的相关资料也有很多，但在找的时候还是有点麻烦，毕竟有很多不是自己需要的，而且自己总结一下对其理解又更深一些，下次要用时也能马上找到自己所需。参考资料[1] c/c++ static 用法总结（三版本合一）[2] C++中static的用法总结[3] C++ 类中的static成员的初始化和特点[4] C++静态成员函数访问非静态成员的几种方法这里的一般是指局部变量，若为全局变量则默认为 extern ，局部变量没有默认初值，其初值不确定，一般需要人为明确的赋初值，而全局变量默认初值为 0 ，一个比较好的编程习惯是声明一个变量就对其进行初始化（赋初值），尽量少用全局变量，全局变量显示声明 extern。↩※注：这里的 auto 与 C++11 中的意义不同，这里的 auto 指的是变量的存储形式，而不是 C++11 那种可以当做任意的变量类型，eg: int, double, std::vector&lt;std::vector&lt;double&gt;&gt;, …… ，与其对应的还有 extern 和 register 关键字，其中 register 关键字基本不用 。↩]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列的三种写法]]></title>
    <url>posts/8fb9f004.html</url>
    <content type="text"><![CDATA[前言 本文预示着本人开始着手准备找工作的事了，初步计划是先把『剑指Offer』上的题先做一遍，对照着 牛客网 上的题进行测试，尽量争取先把书上的题都能 AC 。一般定义的斐波那契数列数列为：0,1,1,2,3,5,8……（对应 \(F(0)=0, F(1)=1, F(2)=1, \cdots \cdots\)），用数学公式表示即为：\(F(n)=F(n-1)+F(n-2)\)。以下代码均用 C++ 实现，且均通过牛客的测试。循环写法1234567891011int fibonacci_loop(const unsigned int &amp;n)&#123; int fn = 0, f1 = 0, f2 = 1; for (int i = 0; i &lt; n; i++) &#123; fn = f1 + f2; f2 = f1; f1 = fn; &#125; return fn;&#125;递归写法123456789101112131415int fibonacci_recursive(const unsigned int &amp;n)&#123; if (n == 0) &#123; return 0; &#125; else if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2); &#125;&#125; ※注：这里本人在牛客上进行测试的时候，如果把 || n == 2 去掉的话，就没法通过，可见多递归一次花费的时间并不是线性增长的。尾递归写法 说来惭愧，这个概念还是在一个小学弟那里得知的，后面才逐渐了解并学会使用。 尾递归，简而言之就是最后会且仅会调用函数本身，递归调用函数之后没有其它的语句需要执行。就像上面的递归，它在递归调用之后还会执行加法运算，而尾递归在执行递归调用之后就没有其它的运算了。1234567891011int fibonacci_tailRecursive(unsigned int n, unsigned int f1 = 1, unsigned int fn = 0)&#123; if (n == 0) &#123; return fn; &#125; else &#123; return fibonacci_tailRecursive(n - 1, fn, fn + f1); &#125;&#125;总结 循环和尾递归花费的时间和空间都差不多，都要比普通的递归要小，普通的递归优势在于便于理解，代码好写，在不强调性能的前提下，用递归写法的代码可读性可能要好些。参考资料[1] 递归与尾递归总结（http://www.cnblogs.com/Anker/category/436371.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>posts/982ff584.html</url>
    <content type="text"><![CDATA[前言 本人一直以为自己的搜索能力还可以，基本上自己想要的东西都能搜到，但是自从接触到这个世界，才知道自己大概只是个入门的水平（或者说连入门都说不上 /つ∇T)），和网上的一些大神相比还有比较大的差距，此文只是网上一些资料的整理，方便本人熟练使用，提高驾驶技巧，毕竟信息检索能力还是很重要的。搜索篇Google 可以通过添加一些字符优化搜索结果，如：搜索需求对应字符搜索社交媒体在用于搜索社交媒体的字词前加上 @。例如：@twitter。从搜索结果中排除特定字词在您要排除的字词前加上 -。例如：jaguar speed -car搜索完全匹配的结果为字词或短语加上引号。例如：&quot;tallest building&quot;。搜索通配符或未知字词在字词或短语中您要放置占位符的地方加上 *。例如：&quot;largest * in the world&quot;。在某个数字范围内执行搜索在两个数字之间加上 ..。例如：camera $50..$100组合搜索在各个搜索查询之间加上“OR”。例如：marathon OR race搜索特定网站在相应网站或域名前加上“site:”。例如：site:youtube.com或 site:.gov搜索相关网站在已知网址前加上“related:”。例如：related:time.com查找链接到某个特定网页的网页在已知网址前加上“link:”。例如：link:chongbuluo.com，就能查到哪些网页中包含链接chongbuluo.com查找在URL地址里有搜索关键词的页面在已知网址前加上“inurl:”。例如：inurl:chongbuluo，就能查到哪些网页 url 中包含链接chongbuluo查找在网页标题里有搜索关键词的页面在已知网址前加上“intitle:”。例如：intitle:chongbuluo，就能查到哪些网页标题中包含链接chongbuluo查找在网页正文里有搜索关键词的页面在已知网址前加上“intext:”。例如：intext:chongbuluo，就能查到哪些网页正文中包含链接chongbuluo查找pdf,xml,xls,txt,doc,csv等特定格式的结果在特定文件格式前加上filetype:。例如 filetype:pdf查找关键词的定义在关键词前加上define:。例如 define:搜索 经本人实测，以上大部分字符对百度搜索引擎同样适用。当然，最好的搜索方式是使用高级搜索，高级搜索可以进行一系列设置，比如时间范围，从而使搜索结果更精确，更容易得到想要的结果，不过在不十分确定的时候，不要做太多限制，不然可能会过滤掉关键信息。 Google 和百度对英文字符大小写都不敏感，搜索 QQ 与 qq 所得到的结果是一样的。搜索是否成功最关键的地方还是在于关键词的选取，关键词的选取这没什么好说的，只能提高搜索熟练度及对问题的把握程度了。 哦，还有一点忘记说了，就是在 Google 中如果要搜索那个的话，必须要在搜索设置里面关闭安全搜索功能，如果简体中文不能关闭安全搜索功能的话，就在搜索设置里将语言更换到繁体中文或英语应该就能关闭安全搜索功能。技巧篇 有时候第一个页面没有想要的结果，于是需要看第二个、第三个页面的结果，是不是觉得翻页很麻烦？（如果不觉得麻烦可以直接跳过🙄），但是设置增加搜索结果条目又会提高显示延迟，这时可以使用 Super_preloaderPlus_one 脚本（Chrome 中可以使用 AutoPagerize 插件），只需鼠标继续往下滚轮就会自动加载下页搜索结果，无需点击翻页。 当点击网页链接却出现404错误或无法显示页面的错误时，这个时候可以使用搜索引擎的「网页快照」功能，Google的这个功能点击搜索结果页面标题下的 绿色小三角 即可看到，百度的这个叫 百度快照，在搜索结果 url 地址的末端，即结果最后面。快照功能最强大的是 互联网档案馆（Internet Archive），又叫『网站时光倒流机器』（Wayback Machine），在知道链接的情况下，将链接输入到 Internet Archive 点击搜索就能查看历史快照了。 如果要查找某个网页出现的关键词，可以利用 Chrome 和 Firefox 的网页搜索功能，一般可以通过 Ctrl + F 去检索。也可以通过 F12 或「鼠标右键」（Firefox 点击「查看元素」，Chrome 点击「检查」，都是右键弹框最后一个选项）进入浏览器控制台开发工具，Chrome 中还要通过 Ctrl + F 才能检索元素，而 Firefox 可以直接搜索 HTML，输入要查找的关键词，回车即可。专项篇 图像搜索：这个一般用 Google 和百度的以图搜图就可以了，不过也有些特殊的图像搜索引擎，如 TinEye 等，当然，图像搜索最好还是安装相应的插件，在 Chrome 中可以安装一个叫 二箱 的插件，在 Firefox 中可以安装一个叫 Search by Image 的插件。 音乐搜索：这个如果能听出歌词的话就直接去搜索引擎上搜听到的歌词，如果无法听出歌词的话，可以尝试各大音乐软件的「听歌识曲」功能。 当然更精确的专项搜索一般只存在于特定的网站，这就要看对整个互联网的了解程度了，这里强推「虫部落-快搜」，不管是日常搜索需求还是特殊搜索需求基本都能满足。后记 尽量优先使用 Google，百度或许能找到自己想要的，但太浪费时间了，浪费时间就是浪费生命，不过能看到本文的看官，应该也是能熟练使用 Google 的了。参考资料[1] 如何在 Google 中进行搜索(https://support.google.com/websearch/#topic=3081620)[2] 优化网页搜索[3] 提高搜索能力的关键技巧（如何查找可靠出处）[4] 谷歌搜索技巧：搜索语法+隐藏彩蛋+高级设置]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>record</tag>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17年走了，18年来了]]></title>
    <url>posts/7cebf0ee.html</url>
    <content type="text"><![CDATA[17 年走了，18 年也过了一个月，从这一个月看，18 年好像并没有对那个傻逼好一点。 17 年，也算是本人人生的一个转折点吧，既然是转折点，况且人也这么大了，不能像以前那样浑浑噩噩的过了，所以总要留下点什么东西吧。 17 年，从本科升入研究生，学校变了，所在城市却没变，所接触到的人好像变了，也好像没变，人还是那样的人。虽然早知读研是个坑，但还是转身继续扎入象牙塔中，但此时的象牙塔已不再是四年前的象牙塔，如果说四年前的象牙塔是白色的，那现在的就是黑色的，虽然是黑色的，但总比外面无尽的黑暗要好一点吧（或许有一点光明），至少是个塔，至少还稍微有点保护作用（心里安慰罢了）。黑色象牙塔和白色象牙塔最大的区别在于黑色象牙塔里有 boss，更NB的是 boss 拥有生杀予夺的权利，而且这种权利没人监管，也无法申述（或许是本人不知道？），除非有玉石俱焚的决心，否则很难反抗 。进入这黑色的象牙塔是为了逃避黑暗还是大势所趋，本人认为自己或许两者皆有，在这黑色的象牙塔待两年，一来能在将来真正进入黑暗之前稍微接触一点黑暗，做好心理准备，起到一个缓冲的作用；二来能趁这两年提升一下自己，为自己在将来在黑暗中寻找那 些微光明 提供一点帮助，而且外界的黑暗也对黑色象牙塔中走出来的人好像更重视，这样不管是硬实力，还是软实力都能得到提升，这在黑暗中行走就更有的底气了，而且也更会有后劲，这样的话走进光明是不是更容易些？ 17 年，不管是求知方面还是视界方面都得到了一定程度的提升和扩大，或许在外面那无尽的黑暗中能提升的更快，扩大的更多也说不好。要说本人真正进入计算机的世界，应该是在大三上的时候吧，那时候才算是真正入门了，以前只能说是上过计算机的基础课，有什么问题还是没办法解决，还处在混沌阶段，没有方向，只能瞎摸。入门了之后感觉学计算机相关的东西就轻松多了，大多数问题都能找准方向，并一步一步的解决，当然最快的解决方案还是在 Google 上。大四做毕设的时候，从没接触过 OpenCV 的本人，借助网上的资料和书本，花了两个月的时间，还是勉强做了简单的手势识别系统，等以后时间把这个系统还是记录一下吧，好歹这其中基本上把经典计算机视觉中数字图像处理和传统机器学习结合的流程走了一遍，做完这个系统，本人的计算机视觉也算是正式入门了。至于目前火热的深度学习，因为设备的原因，暂时还无法实践，不得不说这是一大憾事。 17年，人或许没接触到更多，但事倒是见得更多了。主要是因为接触到了一些更有趣的世界，或者说圈子，这其中强推 「Solidot」 ，该站点的资讯确实更新的很及时，科技界的一些大事都能及时公布出来，还有一个就是 「虫部落」，其快搜资源的聚合简直无敌了。网络如此之大，不知道还有多少有趣的事物等着本人去发现，每发现这些有趣的东西，就像是找到一个宝藏一样，想想就觉得很开心呢 🙃。 17 年，以一种看客的心态看了很多场戏。番茄界的用户资源之争，人肉的厉害之处，本是同根生，相煎何太急，最后有一人只能黯然退出，不知道是好是坏，毕竟本人也没用过那个工具及其提供的相关服务（或许以后会用到吧），但一家独大总归不是什么好事。在网上看到这样一句话：「鲁迅已逝，阿Q 重生」，『暴走大事件』对时事的调侃虽然很尖锐，但三观基本很正，坚持这样不容易啊，望其能唤醒一些 阿Q 吧。『新浪微博』，可以说是当前中国最大的信息聚合平台了，什么样的东西总能在微博上找到，国内大部分的戏也能在微博上看到，尤其是评论区更是有趣，但其信息和用户太杂了，良莠不齐，信息的价值密度比较低，总而言之，微博这种东西是需要带着脑子去逛的，微博上有些东西，本人无法辨别，但借用鲁迅先生的一句话，「我向来是不惮以最坏的恶意来揣测中国人」。至于『知乎』，『V2EX』等，仁者见仁智者见智吧。 17 年，在网上看到这样一句话：“你可以不关心政治，但政治会来关心你”。政治上的事，无非是民主自由，但出于某些不可描述的原因就不谈了，无知是福 （๑乛◡乛๑）。但知道一些人和政策总是有好处的，虽然暗地里可能会违背，但估计没人敢明目张胆的违背吧，通过知道这些事，总能做点趋利避害的事吧。 17 年，已在实验室待了半年，还好有音乐这种东西可以麻痹一下，不然这两年就难熬喽。17 年，总归还是或知道或学会了很多有趣的东西。世界总的来说还是美好的，但这些美好的东西又有多少人能亲身经历，亲身享受。本人能做的只有向这些美好的东西前进，接近，享受，顺便看看路上的风景，不管是好的还是坏的。17 年获得技能：视界开拓17 年获得成就：打开新世界的大门]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵的应用之图像仿射变换]]></title>
    <url>posts/e124baa1.html</url>
    <content type="text"><![CDATA[前言 好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，本人这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。预备篇 首先需要了解的是图像中坐标系和数学课本中常用的坐标系略有不同，图像中坐标系是以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴；而数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴。所以由图像中坐标 \((x,y)\) 转数学课本中常见的坐标 \((x&#39;,y&#39;)\) 的公式为 $x’ = x - C/2; y’ = -y + R/2; $ 其中 \(C\) 表示原图像总列数，即原图像宽度，\(R\) 表示原图像总行数，即原图像高度。X 轴Y 轴X 轴Y 轴数学坐标系图像坐标系 ※注：值得注意的是因为 MATLAB 和 OpenCV 的像素索引坐标形式为 (行坐标，列坐标) ，所以若以本文这样定的图像坐标，则图像中坐标 \((x,y)\) 对应的像素值为 \(f(y,x)\)。变换篇据 OpenCV 文档所说：一个任意的仿射变换都能表示为 乘以一个矩阵 (线性变换) 接着再 加上一个向量 (平移).综上所述, 我们能够用仿射变换来表示:旋转 (线性变换)平移 (向量加)缩放操作 (线性变换)你现在可以知道, 事实上, 仿射变换代表的是两幅图之间的 关系 .我们通常使用 矩阵来表示仿射变换. 考虑到我们要使用矩阵 和 对二维向量 做变换, 所以也能表示为下列形式: or 而在冈萨雷斯的《数字图像处理_第三版》里有：最常用的空间坐标变换之一是仿射变换，其一般形式如下： \[ \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \textbf{T} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \begin{bmatrix} t_{11} &amp; t_{12} &amp; 0 \\ t_{21} &amp; t_{22} &amp; 0 \\ t_{31} &amp; t_{32} &amp; 1 \end{bmatrix} \] 其中 \((v,w)\) 为原坐标，\((x,y)\) 为变换后的坐标，可根据变换矩阵 \(\textbf{T}\) 中的元素选择的值，对一组坐标点做尺度、旋转、平移或偏移变换。一些常见的变换矩阵及作用如下表：变换名称仿射变换矩阵\(\textbf{T}\)坐标公式恒等变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=w \end{cases}\)尺度变换\(\begin{bmatrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vc_x , \\ y=wc_y \end{cases}\)旋转变换（以逆时针为正）\(\begin{bmatrix} cos(\theta) &amp; sin(\theta) &amp; 0 \\ -sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)-wsin(\theta) , \\ y=vsin(\theta)+wcos(\theta) \end{cases}\)旋转变换（以顺时针为正）\(\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)+wsin(\theta) , \\ y=-vsin(\theta)+wcos(\theta) \end{cases}\)平移变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+t_x , \\ y=w+t_y \end{cases}\)偏移变换（水平）\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_h &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+ws_h , \\ y=w \end{cases}\)偏移变换（垂直）\(\begin{bmatrix} 1 &amp; s_v &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=vs_v+w \end{cases}\)仿射变换的实现由两种方式：一种是 前向映射（Forward Mapping）：直接采用利用原图像坐标 \((v,w)\) 通过 \(\begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}\) 得到变换后的坐标 \((x,y)\)，使用前向映射会导致一些问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的花纹状）；更好的一种方式是采用 反向映射（Inverse Mapping）：扫描输出图像的位置 \((x,y)\)，通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)（其中 \(\textbf{T}^{-1}\) 为 \(\textbf{T}\) 的逆矩阵）计算输入图像对应的位置 \((v,w)\)，通过插值方法决定输出图像该位置的灰度值。 本文这里采取冈萨雷斯的《数字图像处理_第三版》的变换矩阵方式，毕竟所学的矩阵论也是将变换矩阵放在后面作为第二个因子。虽然仿射变换都有现成的 API 可以调用，而且速度一般要比自己写的要快，但是知其然终究也要知其所以然。 下面就以旋转变换为例了，因为尺度变换和平移变换只需要相应的缩放图像即可，而旋转变换不仅需要更改图像大小，还要确定旋转中心，而旋转中心一般以图像中心为标准。旋转变换 旋转变换首先需要确定旋转中心，若以图像左上角为旋转中心，则只需要像做尺度变换和平移变换那样通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\) 做普通的变换即可。而以图像中心为旋转中心，首先需要做坐标变换，将以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴的图像坐标系转换为以图像中心为原点，水平向右为 X 轴，垂直向下为 Y 轴的数学坐标系；再做正常的旋转变换；随后再将数学坐标系转换为图像坐标系，所以图像中心为旋转中心的旋转变换总共需要做三次变换。这里就以图像中心为旋转中心为例，由于有三次变换，所以应该有三个变换矩阵相乘，设 图像坐标系==》数学坐标系的变换矩阵为 T1，旋转变换矩阵为 T2，数学坐标系==》图像坐标系的变换矩阵为 T3，设顺时针旋转角度为 \(\theta\) ，原图像宽度为 \(C\)，高度为 \(R\)，旋转后图像宽度为 \(W\)，高度为 \(H\)，则： \[ T1=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ -0.5C &amp; 0.5R &amp; 1 \end{bmatrix} T2=\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} T3=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0.5W &amp; 0.5H &amp; 1 \end{bmatrix} \] 则旋转变换最终形式为：\(\begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}=\begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix}T1*T2*T3\)。※BTW：旋转变换中，旋转后图像宽度 \(W\)，高度 \(H\) 与 原图像宽度 \(C\)，高度 \(R\) 的关系为： \[ \begin{cases} H = |R*cos(\theta)| + |C*sin(\theta)| , \\ W = |C*cos(\theta)| + |R*sin(\theta)| \end{cases} \]插值篇 因为经过采用反向映射1方式的仿射变换之后，得到的原图像坐标 \((v,w)\) 往往不是整数值，所以无法知道其对应的像素值 \(f(w,v)\)，这时需要采取插值的方式近似估计该坐标位置的像素值。 常用的插值方法有最近邻插值（nearest neighbor interpolation）、双线性插值（bilinear interpolation）和双三次插值（bicubic interpolation），其中双三次插值在保持图像细节方面最好，但花费时间也最多，PS 中的消除锯齿和羽化效果好像就采用了双三次插值。 最近邻插值只考虑相邻最近的像素，双线性插值考虑相邻的 4 个像素点，双三次插值则考虑相邻的 16 个像素点。最近邻插值 最近邻插值最简单，将变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，直接对 \((v,w)\) 进行四舍五入得到相应的整数坐标 \((⌊v+0.5⌋,⌊w+0.5⌋)\)2，用该整数坐标的像素值近似估计 \((v,w)\) 的像素值，令 \(f(y,x)=f(⌊w+0.5⌋,⌊v+0.5⌋)\) ，从而得到变换后图像每个像素点的像素值。双线性插值 双线性插值是线性插值方法的一种扩展，它是 X 和 Y 两个方向上线性插值的组合。X 轴Y 轴P1P2P3P4Z1Z2P(v,w)如上图，设变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，即点 \(P\) 正好处于四个像素点 \(P1(v_0, w_0)\)、\(P2(v_0+1, w_0)\)、\(P3(v_0+1, w_0+1)\)、\(P4(v_0, w_0+1)\) 的中间，其中 \(v_0=⌊v⌋\)，\(w_0=⌊w⌋\) ，点 \(P\) 对应的像素值为 \(f(P)\) 因为双线性插值即在 \(X\) 和 \(Y\) 两个方向进行线性插值，首先计算 \(X\) 方向的插值： \[ \begin{cases} \frac{f(P2)-f(P1)}{P2.x-P1.x}=\frac{f(Z1)-f(P1)}{Z1.x-P1.x} , \\ \frac{f(P3)-f(P4)}{P3.x-P4.x}=\frac{f(Z2)-f(P4)}{Z2.x-P4.x} \end{cases} \] 即： \[ \begin{cases} f(Z1)=\frac{Z1.x-P1.x}{P2.x-P1.x}f(P2)+\frac{P2.x-Z1.x}{P2.x-P1.x}f(P1) =(v-v_0)f(P2)+(v_0+1-v)f(P1), \\ f(Z2)=\frac{Z2.x-P4.x}{P3.x-P4.x}f(P3)+\frac{P3.x-Z2.x}{P3.x-P4.x}f(P4) =(v-v_0)f(P3)+(v_0+1-v)f(P4) \end{cases}\tag{1} \] 然后计算 \(Y\) 方向的插值： \[ \begin{equation} \frac{f(Z2)-f(Z1)}{Z2.y-Z1.y}=\frac{f(P)-f(Z1)}{P.y-Z1.y} \end{equation} \] 即： \[ \begin{equation} f(P)=\frac{P.y-Z1.y}{Z2.y-Z1.y}f(Z2)+\frac{Z2.y-P.y}{Z2.y-Z1.y}f(Z1) =(w-w_0)f(Z2)+(w_0+1-w)f(Z1) \end{equation}\tag{2} \] 结合式（1）和式（2）可得： \[ \begin{equation} f(P)=(v_0+1-v)(w_0+1-w)f(P1)+(v-v_0)(w_0+1-w)f(P2)+(v-v_0)(w-w_0)f(P3)+(v_0+1-v)(w-w_0)f(P4) \end{equation} \] 用矩阵形式可表示为： \[ f(P)=\begin{bmatrix} v_0+1-v &amp; v-v_0 \end{bmatrix} \begin{bmatrix} f(P1) &amp; f(P4) \\ f(P2) &amp; f(P3) \end{bmatrix} \begin{bmatrix} (w_0+1-w) \\ (w-w_0) \end{bmatrix} \] 即： \[ f(y,x)=f(w,v)=\begin{bmatrix} ⌊v⌋+1-v &amp; v-⌊v⌋ \end{bmatrix} \begin{bmatrix} f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) \\ f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) \end{bmatrix} \begin{bmatrix} (⌊w⌋+1-w) \\ (w-⌊w⌋) \end{bmatrix} \]双三次插值X 轴Y 轴P11P(v,w) 如上图，双三次插值需要考虑相邻16个像素（4×4），用双三次插值重采样的图像更平滑并且更能保留图像细节，在这三种插值算法中，双三次插值效果最好，但处理速度最慢。同样设变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，与其左上角相邻最近的 点P11 坐标则为 \((⌊v⌋,⌊w⌋)\) ，该插值方法需要选取一个合适的插值基函数，参照维基百科 Bicubic interpolation 的一般为： \[ W(x) = \begin{cases} (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{for } |x| \leq 1, \\ a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{for } 1 &lt; |x| &lt; 2, \\ 0 &amp; \text{otherwise}, \end{cases} \] 其中 \(a\) 一般取 -0.5 、-0.75 或 -1；则：\(f(y,x)=f(w,v)=A*B*C\) ，其中： \[ A=\begin{bmatrix} W( v-(⌊v⌋-1) ) &amp; W(v-⌊v⌋) &amp; W( (⌊v⌋+1)-v ) &amp; W( (⌊v⌋+2)-v ) \end{bmatrix} \\ B=\begin{bmatrix} f(⌊w⌋-1,⌊v⌋-1) &amp; f(⌊w⌋,⌊v⌋-1) &amp; f(⌊w⌋+1,⌊v⌋-1) &amp; f(⌊w⌋+2,⌊v⌋-1) \\ f(⌊w⌋-1,⌊v⌋) &amp; f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) &amp; f(⌊w⌋+2,⌊v⌋) \\ f(⌊w⌋-1,⌊v⌋+1) &amp; f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) &amp; f(⌊w⌋+2,⌊v⌋+1) \\ f(⌊w⌋-1,⌊v⌋+2) &amp; f(⌊w⌋,⌊v⌋+2) &amp; f(⌊w⌋+1,⌊v⌋+2) &amp; f(⌊w⌋+2,⌊v⌋+2) \end{bmatrix} \\ C=\begin{bmatrix} W( w-(⌊w⌋-1) ) \\ W(w-⌊w⌋) \\ W( (⌊w⌋+1)-w ) \\ W( (⌊w⌋+2)-w ) \end{bmatrix} \]即：\(f(y,x)=f(w,v)= \sum\limits_{row=-1}^2\sum\limits_{col=-1}^2f(⌊w⌋+row,⌊v⌋+col)W(row-(w-⌊w⌋))W(col-(v-⌊v⌋))\)另附：网上也有人中间那个矩阵 \(B\) 是本文中间矩阵 \(B\) 的转置，经过下文实践，感觉效果差不多，但从理论上来说，应该本文这样写才是对的吧🤔。实践篇 本次实践采用 Matlab R2016b，具体 matlab 实现代码为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849clc;clear;close all;img = imread('lena_gray.jpg'); % 读取图像[R, C] = size(img); % 获取图像大小theta = 45 * pi / 180.0; % 旋转角度H = ceil(abs(R*cos(theta)) + abs(C*sin(theta))); % 变换后图像的高度W = ceil(abs(C*cos(theta)) + abs(R*sin(theta))); % 变换后图像的宽度res = zeros(H, W); % 构造结果矩阵。每个像素点默认初始化为0（黑色）T1 = [1 0 0; 0 -1 0; -0.5*C 0.5*R 1]; % 将原图像坐标映射到数学笛卡尔坐标T2 = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; 0 0 1]; % 数学笛卡尔坐标下顺时针旋转的变换矩阵T3 = [1 0 0; 0 -1 0; 0.5*W 0.5*H 1]; % 将数学笛卡尔坐标映射到旋转后的图像坐标T = T1*T2*T3;inv_T = inv(T); % 求逆矩阵% inv_T = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; -0.5*W*cos(theta)-0.5*H*sin(theta)+0.5*C 0.5*W*sin(theta)-0.5*H*cos(theta)+0.5*R 1];for y = 1 : H % 变换后图像的纵坐标，行，高 for x = 1 : W % 变换后图像的横坐标，列，宽 original_coordinate = [x y 1] * inv_T; % 矩阵乘法 v = original_coordinate(1); % 原图像的横坐标，列，宽 w = original_coordinate(2); % 原图像的纵坐标，行，高 % 变换后的位置判断是否越界 if v&gt;=1 &amp;&amp; w&gt;=1 &amp;&amp; v&lt;=C &amp;&amp; w&lt;=R res(y, x) = img(round(w), round(v)); % 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） % ------------- 双线性插值（bilinear interpolation）----------------- left = floor(v); right = ceil(v); top = floor(w); bottom = ceil(w); dC = v-left; % 列偏差 dR = w-top; % 行偏差 res(y, x) = (1-dC)*(1-dR)*img(top, left) + dC*(1-dR)*img(top,right) + (1-dC)*dR*img(bottom, left) + dC*dR*img(bottom, right); % ------------- 双三次插值（bicubic interpolation） ------------------------- if left&gt;=2 &amp;&amp; top&gt;=2 &amp;&amp; left&lt;=(C-2) &amp;&amp; top&lt;=(R-2) img = double(img); MA = [bicubic(1+dC) bicubic(dC) bicubic(1-dC) bicubic(2-dC)]; MB = [img(top-1,left-1) img(top,left-1) img(top+1,left-1) img(top+2,left-1); img(top-1,left) img(top,left) img(top+1,left) img(top+2,left); img(top-1,left+1) img(top,left+1) img(top+1,left+1) img(top+2,left+1); img(top-1,left+2) img(top,left+2) img(top+1,left+2) img(top+2,left+2)]; % MB = MB'; % 求转置矩阵 MC = [bicubic(1+dR); bicubic(dR); bicubic(1-dR); bicubic(2-dR)]; res(y, x) = MA*MB*MC; end end endend;figure, imshow(uint8(res)); % 显示图像BiCubic 基函数 Matlab 代码为：1234567891011121314function W = bicubic(x)%bicubic 双三次插值基函数a = -1; % 默认取a为-1x1 = abs(x);x2 = x1*x1;x3 = x1*x2; if x1 &lt;= 1 W = 1 - (a+3)*x2 + (a+2)*x3;elseif x1&gt;1 &amp;&amp; x1&lt;=2 W = -4*a + 8*a*x1 - 5*a*x2 + a*x3;else W = 0;end 旋转变换中感觉插值的作用没体现出来，以肉眼来看感觉三种插值方法的效果差不多，可能是本人选取的示例不好，为了体现插值效果，应该采用尺度变换（缩放变换）的。以上代码改为尺度变换也简单，自定义图像缩放后的宽高，以两倍为例，H = R * 2; W = C * 2;，再将旋转变换矩阵改为尺度变换矩阵，尺度变换矩阵中 \(c_x=W/C；c_y=H/R\)。为了便于理解，本人对代码就不进行优化了（其实是你懒吧 _(:з」∠)_）。后记 本文算是数字图像处理中最基础的知识了，但本人在写时还是查阅了大量相关的资料，有些地方理解的还不是很透彻，行文思路有点混乱 ╮(╯▽╰)╭。本来是不想使用图片的，但本文不用图片很难理解清楚，又为了不使用外部图，最后只得参考 SVG 教程 和 如何创建SVG箭头和polymarker——marker元素 采用 SVG 绘制相应图片了。等有时间再把用 OpenCV 实现的 C++ 代码也贴上吧。最后再感叹一下 Matlab 确实是做科研的好工具（°Д°）Ъ，吐槽一下 MathJax 排版好痛苦啊，太多需要转义符\的地方了吧。，搞错了 Σ(ﾟдﾟ;)，这主要和 markdown 渲染有关，hexo 默认的 markdown 渲染插件 hexo-renderer-marked 太普通了，有些东西根本没办法渲染或者渲染有问题 （╯‵□′）╯︵┴─┴，本人最后决定使用 hexo-renderer-pandoc 插件渲染 markdown，这样就完美了 (๑•̀ㅂ•́)و✧ 。 至于具体怎么使用 hexo-renderer-pandoc 替换默认的渲染器可参考：如何禁止 hexo 在 html 代码里插入&lt;br&gt;标签?。具体如下：12345# 1、安装 Pandoc，可以不顺带安装 MiKTex# 2、卸载默认渲染器npm uninstall hexo-renderer-marked --save# 3、安装 hexo-renderer-pandocnpm install hexo-renderer-pandoc --save附录 挖的坑总是要填的，呐，这就是用 OpenCV 实现的旋转变换，实现语言为 C++ ：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;opencv2/opencv.hpp&gt;#define M_PI 3.14159265358979323846double bicubic(double x)&#123; // bicubic 双三次插值基函数 int a = -1; // 默认取a为 - 1 double x1 = fabs(x); double x2 = x1*x1; double x3 = x1*x2; if (x1 &lt;= 1) &#123; return 1 - (a + 3)*x2 + (a + 2)*x3; &#125; else if (x1 &gt; 1 &amp;&amp; x1 &lt;= 2) &#123; return -4 * a + 8 * a*x1 - 5 * a*x2 + a*x3; &#125; else &#123; return 0; &#125;&#125;int main(int argc, char *argv[])&#123; cv::Mat img = cv::imread("../Data/lena_gray.jpg", 0); // 以灰度模式读取图片 int R = img.rows; // 获取原图像高度 int C = img.cols; // 获取原图像宽度 double theta = 45 * M_PI / 180.0; // 旋转角度 int H = ceil(fabs(R*cos(theta)) + fabs(C*sin(theta))); // 变换后图像的高度 int W = ceil(fabs(C*cos(theta)) + fabs(R*sin(theta))); // 变换后图像的宽度 cv::Mat res = cv::Mat::zeros(H, W, CV_8UC1); // 构造结果矩阵。每个像素点默认初始化为0（黑色） cv::Mat T1 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1, 0, 0, 0, -1, 0, -0.5*C, 0.5*R, 1); // 将原图像坐标映射到数学笛卡尔坐标 cv::Mat T2 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, 0, 0, 1); // 数学笛卡尔坐标下顺时针旋转的变换矩阵 double t3[3][3] = &#123; &#123; 1, 0, 0 &#125;, &#123; 0, -1, 0 &#125;, &#123; 0.5*W, 0.5*H, 1 &#125; &#125;; // 将数学笛卡尔坐标映射到旋转后的图像坐标 cv::Mat T3 = cv::Mat(3, 3, CV_64FC1, t3); cv::Mat T = T1*T2*T3; cv::Mat inv_T = T.inv(); // 求逆矩阵 //cv::Mat inv_T = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, -0.5*W*cos(theta) - 0.5*H*sin(theta) + 0.5*C, 0.5*W*sin(theta) - 0.5*H*cos(theta) + 0.5*R, 1); for (int y = 0; y &lt; H; y++) &#123; for (int x = 0; x &lt; W; x++) &#123; cv::Mat point = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; x, y, 1); cv::Mat original_coordinate = point * inv_T; // 矩阵乘法 double v = original_coordinate.at&lt;double&gt;(0, 0); // 原图像的横坐标，列，宽 double w = original_coordinate.at&lt;double&gt;(0, 1); // 原图像的纵坐标，行，高 // 变换后的位置判断是否越界 if (v &gt;= 0 &amp;&amp; w &gt;= 0 &amp;&amp; v &lt;= C - 1 &amp;&amp; w &lt;= R - 1) &#123; res.at&lt;uchar&gt;(y, x) = img.at&lt;uchar&gt;(round(w), round(v)); // 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） // ------------ - 双线性插值（bilinear interpolation）---------------- - int left = floor(v), right = ceil(v), top = floor(w), bottom = ceil(w); double dC = v - left; // 列偏差 double dR = w - top; // 行偏差 res.at&lt;uchar&gt;(y, x) = (1 - dC)*(1 - dR)*img.at&lt;uchar&gt;(top, left) + dC*(1 - dR)*img.at&lt;uchar&gt;(top, right) + (1 - dC)*dR*img.at&lt;uchar&gt;(bottom, left) + dC*dR*img.at&lt;uchar&gt;(bottom, right); // ------------ - 双三次插值（bicubic interpolation）------------------------ - if (left &gt;= 1 &amp;&amp; top &gt;= 1 &amp;&amp; left &lt;= (C - 3) &amp;&amp; top &lt;= (R - 3)) &#123; cv::Mat MA = (cv::Mat_&lt;double&gt;(1, 4) &lt;&lt; bicubic(1 + dC), bicubic(dC), bicubic(1 - dC), bicubic(2 - dC)); cv::Mat MB = img(cv::Rect(left - 1, top - 1, 4, 4)); // 提取当前相邻区域16个像素点做插值 MB.convertTo(MB, CV_64FC1); // 变换为浮点型数据 MB = MB.t(); // 求转置矩阵 cv::Mat MC = (cv::Mat_&lt;double&gt;(4, 1) &lt;&lt; bicubic(1 + dR), bicubic(dR), bicubic(1 - dR), bicubic(2 - dR)); cv::Mat result = MA*MB*MC; res.at&lt;uchar&gt;(y, x) = static_cast&lt;uchar&gt;(result.at&lt;double&gt;(0, 0)); &#125; &#125; &#125; &#125; cv::imshow("result", res); // 显示变换后图像 cv::waitKey(0); return 0;&#125; 以上 C++ 代码在 VS2013 下能完美运行，不管是用 OpenCV-2.4.11 还是 OpenCV-3.2.0。其实完全理解的话，不管用什么工具都能实现，只是看哪个工具方便一点而已，就这个而言，感觉 Matlab 要方便很多，本人就不继续挖 Python 的坑了，毕竟如果要用 Python 实现其实还是用 OpenCV，只是用 OpenCV Python 版的接口而已。参考资料[１] 第4章 图像几何变换[２] 图像旋转原理及实现[３] 仿射变换（http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html）[４] 图像处理常用插值方法总结[５] Wikipedia Bilinear interpolation[６] 双线性插值算法的详细总结[７] Wikipedia Bicubic interpolation[８] 双三次插值(bicubic interpolation)原理及MATLAB源码实现[９] 图像缩放】双立方（三次）卷积插值（https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95）为啥不说前向映射呢？这是因为若原图像坐标 \((v,w)\) 通过前向映射方式得到变换后图像的坐标 \((x,y)\) ，而且这个坐标为小数的话，一般采用四舍五入的方式得到变换后图像对应的整数坐标 \((⌊x+0.5⌋,⌊y+0.5⌋)\)，令 \(f(⌊y+0.5⌋,⌊x+0.5⌋)=f(w,v)\) 。↩\(⌊x⌋\) 表示向下取整，称为 Floor，指的是小于或等于 \(x\) 的最大整数；\(⌈x⌉\) 表示向上取整，称为 Ceil，指的是大于或等于 \(x\) 的最小整数，\(eg：⌊5.6⌋ = 5，⌊-5.6⌋ = -6；⌈5.6⌉ = 6，⌈-5.6⌉ = -5。\)↩]]></content>
      <categories>
        <category>Study</category>
        <category>DigitalImageProcessing</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本人常用小工具安利]]></title>
    <url>posts/aef52be2.html</url>
    <content type="text"><![CDATA[前言 由于本人目前使用最多的是 Windows 系统，所以以下推荐的软件基本都是 Windows 下的软件，全凭本人主观感觉推荐，也算是个人备份吧。 首先推荐的自然是装机软件 ULTRAISO，下个绿色版就好，只有 1M 多一点 或者 Rufus 好像也不错。下载 Windows 镜像的地方推荐为：MSDN，I Tell You。接下来就是正式的软件推荐篇了：大众篇 首先推荐浏览器：首选的自然是 Chrome 和 Firefox，还有一个比较偏门的是 Tor Browser（如果在一些特殊时段，各种番（fang）茄（qiang）工具都失效的情况下，这个可以临时用用）。推荐完浏览器，自然也要玩浏览器，这里极为推荐的是脚本管理插件：Tampermonkey（支持多种浏览器），有 Tampermonkey 和没 Tampermonkey 是两种浏览体验，会用 Tampermonkey 和没用 Tampermonkey 的是两个世界的人（ᖗ乛◡乛ᖘ），除了 Tampermonkey，使用 Stylish 插件也还可以，Tampermonkey 是通过 Javascript 改变浏览器，而 Stylish 是通过 CSS 改变浏览器，这两者本人选择 Tampermonkey，所以顺便推荐几个常用的脚本：1、护眼脚本；2、Super_preloaderPlus_one；3、解除百度云大文件下载限制（这个配合 IDM 食用效果最佳）；4、贴吧全能助手；5、破解VIP会员视频集合；6、Cat Mouse Translation；7、解除B站区域限制；8、bye-flash-hello-html5 | 再见flash 你好html5；９、网页限制解除(改)。再顺便说一下这两个浏览器中一些比较好用的插件和好看的主题吧。Firefox 最新版的插件本人目前还没发现几个好用的，但是 Adblock Plus 绝对是必须要装的，Firefox 的主题本人目前在用为 Blue space 2 ；而 Chrome 中好用的插件就有很多了，首先自然也是 Adblock Plus，有一个 AutoPagerize 插件可以替代 Super_preloaderPlus_one 脚本，还有一个 划词翻译 可以替换 Cat Mouse Translation 脚本，由于 Chrome 没有撤销关闭的标签按钮，只能通过快捷键 Crtl+Shift+T 操作，对于本人这种习惯用 Firefox 恢复按钮的人来说这很不人性化，所以只能使用 SimpleUndoClose 插件来代替了，当然番茄之所以推荐使用 Chrome 有很大一部分原因在于 Chrome 中有一代理神器 Proxy SwitchyOmega，好像也正在开发 Firefox 版的 Proxy SwitchyOmega，已经在 Firefox 测试版上使用了，Chrome 的主题本人目前在用的为 Blue Space Sunset Chrome Theme ，浏览器相关的东西就推荐到这里了，接下来推荐下载工具吧。附浏览器使用小技巧，有时点击链接不会新建标签页，只是在原标签页刷新，这不符合国人的使用习惯，这时可按住 Crtl 键再点击链接，这时会强制使用新标签页打开链接。 下载工具首推的自然是 IDM，全称是：Internet Download Manager；种子和磁力链接的下载工具推荐 μtorrent 或者 BitTorrent，好像还有一个 qBittorrent ；至于迅雷，勉强推荐个极速版吧，最后一版为 ThunderSpeed1.0.35.366。还有一款免费的下载工具 Free Download Manager 也还不错，可以一定程度上替代 IDM。 解压缩工具首推的是 Bandizip（ta家的图片浏览器 Honeyview 也还不错），其次 7-Zip，最后是 WinRAR（主要是最近版本的广告太恼火，好像 5.2 版本没广告），BTW：IDM 下载百度云的大文件可能会造成部分文件损坏，这时可能需要 WinRAR 的修复工具去修复受损的压缩文件（具体操作为用 WinRAR 打开损坏的压缩文件，选中菜单栏的“工具”==》“修复压缩文件”），才能解压出正常文件。※附：其实 WinRAR 官方也有无广告版的，只是下载链接被隐藏，这位大佬：武文隹山发现了，具体可参考：WinRAR官方不带弹窗广告的简体中文版，其隐藏的链接为：WinRAR5.4官方无广告简体中文版64位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exeWinRAR5.4官方无广告简体中文版32位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exeWinRAR5.5官方不带弹窗广告的简体中文版，具体链接为：WinRAR v5.50 简体中文官方版（试用版，注册后没有广告弹窗！）32位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/wrar550sc.exe64位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/winrar-x64-550sc.exe列位看官应该从下载链接中发现了其中的规律（๑乛◡乛๑）。 拼音输入法，本人使用的是 搜狗拼音智慧版，搜狗拼音的皮肤本人选择 雨后莲色，不过有人说 Win10 自带的微软拼音也还行。 至于清理垃圾的可以用 Advanced SystemCare（ASC），也可以用 CCleaner ，至于 Win10 不需要装杀毒软件，国内的的什么 360 全家桶、百度全家桶、腾讯全家桶（诶，好像就差阿里全家桶了，什么时候阿里再来一个，就装个 BAT 全家桶 （๑乛◡乛๑））可以丢了 （(╯°□°）╯︵ ┻━┻）。 QQ 还是用 TIM 版吧。 播放器推荐的是 Potplayer。不过有一款解码工具叫 终极解码，可以充当播放器（很多人确实把它当播放器用，比如本人（๑乛◡乛๑））。 音乐软件本人用 网易云音乐（等升到 10 级就把它卸了，只听本地音乐）。 PDF 阅读器还是推荐 Adobe Acrobat_DC，毕竟能和 Office 联合使用，有时 Word 转 PDF 需要加密就靠它了。 截图工具推荐 FastStone Capture（FSCapture），国人的 Snipaste 也非常不错。小众篇 远程控制工具当然推荐 TeamViewer。 文件管理相关强推 搜索工具 Everything 和文件资源管理器（即 Windows 快捷键「Win+E」打开的「我的电脑」）增强工具 Listary （有个开源实现的同类产品 Wox ），这两个工具有重叠的地方，如果硬要只装一个的话推荐后者。还有一个文件管理器增强工具 QTTabBar ，可以为文件管理器增加标签页，类似于浏览器标签页那种，当然还有其它一些功能。当然 Windows 下最强的文件管理器当属 Total Commander，只是学习成本略高。 快捷键程序快速启动工具 RunAny ，修改配置文件可以通过快捷键快速启动任意程序，以任意程序打开文件，该工具集成 Everything 和支持 AutoHotkey 热键格式。 Office Tabs 给 Microsoft Office 添加标签页界面，类似于浏览器标签页那种，以实现文档快速切换。再推荐一些程序员的工具吧。 首先当然是编辑器（可别和编译器搞混了），本人就不加入 Vim 和 Emacs 的党争了，就直接推荐 VS Code吧（巨硬出品，必属精品（^_^））。 Windows 下的命令行没一个好用的，要真矮子里面挑高个的话，只能推荐 Git Bash 了，其实以前有个 Babun 也挺好用的，可惜早已停止更新。但是 Git Bash 有时输出中文会乱码，Windows 下真正的命令行神器是 Cmder，完整包直接集成 Git for Windows，也就是包含 Git Bash，mini 包只包含基本命令行工具，关于 Cmder 的一些设置和用法可参考 Win下必备神器之Cmder 。 Markdown 编辑器推荐的是 Typora，不过现在还是 Beta 版，也还能使用，期待正式版，希望到时即使收费的话也能继续推出一个免费版。（推出正式版看看效果怎么样吧，如果真的很不错就去支持一下，如果改进不大的话我还是老老实实继续用 beta 版吧）。 在 VS 下写 C++ 自然少不了 Visual Assist X 这款插件，用 OpenCV 的自然少不了 ImageWatch（ VS2017版ImageWatch ）这款神器。 编程的字体本人目前在用是 Arial monospaced for SAP(优化版)（http://www.vimer.cn/archives/396.html/comment-page-1），背景颜色使用护眼色：R: 204，B: 207，G: 232。 代理工具：本人使用的是 XX-Net 和 Lantern，非特殊情况还是很好用的，还有比较推荐的是 赛风。偏门篇 鼠标手势软件 WGestures，可以利用鼠标手势做一些前进后退，复制粘贴搜索等简单操作。 Tickeys，让打字发出音效。 Windows 系统优（mei）化工具 Dism++ ，桌面美化工具可以用雨滴桌面 Rainmeter，或软媒魔方绿色版（※注：软媒魔方一定要是绿色版），桌面美化工具需要占用一定的配置，配置不高的老电脑还是别用比较好。后记如果以后碰到更多有意思的小东西再和大家分享吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决无法打开某个网页问题]]></title>
    <url>posts/376168c6.html</url>
    <content type="text"><![CDATA[前言 本人最近在某台 Win10 的电脑中打开网页 https://www.typora.io/ 时出现了问题，一直出现无法连接现象。问题篇Chrome 中出现：未连接到互联网请试试以下办法：检查网线、调制解调器和路由器重新连接到 Wi-Fi 网络运行 Windows 网络诊断DNS_PROBE_FINISHED_NO_INTERNETFirefox 中出现：我们无法连接至 www.typora.io 的服务器。 如果确定此网址正确，您可以尝试：过会儿再重试。检查您的网络连接是否正常。如果您部署有网络防火墙，请检查 Firefox 是否已被授权访问网络。手机和其它设备在同一网络下能正常连接，打开 host 文件也没发现域名被劫持的情况，挂代理也能连接上。解决方案篇本人尝试过的方法：刷新 DNS 缓存：在命令行界面中输入 ipconfig /flushdns，无效；改 DNS 服务器：把电脑的 dns 修改为首选 8.8.8.8，备用 114.114.114.114，和将首选改成 8.8.4.4 均无效；Disable Path MTU discovery，具体操作方法为：单击“开始”，单击“运行”，键入 regedit，然后单击“确定”。在注册表中找到下面的项： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters找到EnablePMTUDiscovery，将其值改为 0，如果没找到，则在“编辑”菜单上，指向“新建”，然后单击“DWORD 值”，键入 EnablePMTUDiscovery，然后按 Enter，在“编辑”菜单上，单击“修改”，在“数值数据”框中，键入 0，然后单击“确定”。退出注册表编辑器，然后重新启动计算机。设置 MTU 值，将其调小，完美解决。具体操作方法为：以管理员身份运行命令提示符，在命令行界面输入 netsh interface ipv4 show subinterfaces，查看传入字节和传出字节的接口，修改对应接口的 MTU 的值，具体命令为：netsh interface ipv4 set subinterface &quot;对应接口名&quot; mtu=值 store=persistent，其中 对应接口名 和 值 需要替换成相应修改的东西。后记 将 MTU 值调小，可能会造成网速变慢，但本人又无法去改变其它的东西，既然不能改变其它，只能改变自己喽 ╮(╯﹏╰)╭。但本人这里觉得奇怪的是：别人的电脑设置默认 MTU 的值为 1500 也能访问啊，无奈 （╯‵□′）╯︵┴─┴。参考资料[1] 电脑上部分网页打不开，但是手机可以，如何解决？[2] mtu值怎样设置才网速最快]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5使用小结]]></title>
    <url>posts/5f54aa2c.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，PyQt5 版本为 pyqt5-5.9.1，OpenCV 版本为 opencv-python-3.3.0.10 和 opencv-contrib-python-3.3.0.10，TensorFlow 版本为 tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 本文是上一篇（TensorFlow Object Detection API使用小结）的后续，因为那个 project 还需要一个界面，所以本人使用 PyQt 做了这么个界面，其中借用 OpenCV 的图像数据显示。准备篇 首先使用 pip 安装所需库，由于上一篇已经安装了 tensorflow，所以本文其实只需要安装 pyqt5 和 opencv-python 就可以了，安装 pyqt5 指令为：pip install pyqt5，相关依赖关系解决办法在上一篇中已提到，这里不再赘述，然后再使用指令 pip install opencv-python 安装 opencv，这里本人发现在 python 中配置 OpenCV 简直不要太轻爽 O(∩_∩)O~~，就一个 pip 就解决了，哪有 C++ 那么麻烦，以后可能还会继续使用 python 版的 opencv，所以就顺便把它 python 版的扩展包也顺便一起装上，安装指令为：pip install opencv-contrib-python。至此所需环境库安装完毕。 ※注：相对于上文中使用 pip 在线安装的方式，还有另一种使用 pip 进行离线安装的方式，在 Unofficial Windows Binaries for Python Extension Packages上下载离线包，即 XXXXXX.whl 文件，文件名一般包含库名称和对应版本、python 版本以及是 64 位还是 32 位的等信息，这里以离线包 numpy-1.13+mkl 为例，首先下载适合自己的库版本，适合本人的当然是 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl（这适合 64 位的 python3.6 安装），将命令行目录切换至 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 文件所在目录，输入指令 pip install numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 即可离线安装 numpy-1.13+mkl 库。相比在线安装，这种离线安装更加灵活，而且能够安装一些在线安装无法安装的库，像上文中的 numpy-1.13+mkl 库只能采取离线安装的方式，在线安装只能安装不带 mkl 的 numpy 库。采用离线安装方式也可以直接安装带扩展包的 opencv-python库：opencv_python‑3.3.1+contrib‑cp36‑cp36m‑win_amd64.whl ，不需要像在线安装那样装两个库。实践篇 以前有用过 Qt 的基础，所以这次使用 PyQt5 感觉上手很快，毕竟这里面的语法有很多是相通的，再加上网上的资料也有很多，所以很快就做了个简陋的界面。不过直接用代码控制界面的布局确实很麻烦，每改下布局都要重新运行一下看看，而且启动时间还有点长 ╮(╯﹏╰）╭。网上有种说法是：可以先通过QtDesigner设计UI，然后通过Qt提供的命令行工具pyuic5将.ui文件转换成python代码，具体用法是：若ui文件名称为firstPyQt5.ui，则在命令行界面中输入指令：pyuic5 -o firstPyQt5.py firstPyQt5.ui，即可将firstPyQt5.ui文件转换成python代码文件firstPyQt5.py不过本人这里由于界面比较简陋，没有几个控件，所以就直接将其用 python 代码控制了，没去尝试这个命令行工具 pyuic5 了，下次有机会再尝试吧 ↖(^ω^)↗。 本人做的这个小界面实现的功能是：1、可以选择已经训练好的模型来检测选定图片中的目标；2、可以播放选定的视频；3、还有打开摄像头，显示摄像头拍摄的视频。其中由于本人电脑无法实时检测目标，所以在视频和摄像头拍摄中就没有添加检测的代码，只有选择图片时才会执行检测功能，有需要的童靴可以自行添加(•̀ᴗ•́)。附完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import osimport sys from PyQt5.QtCore import * from PyQt5.QtWidgets import *from PyQt5.QtGui import * import numpy as npimport cv2import tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = './model/hand_model_faster_rcnn_resnet101.pb' # 选择模型文件 self.PATH_TO_LABELS = r'./model/hands_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() # 加载模型 self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) return imageclass DetectUI(QWidget): def __init__(self): super().__init__() self.initUI() self.detector = Detector() self.cap = cv2.VideoCapture() def initUI(self): self.timer = QTimer(self) # 初始化一个定时器 self.timer.timeout.connect(self.showFrame) # 计时结束调用showFrame()方法 self.show_pic_label = QLabel(self) self.show_pic_label.resize(640, 480) self.show_pic_label.move(10, 10) self.show_pic_label.setStyleSheet("border-width: 1px; border-style: solid; border-color: rgb(255, 170, 0);") self.show_filename_lineEdit = QLineEdit(self) self.show_filename_lineEdit.resize(200, 22) self.show_filename_lineEdit.move(10, 500) self.select_img_btn = QPushButton('Select File', self) self.select_img_btn.clicked.connect(self.selectImg) self.select_img_btn.resize(self.select_img_btn.sizeHint()) self.select_img_btn.move(218, 500) self.open_camera_btn = QPushButton('Open Camera', self) self.open_camera_btn.clicked.connect(self.openCamera) self.open_camera_btn.resize(self.open_camera_btn.sizeHint()) self.open_camera_btn.move(292, 500) self.select_model_btn = QPushButton('Select Model', self) self.select_model_btn.clicked.connect(self.selectModel) self.select_model_btn.resize(self.select_model_btn.sizeHint()) self.select_model_btn.move(366, 500) self.show_modelname_lineEdit = QLineEdit(self) self.show_modelname_lineEdit.setText('hand_model_faster_rcnn_resnet101.pb') self.show_modelname_lineEdit.resize(200, 22) self.show_modelname_lineEdit.move(450, 500) self.setGeometry(200, 100, 660, 530) self.setWindowTitle('Hand Detector') self.show() def showImg(self, src_img, qlabel): src_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2RGB) # src_img = self.detector.detect(src_img) # 检测目标 height, width, bytesPerComponent = src_img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(src_img.data, width, height, bytesPerLine, QImage.Format_RGB888) qlabel.setPixmap(QPixmap.fromImage(q_image).scaled(qlabel.width(), qlabel.height())) def showFrame(self): if(self.cap.isOpened()): ret, frame = self.cap.read() if ret: self.showImg(frame, self.show_pic_label) else: self.cap.release() self.timer.stop() # 停止计时器 def selectImg(self): if self.cap.isOpened(): self.cap.release() file_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "Image Files (*.jpg *.png *.bmp *.tif);;Video Files (*.avi *.mp4)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 # print(file_name,file_type) if file_type.find("Image") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) img = cv2.imread(file_name, cv2.IMREAD_COLOR) cv2.cvtColor(img, cv2.COLOR_BGR2RGB, img) img = self.detector.detect(img) # 检测目标 height, width, bytesPerComponent = img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888) self.show_pic_label.setPixmap(QPixmap.fromImage(q_image).scaled(self.show_pic_label.width(), self.show_pic_label.height())) if file_type.find("Video") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) self.cap.open(file_name) self.timer.start(30) # 设置时间隔30ms并启动 def openCamera(self): self.cap.open(0) # 默认打开0号摄像头 self.timer.start(30) # 设置时间隔30ms并启动 def selectModel(self): model_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "model Files (*.pb);;All Files (*)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 if model_name: self.show_modelname_lineEdit.setText(os.path.split(model_name)[1]) self.detector.PATH_TO_CKPT = model_name self.detector.detection_graph = self.detector._load_model() # 重新加载模型 if __name__ == '__main__': app = QApplication(sys.argv) dtcui = DetectUI() sys.exit(app.exec_())后记 初次使用 Python 做一个小东西，其语法确实简洁，不过对于本人这种习惯用 C++ 的人来说确实还有点不太习惯 (˘•ω•˘)。参考资料[1] 用PyQt5+Caffe+Opencv搭建一个人脸识别登录界面[2] PyQt5学习笔记09—-标准文件打开保存框QFileDialog[3] PyQt5教程——第一个程序（2）（http://www.cnblogs.com/archisama/tag/PyQt5/）[4] PyQt5应用与实践[5] PyQt5系列教程(二)利用QtDesigner设计UI界面（http://www.cnblogs.com/tkinter/tag/pyqt5/）[6] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Images[7] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Videos[8] python3.3 分割路径与文件名 小例]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>python</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Object Detection API使用小结]]></title>
    <url>posts/82d3b275.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，TensorFlow 版本为tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 很久没写过东西了，主要原因是最近研究生课程开始陆续结课，本人也要忙于应付各种结课时的考试、论文、project 等一堆麻烦事。这不深度学习结课时需要做个 project，本人也顺便将做这个 project 的过程记录下来。准备篇 该 project 主要利用 TensorFlow 中的 Object Detection API 进行训练和检测。在开始使用该 API 之前需要安装配置 Python 环境。 既然是 Python 首先需要 下载安装Python，安装完之后，为了顺利使用 pip 需要配置环境变量，在 Windows 系统环境变量中 Path 末尾添加：变量名变量值Path;C:\Users\admin\AppData\Local\Programs\Python\Python36\; C:\Users\admin\AppData\Local\Programs\Python\Python36\Scripts\其中 C:\Users\admin\AppData\Local\Programs\Python\Python36 为 python-3.6.2 默认安装目录。 然后为了方便使用命令行工具，下载安装git，安装方式一路默认即可。 接下来利用 pip 安装 TensorFlow，鼠标右键桌面空白处，点击“Git Bash Here”，打开 bash 命令行，输入 pip install tensorflow，其中一些依赖关系可能需要手动解决，手动解决的办法就是用 pip install 相关依赖库，这是 CPU 版的 TensorFlow，若要使用 GPU，则需要安装 GPU 版的 TensorFlow，安装命令为：pip install tensorflow-gpu，以同样方式解决依赖关系。由于本人电脑没 N 卡，所以没安装 GPU 版的 TensorFlow，所以如果想使用 GPU 版的 TensorFlow 请另行尝试。 然后安装 TensorFlow Object Detection API 依赖库，在命令行中输入：1234pip install pillowpip install lxmlpip install jupyterpip install matplotlib 因为 tensorflow 并没有默认自带 Object Detection API，所以该 API 需要自行下载，下载地址为：https://github.com/tensorflow/models ，下载之后解压，本人解压目录为：D:\ProgramFiles\PythonLibs\tensorflow，解压完之后需要配置环境目录，在系统环境目录中添加：变量名变量值PYTHONPATHD:\ProgramFiles\PythonLibs\tensorflow\models; D:\ProgramFiles\PythonLibs\tensorflow\models\research; D:\ProgramFiles\PythonLibs\tensorflow\models\research\slim; 下载配置 Object Detection API 完之后需要安装 Protoc，进入 Protoc下载页，下载 protoc-3.4.0-win32.zip，解压之后将 bin 文件夹内的 protoc.exe 拷贝到 C:\windows\system32 目录下（用于将 protoc.exe 所在的目录配置到环境变量当中）,当然也可以在系统环境变量 Path 中添加该 bin 文件夹路径。 最后在命令行中切换目录至：D:\ProgramFiles\PythonLibs\tensorflow\models\research 文件夹，即 object_detection 文件夹所在目录，在命令行中输入：1protoc object_detection/protos/*.proto --python_out=.编译 object_detection/protos 文件夹下的 proto 文件，生成对应的 python 文件。 至此，Windows 下 TensorFlow中 的 Object Detection API 的使用配置全部完成，至于 Ubuntu 下的配置可参考其官方文档。 至于如何验证，可以在命令行中切换目录至 object_detection，输入：jupyter notebook，稍等一会，浏览器将自动打开 http://localhost:8888/tree jupyter 界面，点击 object_detection_tutorial.ipynb 文件，进入打开的新标签，点击“Cell”中的“Run All”，耐心等待几 ~ 十几分钟（因为它需要下载相应的模型），将会在浏览器下方显示检测结果。 截止本文完成前，该API公开的有以下几个模型：Model nameSpeed (ms)COCO mAP1Outputsssd_mobilenet_v1_coco3021Boxesssd_inception_v2_coco4224Boxesfaster_rcnn_inception_v2_coco5828Boxesfaster_rcnn_resnet50_coco8930Boxesfaster_rcnn_resnet50_lowproposals_coco64Boxesrfcn_resnet101_coco9230Boxesfaster_rcnn_resnet101_coco10632Boxesfaster_rcnn_resnet101_lowproposals_coco82Boxesfaster_rcnn_inception_resnet_v2_atrous_coco62037Boxesfaster_rcnn_inception_resnet_v2_atrous_lowproposals_coco241Boxesfaster_rcnn_nas183343Boxesfaster_rcnn_nas_lowproposals_coco540Boxes 根据上述模型可推知，利用该 API 可能只能训练 Faster-RCNN、R-FCN 和 SSD 三种算法的模型。接下来介绍如何使用该 API 来训练自己的模型进行物体检测。实践篇数据准备篇 既然要训练自己的模型，当然要准备相应的数据，而 TensorFlow 有其独特的输入数据格式 TFRecord，所以通常还要将自己的数据转换成 TFRecord 格式以输入 TensorFlow 中进行训练。以 datitran/raccoon_dataset 数据集为例，该作者在 Google image 上收集了 200 张 Raccoon 图片，用 LabelImg 对这些图片进行标记，并将标记以 PASCAL VOC 格式保存为 xml 文件。作者在文中也提到了另一个图片标记工具 FIAT (Fast Image Data Annotation Tool) 。保存为 PASCAL VOC 格式的 xml 文件之后，可以使用 object_detection 文件夹中的 create_pascal_tf_record.py 文件将数据转化为 TFRecord 格式，用法为：123./create_pascal_tf_record --data_dir=/home/user/VOCdevkit \ --year=VOC2012 \ --output_path=/home/user/pascal.record当然也可以使用 datitran 作者提供的 xml_to_csv.py 文件将 xml 文件先转化为 csv 文件，再利用 generate_tfrecord.py 文件将 csv 文件转化成 TFRecord 格式文件。 注意，使用 xml_to_csv.py 和 generate_tfrecord.py 其文件结构应该是这样的：.├── annotations├── generate_tfrecord.py├── images└── xml_to_csv.py2 directories, 2 files其中 images 文件夹存的是 jpg 图片，annotations 文件夹存的是 xml 标签文件。generate_tfrecord.py 文件中的：12345def class_text_to_int(row_label): if row_label == 'raccoon': return 1 else:None其中的 raccoon 注意要改成自己的类别标签。如此，数据的问题就解决了。训练篇 然后就是正式开始训练了，以 Faster-RCNN 算法为例。首先准备相应的数据，本人准备的数据文件结构如下：TensorFlowObjectDetectionAPITest├── data│ ├── model.ckpt.data-00000-of-00001│ ├── model.ckpt.index│ ├── model.ckpt.meta│ ├── object_label_map.pbtxt│ ├── test.record│ └── train.record├── eval├── eval.py├── export_inference_graph.py├── faster_rcnn_resnet101_coco.config├── model├── train└── train.py4 directories, 10 files其中，TensorFlowObjectDetectionAPITest 为项目文件夹，该 project 在此文件夹下运行；data 文件夹中三个 model.ckpt 文件：model.ckpt.data-00000-of-00001、model.ckpt.index 和 model.ckpt.meta 来自 faster_rcnn_resnet101_coco 模型，用来初始化网络参数；object_label_map.pbtxt 文件内容如下：item { ​ id: 1 ​ name: ‘raccoon’ }将其中的 raccoon 改成自己的类别标签，如果有多个类别标签则可以参考 object_detection\data 文件夹中的 pascal_label_map.pbtxt 文件格式；test.record 和 train.record 是生成的 TFRecord 数据，分别为待输入的测试数据和训练数据；eval 文件夹为空文件夹用来输出测试结果；train 文件夹为空文件夹用来输出训练结果（包括checkpoint文件和最终的模型文件）；faster_rcnn_resnet101_coco.config 为配置文件，包括各种参数和输入输出数据的配置，其来自 object_detection\samples\configs 文件夹中 faster_rcnn_resnet101_coco.config 文件，在使用时需对其做如下修改：首先是 num_classes，这是待检测的类别数目，如果只要检测一种，则将其值改为 1；fine_tune_checkpoint: &quot;PATH_TO_BE_CONFIGURED/model.ckpt&quot;，将 PATH_TO_BE_CONFIGURED 改为 ./data；123456train_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_train.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot;&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_train.record 改为 ./data/train.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；123456789eval_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_val.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot; shuffle: false num_readers: 1 num_epochs: 1&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_val.record 改为 ./data/test.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；至于其它的参数可以选择默认，不对其进行修改；train.py 为训练代码，其来自 object_detection/ 文件夹中的 train.py，直接复制出来使用即可，具体用法为：1python train.py --logtostderr --train_dir=./train --pipeline_config_path=faster_rcnn_resnet101_coco.config其在运行过程中会在 train 文件夹生成一系列训练过程文件，比如 checkpoint、model.ckpt-{num}（{num} 代表训练过程保存的第几个网络模型，一般从 0 开始，包括 .index、.meta和 .data 三个文件）等文件。eval.py 为评估代码，其来自 object_detection/ 文件夹中的 eval.py，直接复制出来使用即可，具体用法为：1python eval.py --logtostderr --checkpoint_dir=./train --eval_dir=./eval --pipeline_config_path=./faster_rcnn_resnet101_coco.config其在运行过程中会在 eval 文件夹生成一系列评估文件，每个文件对应一个测试 image。export_inference_graph.py 为导出 pb 模型代码，其来自 object_detection/ 文件夹中的 export_inference_graph.py，直接复制出来使用即可，具体用法为：1python export_inference_graph.py --input_type image_tensor --pipeline_config_path ./faster_rcnn_resnet101_coco.config --trained_checkpoint_prefix ./train/model.ckpt-18298 --output_directory ./model其中 model.ckpt-18298 表示使用第 18298 次保存的网络模型导出 pb 模型文件，导出的模型文件保存在 model 文件夹，主要有一下几个文件：- graph.pbtxt- model.ckpt.data-00000-of-00001- model.ckpt.info- model.ckpt.meta- frozen_inference_graph.pb其中 frozen_inference_graph.pb 就是训练成功用来检测目标的模型。 TensorFlow 训练时可以随时查看训练过程，如损失函数的值下降曲线等，所用命令为：在命令行中切换目录至 project 运行目录，即 train.py 所在文件夹，本人这里即 TensorFlowObjectDetectionAPITest 文件夹，输入：tensorboard --logdir=./，等待片刻，在浏览器地址栏输入：http://localhost:6006/，即可看到训练过程曲线。检测篇 检测结果使用 opencv 窗口显示（至于 python 中 opencv 的使用详见下一篇（PyQt5使用小结）），具体调用自己训练的模型进行检测的 Python 代码（该代码为 eli 大佬参考 object_detection 文件夹中的 object_detection_tutorial.ipynb（该文件可在 jupyter 中查看）改的）为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import cv2import numpy as npimport tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = r'./model/frozen_inference_graph.pb' # 选择模型 self.PATH_TO_LABELS = r'./data/object_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) cv2.namedWindow("detection", cv2.WINDOW_NORMAL) cv2.imshow("detection", image) cv2.waitKey(0)if __name__ == '__main__': image = cv2.imread('./test_img.jpg') # 选择待检测的图片 detector = Detector() detector.detect(image)后记 经过这次 TensorFlow 训练，感觉深度学习 真tm 吃硬件，费时间，也难怪神经网络理论出来几十年之后才火，当年的硬件根本无法支持这么大的计算量。附录最后附上 datitran 作者提供的 xml_to_csv.py 文件源码和 generate_tfrecord.py 文件源码：xml_to_csv.py 源码如下：1234567891011121314151617181920212223242526272829303132333435import osimport globimport pandas as pdimport xml.etree.ElementTree as ETdef xml_to_csv(path): xml_list = [] for xml_file in glob.glob(path + '/*.xml'): tree = ET.parse(xml_file) root = tree.getroot() for member in root.findall('object'): value = (root.find('filename').text, int(root.find('size')[0].text), int(root.find('size')[1].text), member[0].text, int(member[4][0].text), int(member[4][1].text), int(member[4][2].text), int(member[4][3].text) ) xml_list.append(value) column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax'] xml_df = pd.DataFrame(xml_list, columns=column_name) return xml_dfdef main(): image_path = os.path.join(os.getcwd(), 'annotations') xml_df = xml_to_csv(image_path) xml_df.to_csv('raccoon_labels.csv', index=None) print('Successfully converted xml to csv.')main()generate_tfrecord.py 文件源码 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798"""Usage: # From tensorflow/models/ # Create train data: python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=train.record # Create test data: python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=test.record"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_importimport osimport ioimport pandas as pdimport tensorflow as tffrom PIL import Imagefrom object_detection.utils import dataset_utilfrom collections import namedtuple, OrderedDictflags = tf.app.flagsflags.DEFINE_string('csv_input', '', 'Path to the CSV input')flags.DEFINE_string('output_path', '', 'Path to output TFRecord')FLAGS = flags.FLAGS# TO-DO replace this with label mapdef class_text_to_int(row_label): if row_label == 'raccoon': return 1 else: Nonedef split(df, group): data = namedtuple('data', ['filename', 'object']) gb = df.groupby(group) return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]def create_tf_example(group, path): with tf.gfile.GFile(os.path.join(path, '&#123;&#125;'.format(group.filename)), 'rb') as fid: encoded_jpg = fid.read() encoded_jpg_io = io.BytesIO(encoded_jpg) image = Image.open(encoded_jpg_io) width, height = image.size filename = group.filename.encode('utf8') image_format = b'jpg' xmins = [] xmaxs = [] ymins = [] ymaxs = [] classes_text = [] classes = [] for index, row in group.object.iterrows(): xmins.append(row['xmin'] / width) xmaxs.append(row['xmax'] / width) ymins.append(row['ymin'] / height) ymaxs.append(row['ymax'] / height) classes_text.append(row['class'].encode('utf8')) classes.append(class_text_to_int(row['class'])) tf_example = tf.train.Example(features=tf.train.Features(feature=&#123; 'image/height': dataset_util.int64_feature(height), 'image/width': dataset_util.int64_feature(width), 'image/filename': dataset_util.bytes_feature(filename), 'image/source_id': dataset_util.bytes_feature(filename), 'image/encoded': dataset_util.bytes_feature(encoded_jpg), 'image/format': dataset_util.bytes_feature(image_format), 'image/object/bbox/xmin': dataset_util.float_list_feature(xmins), 'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs), 'image/object/bbox/ymin': dataset_util.float_list_feature(ymins), 'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs), 'image/object/class/text': dataset_util.bytes_list_feature(classes_text), 'image/object/class/label': dataset_util.int64_list_feature(classes), &#125;)) return tf_exampledef main(_): writer = tf.python_io.TFRecordWriter(FLAGS.output_path) path = os.path.join(os.getcwd(), 'images') examples = pd.read_csv(FLAGS.csv_input) grouped = split(examples, 'filename') for group in grouped: tf_example = create_tf_example(group, path) writer.write(tf_example.SerializeToString()) writer.close() output_path = os.path.join(os.getcwd(), FLAGS.output_path) print('Successfully created the TFRecords: &#123;&#125;'.format(output_path))if __name__ == '__main__': tf.app.run()参考资料[1] 对于谷歌开源的TensorFlow Object Detection API视频物体识别系统实现教程[2] TensorFlow学习——Tensorflow Object Detection API（win10，CPU）[3] How to train your own Object Detector with TensorFlow’s Object Detector API[4] TensorFlow 之 物体检测（http://rensanning.iteye.com/category/374992）See MSCOCO evaluation protocol.↩]]></content>
      <categories>
        <category>Study</category>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中整型提升问题]]></title>
    <url>posts/2a3d46b0.html</url>
    <content type="text"><![CDATA[前言 今天有人问了本人一个移位的问题，就是下面这段 C 语言代码：12unsigned short a = 0xffff;printf("%#hx\n", a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4);你认为会输出什么结果？ ੧ಡ ⌣ ಡ੭解答篇 正确答案是：0xfff0。恐怕有一部分会像本人一样觉得答案就是 0xff0 才对，还像模像样的给出对应的说法：看 a 首先向左移四位，即去掉最左边的 f，右边补 4 个 0 变成这样 0xfff0；然后再向右移 8 位，a 将会变成这样 0x00ff；最后向左移四位，得到 0x0ff0，所以应该输出 0xff0。但是，正确答案终究是正确答案。之所以会输出正确答案，是因为这里面还有一个整型提升。所谓的整型提升就是：在一个表达式中，如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成unsigned int型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。 所以在 a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4 中，会先将 a 提升为 int 型，即 a 会变成 0x0000ffff，接着向左移四位，a 变成 0x000ffff0，再向右移 8 位，变成 0x00000fff，最后向左移 4 位，变成 0x0000fff0，最后为了输出，再做一个隐式的类型转换（由 int 转 unsigned short），得到 0xfff0，所以最后输出 0xfff0。后记 这个问题是一个刚入大学的童靴问本人的，刚问本人时本人还没反应过来，后来才想起有整型提升这么回事 o(╯□╰)o。btw，这位童靴主要是想去掉高 4 位和低 4 位只取中间 8 位的值，其实最简单的办法就是直接 a &amp; 0x0ff0，这样管它有没有整型提升，肯定能得到中间 8 位的值 (╯▽╰)。参考资料[1] C语言进阶：整型提升（http://blog.csdn.net/mishifangxiangdefeng/article/category/1058873）[2] 对 unsigned char 先左移 后右移 可以出现两种结果]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TXT数据转OpenCV中的Mat数据]]></title>
    <url>posts/dece8eba.html</url>
    <content type="text"><![CDATA[前言 本文是以前做的一个小东西的处理前奏，当时也记录过，现在把它翻出来重新看看。那个东西需要利用深度图，本人当时还没拿到 Kinect，就在网上下了一些数据（http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm），该数据集包含了彩色图及对应的深度图，但是该数据集没有以图像形式存储深度值，而是用 txt 文本以行列形式存储真正的深度值（单位为 mm），所以并不能直观的看到深度图像，本人需要把这些深度值从 txt 文本提取出来并把它以图像的形式呈现出来，由于需求比较特殊，网上没看到现成的解决的方案，所以本人只有用现成的轮子自己做一个了。思路篇 程序的基本思路是：先找到目录及子目录下的所有 txt 文件路径；再根据路径分别读取 txt 文件，按行读取之后再进行字符串分割提取其中的深度值；为了便于以图像形式显示，将深度值归一化至 0~255 存入 8 位单通道的 Mat 类型数据中，最后以 png 图像形式保存至各个目录。实现篇 因为当时还在用 opencv-2.4.11，所以本文所实现的代码是基于 opencv-2.4.11，不过应该只要在 opencv-2.0 版本及以上只要有 Mat 数据结构的都能用，毕竟本人只用到了 OpenCV 中的 Mat 数据结构。Talk is cheap, show you the code（代码很乱，估计也只用这么一次，所以就没怎么注意了 :-P）。具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;io.h&gt; #include &lt;direct.h&gt; #include &lt;fstream&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;// ******************************************************************// @refer to [C++文件读写操作（二）逐字符读取文本和逐行读取文本](http://blog.csdn.net/wangshihui512/article/details/8921924)// [字符串分割(C++)](http://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html)// [C++读取文件夹中所有的文件或者是特定后缀的文件](http://blog.csdn.net/adong76/article/details/39432467)// [C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用](http://blog.csdn.net/u012005313/article/details/50688257)// [Split a string in C++?](http://stackoverflow.com/questions/236129/split-a-string-in-c)// [Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取](http://blog.csdn.net/zouxy09/article/details/8151044)// [Depth Map Tutorial](http://www.pages.drexel.edu/~nk752/depthMapTut.html)// ******************************************************************// ----- 逐个字符读取文件 --------void testByChar() &#123; fstream testByCharFile; char c; testByCharFile.open("./test.txt",ios::in); while(!testByCharFile.eof()) &#123; testByCharFile&gt;&gt;c; cout&lt;&lt;c; &#125; testByCharFile.close(); &#125; // -------- 逐行读取文件 -------------------void testByLine() &#123; char buffer[256]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 256, '\n');//getline(char *,int,char) 表示该行字符达到256个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; &#125; outFile.close(); &#125; // ------- 分割字符串 --------------void splitString() &#123; char buffer[1280]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 1280, '\n');//getline(char *,int,char) 表示该行字符达到1280个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; const char *d = " ,*"; char *p; p = strtok(buffer, d); while(p) &#123; printf("%s\n", p); p=strtok(NULL, d); &#125; &#125; outFile.close(); &#125; // 获取文件夹下指定格式所有文件名void getAllFormatFiles( string path, string format, vector&lt;string&gt;&amp; files ) &#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string pathName; if((hFile = _findfirst(pathName.assign(path).append("/*." + format).c_str(),&amp;fileinfo)) != -1) &#123; do &#123; //如果是目录,迭代之 //如果不是,加入列表 if((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if(strcmp(fileinfo.name,".") != 0 &amp;&amp; strcmp(fileinfo.name,"..") != 0) &#123; //files.push_back(p.assign(path).append("/").append(fileinfo.name) ); getAllFormatFiles( pathName.assign(path).append("/").append(fileinfo.name), format, files); &#125; &#125; else &#123; files.push_back(pathName.assign(path).append("/").append(fileinfo.name) ); &#125; &#125;while(_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; // http://stackoverflow.com/questions/236129/split-a-string-in-c// ---- stackoverflow上大神的C++版本分割字符串 --------------------std::vector&lt;std::string&gt; split(const std::string&amp; text, const std::string&amp; delims)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = text.find_first_not_of(delims), end = 0; while((end = text.find_first_of(delims, start)) != std::string::npos) &#123; tokens.push_back(text.substr(start, end - start)); start = text.find_first_not_of(delims, end); &#125; if(start != std::string::npos) tokens.push_back(text.substr(start)); return tokens;&#125;// 创建文件夹及子文件夹void makeDir(const string &amp;path)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = 0, end = 0; while ((end = path.find('/', start)) != std::string::npos) &#123; if (end != start) &#123; tokens.push_back(path.substr(0, end)); &#125; start = end + 1; &#125; if (end != start) &#123; tokens.push_back(path); &#125; vector&lt;string&gt;::const_iterator itp = tokens.begin(); while (itp != tokens.end()) &#123; if (access(itp-&gt;c_str(), 0) == -1) // 判断文件夹是否存在 &#123; cout&lt;&lt;*itp&lt;&lt;" is not existing"&lt;&lt;endl; cout&lt;&lt;"now make it"&lt;&lt;endl; if (mkdir(itp-&gt;c_str()) == 0) // 不存在则创建，只能一级一级的创建 &#123; cout&lt;&lt;"make successfully"&lt;&lt;endl; &#125; &#125; cout &lt;&lt; *itp++ &lt;&lt;endl; &#125;&#125;// Txt文件转opencv Mat（txt文件中存的是以行列形式的深度值）cv::Mat Txt2DepthMat(const string &amp;txtname)&#123; cv::Mat result(480, 640, CV_8UC1, cv::Scalar(0)); char buffer[12800]; // 按行读取文件 fstream outFile; const char *d = ","; // 以,为分割点 char *p; // 分割出的子串 outFile.open(txtname, ios::in); for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) &#123; p = strtok(buffer, d); for (int j = 0; p &amp;&amp; j &lt; result.cols; j++) &#123; int realDepth = (atoi(p) &amp; 0xfff8) &gt;&gt; 3; //提取距离信息，高13位 int depth = (int)(256 * realDepth / 0x0fff); //因为提取的信息是距离信息，为了便于显示，这里归一化为0-255 result.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(depth); p = strtok(NULL, d); &#125; &#125; outFile.close(); return result;&#125;// 以颜色表示深度信息，越暖（红色）越近，越冷（蓝色）越远cv::Mat Depth2Color(const cv::Mat &amp;depth)&#123; cv::Mat result(depth.size(), CV_8UC3, cv::Scalar::all(0)); int tempDepth, depthRed, depthGreen, depthBlue; for (int i = 0; i &lt; result.rows; i++) &#123; for (int j = 0; j &lt; result.cols; j++) &#123; tempDepth = 255 - depth.at&lt;uchar&gt;(i, j); if(tempDepth &lt; 43) &#123; depthRed = tempDepth * 6; depthGreen = 0; depthBlue = tempDepth * 6; &#125; if(tempDepth &gt; 42 &amp;&amp; tempDepth &lt; 85) &#123; depthRed = 255 - (tempDepth - 43) * 6; depthGreen = 0; depthBlue = 255; &#125; if(tempDepth &gt; 84 &amp;&amp; tempDepth &lt; 128) &#123; depthRed = 0; depthGreen = (tempDepth - 85) * 6; depthBlue = 255; &#125; if(tempDepth &gt; 127 &amp;&amp; tempDepth &lt; 169) &#123; depthRed = 0; depthGreen = 255; depthBlue = 255 - (tempDepth - 128) * 6; &#125; if(tempDepth &gt; 168 &amp;&amp; tempDepth &lt; 212) &#123; depthRed = (tempDepth - 169) * 6; depthGreen = 255; depthBlue = 0; &#125; if(tempDepth &gt; 211 &amp;&amp; tempDepth &lt; 254) &#123; depthRed = 255; depthGreen = 255 - (tempDepth - 212) * 6; depthBlue = 0; &#125; if(tempDepth &gt; 253) &#123; depthRed = 255; depthGreen = 0; depthBlue = 0; &#125; if (tempDepth == 255) &#123; depthRed = 0; depthGreen = 0; depthBlue = 0; &#125; result.at&lt;Vec3b&gt;(i, j)[0] = depthBlue; result.at&lt;Vec3b&gt;(i, j)[1] = depthGreen; result.at&lt;Vec3b&gt;(i, j)[2] = depthRed; &#125; &#125; return result;&#125;int main(int argc, char *argv[])&#123; string filePath = "C:/Users/XXXXXX/Downloads/NTU-Microsoft-Kinect-HandGesture Dataset/Depth"; vector&lt;string&gt; files; //读取所有文件 string format = "*"; // 不知道为什么在我电脑读不了特定文件？ getAllFormatFiles(filePath, format, files); for (int i = 0; i &lt; files.size(); i++) &#123; cv::Mat tempMat = Txt2DepthMat(files[i]); files[i].replace(0, 66, "../data"); files[i].replace(files[i].find(".txt"), files[i].length() - 1, ".png"); cout&lt;&lt; files[i] &lt;&lt; endl; string tempString = files[i].substr(0, files[i].find_last_of("/")); makeDir(tempString); cv::imwrite(files[i], tempMat); &#125; cout &lt;&lt; "File Size: " &lt;&lt; files.size() &lt;&lt; endl; //cv::imshow("test", Depth2Color(Txt2DepthMat("./1.txt"))); cv::waitKey(0); return 0;&#125;2018-01-01 BTW：以上代码在 VS2010+Win7 下编译运行通过，在 VS2013+Win10 下 for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) 会报错，可能需要改成 for (int i = 0; outFile.getline(buffer, 12800, '\n') &amp;&amp; i &lt; result.rows; i++) ，即去掉后面的 != NULL。后记 正如前言所说，本文是以前记录过的，一些细节也快忘记，这次重写算是回顾一下吧，这段程序可能也确实只用这么一次，但其中用到了不少 C++ 处理字符串和读写文件等相关知识，而这些知识，在以后有极大的可能会再次用到，因此记录 ↖(^ω^)↗。参考资料[1] C++文件读写操作（二）逐字符读取文本和逐行读取文本（http://blog.csdn.net/shihui512/article/category/1397194）[2] 字符串分割(C++)（http://www.cnblogs.com/MikeZhang/category/345894.html）[3] C++读取文件夹中所有的文件或者是特定后缀的文件（http://blog.csdn.net/adong76/article/category/1632029）[4] C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用（http://blog.csdn.net/u012005313/article/category/5586103）[5] Split a string in C++?（http://stackoverflow.com/questions/236129/split-a-string-in-c）[6] Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取（http://blog.csdn.net/zouxy09/article/category/1273380）[7] Depth Map Tutorial（http://www.pages.drexel.edu/~nk752/depthMapTut.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中滑动条和鼠标事件响应操作的使用小结]]></title>
    <url>posts/e8b35736.html</url>
    <content type="text"><![CDATA[前言 既然在上一篇中提到了回调函数，本人就干脆把 OpenCV 中较常使用的两个使用回调函数的函数使用方法也一并记录下来吧。说明篇OpenCV 中使用回调函数的两个函数为：鼠标事件响应操作函数：void cv::setMouseCallback(const string&amp; winname, MouseCallback onMouse, void* userdata = 0);参数浅解：const string&amp; winname：窗口名称，对名为winname的窗口执行鼠标事件响应操作；MouseCallback onMouse：鼠标响应事件回调函数，监听鼠标的点击，移动，松开，判断鼠标的操作类型并做出相应处理；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);参数浅解：int event：鼠标滑动（CV_EVENT_MOUSEMOVE）、左键单击（CV_EVENT_LBUTTONDOWN）、右键单击（CV_EVENT_RBUTTONDOWN ）等10种鼠标点击事件的int型代号；int x, int y：鼠标位于窗口的（x，y）坐标位置，窗口左上角默认为原点，向右为x正轴，向下为y正轴；int flags：鼠标左键拖拽（CV_EVENT_FLAG_LBUTTON）、右键拖拽（CV_EVENT_FLAG_RBUTTON）等6种鼠标拖拽事件的int型代号；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。创建滑动条函数：int cv::createTrackbar(const string&amp; trackbarname, const string&amp; winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0);参数浅解：const string&amp; trackbarname：创建的滑动条名称；const string&amp; winname：所在窗口名称，对名为winname的窗口添加滑动条；int* value：滑块的位置，其初始值对应滑块的初始位置；int count：滑块可达到的最大位置的值，滑块最小位置的值总为0；TrackbarCallback onChange：滑动条事件回调函数，当滑动条上位置改变的时，则执行该回调函数；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);参数浅解：int pos：滑动条的位置对应的值；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。※注：本文的函数说明采用的是 opencv-2.4.11 的函数声明，与 opencv-3.2.0 的函数声明区别在于 string 类型，opencv-3.2.0 采用的是其自己实现的一个 String 类。实例篇Show u the code，具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;// ---------------- 鼠标事件回调函数 ---------------------------------static cv::Mat src_img; // 原始图像全局变量static void mouseCallback(int event, int x, int y, int flags, void *)&#123; bool selected = false; static cv::Point left_top_vertex, right_down_vertex; // 左上角顶点和右下角顶点 // When the left mouse button is pressed, record its position and save it in corner1 if (event == CV_EVENT_LBUTTONDOWN) // 左键按下 &#123; left_top_vertex.x = x; left_top_vertex.y = y; std::cout &lt;&lt; "Corner 1 recorded at " &lt;&lt; left_top_vertex &lt;&lt; std::endl; &#125; // When the left mouse button is released, record its position and save it in corner2 if (event == cv::EVENT_LBUTTONUP) // 左键弹起 &#123; // Also check if user selection is bigger than 20 pixels (jut for fun!) if (abs(x - left_top_vertex.x) &gt; 10 &amp;&amp; abs(y - left_top_vertex.y) &gt; 10) &#123; right_down_vertex.x = x; right_down_vertex.y = y; std::cout &lt;&lt; "Corner 2 recorded at " &lt;&lt; right_down_vertex &lt;&lt; std::endl &lt;&lt; std::endl; selected = true; &#125; else &#123; std::cout &lt;&lt; "Please select a bigger region" &lt;&lt; std::endl; &#125; &#125; // Update the box showing the selected region as the user drags the mouse if (flags == CV_EVENT_FLAG_LBUTTON) // 左键拖拽 &#123; cv::Point pt; pt.x = x; pt.y = y; cv::Mat local_img = src_img.clone(); rectangle(local_img, left_top_vertex, pt, cv::Scalar(0, 0, 255)); imshow("Cropping app", local_img); &#125; // Define ROI and crop it out when both corners have been selected if (selected) &#123; cv::Rect box; box.width = abs(left_top_vertex.x - right_down_vertex.x); box.height = abs(left_top_vertex.y - right_down_vertex.y); box.x = cv::min(left_top_vertex.x, right_down_vertex.x); box.y = cv::min(left_top_vertex.y, right_down_vertex.y); // Make an image out of just the selected ROI and display it in a new window cv::Mat crop(src_img, box); cv::namedWindow("Crop"); imshow("Crop", crop); &#125;&#125;// ---------- 响应鼠标事件 ------------------------------------void setMouseCallbackTest()&#123; src_img = cv::imread("../data/lena.jpg", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("Cropping app"); imshow("Cropping app", src_img); // Set the mouse event callback function cv::setMouseCallback("Cropping app", mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// -------------- 滑动条回调函数 ------------------------static void thresholdCallback(int slider_value, void* gray)&#123; //static_cast&lt;&gt;用于安全转换指针 cv::Mat *tmp_gray = static_cast&lt;cv::Mat *&gt;(gray); cv::Mat tmp = *tmp_gray; cv::Mat dst; threshold(tmp, dst, slider_value, 255, CV_THRESH_BINARY); //显示效果图 cv::imshow("Trackbar Demo", dst);&#125;// ------------ 创建滑动条 ----------------------------------void createTrackbarTest()&#123; cv::Mat src_gray = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Trackbar Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_gray); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_gray); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// ------- 将两个函数在同一个窗口执行 ------------void callbackTest()&#123; src_img = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Callback Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_img); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_img); // 鼠标事件响应 cv::setMouseCallback(window_name, mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;int main(int argc, char *argv[])&#123; //setMouseCallbackTest(); //createTrackbarTest(); callbackTest(); while (char(cv::waitKey(30)) != 'q') &#123;&#125; return 0;&#125; 经本人测试，上面示例程序在 Win10 的 VS2013 中 opencv-2.4.11 和 opencv-3.2.0 下都能完美运行。后记 本来这两个函数都已经写（chao）好了，但为了更好的体现示例程序，又稍作了修改：添加鼠标左键拖拽事件及不使用全局变量等。参考资料[1] opencv2 使用鼠标绘制矩形并截取和保存矩形区域图像（http://www.cnblogs.com/lidabo/category/516776.html）[2] Opencv中添加进度条及回调函数（http://blog.csdn.net/weixin_35738542/article/category/6337413）[3] OpenCV2中滑动条（Trackbar）回调函数的小发现（http://blog.csdn.net/u014291399/article/category/3097955）[4] OpenCV GUI基本操作，回调函数，进度条，裁剪图像等（http://blog.csdn.net/wangyaninglm/article/category/1653815）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用回调函数计算函数运行时间]]></title>
    <url>posts/b6fb6109.html</url>
    <content type="text"><![CDATA[前言 曾有一段时间在写一个小程序，由于其对运行时间有要求，所以每写一段代码就要测试一下运行时间，如果超出就需要优化一下代码或换一种方法和算法。但是每次都需要插在某两个位置插两段代码感觉有点烦，也有点浪费时间，毕竟浪费时间就是浪费生命，本着保尔柯察金关于生命的言论，本人不愿虚度年华，所以只得寻找一个方便简洁的方法计算运行时间（说了这么多，说到底其实就是懒吧 */ω\*）。后面就想到了回调函数，将想要计算运行时间的代码段放入一个函数中，并将其作为回调函数，用事先写好的计算时间函数调用它，从而方便计算该代码段的运行时间。正文Show u the code，具体 C++ 实现代码为：12345678910111213141516171819202122232425262728#include &lt;ctime&gt;#include &lt;cstdio&gt;#define _CALLED_ printf("The function %s", __FUNCTION__);// 使用回调函数计算一段代码执行时间void computeTotalTime(void(*processingCallback)() = 0)&#123; clock_t start_time = clock(); processingCallback(); clock_t end_time = clock(); printf(" takes: %fs.\n", (double)(end_time - start_time) / CLOCKS_PER_SEC);&#125;void test()&#123; for (int i = 0; i &lt; 1000; i++) &#123; printf("Hello World!\n"); &#125; _CALLED_;&#125;int main(int argc, char *argv[])&#123; computeTotalTime(test); return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 本来是想在网上找一个的，谁知道并没有找到，就只有自己动手实现一个了 ╮(╯_╰)╭。后面使用了一下该函数，发现好像并没有提高生产力 o(╯□╰)o，所以就没人放在网上？-_-!，不过确实从实现过程中学到了一些东西 ↖(^ω^)↗。参考资料[1] C/C++之回调函数（http://www.cnblogs.com/danshui/category/345046.html）[2] c/c++在windows下获取时间和计算时间差的几种方法总结（http://blog.csdn.net/coder_xia/article/category/837943）[3] (转)用宏获取函数名（http://www.cnblogs.com/steady/category/264974.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论如何科学的上网]]></title>
    <url>posts/df943c4f.html</url>
    <content type="text"><![CDATA[科学式上网推荐组合：Chrome，Proxy SwitchyOmega，Lantern 等代理工具。前言 所谓的科学式上网，懂的自然懂，本人也就不做过多解释了。本来一直在用别人免费提供的 pac 代理，但最近可能别人关掉了，上不了 google 了，就只能另寻他路了。所谓的另寻他路也就是尝试云端框架网站站长 枂下 提供的另外几种科学式上网攻略。本文只是对 枂下 站长的攻略做一下试验记录，若想看原滋原味的攻略，还请移步 云端框架。科学的上网方法 尽量使用 Chrome 进行科学式上网，因为其有一个代理管理插件 Proxy SwitchyOmega，该插件称之为代理切换神器也不为过，网上大量的教程和配置文件也是基于该神器做的。使用 Proxy SwitchyOmega 需要进行配置，这对初学者有一定的难度，这里本人推荐直接使用站长 枂下 提供的配置文件，至于 SwitchyOmega 的配置文件可以去站长的 云端框架 网站上去下，也可以联系本人。至于代理工具请看下文，本人目前也只尝试过使用以下几种工具。lantern 其实本人最先尝试的工具是 XX-NET，但是其配置起来稍显繁琐，而且在第一步的时候必须处在科学式上网环境，而 Lantern 就比较简单了，只要装上之后再稍微动动手脚就可以了，所以就把 lantern 写在第一位了。从站长 枂下 那下载【蓝】灯电脑破解版压缩包，不过本人觉得应该随便在哪里下载个原版 lantern-2.2.5 安装都可以，只要后续的破解方法一样即可。 具体破解方法为：主要是令 lantern 一直保持在 2.2.5 版本不变。但是一般来说 lantern 在安装之后会自动更新到最新版（本人在两台电脑上都安装过 lantern，其中一台安装完之后打开 lantern 安装文件夹发现其已更新，而另一台却没有更新，这就有点玄学了 -_-!），至于判断 lantern 有没有更新的办法是：首先进入 lantern 的安装文件夹：C:\Users\XXX\AppData\Roaming\Lantern（将XXX改成自己的用户名），1、看 lantern.exe 文件的修改日期，如果还是 2016 年的，就说明其还没更新；2、显示隐藏文件，看有没有 .lantern.exe.old 文件，如果没有，则也还没更新。如果已经更新了，参考站长 枂下 的说法：删除lantern.exe文件，修改.lantern.exe.old为lantern.exe这样就又可以回退至 lantern-2.2.5 版。如果没更新的话就不用进行删除回退这一步，直接进行下一步。 下一步为修改 lantern-2.2.5.yaml 文件中的更新路径 updateserverurl，使 lantern 永远不再更新，一直维持在 2.2.5 版本不变。具体更改方式为：将其中的updateserverurl: https://update.getlantern.org修改为updateserverurl: https://pic.black1ce.com修改完之后保存退出。这里本人觉得可以随便将其修改成其它路径即可，毕竟只是让其不更新而已，这个路径应该除了更新就没有其它作用了，这纯属本人拙劣的猜测，有（ai）兴（gao）趣（shi）的童靴可以试试 :-P。 原本以为到这一步就完成了，但是 枂下 站长后来又补发了一步，就是上面几步只是让 lantern 不再更新，而 500M 流量之后限速的问题仍然存在（本人目前还没超过 500M，所以不知道这个问题，但抱着有备无患的心态先把 枂下 站长的攻略记一下 O(∩_∩)O~），所以接下来才是上正菜，破解“限制500M流量”问题的具体方法为：当使用 lantern 流量超过 500M 时，打开 lantern 的安装目录，打开 lantern-2.2.5.yaml 文件，修改其中第九行的设备号，随意更换一个数字或者字母即可。按 枂下 站长的说法是 8 位随机字母数字大小写均可，只是为方便起见推荐只改动某位即可。eg：本人目前第 9 行为：deviceid: Gu25Sfoz，一旦 500M 流量用完了，本人就只需要将其修改为 deviceid: Gu25Sfoa 即可。到这一步 lantern 的破解算是基本完成了吧，如果 枂下 站长有新的更新且被本人看到的话再进行实验更新吧。XX-NET 该工具应该是本人尝试配置的首款代理工具，不得不说其配置和 lantern 相比实在是太复杂了，而且其中有一步还必须处在科学式网络环境中，本人还是借助别人的 VPN 上的（当时还没用 lantern，所以没用其 500M 免费不限速的流量 ~~o(&gt;_&lt;)o~~）。本人经过实测 XX-NET 无法在 Firefox 中用 google 搜索，一用 google 搜就会报错：您的连接并不安全www.google.com 的网站管理员未正确配置网站。为避免您的信息被窃，Firefox 没有与该网站建立连接。此网站采用了 HTTP 严格传输安全（HSTS）机制，要求 Firefox 只能与其建立安全连接。正因如此，您也不能将此证书加入例外列表。www.google.com 使用了无效的安全证书。 该证书因为其颁发者证书未知而不被信任。 该服务器可能未发送相应的中间证书。 可能需要导入一个额外的根证书。 错误代码: SEC_ERROR_UNKNOWN_ISSUERhttps://www.google.com/search?q=test&amp;ie=utf-8&amp;oe=utf-8对等端的证书颁发者不受认可。HTTP 严格传输安全（HSTS）：false HTTP 公钥钉扎：true证书链：—–BEGIN CERTIFICATE—– MIIDkzCCAnugAwIBAgIQSu4RvcIwnqiEQE6Z68FlaDANBgkqhkiG9w0BAQsFADBz MQswCQYDVQQGEwJDTjERMA8GA1UECAwISW50ZXJuZXQxDzANBgNVBAcMBkNlcm5l dDEQMA4GA1UECgwHR29BZ2VudDEVMBMGA1UECwwMR29BZ2VudCBSb290MRcwFQYD VQQDDA5Hb0FnZW50IFhYLU5ldDAeFw0xNzA5MTYxNDIzMjRaFw0yNzA5MTQxNDMz MjRaMHgxCzAJBgNVBAYTAkNOMREwDwYDVQQIDAhJbnRlcm5ldDEPMA0GA1UEBwwG Q2VybmV0MRcwFQYDVQQLDA5Hb0FnZW50IEJyYW5jaDEVMBMGA1UEAwwMKi5nb29n bGUuY29tMRUwEwYDVQQKDAwqLmdvb2dsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDL3K1OgwalKOJPtO4urpAiu+lioGNax/EIaYR1D2kH66AJ lpal0pYFhXF6MOYCUNfpZIqP5qAQs7JGuRmFdo7rWaLHZ+3S+TlIHdZkoLvyYBcX ENVBcLQvZ7IL7DDUZObK/R7OOKz82dEoITQnT+q/lecR9wQ7QNdNVNqn0xS0NPt7 bS76irMxkJcO2q7Lu4R56ImCox/G7dUEepjL0Po516l6fLKG3qi5org2z6ap0yl2 Etu8cRfqiqaqhO0HI1Twz+Rbp/8KUdUBgnNkjcod83HE+jJKxIUDmn18+l7J8sBi a0JvWSIYy2ccFXoR8L4lfvIa8PhTuMmpxyDkwDdPAgMBAAGjHjAcMBoGA1UdEQEB /wQQMA6CDCouZ29vZ2xlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEADiM6yWCaGNLn ggirjN0b34j5JmjgYYx3bRaKDe4We2emjlLsdskBo2ztkd/tPBfUa7DWExgFPvVq B2FeEf85Zj72kMmc2JikJBtPF1qK9fa4O1gST4VE0xIF99zGrgkDhGaYd1ocElWS qfBNQfzwsO+nl2OQf99ATMqMSCGacN7z+LJBLn65de+ODzYUkIHzhU5/xJMian3y fQzNFCAgK8OMf16excqRUcX8zfGPfvtAafDrdOYEXcGayLIvt4tGr8T+tii+MtCR O5hXK8/ABMLGI74zgLYloVFjJv21VsLrNCvvD43T5E3c+8d1MENozdEnsyzWkTkp knP4aEiLOQ== —–END CERTIFICATE—–本人不知道为什么 (+﹏+)~。所以为了能正常使用科学式网络，还是老老实实的用 Chrome 吧，何况其还有 Switchyomega 神器，并且建议把 Chrome 设置为默认浏览器。具体配置流程如下： 从 枂下 站长那下载 XX-NET（本人其实最先是直接在 GitHub 上下载最新的 XX-NET，但本人由于在 Firefox 上尝试失败了，当时也没在 Chrome 上尝试，以为最新版 XX-NET 有问题，后来用上 枂下 站长那下的 XX-NET 在 Chrome 上试了下可以，而 Firefox 不行，就知道可能是 Firefox 的问题，而既然已经能用了，本人也没用最新的 XX-NET 在 Chrome 上尝试了），直接解压到某个文件夹，然后将 XX-Net-3.3.6 文件夹重命名为 XX-Net，即去掉末尾的版本号，据 枂下 站长说法是为了减少后续 XX-NET 出错（本人这里老老实实的照 枂下 站长说的做了，所以也不知道如果没去掉版本号会有什么后果）。接着以管理员身份运行 XX-Net 目录下的 start.vbs 文件（这里右键是没有“以管理员身份运行”选项的，要想以管理员身份运行就只有使用 Windows 命令行了，具体做法就是以管理员身份运行“命令提示符”，再在其中运行 start.vbs 文件即可），运行成功后将弹出已经导入GoAgent证书,请重启浏览器.点击确定即可。再次启动默认（Chrome）浏览器，将打开 127.0.0.1:8085 页面，即为 XX-NET 的配置界面。将看到 GAEProxy 状态信息（可能是由于 google 取消了公共 APPID，所以本人看到的不是“您正在使用公共APPID，….”这条消息，而是另外一条消息（具体什么消息本人忘记了 o(╯□╰)o）），打开显示详细信息（其实也没用，本人并看不懂这么多 -_-|||），先放这里吧，部分信息以后再说，先进入正式配置步骤。首先点击左边的“高级”选项，据枂下站长说，将自动调整扫描线程数关掉，最大扫描线程数设为 200，点击提交（可能这样连接速度更快一些）。本人这里这里没有照做，而是保持默认设置，本人只是要求能上就可以了，对速度要求可以稍微放松一点（或许以后会调成站长推荐的配置）。接下来点击“部署服务端”选项，填写 AppID，点击“开始部署”。但是这一步，本人并没有 AppID，所以只能上 google 申请，这样最麻烦的一步就来了。照着 枂下 站长的指引，本人一步步的申请了 AppID。具体申请步骤如下（这一步需要登录 google 账号，必须处于科学式网络环境）：点击 打开Appid申请页面，登录 google 账号，创建项目，并在新建项目中修改项目 ID（这就是第一个 AppID ），为方便，建议直接以“项目名-00”的方式按顺序命名 AppID，创建成功后继续点击“Google Cloud Platform”旁的一个小三角，点击弹框的“+”，按上述方式进行创建新的 AppID，如此重复，本人总共创建 10 个 AppID，10 个之后会提示配额已用完，硬是要创建只会覆盖掉第一个 AppID。接下来就是需要选择语言和地区，只有为每个 AppID 选择语言和地区之后，该 AppID 才会生效。语言和地区的选择界面可以从“App Engine”界面中进入，也可以直接在添加 AppID 界面的那个弹框中点击相应的 AppID 进入，当然如果是第一个 AppID 选择语言可以直接点击界面上的“选择一种语言” 。语言选择 Python，地区选择亚洲（asia-northeast1），选错了后果自负（当然可以覆盖掉该 AppID 重新设置）。其实可以照 枂下 站长那样设置完第一个 AppID 的语言和地区之后直接修改浏览器的地址栏的 url 以快速设置 AppID 的语言和地区。具体修改方法为：将 url 地址末尾的 project 参数的值改为你想要设置的下一个 AppID，eg:本人当前 AppID 为 test-00，对应的浏览器 url 地址末尾的参数为 lang=python&amp;project=test-00，本人想设置的下一个 AppID 为 test-01，则只需将其修改为 lang=python&amp;project=test-01 回车即可快速设置 test-01 的语言和地区。如此重复，就可以设置完全部的 AppID 语言和地区。设置完之后，这些 AppID 就能进行部署了（据说每个 AppID 每天有 1G 的流量可以使用，并于每天下午三点更新，也就是本人每天有 10G 流量，一般是够用了 :-D）。将上文申请并设置完成的 AppID 放入“GAE AppID”文本框中，多个 AppID 可以按这样的格式放入：test-01|test-02|test-03，两个 AppID 以|分隔即可。点击“开始部署”，会弹出一个登录 google 账号的标签页，登录并允许即可，等待 2~5 分钟，可发现日志页面出现 Done!和Deploy 10 appid successed. 等字样即表示服务端部署成功。点击“部署”选项，将上面部署服务端的 AppID 以相同格式输入“GAE AppID”文本框中，点击“保存”即可。保存完之后，即可在状态信息界面显示详细信息中 Appid 发现当前工作 AppID 就是部署的 AppID ，至于那个配置下的监听代理就是设置代理的地址和端口。这样 XX-NET 就算是配置完成了，至于 枂下 站长说的扫描 ip，本人就没做实验了，因为这样配置完就可以科学式上网了。 以上代理工具配置完成后，即可在 Chrome 中畅游 Internet 了，但是正确的科学式上网姿势应该是：国内的网站走本地连接，而国外被屏蔽的网站才走代理。这就需要 Proxy SwitchyOmega 这款插件了，它能按照一定的规则自动选择走本地还是走代理，这样既不会浪费流量，也能使国内的网站联网速度不受影响。导入前文推荐的配置文件后，就可选择对应的代理方式。这里当然是选择自动切换，至于虚拟切换是选择 Lantern for 8787 还是 XXNET for GAE 就随便个人的喜好了（在走代理的时候别忘了把相应的代理工具开启）；如果直接选择其中一种代理方式就相当于全局代理，这也就失去这款插件的作用，只有自动切换加上虚拟切换才能充分发挥这款神器的真正作用。匿名网络 要想使用匿名网络，当然少不了专用的浏览器：Tor Browser，下载并安装（下载时需要身处科学式网络环境，安装时最好改变一下目录，而且路径中最好不要有中文）。接下来就是配置了 Tor 网络了。具体配置流程如下： 首先，它问直接连接 Tor 网络还是配置网桥或代理，这里当然是选择配置；其次它问互联网服务提供商( ISP )是否对 Tor 网络连接进行了封锁或审查，这里选否，据枂下站长所说因为国内网桥大部分已失效，连接网桥没有意义还会拖慢速度；然后它问是否本地代理访问互联网，这里当然选择是；最后填写本地代理配置，这里需要注意，枂下站长提供的部分代理配置是：SSR/SS Socks5//127.0.0.1 : 1080Seed HTTP//127.0.0.1 : 1080Lantern Socks5//127.0.0.1 : 8287（2系列），三系列的在Lantern设置页面查看Psiphon 可以在配置页面自定义 其中经本人实测，上面 Lantern 的代理配置是连接不上的，本人后来参考 SwitchyOmega 配置文件中 Lantern 的代理为 HTTP//127.0.0.1 : 8787，经尝试如此配置可以连接 Tor 网络，所以 Lantern 的正确配置应为：Lantern HTTP//127.0.0.1 : 8787（2系列），三系列的在Lantern设置页面查看设置完成后等待片刻就能连上 Tor 网络了，最好就保持原来的 DuckDuckGo 搜索引擎，不要更改，接下来就可随心所欲的畅游 Internet 了。 至于想访问暗网，可以参考Hacking/整理的暗网网址Tor.txt和Working Links to the Deep Web或者直接用站长枂下给的网址：torlinkbgs6aabns.onion和xmh57jrzrnw6insl.onion。据枂下站长回答：XX-Net可以作tor的前置代理吗？不行的，xx-net是假http协议所以 XX-NET 不能用作 Tor 的代理配置。 最后再简要记录一下 Chrome 调用 Tor Browser 的代理吧。本人没有像 枂下 站长那样用命令行去实验，只是享受了一下 ta 的试验成果（O(∩_∩)O谢谢）。总而言之，还是利用 SwitchyOmega，代理方式选择 Tor for 9150，就可以在 Chrome 中调用 Tor Browser 的代理，畅游 Internet 了。更新于：2017-11-27 时久达期间及之后，lantern 的那种破解方式从时灵时不灵，到完全失效，而 XX-NET 则一开始就失效了，这见证了 Google 和 GFW 的斗智斗勇（๑乛◡乛๑），但很明显，google 失败了，事实证明没有 GFW 封不了的，只是看它想不想封 (๑•ั็ω•็ั๑)。至于 lantern 和 XX-Net 的复活方式请移步 枂下 站长的网站，本人这里就不再赘述了。这里需要更新的一点是：Tor 的网桥配置采用“meet-amazon”（亚马逊的云计算平台）或者“meet-azure”（微软的云计算平台）传输也能实现科学式上网，但速度很慢，仅能浏览网页而已，可以当做备选临时用用。更新于 2017-12-24：今天使用了下 赛风（Psiphon），其操作完全傻瓜式，简直不要太好用，而且为单个绿色文件，携带也方便，用的时候只要设置一下端口就行。不出意外的话，妈妈再也不用担心本人搞科研了（؏؏☝ᖗ乛◡乛ᖘ☝؏؏）。更新于 2018-03-14：现在最新版的 Firefox 59.0 也有 Proxy SwitchyOmega 插件了，虽然还是测试版，但还是能够正常使用，既然 Firefox 有了这款神器，本人也就有动力将 Firefox 使用 XX-Net 连接 Google 搜索出现的问题解决了，首先进入 Firefox 的 「选项」或设置 ==》「隐私安全」，下滑到最下面的「证书」，点击「查看证书」，在弹框中选中「证书机构」，点击「导入」，添加 XX-Net\data\gae_proxy目录下的 CA.crt 证书，在导入中出现的弹框全部选中信任，将会在上方的证书栏中出现 GoAgent XX-Net 证书，这样就能解决上文出现的问题，参考自：【已解决】Firefox报错：github.com 使用了无效的安全证书。 证书因为未提供证书发行链信而不被信任。 （错误码： sec_error_unknown_issuer）后记 最后的匿名网络是本人弄着好玩的，像暗网这种东西本人这种遵纪守法的好公民才不会访问呢 (ಡωಡ)。等以后时机到了再去买个国外 VPS 自己搭建一个科学式上网环境吧。最后感谢 枂下 站长的无私分享。附录 原本还以为本人搭建的 Hexo+GitHub 个人博客站点还是个深网，没想到搞完科学式上网后用 google 搜索竟然能搜到，虽然本人没做什么，但 google 仍然能搜到，google 的蜘蛛还挺厉害的，不过如果百度的蜘蛛没被 GitHub 屏蔽的话百度可能也能搜到（从某些原因上来说，GitHub 把百度屏蔽掉也好 O(∩_∩)O~）。既然已经被 google 收录了，本人也就不去搞那个站点地图了，等以后想搞 SEO 了再去做吧。参考资料[1] Switchyomega超详细教程之Chrome与Firefox版本[2] 【蓝】灯电脑破解版之2系列禁止自动升级最终办法[3] XX-NET史上最详细完整教程[4] XX-NET史上最详细完整教程之第一部分：Appid创建部分[5] Tor Browser在国内Windows平台下的超详细教程[6] Chrome等其他程序如何完美调用Tor Browser的代理来上网[7] “如何翻墙”系列：TOR 已复活——meek 流量混淆插件的安装、优化、原理（https://program-think.blogspot.com/search/label/IT）[8] 如何翻墙？——写在 BlogSpot 被封之后 {2015-08-28}]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>record</tag>
        <tag>gfw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的SPFK主题修改小记]]></title>
    <url>posts/b1e9411b.html</url>
    <content type="text"><![CDATA[前言 本人一直在对 Hexo 的 SPFK 主题进行持续修改以符合本人自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。修改篇1、修改 aboutme 排版问题修改日期：2017-09-16需求描述：本人为了使 aboutme 排版好看一点，使“关于我”的内容更有段落感，本人尝试在主题配置文件中 aboutme 对象的内容添加各种换行转义符号均于事无补，如 \n、\r\n、&amp;#13;、&amp;#10;、&lt;br /&gt; 等，站点不仅不会换行，还会直接将转义符号都显示出来 (╯﹏╰）。解决办法：既然本人基本把所有的换行方法都试过了，还没有任何作用，那就只能是问题出在其它地方了。本人首先找到显示 aboutme 内容的地方，其位于主题文件夹下 \layout\_partial\left-col.ejs，显示 aboutme 内容的代码为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%=theme.aboutme%&gt;&lt;/div&gt;，查阅相关资料，具体为 与大家分享ejs源码阅读心得，其中有这样一段话：关于ejs模板的五种模式对应几种指令ejs主要提供了如下几种指令:&lt;%, 该指令主要通过js中的eval来执行js代码, 如上模板代码&lt;% [1,2].forEach(function(v){ %&gt;将通过eval编译成; [1,2].forEach(function(v){即直接可执行的js代码, 并且不会存放到__output函数中输出.&lt;%=, 该指令主要用于输出变量内容, 如上模板代码&lt;%= v %&gt;将通过escape函数编译成__append(escape(v)), 可以看到该指令用于输出变量内容, 最后将通过__output输出内容.&lt;%-, 该指令与&lt;%=区别是, &lt;%=指令使用escape函数来对特殊字符进行编码, 如将&gt;转为%3E, 查看关于escape函数.&lt;%#, 该指令主要用于模板内注释, 既不会执行也不会输出.&lt;%%, 主要用于输出字面值%.关于以上各个指令对应的解析, 可参考ejs源码根目录lib/ejs.js文件中的scanLine函数.从中可得知 &lt;%= 指令会将变量内容中一些特殊字符先转义，再原封不动的输出，所以本人无论怎么修改主题配置文件中 aboutme 对象的值，其输出内容都会是原封不动的 aboutme 对象的值。为了让其输出内容可以有相应的特殊格式，就不能让其转义，只能用 &lt;%- 指令，将其修改为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%-theme.aboutme%&gt;&lt;/div&gt;，这样就能使输出内容可以自定义特殊格式，本人最后在 aboutme 对象的内容中需要换行的地方添加了 &lt;br /&gt;，实测如此修改后可以换行。2、给左栏添加滚动条修改日期：2017-09-18需求描述：SPFK 主题是双栏的主题。因为左栏主要是用来显示一些菜单和头像等内容，这些内容也不多，所以原作者就没有添加滚动条。但是由于本人添加了个本地搜索功能，在刚开始文章少的时候还不受影响，但是随着文章的增多，搜索功能就会影响左栏的布局，这是就必须添加一个滚动条了。本以为添加滚动条很简单，就是添加一个 overflow: auto;，谁知道还没这么简单 ╮(╯﹏╰）╭。解决办法：本人对问题的定位没问题，就是修改主题文件夹下的 \source\css\_partial\main.styl 文件中 .left-col 样式，问题在于怎么修改，本想直接在其中加入 overflow: auto;，按道理说问题就能解决的，但是本人去搜索试试，发现搜索框上方的头像，文字等全部消失了，滚动条没起到作用，而下方的菜单可以通过滚动条看到。于是本人觉得可能是 div 上界没撑开，而超出的地方却隐藏了，但下界为什么能撑开，本人这里还是很不明白 ?_?。既然是这里隐藏了，本人就去看相关标签有没有 overflow: hidden; 属性，谁知道要么是没有，要么是即是关闭了也没有作用，那问题应该不是出在这里。就只能是这些元素所在的子 div 里了，本人找到其子 div 属性 .intrude-less，其中虽有 overflow: auto; 但没设置 height 属性，所以就不能发挥其作用，本人于是给它加上 height 属性，搜索后发现有两个滚动条，这显然不简约，于是本人把 .intrude-less 的 overflow: auto; 属性注释掉，没想到居然能完美解决问题，可能是因为加上高度属性之后就能撑大父元素 div 了吧（来自某业余前端的猜测 (⊙_⊙)）。后面为了更美观，本人把下方菜单区域的 div 样式 .switch-area 高度 min-height 改小了一点，顺便也把主题文件夹下的 \layout\_partial\left-col.ejs 文件中首行注释掉 &lt;!-- &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; --&gt; 。本人也曾想把 height 改为 min-height，谁知道又出现相同的问题，不得不又改回去。虽然这次已经解决了问题，但有些细节问题还是不太明白，只有等以后前端水平上去了再去想了，如有大佬知道还望不吝赐教 (^人^)。3、更换鼠标指针修改日期：2017-9-26 ~ 2017-9-27需求描述：本人在玩《Ori and the Blind Forest》这款游戏的时候觉得其鼠标指针很酷炫，于是想把其鼠标指针放在本人的博客站点中 (๑´ڡ`๑) 。解决办法：要想更改指针，首先需要找到对应的指针文件，最终在万能的贴吧得到指引，在 RealWorld Graphics 上找到两个 ori指针 文件，一个是 动态的 ani指针文件，还有一个是 静态的 cur指针文件（好像该游戏的作者也在 steam 上的评论中提供了游戏中的指针文件，详见：I wanna use this games cursor. ）。既然已经找到了指针文件，就可以开始更换炫酷的鼠标指针 (•̀ᴗ•́)。具体更改方法如下：将下好的指针文件放在主题文件下的 \source\img 文件夹中，在主题配置文件中添加 cursor 属性：12345# set cursor | 设置鼠标指针图标cursor: on: true cursor_0: img/cursor.ani # 首选指针 cursor_1: img/cursor.cur # 备选指针其中 cursor_0 和 cursor_1 代表使用哪个指针，因为 firefox 和 chrome 不支持 ani文件 的指针（好像是 ani 文件有很大的漏洞），所以 ani 动态指针是用不了的，只能用 cur 格式的静态指针，而 IE 是可以加载 ani 格式的动态指针，所以本人这里就将两个指针文件全放上去了，首选加载动态指针；最后增加相应的代码调用 cursor 属性，加载指针文件，在主题文件夹下 /layout/_partial/background.ejs 文件末尾添加：12345678&lt;% if (theme.cursor.on)&#123; %&gt; &lt;style&gt; body&#123; background: #3f3f3f; cursor: url(&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_0 %&gt;), url(&quot;&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_1 %&gt;&quot;), auto; &#125; &lt;/style&gt;&lt;% &#125; %&gt;如此更新站点之后即可使用新鼠标指针样式，可能需要先进行 hexo clean 再发布。BTW：这次修改是一个月之前的了，当时不知怎么的忘记记录了，还好本人的 git 提交记录比较详细，对应的提交记录为：add a function – change cursor和update set cursor function 。4、修改打赏问题修改日期：2017-10-13问题描述：本人突然想玩一下那个打赏小东西，但照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性，没有任何作用，于是去主题文件夹搜索 reward 属性相应的代码，结果是“找不到结果”（坑爹了这是，摔！（╯‵□′）╯︵┴─┴ ）。解决办法：既然 reward 属性找不到就只有搜索 reward_type 属性，最终在主题文件夹下 \spfk_c\layout\_partial\article.ejs 文件中找到这样一条语句 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index){ %&gt;，其下面就是打赏相关的代码，查看 SPFK 主题原作者介绍信息（Hexo 主题：SPFK）发现 toc 属性是用来显示目录的（一个用来打赏的代码怎么与文章目录相关了 -_-#），所以上面的 toc 应该改成 reward，修改后的代码为 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;，这时照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性就能在相应的文章后面看到一个大大的“赏”字。本来写到这里应该打赏这玩意应该完结了，但本人无意中在该文件的下面发现这样一段代码：123&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; &lt;%- partial(&apos;_partial/toc&apos;) %&gt;&lt;% &#125; %&gt;这是和 toc（即文章目录）真正相关的代码，功能大概就是判断是否加载文章目录相关的代码，如果在文章开头设置 toc: false，则该文章不会显示目录，但是如果在文章中不加 toc 属性，也会显示文章目录，但上面的打赏却不会显示，看起来 post.toc != false 和 post.toc 应该逻辑差不多，这里是本人感到十分奇怪的一个地方？后面查阅相关资料（JavaScript undefined 属性）得知:注释：null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。而本文这里因为没有在文章开头设置 toc 属性，所以其为 undefined，其既不为 false 也不为 true，只为 undefined，当在 if 语句中做判断，会执行 else 分支，作 ! 运算，结果则为：true。所以 if(post.toc) 不能执行其下代码，因为 post.toc 为undefined，不为 true 也不为 false，而 if(post.toc != false) 能执行其下代码，因为 post.toc != false 为真。至于 javascript 中 if(a == ture) 和 if(a) 的区别具体为：前一种是 a 必须为 1 或者 true 才执行；而后一种只要 a 不为 false undefined null 0 -0 NaN &quot;&quot; 这 7 个字符中的其中任何一个都能执行。5、交换内容栏和左侧栏位置修改日期：2017-11-22 ~ 2017-11-23需求描述：本人最近逛网站时发现，好像一些博客网站基本都是把内容放在左侧，百度和 google 的搜索结果也是在左侧，可能是内容在左侧要好一点吧，于是本人略微修改之后，将内容放在左侧，而原来的左侧栏放到最右侧，好像是顺眼了一点（不排除是心理作用 (ಡωಡ)），如果以后还觉得不错的话，再把相关的变量名换掉吧（此次修改仅仅是将 CSS 相关的值改变，div 类名没变）。解决办法：首先当然是定位左侧栏 .left-col，它在主题文件夹下 source/css/_partial/main.styl 文件中，为其添加 right: 0px; 属性，使左侧栏靠右侧停放；在定位内容栏 .mid-col ，将 right:0; 改成 left:0;，将 left: 300px; 改成 right: left-col-width;，使内容栏靠左侧停放，同时使其距离右侧有左侧栏的宽度。最后就是再修改其他一些小东西（比如目录按钮和目录内容 div 等）的 css 值，关于这个本人就细述了，反正也就是更改 left、right、bottom 以及 top 属性及其值，具体修改了哪些内容可以见本人 github 提交记录。BTW：诶呀呀！昨天忘记测试手机端，今天用手机打开一看，手机端页面也距右边 left-col-width 宽度，这使得内容全挤在一起了，完全没法看 ರ_ರ …。所以不得不添加手机端样式，定位手机端 .mid-col，它在主题文件夹下 /source/css/_partial/mobile.styl 文件中，为其添加 right: 0; 属性值；后面看见回到顶部、回到底部的导航栏也有点问题，就在该文件中 /*导航*/ 下面 .scroll 上面添加：123#scroll&#123; right: 0;&#125;使得该导航栏靠右停靠。6、更新站点部分 CSS 文件和代码结构修改日期：2017-12-04 ~ 2017-12-06更新日志：本人将 left-col 相关的东西（比如 css 样式和 ejs 文件）全部重名为 right-col，毕竟经过几天的适应，感觉放在右侧还不错，就干脆也将其重命名算了，所以原左侧栏 left-col 从现在开始就完全变成右侧栏 right-col 了；原来的本地搜索框有两个 .search 样式，本次修改将两个 .search 样式合并了，删除重复的样式，只留下一个合并后的 .search 样式；本人同时还优化了一下本地搜索功能的结构，将原来主题配置文件中的 search_box 属性删掉，给 search 属性添加一个 on 的属性来代替 search_box 属性，这样让结构不那么混乱，只由一个 search 属性决定本地搜索功能的开启和关闭及功能的实现，而不是像以前那样由 search_box 属性决定右侧栏搜索框的显示，而 search 属性决定本地搜索功能的实现；更改右侧栏 right-col 的 overflow 样式，原来是右侧栏 right-col 垂直超出滚动，水平超出隐藏，这样在屏幕比较窄的情况在右侧会出现两条滚动条，很不美观。现在本人将 overflow 样式改成 &amp;:hover {overflow-y: auto; overflow-x: hidden;} ，这样只有在鼠标指针悬浮在右侧栏 right-col 上时才会再右侧栏出现滚动条，这样虽然不能从根本上解决问题，但稍微缓解了一下，等以后再看能不能彻底解决滚动条的问题 ರ_ರ …；本人以前添加 RevolverMaps 这个小部件的时候只是简单粗暴的添加 div 及对应的样式，完全没考虑到主题的扩展性和易修改性。于是本人将其改成配置文件的形式，在主题配置文件中添加 visual_visitor 属性，只要将其值设置为 RevolverMaps官网 获取的那串 script code，eg：&lt;script type=&quot;text/javascript&quot; src=&quot;//ra.revolvermaps.com/0/0/8.js?i=0lpycb5p234&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt;，即可在右侧栏菜单下的访问情况中看到一个 3D 地球实时显示访客的位置信息，本人为了优化异步访问信息，将其中的 async=&quot;async&quot; 改成 defer=&quot;defer&quot;，这样好像能优化加载次序。这两者的区别可参考 defer和async的区别，好像是都能异步加载，只是 async 是该 script 加载完立即执行，而 defer 是该 script 加载完之后在整个页面结束加载之前执行，也就是最后执行的；最后还修改了 MathJax 的 CDN 地址及配置属性。MathJax 的配置属性可参考 加载和配置MathJax，具体如下：第一种配置Mahtjax的方法就是使用配置文件。MathJax附带了很多种预制配置文件。它们存储在MathJax/config 目录。主要有其中以下几个：default.js：这个文件包含了所有MathJax可用的配置选项，并附有注释和说明，你可以编辑它们来满足你的需要。TeX-AMS-MML_HTMLorMML.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS_HTML.js：允许使用 TeX 或者 LaTeX 符号书写公式。使用Html和Css渲染。MML_HTMLorMML.js：允许使用 MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。AM_HTMLorMML.js：允许使用 AsciiMath 符号书写。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS-MML_SVG.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。使用SVG产生输出。TeX-MML-AM_HTMLorMML.js：允许使用 TeX, LaTeX,MathML,或者 AsciiMath 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。第一个文件是提供给你修改的。它基本上包含了MathJax的所有配置选项，同时有注释解释。其他的文件就是我们联合配置文件。它们不仅仅配置Mathjax,还预加载了一些配置所需的文件。这些文件内容在 联合配置 中有详细的解释。原来的 CDN 地址 cdn.mathjax.org 已经在 2017-04-30 日关闭，所以必须更新 CDN 地址，其推荐的 CDN 地址为 cdnjs.cloudflare.com/ajax/libs/mathjax，而新的 MathJax 也提供一种一种新的配置文件 TeX-MML-AM_CHTML（允许使用 TeX, LaTeX,MathML或者 AsciiMath 符号书写公式，使用 CommonHTML 产生输出），新的 MathJax 推荐使用的就是这种配置文件，因为它计划在 V3.0 将 HTML-CSS 输出格式丢弃，只留下 CommonHTML 和 SVG 这两种输出格式。而且新的 CDN 地址不支持 /latest/MathJax.js 这种格式，必须指定一个确定的版本，截止本人此次修改日期之前，最新的版本为 2.7.2，所以比较推荐的一种加载格式为：&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 。7、添加 404 页面和一些插件等修改日期：2017-12-09 ~ 2017-12-10更新日志：修改文章内 a 标签的高度，即 .article-entry p a 中 padding 的上下边距。文章内的 a 标签在外面加个虚线框本来就很突出了，还设置上下 padding 为 8px，这就显得有点浮夸了 :) 。最后将其上下边距设为 0px；添加 404 页面，具体参考自：在 Hexo 中创建匹配主题的404页面，启动 Git Bash，进入 Hexo 所在文件夹，输入 hexo new page 404 ；打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md；在顶部插入一行，写上permalink: /404，这表示指定该页固定链接为 http://&quot;主页&quot;/404.html12345title: 404 Not Found：该页面无法显示toc: falsecomments: falsepermalink: /404---添加 hexo-abbrlink 插件，使文章生成唯一永久链接。这个插件最好是在建站之初就加上，不然写了很多文章之后又都得重新生成链接，搜索引擎需要再次抓取新链接，不利于 SEO，本人这里也就只有等 Google 慢慢抓取更新，还好写的不多，不算太迟。安装完之后本人在站点配置文件中添加：1234permalink: posts/:abbrlink.html # 需安装hexo-abbrlink插件abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex※BTW：需要将原来的 permalink 注释掉或直接删除。更多设置可参考 hexo-abbrlink 。添加 hexo-all-minifier 插件，快速压缩代码，分别对 html、css、js、images 进行优化。本人这里就直接使用推荐的配置了，直接在站点配置文件中添加：1all_minifier: true # 需安装hexo-all-minifier插件更多设置可参考 hexo-all-minifier 。原来文章标题不可点击，反而日期可点击，这有点奇怪 ◔ ‸◔?。本次修改之后，点击文章标题即为刷新页面。更新日期：2017-12-19 ~ 2017-12-19具体修改内容：主要更新了 404 页面上面的动图，个人偏好喜欢一些星系漩涡之内的动图，偶然发现这个东西（HTML5+Three.js实现的3D可拖拽银河星系旋转动画特效源码），于是将它的源码略作修改放进本人的 404 页面，将相关的 js 文件放入主题文件夹中 \source\js 文件夹里，最初时是将相关 js 文件引入路径当成相对路径引入，没想到这样造成有的 404 页面会显示旋转动图，而有的 404 页面则不会显示，后面参考网上资料（解惑页面中的相对路径和绝对路径）了解到：html 中引入的资源（包括js、css、img）相对路径：相对的是 网页本身的 URL ；绝对路径：相对的是 网页 URL 的根路径 ；css 中引入的资源相对路径：相对的是 css 文件本身的 URL ；绝对路径：相对的是 网页 URL 的根路径；结论： html 中引入资源的相对路径与 网页的 URL 有关，而css中则与 css 资源本身 URL 有关。但使用绝对路径时，不管是在 html中，还是css中，都只与 网页 URL的根路径有关。将相对路径改为绝对路径，即可在本人博客域名下所有 404 页面正常显示旋转动图。8、添加 Gitalk 评论系统修改日期：2017-12-16 Gitalk 是一款类似 gitment 的评论系统，本人先是照着它提供的配置添加之后，发现居然与 spfk 主题中的 require-2.1.6,jquery-1.9.1.min.js 冲突，显示不了 Gitalk，本人以为是 bug，所以就去提了个 issue，作者 booxood 还是挺认真负责的（°Д°）Ъ，耐心的解决本人的问题，原来是本人的引用方式有问题，需要用 require 方式引用，大佬就是大佬 ○|￣|_，小白还是小白，萌新完全没见过还有这种操作，也算是开眼界了 ✪ω✪。由于大佬解决完问题之后就直接把 issue 关闭了，所以本人就只有在这里表示感谢了 /つ∇T)。本人最后添加 gitalk 的 ejs 代码如下：123456789101112131415161718&lt;div id=&quot;comments&quot; class=&quot;gitalk&quot;&gt; &lt;div id=&quot;gitalk-container&quot; class=&quot;article article-inner article-entry&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&apos;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&apos;], function (Gitalk) &#123; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%= theme.gitalk.client_id%&gt;&apos;, clientSecret: &apos;&lt;%= theme.gitalk.client_secret%&gt;&apos;, id: window.location.pathname, repo: &apos;&lt;%= theme.gitalk.repo%&gt;&apos;, owner: &apos;&lt;%= theme.gitalk.owner%&gt;&apos;, admin: &apos;&lt;%= theme.gitalk.admin%&gt;&apos;, // facebook-like distraction free mode distractionFreeMode: true &#125;) gitalk.render(&apos;gitalk-container&apos;) &#125;) &lt;/script&gt;&lt;/div&gt;还有其它的一些修改也是仿照 gitment 的代码添加的，我这上面没有添加 css 文件是因为 gitalk 原有的 css 文件与本人的主题不相符，所以就稍微修改了一下。※BTW：上次修改文章内a标签的高度后突然发现打赏的“赏”字背景圆形变成椭圆了 o(╯□╰)o，后面发现原来它也继承文章内 a 标签的属性，没有自己的 padding，后面只有给 .dashang 添加个独立的 padding: 8px;。9、Fix Bugs修改日期：2017-12-20修复bug：鼠标悬浮 a 标签之上会出现显示 a 标签 title 内容的气泡，当 title 内容过多时，会造成气泡位置下调，从而遮住相应 a 标签内容的 bug。解决方案为：定位气泡文件为主题文件夹下 \layout\_partial\post\TipTitle.ejs 文件，将其中气泡出现的位置改变，原来气泡的位置确定由 top 和 left 决定，现改为 bottom 和 left，毕竟气泡是出现在 a 标签上方，如果将 top 确定，则 title 内容过多时，其只能向下扩张，造成气泡位置下移现象，从而遮住原来的 a 标签内容，改为 bottom 确定之后，气泡只会向上扩张，气泡位置相对稳定，不会遮住原来的 a 标签内容。具体修改内容为，将 top: offset.top - a.outerHeight() - 15 替换为 bottom: window.innerHeight - offset.top + 10 ，其它内容保持不变。修改日期：2017-12-26BUG描述：由于 spfk 主题启用的是百度分享，而原作者没有为其添加邮件分享，本人为了好玩就添加个邮件分享，但是在添加过程中，本人发现了个 BUG，就是为其添加的 title 属性没有作用，它会自动更改 title 内容，而 spfk 主题有显示 title 的气泡 TipTitle，所以不需要用默认的东西显示 title 内容，但是，这个百度分享还是强制默认显示，TipTitle 并不能消除其 title 内容。解决方案：定位百度分享强制添加 title 的代码，其位于主题文件夹下\source\static\api\js\view\share_view.js 中，具体代码如下：1234function(e)&#123; var i=e.partners,s=i[n]?"\u5206\u4eab\u5230"+i[n].name:""; !r(t).attr("title")&amp;&amp;s&amp;&amp;r(t).attr("title",s)&#125;因为 TipTitle 会首先将 title 去掉，所以这里会强制添加百度分享自己的 title，所以需要将其注释掉，具体注释代码为：/*&amp;&amp;r(t).attr(&quot;title&quot;,s)*/。本来这样就可以了，但是本人发现添加邮件分享之后，布局又不对，所以定位主题文件夹下 \source\css\_partial\baidushare.styl 文件，发现它的居中布局居然是有宽度决定的，于是本人为其添加 text-align: center; 谁知还是没变，不能自动居中，后来在主题文件夹下找到 \source\static\api\css\share_style2_24.css 文件，发现 .bdshare-button-style2-24 a 设置了浮动样式，难怪（⊙﹏⊙），最后将其注释掉就能自动居中了。最后还需要更改移动端 \source\css\_partial\mobile.styl 中 .bdshare-button-style2-24 的样式设置为自动居中就可以了。10、使文章目录可折叠修改日期：2017-12-28首先声明，本次修改完全参考：为 Hexo 添加可折叠的文章目录，所用代码也来自其文（本人只是做了点微不足道的修改），在此表示感谢 Yelee 主题的作者 MOxFIVE 👍 。具体修改如下：首先在主题文件夹下 \layout\_partial\toc.ejs 中添加 js 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- 折叠目录 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; // -------------添加小图标-------------- var $itemHasChild = $(&quot;#toc .toc-item:has(&gt; .toc-child)&quot;); var $titleHasChild = $itemHasChild.children(&quot;.toc-link&quot;); $itemHasChild.prepend(&quot;&lt;i class=&apos;fa fa-caret-down&apos;&gt;&lt;/i&gt;&lt;i class=&apos;fa fa-caret-right&apos;&gt;&lt;/i&gt;&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); $iconToExpand.addClass(&quot;hide&quot;); // --------------点击小图标-------------- var clickIcon = function () &#123; $(&quot;#toc .toc-item &gt; i&quot;).click(function () &#123; $(this).siblings(&quot;.toc-child&quot;).slideToggle(100); $(this).toggleClass(&quot;hide&quot;); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) &#125;() // 默认展开目录，所以隐藏掉表示“目录已展开”的图标（向下的小三角） var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); $iconToExpand.addClass(&quot;hide&quot;); // ------------点击大标题----------------- var clickTitle = function () &#123; $titleHasChild.dblclick(function () &#123; $(this).siblings(&quot;.toc-child&quot;).hide(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) // After dblclick enent $titleHasChild.click(function () &#123; var $curentTocChild = $(this).siblings(&quot;.toc-child&quot;); if ($curentTocChild.is(&quot;:hidden&quot;)) &#123; $curentTocChild.show(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125; &#125;) &#125;() // ---------点击总标题----------------- var clickTocTitle = function () &#123; var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $subToc = $titleHasChild.next(&quot;.toc-child&quot;); var $tocTitle = $(&quot;#toc .toc-title&quot;); // 当包含多级目录时再执行 if ($titleHasChild.length) &#123; $tocTitle.addClass(&quot;clickable&quot;); $tocTitle.click(function () &#123; if ($subToc.is(&quot;:hidden&quot;)) &#123; $subToc.show(150); $iconToExpand.removeClass(&quot;hide&quot;); $iconToFold.addClass(&quot;hide&quot;); &#125; else &#123; $subToc.hide(100); $iconToExpand.addClass(&quot;hide&quot;); $iconToFold.removeClass(&quot;hide&quot;); &#125; &#125;) &#125; &#125;()&lt;/script&gt;然后添加相应的 css 样式，在主题文件夹下 \source\css\_partial\article.styl 中 #toc 样式里添加 css 样式：1234567891011121314151617181920212223242526ol.toc li.toc-item i &#123; display: inline-block; margin-left: -0.9em; width: 0.9em; color: #b3b3b3; font-weight: bold; cursor: pointer; &amp;:hover &#123; color: #000; &#125; &amp;.hide &#123; display: none; &#125;&#125; .toc-title.clickable &#123; cursor: pointer; &amp;:hover &#123; color: #88acdb; &#125; &amp;:active &#123; color: #d3d3d3; &#125;&#125;以上两步做完之后，点击目录前的小三角符号或双击目录名就能折叠相应目录，点击“文章目录”就能折叠所有目录。待续。。。后记 先就写到这里，如后续修改中发现问题再继续记录吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题]]></title>
    <url>posts/22c3daf1.html</url>
    <content type="text"><![CDATA[前言 曾写过一个程序，需要有一个界面，但本人不想使用 MFC，因缘巧合，在网上看到 Qt，就尝试用了一下，遂有此文。本人的 Qt 版本为 qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的 Qt 可以通过 Visual Studio 2013 开发 Qt 程序（各位看官猜的没错，本人并没有直接使用 Qt Creator 开发 Qt 程序，而是通过 VS 开发 Qt 程序的 \(^o^)/），一来是熟悉 VS 开发，对 Qt Creator 完全没用过；二来是已经在 VS 配好全套的开发环境了（画外音：说白了就是懒嘛 ╭(╯^╰)╮）。但是在 VS 中开发 Qt 程序还需要一些其它的配置。准备篇 在 VS 中开发 Qt 程序首先需要安装一个 addin 外接程序，下载并安装 qt-vs-addin-1.2.5.exe（http://download.qt.io/archive/vsaddin/），（网上说该程序已不支持 VS2013 及以上版本的 VS，原因是 VS2013 及其以上版本的 VS 都不支持该种类型的插件，新版本的 VS 需要安装新型插件 qt-vs-tools-msvc2013-2.1.1.vsix 或 qt-vs-tools-msvc2015-2.1.1.vsix），但是经本人实测，本人的 VS2013-update5 英文旗舰版通过 qt-vs-addin-1.2.5 编写 Qt 程序完全没问题，不过 VS2015 就不知道了，可能真需要安装新型插件。下载安装好相应的软件之后需要在 VS 中配置 Qt 环境，虽然不配置也能正常编译，但是会在 Qt 相关的语句下面出现红色波浪线，本人轻微强迫症表示不能忍 ╭(╯^╰)╮。具体配置如下：选中“VC++目录”，在“包含目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\include在“库目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\lib配置完成之后即可发现红色波浪线已消失。使用篇 VS 中如何开发 Qt 程序请详见参考资料，懒癌发作，不想写了 =_=（其实是因为要写的话只能贴图了，本人表示不想使用图片 (╯﹏╰) ）。问题篇问题描述：本人在用 Qt 显示 OpenCV 的 Mat 数据图像时，有时会发生扭曲现象（图像从对角线分开，两边颠倒，扭曲），有时却不会，为了撤了解决问题，查阅了相关资料，终于发现症结所在，原来是图片数据格式不符合 Qt 的图片数据格式。解决办法：正文来喽 ~\(≧▽≦)/~，就不说废话了，“Talk is cheap. Show you the code”，具体完整正确显示C++代码为：123456789101112131415161718192021222324void showMatWithQtQlabel(const cv::Mat &amp;img, QLabel *label)&#123; // [Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决](http://lovelittlebean.blog.163.com/blog/static/11658218620125208212189/) QImage q_img; if(img.channels() == 3) // RGB image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB888).rgbSwapped(); &#125;else if (img.channels() == 4) // RGBA image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB32); &#125;else // gray image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_Indexed8); &#125; // -------------- 图片自适应label ------------------- QImage q_label_img = q_img.scaled(label-&gt;size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 图片自适应label大小 label-&gt;setPixmap(QPixmap::fromImage(q_label_img)); // 将图片显示到label上 // -------------- label自适应图片 ------------------- /*label-&gt;setPixmap(QPixmap::fromImage(q_img)); // 显示在label中 label-&gt;resize(label-&gt;pixmap()-&gt;size()); // 改变label的尺寸以自适应图像 label-&gt;show(); */&#125; rgbSwapped() 函数是为了使 Qt 中显示图形颜色更自然，因为 OpenCV 的 Mat 数据 RGB 图像是以 BGR 的顺序排列，而 Qt 中是以 RGB 的顺序排列，所以需要 rgbSwapped() 交换一下颜色通道排列顺序。附录1、摄像头数据采集问题注意：如果是从摄像头实时采集显示图像，在显示时需先判断图像有没有数据1234567if (image.data)&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;或1234567if (!image.empty())&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;具体原因可参考本人的一篇文章 解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题 。2、信号与槽的连接函数问题Qt4 中信号与槽的连接函数语法为：1connect(&amp;theTimer,SIGNAL(timeout()),this,SLOT(getFrame())); // 超时就去取下一帧而 Qt5 中信号与槽的连接函数新语法为：1connect(&amp;theTimer, &amp;QTimer::timeout, this, &amp;QtTest::getFrame); //超时就去取下一帧推荐使用 Qt5 新语法，具体原因可参考 qt5中信号和槽的新语法 。个人粗浅理解：信号函数一般是 Qt 中控件的库函数，比如按钮控件 QButton 的 QButton::clicked () 函数，定时器 QTimer 的 QTimer::timeout () 等函数；而槽函数是响应函数，一般由用户自己编写，也可以使用 Qt 中库函数。 使用 Qt 中可能会遇到的一些错误请参考 使用VS2010开发Qt程序的一点经验（http://www.cnblogs.com/csuftzzk/category/445772.html）。后记 本来其实就想把问题篇写出来的，毕竟主要就是想记录一下那个显示函数，但是感觉有点没头没尾，就把 VS 集成 Qt 开发环境也稍微写了一下，而使用篇确实是因为参考资料已经写的很详细了，所以就直接一笔带过了。参考资料[1] QT +openCV 实现摄像头采集以及拍照功能（http://blog.csdn.net/llh318724/article/category/930663）[2] VS2010 + QT5.2+ QT-VS-Addin1.2.2开发环境配置（http://blog.csdn.net/qqmindyourwill/article/category/5990841）[3] Qt+OpenCV界面（http://blog.csdn.net/fm0517/article/category/1110960）[4] Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决（http://blog.csdn.net/loveaborn/article/category/1164072）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题]]></title>
    <url>posts/509ee93b.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-2.4.11，编程语言为 C++。前言 本文其实是以前在刚学 OpenCV 时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。问题篇问题描述：使用 OpenCV-2.4.11 调用摄像头显示拍摄视频时报 runtime error，控制台窗口出现 OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file ……...cpp, line 261。解决办法：在显示图片时先判断是否有图像数据，如下：1234if (!image.empty()) &#123; imshow("window", image);&#125;或1234if (image.data) &#123; imshow("window", image);&#125;原因可能是：用 imshow() 显示图像时，其 image 必须有数据，如果它为空则程序会报错，而一般打开摄像头会有一定时间的延迟，这时程序已经启动，而摄像头由于启动延迟，不一定能及时获取图像，造成要显示的 image 为空，因此报错。个人粗浅理解，板砖轻拍 ⊙﹏⊙b。而网上有人也认为：我也是遇到这个问题，不过看到一个帖子写得不错（英文的），里面给出了一个可能的理由，就是我们用 opencv 打开视频的时候，会自动先监测摄像头有没有读到帧，如果没有，就会报错，然后再执行你的程序，加一个if判断就是跳过系统自己的判断，直接执行我们的程序。来自：https://zhidao.baidu.com/question/1831122325089024420.html有人说的原因是在 VideoCapture 刚开始获取摄像头视频流的过程不返回信号，所以判断 Mat 是否为空，并不断循环去获取 Mat。来自：http://www.cnblogs.com/tiny656/p/3538115.html附最终完整示例程序：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;// 调用摄像头void videoCaptureTest()&#123; //cv::VideoCapture cap(0); // 打开默认摄像头，参数0代表默认摄像头的ID cv::VideoCapture cap; cap.open(0); // 设置摄像头 cap.set(CV_CAP_PROP_FRAME_WIDTH,640); cap.set(CV_CAP_PROP_FRAME_HEIGHT,480); // 确认是否成功打开摄像头 if (!cap.isOpened()) &#123; printf("打开摄像头失败，退出！\n"); exit(-1); &#125; cv::namedWindow("Capture", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO); while (1) &#123; cv::Mat frame; cap &gt;&gt; frame; // 获取帧 // 对摄像头获取的帧进行各种处理 if (!frame.empty()) // 最好加上该判断，并在该判断中对帧进行处理 &#123; cv::imshow("Capture", frame); &#125; if(cv::waitKey(30) &gt;= 0) break; // 每30ms取一帧 &#125;&#125;int main(int argc, char *argv[])&#123; videoCaptureTest(); return 0;&#125; 其实也可以通过在获取帧时，反复获取帧，直到取到的帧有数据为止，这样就不需要判断语句了，直接显示即可，具体代码如下：123456do&#123; cap &gt;&gt; frame;&#125;while(frame.empty());cv::imshow("Capture", frame);参考自：https://stackoverflow.com/a/9285151 。后记 本文还是当初在国内某平台写博客时写的，但现在再回头看，又稍微有了点新的思路，温故确实能知新 (*^__^*) 嘻嘻……。参考资料[1] OpenCV2.3使用摄像头和视频（http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html）[2] OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, fi 这个问题怎么办？[3] OpenCV打开摄像头出现运行错误OpenCV Error：Assertion failed (size.width&gt;0&amp;&amp;size.height&gt;0)in cv::imshow，……（http://blog.csdn.net/czl389/article/category/6381887）[4] [OpenCV]获取摄像头视频（http://www.cnblogs.com/tiny656/category/550972.html）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加各种小部件]]></title>
    <url>posts/3bc0decc.html</url>
    <content type="text"><![CDATA[前言 本人目前还在使用对 Hexo 的主题 SPFK 自行魔改的那个主题（所谓的魔改也就是对照着 black-blue 主题修改了部分 CSS，然后又添加了一个站内搜索功能 (&gt;^ω^&lt;)），主题 SPFK 主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。添加 QQ 邮箱联系添加日期：2017-9-15 进入 QQ邮箱开放平台，点击“获取邮我按钮”，登录 QQ 之后继续点击该按钮，因为本人不需要其样式，只需要其链接即可，所以就默认样式，直接点击“获取代码”即可，本人默认的“HTML代码”为：1&lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" style="text-decoration:none;"&gt;&lt;img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_01.png"/&gt;&lt;/a&gt;提取其中的 href，即http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ，将该链接添加到 主题配置文件 中，具体如下：12subnav: mail: "http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ"重新部署站点即可发现对应的邮箱图标，点击该图标可直接给本人发邮件。添加 QQ 交谈链接添加日期：2017-9-15 进入 QQ推广，点击上方的“推广工具”，若没登录 QQ 则先登录 QQ，组件样式同样默认即可，这里需要注意的是，需要点击左边的“设置”，下滚页面，找到“安全级别设置”，如下安全级别设置完全公开（推荐商家，客服等用户使用，代码中显示QQ号码，易于推广）安全加密（推荐博主，论坛用户等使用，代码中不显示QQ号码）选中“安全加密”，不然该选项默认的为完全公开，这样 QQ 号码就直接会显示在代码中，不利于隐私保护，选中之后，点击“保存”。保存之后，再次点击“推广工具”，即可发现下方的复制代码区域的 HTML 代码已看不到明码显示的 QQ 号，（若还是能看到 QQ 号，没有任何变化，可关闭该界面，重启浏览器重新进入该界面），本人的“复制这段代码并将其粘贴到您的网页上”下方区域的默认的代码为：1&lt;a target="_blank" href="http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422"&gt;&lt;img border="0" src="http://wpa.qq.com/imgd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422&amp;pic=52" alt="点击这里给我发消息" title="点击这里给我发消息"/&gt;&lt;/a&gt;提取其中的 href，即http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422，将该链接添加到 主题配置文件 中，具体如下：12subnav: QQ: "http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12"重新部署站点即可发现对应的 QQ 图标，点击该图标可直接给本人发临时 QQ 消息。添加用户访问统计信息小工具 —— RevolverMaps添加日期：2017-10-12 由于本人暂时不想搞 SEO，所以就没有搞站点地图，更没有将本人的站点提交到百度和 Google 的站长平台上。但本人又想查看用户访问信息（是不是很矛盾 o(╯□╰)o），而正好本人看到有个很酷炫的 3D地球 能满足本人的需求（其实很酷炫才是主要原因 O(∩_∩)O~），所以本人决定将其加入本人的站点中（当做一部分装饰品 ๑乛◡乛๑）。该插件的名称为 RevolverMaps，具体样式可以去其官网看，本人就不贴图了。设置完前三步之后，第四步让用户复制代码到自己的站点上，注意第四步会让你选“new map”还是“update”，由于本人是初次使用，当然是选择默认的“new map”，如果是以前使用过，就选择“update”，并将原来使用的 script 代码输入出现的文本框并提交，这样就只是更改 3D 地球样式而不会丢失用户访问信息数据。 具体添加方法为：将复制的 script 代码放入想显示的某个 div 中。本人得到的 script 代码为：&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 由于本人的博客是双栏的，本人当然是把 RevolverMaps 放入左栏中，本人刚开始是把得到的 script 代码放入主题文件夹下 \layout\_partial\left-col.ejs 文件末尾的12 &lt;/header&gt; &lt;/div&gt;&lt;/header&gt; 标签之前（即在 header 的最下端显示 RevolverMaps ），但实际用起来有点不好看；本人又想干脆另外创造一个 div 放置地球，具体思路为：在 birdhouse 图标旁创建一个新的地球图标，再做一个像 birdhouse 图标一样的动画，鼠标移到地球图标时，出现一个 div，该 div 用来放置 RevolverMaps，这一步做到一半（即将一个新的地球图标并排放在 birdhouse 图标旁）发现这个效果感觉更不好看了，如果要改就需要大改了，有点麻烦 o(︶︿︶)o唉；于是本人看到鼠标放在 birdhouse 图标出现的菜单栏上，想到何不如将该菜单栏在添加一栏，创建一个 div 用来显示 RevolverMaps？事不宜迟，马上就动手添加该 div，具体添加步骤如下：首先当然是添加一个“访问情况”的列表名称，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;ul class=&quot;tips-inner&quot;&gt; 下最后一个 &lt;li&gt; 后即 &lt;/ul&gt; 前添加 &lt;li&gt;访问情况&lt;/li&gt;；接着像其它的列表一样（点击该列表 birdhouse 图标就会改变成相应的图标），点击“访问情况”会将 birdhouse 图标改变成一个地球小图标，经查阅相应的 css 文件，其它的列表对应的图标好像是利用 div 的边框属性画出来的（某业余前端的猜测+_+），本人目前还没有这样的才能，就只有投机的采用 Font Awesome 中的 globe 图标了。在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;icon-ctn&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;div class="icon-wrap icon-globe hide" data-idx="4"&gt; &lt;i class="fa fa-globe fa-spin fa-2x" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt;这样点击“访问情况”会将 birdhouse 图标变成一个旋转的地球小图标了；接下来就需要创建“访问情况”对应的 div 了，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;switch-wrap&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;section class="switch-part switch-part5"&gt; &lt;script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49" async="async"&gt;&lt;/script&gt;&lt;/section&gt;这样点击“访问情况”就能出现酷炫的 3D 地球了，才怪 :p。这样只能让 3D 地球出现在菜单界面，还需要添加修改相应的 css；最后就是改 css 样式了，本以为这一步很简单，没想到这一步花费本人最多时间 ╮(╯_╰)╭，修改的样式位于主题文件夹下 \source\css_partial\main.styl 文件中，首先为 switch-part5 添加对应的样式，在 .switch-part4 样式后添加：123456.switch-part5&#123; left: 400%; width: 100%; //height: 200px; //margin-left: 47px; &#125;做完这一步会发现 3D 地球显示不完全，下面会缺一点，所以还需要继续修改，修改过程如下：本人曾将该 width 减小（如上面代码中的注释），这样确实能让 3D 地球显示完全，但有点小，不是很好看；后面想到没显示完全可能是上层 div（.switch-area）太小且设置了 overflow: hidden;，于是这里本人首先增加了 .switch-area 的高度，这样确实能解决问题，但会使左栏的滚动条显示出来；所以本人接着尝试将 .switch-area 的 overflow: hidden; 注释掉，谁想注释掉之后出现了横向滚动条，这样更不好了，于是本人又更改为 overflow-x: hidden; ，谁想 .switch-area 又出现了竖直滚动条（感觉像拆东墙补西墙 -_-|||），查阅相关资料（CSS-overflow特性及总结）得知若 overflow-x 为 hidden，overflow-y 不为 hidden，则 overflow-y 将会自动重置为 auto，所以这里不能这样改，但 overflow: hidden; 还是得注释掉，不然上层 div 撑不开，而且不增加高度的话，还是不能完全显示 3D 地球，因为超出就隐藏了嘛；因为注释掉之后会出现横向滚动条，而又不能修改 .switch-area 的 overflow-x，所以就只能改更上层的 div，这里本人突然想起上次给左栏添加滚动条时，在 .left-col 下添加了 overflow: auto;，这次不如还修改这里，毕竟本人只想要竖直滚动条（其实不要滚动条却能滚动最好，但本人目前还没找到好的解决方案 (╯﹏╰)b），不要横向滚动条，于是将其修改为：12overflow-y: auto;overflow-x: hidden;没想到这样也能解决问题，虽然还是会在左栏出现滚动条，但这样感觉比增加 .switch-area 的高度要好（嗯，应该要好吧 (～ o ～)Y）。看以后能不能改成点击“访问情况”时才出现滚动条，点击其它列表则不出现滚动条（其实把滚动条隐藏最好，但网上那个两个 div 嵌套的方法本人尝试过会出现一些奇怪的问题，等以后再试试吧 ↖((^ω^)↗）。待续。。。后记 目前就添加这些小组件，以后应该会陆续添加一些其它的小东西 ↖(^ω^)↗。参考资料[1] 如何在自己网站上或者博客上放置QQ邮箱联系反馈（http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1）[2] 如何在自己的博客添加QQ组件（http://www.29mo.com/category/wltg）[3] 一步一步教你给自己博客添加QQ在线（http://www.feizl.com/feizhuliu/QQbaodian/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中显著性检测算法的使用]]></title>
    <url>posts/fd0f8195.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV 中实现了两种显著性检测算法，分别为 Spectral Residual 算法,出自 Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on, pages 1–8. IEEE, 2007. 和 Fine Grained Saliency 算法,出自 Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In Image and Vision Computing, Vol. 28 Issue 3, pages 391–402. Elsevier, 2010.。这两种算法同样是在扩展包 opencv_contrib-3.2.0 中，也是由于 opencv 官方示例程序对初学者不友好（主要是本人境界不够 o(╯□╰)o），所以本人对照其官方文档重新整理了一下。说明篇 使用 OpenCV 中实现的显著性检测算法进行显著性检测十分方便简洁，利用以下三个函数就可以：创建 Spectral Residual 算法显著性检测对象：static Ptr&lt;StaticSaliencySpectralResidual&gt; cv::saliency::StaticSaliencySpectralResidual::create();Spectral Residual 算法计算显著性图：bool cv::saliency::StaticSaliencySpectralResidual::computeSaliency(InputArray image, OutputArray saliencyMap);Fine Grained Saliency 算法显著性检测对应的函数声明同 Spectral Residual 算法类似。计算显著性图的二值图：bool cv::saliency::StaticSaliency::computeBinaryMap(InputArray _saliencyMap, OutputArray _binaryMap) ;具体使用方法可参考实例篇。实例篇 使用 OpenCV 中的显著性检测算法需要包含头文件#include &lt;opencv2/saliency.hpp&gt;，具体示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/saliency.hpp&gt;//******************************************************// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)////Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)//&#123;// if (saliencyType == "SPECTRAL_RESIDUAL")// return makePtr&lt;StaticSaliencySpectralResidual&gt;(); //computeSaliency返回的是32FC1// else if (saliencyType == "FINE_GRAINED")// return makePtr&lt;StaticSaliencyFineGrained&gt;(); //computeSaliency返回的是8UC1// else if (saliencyType == "BING")// return makePtr&lt;ObjectnessBING&gt;();// else if (saliencyType == "BinWangApr2014")// return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();// return Ptr&lt;Saliency&gt;();//&#125;//// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）//*****************************************************void spectralResidualTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入最真实的原始图像 cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); // [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687) if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Mat planes[] = &#123; cv::Mat_&lt;float&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;; cv::Mat complex_img; //复数矩阵 merge(planes, 2, complex_img); //把单通道矩阵组合成复数形式的双通道矩阵 dft(complex_img, complex_img); // 使用离散傅立叶变换 //对复数矩阵进行处理，方法为谱残差 cv::Mat magnitude, phase_angle, mag_mean; cv::Mat real_part, imaginary_part; split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; //实部 imaginary_part = planes[1]; //虚部 cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值 phase(real_part, imaginary_part, phase_angle); //计算相角 float *pre, *pim, *pm, *pp; //对幅值进行对数化 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = log(*pm); pm++; &#125; &#125; blur(magnitude, mag_mean, cv::Size(5, 5)); //对数谱的均值滤波 magnitude = magnitude - mag_mean; //求取对数频谱残差 //把对数谱残差的幅值和相角划归到复数形式 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pre = real_part.ptr&lt;float&gt;(i); pim = imaginary_part.ptr&lt;float&gt;(i); pm = magnitude.ptr&lt;float&gt;(i); pp = phase_angle.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = exp(*pm); *pre = *pm * cos(*pp); *pim = *pm * sin(*pp); pre++; pim++; pm++; pp++; &#125; &#125; cv::Mat planes1[] = &#123; cv::Mat_&lt;float&gt;(real_part), cv::Mat_&lt;float&gt;(imaginary_part) &#125;; merge(planes1, 2, complex_img); //重新整合实部和虚部组成双通道形式的复数矩阵 idft(complex_img, complex_img, cv::DFT_SCALE); // 傅立叶反变换 split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; imaginary_part = planes[1]; cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值和相角 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = (*pm) * (*pm); pm++; &#125; &#125; GaussianBlur(magnitude, magnitude, cv::Size(7, 7), 2.5, 2.5); cv::Mat invDFT, invDFTcvt; normalize(magnitude, invDFT, 0, 255, cv::NORM_MINMAX); //归一化到[0,255]供显示 invDFT.convertTo(invDFTcvt, CV_8U); //转化成CV_8U型 cv::namedWindow("SpectualResidual", CV_WND_PROP_ASPECTRATIO); cv::imshow("SpectualResidual", invDFTcvt); cv::Mat thresholded; cv::threshold(invDFTcvt, thresholded, 0, 255, CV_THRESH_OTSU); cv::namedWindow("Thresholded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded Image", thresholded); cv::Mat eroded; // 纵向腐蚀 cv::erode(thresholded, eroded, cv::Mat(5, 1, CV_8UC1, cv::Scalar(1)), cv::Point(-1, -1), 3); // cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心 cv::namedWindow("eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("eroded Image", eroded); //cv::Mat thresholded; cv::threshold(eroded, thresholded, 60, 255, CV_THRESH_BINARY); cv::namedWindow("Thresholded eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded eroded Image", thresholded);&#125; // 显著性检测算法基类void saliencyTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create("SPECTRAL_RESIDUAL"); // FINE_GRAINED为Fine Grained Saliency算法 cv::Mat saliency_map; if (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map)) // 计算显著性图 &#123; cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", saliency_map); cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1); normalize(saliency_map, saliency_map_show, 0, 255, CV_MINMAX); //归一化到[0,255]供显示 saliency_map_show.convertTo(saliency_map_show, CV_8U); //转化成CV_8U型 cv::namedWindow("saliency_map_show", CV_WND_PROP_ASPECTRATIO); cv::imshow("saliency_map_show", saliency_map_show); cv::Mat binary_map; cv::saliency::StaticSaliencySpectralResidual spec; if (spec.computeBinaryMap(saliency_map, binary_map)) // 对显著性图进行二值化 &#123; cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); &#125; &#125;&#125;// Fine Grained Saliency算法void FGSTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create(); cv::Mat fgs_saliency_map; fgs-&gt;computeSaliency(src_img, fgs_saliency_map); cv::namedWindow("FGS saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("FGS saliency map", fgs_saliency_map); //cv::imwrite("../data/T_S.png", fgs_saliency_map); cv::Mat binary_map; cv::threshold(fgs_saliency_map, binary_map, 0, 255, CV_THRESH_OTSU); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); //cv::imwrite("../data/T_S_B.png", binary_map);&#125;// Spectral Residual算法void SRTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create(); cv::Mat sr_saliency_map; sr-&gt;computeSaliency(src_img, sr_saliency_map); cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", sr_saliency_map); cv::Mat binary_map; sr-&gt;computeBinaryMap(sr_saliency_map, binary_map); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map);&#125;int main(int argc, char *argv[])&#123; //spectralResidualTest(); //saliencyTest(); //FGSTest(); SRTest(); while (cv::waitKey(0) != 27) &#123; &#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。 这里面有个小东西需要注意，就是 computeBinaryMap() 函数，看其文档描述其中使用 K-means 算法和 Otsu 算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV 中 Spectral Residual 算法 computeSaliency() 返回的结果为浮点数，而 Fine Grained Saliency 算法 computeSaliency() 返回的结果却是整型数据，所以这一点需要注意 Fine Grained Saliency 算法返回的结果不能直接使用 computeBinaryMap() 函数，一般对其结果直接使用 OTSU 算法进行阈值分割即可。后记 本文使用的这两种算法在本人的电脑上运行时间都较长，基本不可能用来处理视频流，而且在本人的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过 OpenCV 中也有用来处理视频流的显著性检测算法，其为 BING 算法,出自Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In IEEE CVPR, 2014.，实际上这是一种快速提取目标候选框的算法。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中Selective Search算法的使用]]></title>
    <url>posts/35132cb7.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV-3.2 中的 Selective Search 算法是在其扩展包中，所以要想使用该算法需自行编译 opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（本人编程水平有限，粗浅评价，勿怪 (*^__^ *) 嘻嘻……），所以本人参考其官方文档及其官方示例程序写下此文。说明篇 该算法是选取 region proposal（一般翻译成候选区域 / 区域建议）领域中当时的 state-of-the-art。其算法具体思想出自 Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154–171, 2013.，若英文水平不够，还想了解其中文思想请参考文末参考资料。 OpenCV中实现的相应函数：void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addGraphSegmentation(Ptr&lt;GraphSegmentation&gt; g);：添加相应的图割算法；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addImage(InputArray img) ; ：添加待处理的图片；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addStrategy(Ptr&lt;SelectiveSearchSegmentationStrategy&gt; s); ：添加相应的策略（颜色相似度、纹理相似度、尺寸相似度和填充相似度）；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::process(std::vector&lt;Rect&gt; &amp;rects);：结合图割算法和相应策略进行处理，返回候选框。实例篇 使用 Selective Search 算法需包含#include &lt;opencv2/ximgproc.hpp&gt;，完整示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/ximgproc.hpp&gt;void SSTest()&#123; // [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入原始图像 cv::namedWindow("src_img", CV_WINDOW_KEEPRATIO); cv::imshow("src_img", src_img); //// 转换为灰度图 //cv::Mat gray_img; //cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY); // 图割算法 cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation(); cv::Mat graph_segmented; gs-&gt;processImage(src_img, graph_segmented); normalize(graph_segmented, graph_segmented, 0, 255, CV_MINMAX); // 归一化到[0,255]供显示 graph_segmented.convertTo(graph_segmented, CV_8U); // 数据类型转化成CV_8U型 // cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR); cv::namedWindow("graph_segmented", CV_WINDOW_KEEPRATIO); imshow("graph_segmented", graph_segmented); // 为selective search算法添加图割算法处理结果 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;addGraphSegmentation(gs); ss-&gt;addImage(src_img); // 添加待处理的图片 // 自定义策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(); // 颜色相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(); // 纹理相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(); // 尺寸相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(); // 填充相似度策略 // 添加策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill); // 合并以上4种策略 ss-&gt;addStrategy(sss); std::vector&lt;cv::Rect&gt; regions; ss-&gt;process(regions); // 处理结果 // 显示结果 cv::Mat show_img = src_img.clone(); for (std::vector&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r) &#123; cv::rectangle(show_img, *it_r, cv::Scalar(0, 0, 255), 3); &#125; cv::namedWindow("show_img", CV_WINDOW_KEEPRATIO); imshow("show_img", show_img); // -------忽略上述步骤，直接采用方便算法提取候选区域------------------------ /*************************************************************************** cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;setBaseImage(src_img); // 采用switch* functions提取候选区域 ss-&gt;switchToSelectiveSearchFast(); // 快速提取区域 std::vector&lt;cv::Rect&gt; rects; ss-&gt;process(rects); int nb_rects = 10; char c = (char)cv::waitKey(); while (c != 'q') &#123; cv::Mat wimg = src_img.clone(); int i = 0; for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it) &#123; if (i++ &lt; nb_rects) &#123; cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3); &#125; &#125; cv::namedWindow("Output", CV_WINDOW_KEEPRATIO); imshow("Output", wimg); c = (char)cv::waitKey(); if (c == 'd') &#123; nb_rects += 10; &#125; if (c == 'a' &amp;&amp; nb_rects &gt; 10) &#123; nb_rects -= 10; &#125; &#125; ********************************************************/&#125;int main(int argc, char *argv[])&#123; SSTest(); while (cv::waitKey(0) != 27) &#123;&#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法 switchToSelectiveSearchFast() 的参数。本人的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在本人电脑上略显长。GitHub 上也有大神自己用 opencv 实现了该算法，参考 watanika/selective-search-cpp，该算法的参数感觉比 OpenCV 自带的 Selective Search 算法要好调一些，但优化效果没有 opencv 好，其运行时间在本人电脑上更长，毕竟 OpenCV 是 Intel 的亲儿子，Intel 肯定针对处理器对 OpenCV 底层做了一定的优化。参考资料[1] 论文笔记：Selective Search for Object Recognition（http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/）[2] Selective Search for Object Recognition(阅读)（http://blog.csdn.net/langb2014/article/category/5772811）[3] 论文笔记 《Selective Search for Object Recognition》（http://blog.csdn.net/csyhhb/article/category/6048588）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10以树形结构显示文件目录结构]]></title>
    <url>posts/c3f26b1.html</url>
    <content type="text"><![CDATA[前言 本文其实可以算是标题党，Windows本身并不能以树形结构显示文件目录结构，一般需要借助第三方工具（后面去网上搜索了一下，发现 Windows 居然也有一个 tree 命令 o(╯□╰)o），Windows 虽然能用命令行显示树形结构文件目录，但不像 Linux 那样可以输入一些参数控制其输出。Win10 有个特殊的功能，就是可以使用 Ubuntu 的 bash，只需要开启这个有趣的功能，就可以将 Win10 当 Ubuntu 使用，从而像 Linux 那样只输入相关命令即可显示树形结构文件目录。*注：值得注意的是 Win10 中的 bash 目前不支持中文输入，只能切换到英文输入才能正常输入。准备篇首先需要在 Win10 下开启 bash 功能。具体开启方法为：打开 Win图标 ==》 设置 ==》 更新和安全 ==》 针对开发人员（左侧），选中开发人员模式，打开 Win图标 ==》 设置 ==》 应用 ==》 应用和功能（左侧） ==》 程序和功能（最下面的相关设置中） ==》 启用或关闭Windows功能（左侧），选中适用于Linux的Windows子系统(Beta)后点击确定。重启计算机。打开 bash，打开 bash 的方法很多，这里列出三种：1、直接在微软小娜中输入关键字“bash”搜索 Bash on Ubuntu on Windows；2、Win键+R，输入 bash，点击确定即可打开 bash；3、Win键+R，输入 cmd，在 cmd 中输入 bash，回车即可打开 bash。打开 bash 后将会提示你是否下载安装 Ubuntu on Windows，输入 y 继续，稍等片刻即可完成下载安装。设置篇 安装完成后系统将会提示你设置用户名和密码。（如果这一步设置成功可以直接跳过设置篇直接看使用篇）。不知道怎的，本人这一步没有完成，每次系统都是直接以 root 用户登录，而且没有密码，为了安全考虑，也幸好登录时是 root 用户，可以自由对系统修改。所以本人需要对 root 密码进行修改，并创建新的用户。具体过程需执行以下命令：root 用户下，修改用户密码：1passwd 用户名 (修改密码) 由于本人需要修改 root 密码，所以该用户名即为 root，执行之后需要输入新密码（在 *nix 哲学中，密码是不会显示在输入屏幕中的，所以如果在输入密码时发现屏幕没有任何变化是没关系的，只管输入即可 ↖(^ω^)↗），两次输入完成后会显示密码更新成功。接下来需要创建新的普通用户，在 root 用户下执行：1adduser xxx # 这样的命令会在home目录下添加一个帐号或者1useradd xxx #仅仅是添加用户，不会在home目录添加帐号 推荐使用前者，这样可以很明确已经成功创建新用户，而且如果用户需要存放一些文件也更安全和方便。 在 *nix 中，绝对不推荐直接使用root用户对系统执行各种命令，毕竟其权限太大，一旦误操作将造成无法挽回的后果。有些命令普通用户可能没有权限执行，这时需要提高其权限，普通用户临时获取 root 权限的方法为：在需要执行的命令前添加sudo，像上文中如果普通用户需要创建新用户 xxx 则需要执行sudo adduser xxx，执行以上命令后同样需要输入新用户的密码。使用篇 先切换至普通用户，执行su xxx切换用户，即可发现 shell 提示符由#变为$，前面的用户名由root变为xxx；执行cd ~切换至用户目录。由于 Ubuntu 系统中本身没有 tree 这个命令，需要执行以下命令安装 tree 命令工具：1sudo apt install tree 直接输入tree命令，系统将会自动以树形结构列出当前目录中所有文件及文件夹；执行tree -L N 命令，以树形结构查看当前 N 级的目录和文件，eg：以树形结构查看当前目录二级文件结构，则执行tree -L 2。若想将输出的2级文件结构保存至上一层文件的tree.txt文件中，可执行tree -L 2 &gt; ../tree.txt，进入上一层目录cd ..，打开 tree.txt 即可发现该目录的文件结构。后记 遇事还是需要多查证一下啊，想当然果然是会出问题的，文章开头差点就犯错误了 ~\(≧▽≦)/~。本文其实是在写 Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 时，为了方便显示输出文件结构而查找的相关资料。参考资料[1]linux tree命令以树形结构显示文件目录结构（http://jingyan.baidu.com/tag?tagName=linux）[2] win tree命令 tree导出目录 tree显示树形结构（http://jingyan.baidu.com/tag?tagName=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F）[3] win10下linux系统的安装（开启）和使用[4] Ubuntu建立和删除用户[5] linux修改root密码和linux忘记root密码后找回密码的方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACGN作品个人印象简评]]></title>
    <url>posts/68065b99.html</url>
    <content type="text"><![CDATA[前言 本人无意向任何人推荐任何东西，毕竟那个年纪已经过去了，有些东西还是独自品味比较好，写这些东西只是单纯的想留个纪念。本文主要是分享一下本人看过的一些 ACGN 作品及相应的感觉感受，也算是记录一下，以免雁过不留痕，看过的就这样看过了。以下作品只是简单排列，没有的所谓的排名之分，只凭个人当时主观印象深浅，简单来说就是想到哪就写到哪。※注：本文所指的 ACGN 只是单纯的指 Animation（动画）、Comic（漫画）、Game（游戏）、Novel（小说）四个独立并列的部分，不是通俗意义上霓虹国的那种紧密联系的一个整体。Animation 篇 动画，真正接触霓虹国的动画还是在中学时代吧，那时也是在同学的推荐下入坑了「火影」（直到现在都还没去看结局，虽然前年就完结了），当时完全接受不了「海贼王」的画风，还是后来画了一个暑假追上来的。『海贼王』。本人偏向于「海贼王」这个译名，个人感觉顶上战争之前和顶上战争之后完全是两部作品，还是觉得顶上战争之前比较好看，之前就像是游戏里打怪升级，能过些热血的瘾，但之后变成了只打怪不升级，而且感觉怪是强行被画败的 ╮(╯▽╰)╭，海贼王里还有个奇怪的现象，好像几乎不死人，不过也可能是侧重点不同，死人的场景没必要画出来了。『CLANNAD』。CL 或许能称作为人生，但人生却不是一部 CL，毕竟人生不可能有光玉存在，看完『AIR』之后，本人并没有什么很强烈的感触，所以直接又接着看了 CL，没想到着实让本人这堂堂七尺男儿好生体验了把热泪盈眶的感觉。另，CL 和 Air 的音乐也很赞，麻枝准真提莫的不负其大魔王的称号 （°Д°）Ъ。『天降之物』。算是本人的入宅作了吧，没想到当时霓虹国的肉番也能做的这么精良，这里不得不赞一下「天降之物」的制作组，实在是太良心了，都破产了，还硬是把结局用 屁屁踢 形式放出来了，对比隔壁的『约会（pao）大作战』，可以说是有生之年了 ╮(╯▽╰)╭，不过还是比现在的肉番要好，现在的肉番只剩下肉了，还不如直接出里番 ๑乛◡乛๑ 。『进击的巨人』。本人只能说制作组的经费别烧的那么快啊，不然可能又是一个有生之年，感觉每一帧都在烧钱。坐等同样制作精良的今年4月番『东京喰种』第三季 (๑´ڡ`๑) 。『龙珠』系列。童年回忆啊，虽然目前还在更「龙珠超」，但是已经找不到童年时的感觉了。『犬夜叉』。虽说中学时代就听童靴讨论过，但本人真正接触还是在本科时代，剧情设计的很好，音乐也很赞。『死神』。感觉打完蓝染之后直接结束还是一部很好的作品。『新世纪福（quan）音（qian）战士』。以当时的社会环境看应该是很黄很暴力了，如果没看过TV版的EVA，直接看剧场版就行，剧场版差不多就是TV版的高清重制，虽然重制的画面很良心，但这也改变不了其圈钱的本质，你要出个正儿八经的完结篇或者对剧情进行完善补充该多好。『浪客剑心』。个人觉得TV版打败志志雄就可以结束了，「追忆篇」也十分不错，「巴」和「熏」都可以说是剑心的救赎者。『钢之炼金术师FA』。本人没看过 03 版的钢炼，只能说 FA 不管是音乐还是剧情都堪称完美（本人不知道真正的完美应该是什么样子），塑造的人物都有血有肉。『噬魂师』。这部动画的结局骨头社也做的太水了 o(︶︿︶)o，不然也是一部上佳之作。『瑞克和莫蒂』。很有意思的美漫，各种天马行空的想象，对一些事物的毒舌吐槽也无敌了 (≧ω≦)。『魔法少女小圆』。其实一开始要本人看魔圆，本人是拒绝的，因为一听名字就以为是什么少女漫 (#-_-)，后面看了一下又没法接受那奇诡的画风，尤其是魔女出来的时候，卧槽，这 TM 是啥么鬼 (⊙_⊙)？后面无聊的时候看了几集勉强就能接受了，不过说好的要做「爱的战士」呢？结局就这样？(╯°□°）╯︵ ┻━┻，还好剧场版稍微补充了一下，音乐也很好听。美好的事物表面可能隐藏着最深的邪恶，丑陋的事物表面也可能隐藏着无尽的美好，当然，对于宇宙维稳来说，QB 的做法没错，但对于马猴烧酒来说，这就很残忍了，但人类也不会在意蝼蚁的想法吧，所以与其说是悲剧，不如说是真实，正如结局魔女是不存在了，但其它的魔物出现了。『零之使魔』。其实本人是看完「夏娜」第一季之后看的，虽说夏娜和露易丝的都是钉宫配的，但个人感觉还是露易丝萌一点呢 ～(￣▽￣～)，才人万人斩那里的 BGM 实在是斯巴拉西，最后居然不是后宫，啊啊啊 🔥，可惜了蒂法那么大的欧派了，说好的 naizi 即正义呢 _(:з」∠)_。『Angle Beats!』。AB 是曾经的一个室友推荐看的，说实话不知道是本人没看懂还是咋的，没看出什么名堂啊，只能说 OP 很赞。『潜行吧！奈亚子』。吐槽能力很有意思啊，还有全宇宙最长的呆毛，可以说很萌了，搞不懂为啥会被禁，难道是奈亚子表达爱意的方式太露骨了 (ಡωಡ)。『夏洛特』。网易云音乐推荐的，ED 很好听啊，看了动画只记得主角好像把全世界的超能力都吸收了，其它的剧情也不记得了，初次看到奈绪的图片还以为是奈亚子（雾）。『紫罗兰永恒花园』。个人还是有点无法体会剧中的感情，只能说画面做的很精致。一开始还以为是神马科幻战争片，毕竟女主的手摆在哪里 （雾）。『少女终末旅行』。也是网易云推荐的，主要是第五集的插曲很好听呢，以一种轻松的心态看这种沉重的番另有一番滋味。emmm……，知道漫画的结局之后还是感觉很沉重，（哇的一声就哭了 😭），这或许就是最深的绝望了吧，堪比「迷雾」，想必漫画作者的刀片应该收了不少呢，（突然黑化 ヾ(▼ﾍ▼；)ｵｲｺﾗ）。其实第 9 集的ED也很好听，可惜 OST 没有收录，MMP，只能截取音频听听了。『来自深渊』。不行，刚看完「末旅」，心情太沉重了，要看点稍微轻松的冷静一下，抚慰一下本人受伤的心灵，「深渊」虽然相比日常番还是沉重一些，但至少不绝望，感觉还是有 “希望” 的，期待下一季。『宝石之国』。骨肉魂的设定很有意思，只记得第九集台词老师说：“强大的力量总伴随着孤独”，也正如「B站」下的某个评论所说：“或许这就是成长所需要的代价”。个人感觉人的成长也是如此，成长意味着不再天真，不再给别人添麻烦，但这中间会失去许多，人与人之间的隔阂也越来越大，至于是好事还是坏事就只有自己知道了，有些东西只有直接接触之后才知道是好是坏。成长之后就会自然而然的开始求真，当然有很大一部分人会在求真之路上迷失自我，继续浑浑噩噩，却又不似初始的天真，而是成为一种活死人状态，成为社会这个大机器上的一个微小零件，少一个不少，多一个也不多。如果说第一季是成长之路，那下一季应该就是求真之路了。『滑头鬼之孙』。百鬼夜行时的 BGM 很赞呀！只怕是天国的第三季了。Comic 篇 漫画，本人看的比较少，了解也不多，就不做评价了。印象里比较深的就是『伊藤润二』系列中的「漩涡」了，看完这个本人只能感叹作者的奇思妙想了。还有就是当年在追三大民工漫的时候，有时为了提前了解剧情，也会去看一下其漫画。当然偶尔也会看一下那个，，，那种漫画 (⁄ ⁄•⁄ω⁄•⁄ ⁄) ，毕竟刺激性更强，画面感更强，像那个「搞笑漫畫日和」什么的（诶，在想什么呢 (￣ε(#￣)☆╰╮(￣▽￣///)）。Game 篇 游戏，本人也玩的比较少，小时候在小伙伴家里偶尔会蹭一下 FC 游戏，中学时陪同学玩街机，也两下子就把游戏币给玩没了 Σ(ﾟдﾟ;)，大学时玩通两三个单机，专注的玩了一个手游，至于什么网络游戏就根本没玩过，本人还是偏向于动作冒险类游戏。『奥日与黑暗森林』（Ori and the Blind Forest）。巨硬出品，必属精品，不管是画质，画风，音乐都是五星好评，但是手残党伤不起啊，有些关卡的难度简直是阶跃性的 /つ∇T)。期待续作『奥日与精灵意志』（Ori and the Will of the Wisps）。『鬼泣』系列（Devil May Cry）。这个系列本人没一个通关的，只是稍微玩过一下，不得不说卡普空公司虽然经常炒冷饭，但是其制作也确实精良，可以说是动作类游戏的代表作了，打击感和连招特效都超带感，dei劲，以后有时间再给它通关。『艾希ICEY』。算是国产游戏的佳作了，只是碍于其独立游戏的经费，最大的不足之处就是其体量也太小了吧，两个小时打通绰绰有余，而且通关之后就没有欲望玩第二次了，玩法比较单一。『菲斯 Fez』。「纪念碑谷」就是受到这款游戏的启发，其中的一些玩法和游戏元素也借鉴了这款游戏，这款游戏简直太斯（sang）巴（xin）拉（bing）西（kuang），还有依靠 BGM 解谜的，这种操作还真没见过（也有可能是本人游戏玩的太少了 o(╯□╰)o），这是本人玩的第一个多周目游戏，每周目都会有新的体验，而且这游戏的世界观真是惊人，数学中的维度在这游戏里面会有一种非常直观的体验，尤其是每周目结束时的剧情动画。Novel 篇 小说，也算是中学时代入的坑吧，在本科前两年达到顶峰，目前处于逐渐退坑的状态，一来确实是没有什么小说吸引本人了；二来是没那么多时间看小说了。『驭兽斋』，作者：雨魔。可以算是本人这么多年的网络小说生涯的入坑之作了，现在虽然剧情忘记了，但当年看的如痴如醉的感觉却没忘。『仙逆』，作者：耳根。还是当年在小白时代看的，可以说印象非常深了，个人感觉「凡人修仙传」和它没法比。『幽冥仙途』，作者：减肥专家。这个是本人渡过小白时代书荒的时候在书荒吧看到别人推荐的，这简直是暗黑系的典范，或许李珣的人生才是人生该有的样子。『贩罪』，作者：三天两觉。很有意思的写法，各种插叙蒙太奇手法，画面感极强，作者的吐槽能力MAX啊。『死人经』，作者：冰临神下。本人武侠小说看得极少，像什么金庸、古龙等人的小说本人一部也没看看过，只是看过相关的影视作品，但这部小说确实本人痴迷的看完了，虽然以当前的眼光看其好像还是有点金庸那种 “掉进悬崖就能得到绝世武功” 的味道，但是主角却还是慢慢成长变化的，并不是一触而就的状态。『亵渎』，作者：烟雨江南。这本书还是本人入坑时期看的，所以一些剧情完全忘记了，只记得有一只很有意思的骷髅。回想当年看书真是不挑剔啊，无论什么书，只要知道个名字就会去看完，也是在那段时间，把番茄、唐三、辰东等的作品都看完了，也逐渐脱离小白时代，不得不说，当年这些作品对本人三观的形成还是有很大影响的。另外以现在的眼光来看就是感觉这些作者的作品只需要选择一本代表作看看就行（eg：唐三（斗罗大陆）、土豆（斗破苍穹）、番茄（盘龙）、辰东（神墓）），毕竟一个作者的风格确实很难改变，其它的也是差不多的套路，一般来说一个作者因一部作品封神之后，很难再写出超越之作，从某种意义上来说这并不是江郎才尽，而只是人只有在特定的时候才能有特定的想法，发挥比较好而已。『 无极魔道』，作者：逆苍天。后期书荒时偶然看到的，没想到还是一部很不错的作品，快意恩仇，最后居然把所有人都坑杀了。『庆余年』，作者：猫腻。也是后期书荒看，本来本人是不大想看这种架空历史小说的，但是看了之后感觉里面的权谋很有意思。『紫川』，作者：老猪。这本书本人没读完，主要是当时的状态不适合看这本书，里面有些情节以当时的状态实在是没法看下去。『佣兵天下』，作者：说不得大师。这本书也是本人小白时代看的，记得这本书当年好像是在看完「静官」的『兽血沸腾』之后看的，当时只感叹其友情。『诛仙』，作者：萧鼎。以本人现在的眼光来看感觉有点名过其实。『鬼吹灯』，作者：天下霸唱。这本书本人也没看完，其实本人是先看的『盗墓笔记』，后面才去看鬼吹灯，所以也稍微了解了一下这两部作品的渊源，个人感觉，盗墓笔记还是很大一部分借鉴了鬼吹灯，而且盗墓笔记感觉后面有点胡乱写的味道。『恶魔法则』，作者：跳舞。本人小白时代看的作品，剧情也全都忘记了，不做评价，依稀记得好像有点搞笑。『七界传说』，作者：心梦无痕。算是本人看的第一本这种风格的小说——主人公刚出山就差不多是无敌之姿了，后期的对手也不是庸人，感觉十分有意思。『升邪』，作者：豆子惹的祸。读起来感觉很轻松的一本小说。『宠魅』，作者：鱼的天空。记得当时看这本小数是为了找一本类似于 驭兽斋 描写宠物的小说，于是就找到了这本，感觉结局还是有点虐心，现在想起来还是有点不好受。『长生不死』，作者：观棋。里面的计谋还是很有意思，居然用传销之法颠覆一个国家的经济，好像是的吧。『风姿物语』，作者：罗森。不愧是誉为“现代玄幻小说鼻祖”的网文，后面玄幻小说的模式或多或少都能在这里看到影子。作者也真是个人才，不仅正经的网文写的不错，而且小 h 书也写的很溜，像小黄书中的典范，「阿里布达年代祭」和「六朝」系列等。后记 以后有看过或回想起看过的作品再继续更新吧 （↖(^ ω ^)↗）。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加站内本地搜索]]></title>
    <url>posts/4f6225b7.html</url>
    <content type="text"><![CDATA[前言 虽然本人博客目前数量不多，质量也不高，但抱着搞事的心态，先弄它一个站内本地搜索再说。准备篇 要想使用本地搜索功能，首先需要安装相应的搜索插件 hexo-generator-searchdb，网上可能大多数用的是 hexo-generator-search 这个插件，也有都装的，但本人就只安装这一个了，好像 hexo-generator-searchdb 更完善一点，由于本人前端接触的极少，所以就没有一一对比了，网上也没查到具体对比情况，有兴趣的童靴可以试试 (╯▽╰)。至于具体安装如下，在站点根目录执行：1npm install hexo-generator-searchdb --save 安装完之后重新生成页面，将会发现 public文件夹 下多出一个 search.xml 文件。然后在配置文件 _config.yml 中添加：1234# 站点本地搜索search: path: search.xml field: all其中：path - 指定生成的索引数据的文件名。默认为 search.xml 。field - 指定索引数据的生成范围。可选值包括：post - 只生成博客文章（post）的索引（默认）；page - 只生成其他页面（page）的索引；all - 生成所有文章和页面的索引。 至于是在 主题配置文件，还是在 站点配置文件 中添加，个人觉得都没关系，附：本人是在主题配置文件中添加的。接下来就需要修改原主题的代码了。改码篇 由于本人博客主题是基于 SPFK 对照着 black-blue 进行修改的，而且因为 black-blue 是有搜索的（本人不知道 black-blue 主题的作者是如何完成的，借助了什么技术），所以本人就看 black-blue 的搜索功能是修改了 SPFK 哪个地方，再将相应的代码添加至 SPFK 中（其中相应的代码来自让 Hexo 博客支持本地站内搜索），从而逐渐完成本次搜索功能。首先找到 spfk 主题下的 left-col.ejs 文件，对其修改如下：123456789101112&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot;&gt; &lt;/form&gt; --&gt; &lt;form id=&quot;search-form&quot;&gt; &lt;!-- 搜索框相关 --&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;Search...&quot; class=&quot;search form-control&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot;/&gt; &lt;i class=&quot;fa fa-times&quot; onclick=&quot;resetSearch()&quot;&gt;&lt;/i&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;/form&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;p class=&apos;no-result&apos;&gt;No results found &lt;/p&gt; &lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt; &lt;%&#125;%&gt;其次找到 spfk 主题下的 after-footer.ejs 文件，将其修改如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125; &lt;/script&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 激活搜索框时才搜索 var inputArea = document.querySelector(&quot;#local-search-input&quot;); var getSearchFile = function()&#123; // 调用搜索函数 var search_path = &quot;&lt;%- config.search.path %&gt;&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;&lt;%- config.root %&gt;&quot; + search_path; searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;); &#125; inputArea.onfocus = function()&#123; getSearchFile() &#125; // 搜索重置 var $resetButton = $(&quot;#search-form .fa-times&quot;); var $resultArea = $(&quot;#local-search-result&quot;); inputArea.oninput = function()&#123; $resetButton.show(); &#125; resetSearch = function()&#123; $resultArea.html(&quot;&quot;); document.querySelector(&quot;#search-form&quot;).reset(); $resetButton.hide(); $(&quot;.no-result&quot;).hide(); &#125; // 屏蔽回车 inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125; // 无搜索结果 $resultArea.bind(&quot;DOMNodeRemoved DOMNodeInserted&quot;, function(e) &#123; if (!$(e.target).text()) &#123; $(&quot;.no-result&quot;).show(200); &#125; else &#123; $(&quot;.no-result&quot;).hide(); &#125; &#125;) // 搜索函数 var searchFunc = function(path, search_id, content_id) &#123; &apos;use strict&apos;; $.ajax(&#123; url: path, dataType: &quot;xml&quot;, success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( &quot;entry&quot;, xmlResponse ).map(function() &#123; return &#123; title: $( &quot;title&quot;, this ).text(), content: $(&quot;content&quot;,this).text(), url: $( &quot;url&quot; , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function()&#123; var str=&apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;/&quot;+ data_url +&quot;&apos; class=&apos;search-result-title&apos; target=&apos;_blank&apos;&gt;&quot;+ &quot;&gt; &quot; + data_title +&quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace(regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot;+keyword+&quot;&lt;/em&gt;&quot;); &#125;) str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content +&quot;...&lt;/p&gt;&quot; &#125; &#125; &#125;) $resultContent.innerHTML = str; &#125;) &#125; &#125;) &#125; &lt;/script&gt;&lt;%&#125;%&gt;最后找到 spfk 主题下的 main.styl 文件，在其末尾添加：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*搜索框*/.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid #d3d3d3; border-radius: 2px; opacity: 0.65; background: none;&#125;.search:hover &#123; border: 2px solid #d3d3d3; opacity: 1; box-shadow: 0 0 10px rgba(0,0,0,0.3);&#125;/*搜索重置按钮*/#search-form .fa-times &#123; display: none; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0,0,0,0.15); cursor: pointer; color: #4094c7;&#125;#search-form .fa-times:active &#123; background: #d3d3d3;&#125;#search-form .fa-times:hover &#123; zoom: 1.1; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0,0,0,0.25);&#125;/*搜索结果区*/#local-search-result &#123; //margin: auto -12% auto -6%; margin: 0; font-size: 0.9em; text-align: left; word-break: break-all; box-shadow: 4px 4px 6px rgba(0,0,0,0.46);&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*单条搜索结果*/#local-search-result li &#123; margin: 0.5em auto; border-bottom: 2px solid #d3d3d3;&#125;#local-search-result .search-result-list li:hover &#123; background: rgba(47,46,46,0.8); box-shadow: 0 0 5px rgba(0,0,0,0.2);&#125;/*匹配的标题*/#local-search-result a.search-result-title &#123; line-height: 1.2; font-weight: bold; color: #4094c7;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; line-height: 1.2em; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #ffffffb3;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 1em;&#125;/*无匹配搜索结果时显示*/p.no-result &#123; display: none; margin: 2em 0 2em 6%; padding-bottom: 0.5em; text-align: left; color: #808080; font-family: font-serif serif; border-bottom: 2px solid #d3d3d3;&#125; 这里请注意，当对 main.styl 文件做以上修改时，可能会发现有两个 .search 样式，而且相差不大，这时，不要对其原有的 .search 进行修改，更不要去注释掉它，只做上述修改就不用管了，不然可能会发生一些奇怪的事 o(&gt;﹏&lt;)o。本人当时做以上修改时，将其原有的 .search 样式注释掉之后，整个页面的 css 布局全部都乱了 (╯﹏╰)，不知道为什么 (⊙_⊙?)，这两个同名样式看起来明明差不多的，最后只能维持现状了，等以后有机会再看看吧，业余前端伤不起啊! ╮(╯_╰)╭。 至此整个站内本地搜索功能基本完成，勉强可以使用站内搜索功能了。问题篇 *注：以下问题于 2018-03-02 都已经解决 ╮(╯▽╰)╭。1、搜索函数返回的 url 地址有问题。 问题描述：当点击搜索结果时，新弹出的标签页地址栏中 url 地址会有部分乱码情况；当鼠标移到搜索的结果列表上时，浏览器左下角显示的 url 地址虽然没有乱码情况，但其中有一个重复的/符号。所幸这两个问题并没有造成浏览器解析错误，浏览器还是可以正常显示页面的。================= 修改日期：2018-03-02 ================= 解决办法：将 \blog\node_modules\hexo-generator-searchdb\templates\xml.ejs 文件中的 &lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;/url&gt; 修改为 &lt;url&gt;&lt;%- encodeURI(post.path) %&gt;&lt;/url&gt; ，使其中一些 url 中常见的字符（如：&amp;, ?, /, =）不被十六进制的转义序列进行替换。参考：escape,encodeURI,encodeURIComponent有什么区别? 和 JavaScript encodeURIComponent() 函数 。=====================================================2、搜索结果区布局有问题。 问题描述：当显示搜索结果时，搜索结果区会上下扩张，从而将其上下本来存在的一些布局挤开，造成布局混乱。这其实不算是一个 spfk 主题或者新添加的搜索功能的问题，而是新添加的一个东西又没有相应的和原本布局结合的布局文件，那就极大可能会有布局混乱的问题，至于这个要和原本布局契合的搜索结果区布局文件就只有等本人以后有机会有时间再完善去喽 ╮(╯▽╰)╭。3、搜索框激活问题。 问题描述：搜索框激活延迟很大，有时过很久或者需要切换站内页面它才能激活，给人的感觉就是好像没有搜索功能似的。添加搜索框激活功能据作者 MOxFIVE 所说是为了不让索引文件影响页面加载速度，MOxFIVE 同时也在文末指出了一些不足之处，如果索引文件太大，可能还是会造成一些问题，但本人的博客数量又不多，所以估计还是本人的代码混合问题，而且 MOxFIVE 的博客搜索功能好像没这个问题（至少本人目前没发现）。这个问题同样只有等以后再说了 (*^__^*) 嘻嘻……。后记 本文添加的本地搜索还很粗糙，还有很多地方需要以后去完善。但这好歹是一个好的开始，搜索功能至少勉强能够正常使用，总比以前是个空壳要好，以后有机会再慢慢去去完善吧 ↖(^ω^)↗。参考资料[1] jQuery-based Local Search Engine for Hexo（http://www.hahack.com/categories/codes/）[2] 让 Hexo 博客支持本地站内搜索（http://moxfive.xyz/tags/Hexo/）[3] Hexo博客添加站内搜索（https://www.ezlippi.com/categories/hexo/）[4] Hexo本地搜索及部分SEO优化 （https://www.oyohyee.com/categories/Note/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用OpenCV显示OpenGL图形]]></title>
    <url>posts/302a6244.html</url>
    <content type="text"><![CDATA[前言 本文就是一个小实验，试验 OpenCV 到底能不能支持 OpenGL 图形显示。正文 如果在 OpenCV 用 CMake 编译时勾选 WITH_OPENGL 且编译一切顺利的话，编译和配置的具体步骤和情况可以看本人写的一篇文档：Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 ，那么就可以用 OpenCV 窗口显示 OpenGL 图形。 在 VS 下使用 Windows 原有的 OpenGL 函数需要包含以下头文件和库文件：123456#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib") 在 OpenCV 中显示 OpenGL 图形需要 cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL)，在 namedWindow 函数中添加 cv::WINDOW_OPENGL 参数说明该窗口支持 OpenGL 图形。附示例程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;opencv.hpp&gt;#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib")static const float vertex_list[][3] =&#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;;// 将要使用的顶点的序号保存到一个数组里面 static const GLint index_list[][2] =&#123; &#123; 0, 1 &#125;, &#123; 2, 3 &#125;, &#123; 4, 5 &#125;, &#123; 6, 7 &#125;, &#123; 0, 2 &#125;, &#123; 1, 3 &#125;, &#123; 4, 6 &#125;, &#123; 5, 7 &#125;, &#123; 0, 4 &#125;, &#123; 1, 5 &#125;, &#123; 7, 3 &#125;, &#123; 2, 6 &#125;&#125;;static float rotate = 0;static int times = 0;GLint windowWidth = 800;GLint windowHeight = 800;GLfloat xRotAngle = -75.0f;GLfloat yRotAngle = 0.0f;GLfloat zRotAngle = -135.0f;float MIN_X = -200;float MAX_X = 200;float MIN_Y = -200;float MAX_Y = 200;float MIN_Z = -200;float MAX_Z = 200;GLfloat coordinatesize = 200.0f;GLfloat ratio = 1;void drawLine(float x1, float y1, float z1, float x2, float y2, float z2)&#123; glBegin(GL_LINES); glVertex3f(x1, y1, z1); glVertex3f(x2, y2, z2); glEnd(); glFlush();&#125;// 绘制立方体void DrawCube(void)&#123; int i, j; glBegin(GL_LINES); for (i = 0; i &lt; 12; ++i) // 12 条线段 &#123; for (j = 0; j &lt; 2; ++j) // 每条线段 2个顶点 &#123; glVertex3fv(vertex_list[index_list[i][j]]); &#125; &#125; glEnd(); glFlush();&#125;void reshapeOperate()&#123; glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (ratio &lt; 1) glOrtho(-coordinatesize, coordinatesize, -coordinatesize / ratio, coordinatesize / ratio, -coordinatesize, coordinatesize); else glOrtho(-coordinatesize*ratio, coordinatesize*ratio, -coordinatesize, coordinatesize, -coordinatesize, coordinatesize); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void reshape(int w, int h) &#123; if ((w == 0) || (h == 0)) return; glViewport(0, 0, w, h); ratio = (GLfloat)w / (GLfloat)h; reshapeOperate();&#125;GLfloat AngleX = 45.0f;GLfloat AngleY = 315.0f;void reshape1(int w, int h)&#123; GLfloat aspect = (GLfloat)w / (GLfloat)h; GLfloat nRange = 100.0f; glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式 glLoadIdentity(); //设置三维投影区 if (w &lt;= h) &#123; glOrtho(-nRange, nRange, -nRange * aspect, nRange * aspect, -nRange, nRange); &#125; else &#123; glOrtho(-nRange, nRange, -nRange / aspect, nRange / aspect, -nRange, nRange); &#125;&#125;void onDraw(void*)&#123; // Draw something using OpenGL here //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清除所有的像素 //glMatrixMode(GL_MODELVIEW); //glLoadIdentity(); //glPushMatrix(); ////glTranslatef(-0.2, 0, 0); // 平移 ////glScalef(2, 1, 1); // 缩放 //glRotatef(xRotAngle, 1.0f, 0.0f, 0.0f); //glRotatef(yRotAngle, 0.0f, 1.0f, 0.0f); //glRotatef(zRotAngle, 0.0f, 0.0f, 1.0f); //glColor3f(1, 0, 0); //drawLine(0, 0, 0, MAX_X, 0, 0); //x轴 //glColor3f(0, 1, 0); //drawLine(0, 0, 0, 0, MAX_Y, 0); //y轴 //glColor3f(0, 0, 1); //drawLine(0, 0, 0, 0, 0, MAX_Z); //z轴 //times++; //if (times &gt; 1) //&#123; // times = 0; //&#125; //if (times % 1 == 0) //&#123; // rotate += 0.3; //&#125; //glRotatef(rotate, 0, 1, 0); //glRotatef(rotate, 1, 0, 0); //glColor3f(0, 1, 1); //DrawCube(); //glPopMatrix(); reshape1(windowWidth, windowHeight); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); AngleX++; AngleY++; glPushMatrix(); &#123; glRotatef(AngleX, 1.0f, 0.0f, 0.0f); glRotatef(AngleY, 0.0f, 1.0f, 0.0f); glBegin(GL_POLYGON); //前表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)0);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)255);//颜色设置为白色 glVertex3f(-50.0f, 50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //后表面 glColor3f(0.0f, 1.0f, 1.0f);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3f(0.0f, 1.0f, 0.0f);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //上表面 glColor3d(0.0, 1.0, 1.0);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3d(1.0, 1.0, 1.0);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3d(1.0, 0.0, 1.0);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3d(0.0, 0.0, 1.0);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //下表面 glColor3ub(0u, 255u, 0u);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub(255u, 255u, 0u);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub(255u, 0u, 0u);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub(0u, 0u, 0u);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //左表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)255);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)0);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //右表面 glColor3f(1.0f, 0.0f, 1.0f);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(1.0f, 0.0f, 0.0f);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glEnd(); &#125; glPopMatrix();&#125;void opencvWithOpenGLTest()&#123; std::string openGLWindowName = "OpenGL Test"; cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL); cv::resizeWindow(openGLWindowName, windowWidth, windowHeight); cv::setOpenGlContext(openGLWindowName); cv::setOpenGlDrawCallback(openGLWindowName, onDraw, NULL); while (cv::waitKey(30) != 27) &#123; cv::updateWindow(openGLWindowName); // when needed &#125;&#125;int main(int argc, char *argv[])&#123; opencvWithOpenGLTest(); return 0;&#125;运行成功后可看到一个旋转的彩色立方体。结论 从实验结果来看，OpenCV 确实能支持 OpenGL 图形的显示，但其不足之处也很明显：没有提供鼠标和键盘的交互操作（可能是本人还没发现，毕竟只是尝试一下看它能不能显示），仅仅只是提供一个显示窗口。如果真想用 OpenGL 做一些好玩的东西，还是用 glut 和 glew 吧，不过 glut 已经停止更新许久，glew 在调试时可能会出现一些莫名其妙的错误，所以网上有人用 freeglut 代替 glut，glee 代替 glew，具体的东西本人也没试过，本人目前还没做过 OpenGL 相关的事，这次用 OpenCV 显示 OpenGL 图形纯粹是为了好玩 (*^__^ *) 嘻嘻……。后记 本篇文档也是上次编译配置完 OpenCV-3.2 后做的一次小实验，但当时并没有记录，所以还有一些参考资料也已经不知道了 :-(。参考资料[1] OpenCV学习笔记（六十一）——建立支持OpenGL的OpenCV工程“Master OpenCV”chp.3（http://blog.csdn.net/yang_xian521/article/category/910716）[2] 几个opengl立方体绘制案例（http://blog.csdn.net/bcbobo21cn/article/category/3104565）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0]]></title>
    <url>posts/7df528b4.html</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64 英文企业版；VS2013-update5 英文旗舰版；CMake-3.6.3-win64-x64 免安装版；Qt-opensource-windows-x86-msvc2013-5.6.2。 *注：本人写的这篇文档主要用来编译 x86 版的动态 debug 库，想编译其它类型的库请自行参考其它资料，做相关改变。（ 其实如果想编译 x64 版的可以在用 VS2013 编译时将上方的 Win32 平台选择 x64 平台；想编译 release 版的可以在用 VS2013 编译时将上方的 Debug 模式选择 Release 模式；想编译静态库的可以在用 CMake 生成时取消勾选 BUILD_SHARED_LIBS 选项即可。:-P ）前言 因为 OpenCV-3.2 官方的 release 版只有支持 VS2015 的库，而且不包括扩展包（ opencv_contrib ）中的库，而由于某些历史原因，本人目前使用的编译器还是 VS2013，又想用用扩展包中一些有趣的算法，在加上上个月 opencv-3.3 还没有正式 release，所以上个月本人就利用 VS2013 对 opencv-3.2 进行编译。具体编译过程如下：准备篇 先在 GitHub 上下载对应的 opencv 源码包：opencv-3.2.0 和 opencv_contrib-3.2.0（https://github.com/opencv），扩展包版本一定要和 opencv 版本相同。本人为了添加 Qt 后端显示支持（为了好看和方便 :-P），所以还下载安装了支持 VS2013 的 Qt-5.6.2（http://download.qt.io/archive/qt/）。再下载 CMake-3.6.3-win64-x64 免安装版（https://cmake.org/files/）。至于微软的东西，推荐直接去 MSDN 我告诉你去下载。 由于网上有的资料（具体是哪篇文章本人忘记了 o(╯□╰)o）说编译时的文件结构可能会影响编译是否成功，再加上为了方便编译管理，本人的编译时的文件结构为：opencv-3.2.0_build├── build└── sources​ ├── opencv-3.2.0​ └── opencv_contrib-3.2.04 directories, 0 files其中 opencv-3.2.0 用来装 opencv-3.2.0.zip 解压后的源码；opencv_contrib-3.2.0 用来装opencv_contrib-3.2.0.zip 解压后的源码；build 用来装 CMake 编译完成后的文件。编译篇 打开 /cmake-3.6.3-win64-x64/bin/cmake-gui.exe，在 Where is the source code 文本框中选择 /opencv-3.2.0_build/sources/opencv-3.2.0；在 Where to build the binaris 文本框中选择 /opencv-3.2.0_build/build，点击 Configure，在弹出的编译器选择框中选择 Visual Studio 12 2013，一直 Configure 直到红色的条变白。 网上有人在这一步可能会出现ffmpeg not downloaded和“ippicv_windows_20151201.zip”not downloaded这两个问题，本人没出现这两个问题，所以没有机会验证 cmake-gui和vs2013编译opencv和opencv_contrib源码 中的解决办法是否正确。 接下来就是添加扩展包，在白色条中找到 OPENCV_EXTRA_MODULES_PATH 文本框，在其中选择 opencv_contrib 源码中 modeles 所在路径：/opencv-3.2.0_build/sources/opencv_contrib-3.2.0/modules。 至于想要支持 OpenGL 和 Qt 就需要勾选 WITH_OPENGL 和 WITH_QT 并 Configure 后选择好 Qt 的安装目录，如果配置好 Qt 的环境变量 Cmake 将会自动选择好 Qt 所在路径。 随后再次反复 Configure 直到界面不再出现红色背景，之后单击 Generate。不出意外的话，你会看到 Configure done 和 Generate done。 本人在这一步出现了 VS2013_CMake_opencv3.1动态库与静态库的配置与编译 中的问题，原因是同时勾选了同时勾选了 BUILD_opencv_world 和 BUILD_opencv_contirb_world，本人的解决办法是将它们全部取消勾选，再次 Configure 和 Generate。 如果上面一切顺利的话就可以进行下一步了：使用 VS2013 编译 OpenCV。打开 /opencv-3.2.0_build/build 目录，将会看到一大堆文件和文件夹，双击 /opencv-3.2.0_build/build 目录下的 OpenCV.sln，用 VS2013 打开。找到 CMakeTargets 中的 INSTALL ，然后右键选择“Project Only”–&gt;“Build Only INSTALL”。漫长的等待。。。。。。 (╯﹏╰)b 本人在这一步出现了一个问题，具体问题和解决方法详见问题篇。 一切顺利的话，应该会比本人下面的库多两个，本人最后生成的 Debug 库为：opencv_aruco320d.libopencv_bgsegm320d.libopencv_bioinspired320d.libopencv_calib3d320d.libopencv_ccalib320d.libopencv_core320d.libopencv_datasets320d.libopencv_dnn320d.libopencv_dpm320d.libopencv_face320d.libopencv_features2d320d.libopencv_flann320d.libopencv_fuzzy320d.libopencv_highgui320d.libopencv_imgcodecs320d.libopencv_imgproc320d.libopencv_line_descriptor320d.libopencv_ml320d.libopencv_objdetect320d.libopencv_optflow320d.libopencv_phase_unwrapping320d.libopencv_photo320d.libopencv_plot320d.libopencv_reg320d.libopencv_rgbd320d.libopencv_saliency320d.libopencv_shape320d.libopencv_stereo320d.libopencv_stitching320d.libopencv_structured_light320d.libopencv_superres320d.libopencv_surface_matching320d.libopencv_text320d.libopencv_tracking320d.libopencv_video320d.libopencv_videoio320d.libopencv_videostab320d.libopencv_xfeatures2d320d.libopencv_ximgproc320d.libopencv_xobjdetect320d.libopencv_xphoto320d.lib共41个。配置篇 因为本人只编译了 x86 版动态 debug 库，所以以下环境配置都只针对 x86 版动态 debug 库。（其实要配置 x64 的库就只需将 x86 换成 x64 即可；要配置 release 模式的库就只需在添加附加依赖项中的库文件选择 release 模式的库（即数字后没有 d的 lib）；若要配置静态库就需要选择静态库文件夹以及在附加依赖项中添加相应的静态库文件。:-P） 首先把 /opencv-3.2.0_build/build/install 中的文件都提取出来，这和 OpenCV 官方 release 的 opencv 文件结构差不多，具体两层结构如下.├── bin│ └── opencv_waldboost_detectord.exe├── etc│ ├── haarcascades│ └── lbpcascades├── include│ ├── opencv│ └── opencv2├── LICENSE├── OpenCVConfig.cmake├── OpenCVConfig-version.cmake└── x86​ └── vc129 directories, 4 filesx86 文件夹就是 VS2013 生成的对应 VS 版本 32位 的各种库，include 文件夹就是 opencv 的各项模块。本人将其中提取出的文件全部放入了 C:\Program Files\OpenCV\3.2.0\build 文件夹中。 首先配置环境变量，系统（或用户）环境变量如下：变量名变量值PathC:\Program Files\OpenCV\3.2.0\build\x86\vc12\binOPENCVC:\Program Files\OpenCV\3.2.0\build不然可能会报错：程序“XXXXXX”已退出，返回值为 -1073741701 (0xc000007b)。其中下面那行可以选择不要添加。 然后在 VS 中配置环境。新建工程，然后在“属性管理器”中对应项目下 Debug | Win32 文件夹右键“添加新项目属性表”。（方便一次配置，多次使用，以后再使用只要在相应项目下右键“添加现有属性表”即可），本人新项目属性表取名为：opencv-3.2.0_msvc2013_x86d.props。接下来就是真正的 VS 环境配置了： 双击打开刚才新建的属性表，选中“VC++目录”，注意在进行以下配置时建议都勾选左下角的“从父级或项目默认设置继承”“可执行文件目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin“包含目录”中添加：C:\Program Files\OpenCV\3.2.0\build\includeC:\Program Files\OpenCV\3.2.0\build\include\opencvC:\Program Files\OpenCV\3.2.0\build\include\opencv2“库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib选中“链接器” –&gt; “常规”，“附加库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib“链接器” –&gt; “输入”，“附加依赖项”中添加 C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib 中数字后带 d 的库文件，即编译篇中本人最后生成的 41 个库文件。 配置完之后不要忘了右键该属性表进行保存处理，以便下个项目直接使用，不需要再重复进行配置。最后附示例程序：1234567891011#include &lt;opencv2/opencv.hpp&gt; int main(int argc, char *argv[])&#123; cv::Mat lena = cv::imread("lena.jpg"); //载入图像到Mat，jpg文件和该cpp在同一文件夹 cv::namedWindow("lena"); //创建一个名为 "lean"的窗口 cv::imshow("lena", lena); //显示名为 "lena"的窗口 cv::waitKey(5000); // 只对窗口机制起作用（显示5000ms，随后返回-1，即窗口关闭），若在此期间有按键按下，则马上返回按键的ASCII码。 //system("pause"); return 0;&#125;这里必须在 imshow 后加入 waitkey，因为 WaitKey 不止是 Wait Key 而已，它其实还涉及到消息响应，有这个函数 cv 内部的 WndProc 函数才能起作用，才会更新窗口。 最后程序运行成功并显示 lena 图，则说明编译和配置没问题。问题篇1、用 VS2013 编译 OpenCV 在漫长的等待阶段出现的问题。 问题描述：CVV 模块报错，TS 模块编译不出来，好在这两个模块都不是很重要，可以忽略，本人强迫症也没到这种程度 O(∩_∩)O~。 解决办法： 在 CVV 模块报错后可在 CMake（不知道具体是 INSTALL 下的 CMake Rules 中的 INSTALL_force.rule，还是 ALL_BUILD 下的 CMakeLists.txt，忘记了 o(╯□╰)o）中添加 -DBUILD_opencv_cvv=OFF 忽略 CVV 模块，从而正常编译其它模块。参考 errors on build opencv with cvv module and qt5 #577。如果实在不行的话就在 CMake 生成的时候取消勾选出错模块，若是用 CMake 重新生成的话不要忘了先把 /opencv-3.2.0_build/build 目录下的文件全部删除干净。后记 这是以前写的两篇文档，现在再来整理成一篇。附录 既然能看到这里，说明是想在 VS 下使用 OpenCV，这里推荐一款 VS 下 OpenCV 开发调试神器：Image Watch，效果谁用谁知道。Image Watch 是 VS 的一个插件，不过它只支持 VS2012 及以上版本。使用方法为先设置断点（ F9 ），随后在调试（ F5 ）模式下，鼠标指针悬停在 cv::Mat 类型变量上，即可出现 ，点击查看图标即可显示相应图像。参考资料[1] cmake-gui和vs2013编译opencv和opencv_contrib源码（http://livezingy.com/category/opencv/）[2] VS2013_CMake_opencv3.1动态库与静态库的配置与编译（http://livezingy.com/category/opencv/）[3] 使用VS2015编译以及静态编译opencv3记录[4] errors on build opencv with cvv module and qt5 #577[5] VS2013中Image Watch插件的使用(OpenCV)（http://blog.csdn.net/fengbingchun/article/category/721609）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyThoughts]]></title>
    <url>posts/17017530.html</url>
    <content type="text"><![CDATA[前言 本篇主要用来记录本人的心路历程。Thoughts日期Thought2018-03-14曾看到一句类似这样的话：“死刑最可怕的不是它本身，而是其漫长的等待过程”。——观《大卫·戈尔的一生》2018-03-06吃饭抢单，一如既往的高质量反转。——观《九号秘事》S03E032018-02-06每件事都有其价值，做的事不同，得到的也不同，有些人辛劳一生，却穷困潦倒，有些人游手好闲，照样荣华富贵。这取决于你的爹和你做的事。2018-01-30重复的事情总有一天都会被机器取代。2018-01-10真正的真相只掌握在少数人手里。2018-01-06老师终究只是一种职业，而学校服务的对象以老师为主，学生明明是被约束自由的一方，却还要给学校支付相应的费用，这感觉有点不正常啊。仔细想想又挺正常的，毕竟学校本身没逼你去，是你自己去的，既然要去一个本身不属于你的地方，当然要先缴各种服务费，即使物非所值。那为啥要去呢？2017-12-24当隐私荡然无存，你又会如何 🤔。——观《 菲利普·K·迪克的电子梦》S01E012017-12-21世界很渺小，差的只是一个引路人。2017-12-20无知是福，不谈国是 :）。2017-12-07社会工程学，有意思的领域。——观《我是谁：没有绝对安全的系统》2017-11-29知道的越多，不知道的也越多。2017-11-15我所理解的编程就是用尽可能简单的方法得到想要的变量值。2017-10-24读研究生两个月，最大的改变就是对人对事都比以前有更大的耐心了 :）。2017-10-21无论什么事，当ta成为一种任务的时候，都是一种负担。2017-10-20键盘侠就该看看《黑镜》S03E06，真看热闹不嫌事大啊 😒。2017-10-19人类基因组计划，真不知道是好是坏，希望是好的吧 😶。——观《黑镜》S03E052017-10-15镇定，面不改色；节奏很快，就一个晚上的事，音乐和光影也很赞 👍。——观《暗花》2017-10-07国家意志啊，让人不由得想起那年春夏之交（5月35日）的一场风波╮(╯▽╰)╭。——观《出租车司机》2017-10-04什么时候能控制情绪了，什么时候就成熟了。——观《头脑特工队》2017-10-03所谓的朋友（ta）只是在正确的时间正确的地点遇到的正确的人。2017-09-291. 有些事不知道比知道要好，但真相总还是知道要好。2. 不同层次的人心态不同，难以相互理解。2017-09-28各大（网络）小说家的风格真的很难改变啊！ 😪2017-09-231. 你想成为什么样的人，必须自己决定。——《虫师》2. 情感是最不可控的。——观《宝莱坞机器人之恋》3. 人或许只有善恶，没有好坏。2017-08-29科研之上，如何能成为一个挖坑人（开创性的结果）？ 😕2017-08-11学生最重要的两种能力是学习能力和解决问题的能力。2017-08-10爱情是需要理由的。2017-08-05无能是万恶之源。2017-07-20有些话，自己心里明白就行，绝对不能说出来，否则可能存在某种未知的危险。2017-07-18很多东西是不能向别人推荐的，比如音乐，电影，小说等自己喜欢的东西。2017-07-14有些事是交给别人判断的，自己心里知道就行；有些事是交给自己判断的，自己心里知道就行。2017-07-11走进一个学科之前，最先应该知道的是该学科的研究对象、研究方法，以及当前研究中的热点难点问题，而不应该被广告一样的花哨演示糊弄住。——《上海交通大学学生生存手册》2017-04-09真正的独立，应该是离开任何人你都能活的好好的；真正的自由，应该是任何人都不能让你做违背你意志的事。2017-02-08小提琴，悠扬，忧伤。2017-01-27唉！渐行渐远╮(╯▽╰)╭。2017-01-18不能飞的猪，就只是猪而已。——《红猪》2016-12-30梦想还是要有的，万一实现了呢，试一下又不吃亏。——观《百日梦想家》2016-12-26过去的如果就这么过去了，那以后只会越来越糟。——《驴得水》2016-12-25只有人才是最重要的。2016-12-10与人相处之道，不外乎尊重和坚强。2016-11-06烈日灼心，片如其名。——观《烈日灼心》2016-11-04后来我发现，教授们貌似不喜欢有自己想法的学生，他们更希望找到愿意“打下手”的学生，帮助实现他们自己的想法。——《王垠：我和权威的故事》2016-10-31为何总要责怪自己？为何要为没必要的人改变自己？不需要做老好人，做好自己，随便别人。——观《被嫌弃的松子的一生》2016-10-303~7的小孩的自主谎言最可怕，撒谎乃人之天性，远离无脑之人。——观《狩猎》2016-10-27世界上有三种人，一种是人渣，一种愚漠的人，还有一种是所谓的好人。第二种人最多，参考正态分布。——观《熔炉》2016-10-22面对长者（诸如领导，老师等），要多听他们说，自己尽量少说，绝对不要找理由，要多说嗯，是的，对的，没错，明白，可以等肯定语句，绝对不要说由于，因为等原因语句。更重要的是尽量少说自己不知道，忘记了，了解一点等否定语句，不要把自己差的一面表现出来；要说自己会，行，知道等肯定语句，一定要把自己好的一面表现120%出来。（※附：以本人2017-12-21的眼光来看这段话还是不妥）2016-10-02平静中的悲和喜，最悲痛。——观《那年夏天，宁静的海》2016-09-22韩国好的电影对人性的把握比较到位，但有时为了突出人性好的一面，而做的有点婊了，为了剧情而剧情。——观《摩天楼》《流感》《铁线虫入侵》《釜山行》2016-09-13这世上有很多事，不试一下永远不会知道结果。2016-09-05公式本就存在，就等有天赋的人去感知并发现它。——观《知无涯者》2016-09-03管理者需要心平气和，更要沉得住气，有耐心。2016-08-12自紧力，自紧扳手，和初中做的物理实验：把两本书夹在一起后，无论怎么用力向两边拉都拉不开，估计有点类似吧。（※附：以本人2017-12-21的眼光来看这个事感觉有点玄学）2016-08-10为什么人们总认为小孩（弱者）说的是对的？有没有想过，有时候小孩并不小，弱者并不弱。2016-08-09《人工智能》，好可怖的一个世界。——观《人工智能》2016-08-06一起做一件事能很好的增进感情。（※附：以本人2017-12-21的眼光来看也有可能增加矛盾╮(╯▽╰)╭）2016-08-04尽量不要去接手别人已经做了一部分的事物。（※附：以本人2017-12-21的眼光来看如果别人做的很好理解的话接手也可以）2016-08-021. 有时候很难理解他人，只是因为没有和他人类似的经历而已。2. 让人的本性被改变咋就这么难？读大学是掉噶果？（※附：以本人2017-12-21的眼光来看ta确实老了，也变了，或许时间能改变一切吧）2016-07-29《计算机：一部历史》，很有意思的一本计算机史。2016-07-26人们总是习惯于用固有的标准看待新事物。2016-07-24《妖尾》的世界观简直不敢苟同，世界上真有那种人，杀了或要杀自己朋友的人还能做伙伴？每遇到boss第一次总被秒杀，第二次才能完胜？这尼玛是什么逻辑。2016-07-171. 不要嘲笑别人的梦想，也不要轻易说出自己的梦想。2. 看完《活着》，心情有点沉重，难道生命的意义就在于为活着而活着？或者还是太年轻了。2016-07-161. 是待人以诚，人待以诚，还是人待以诚，待人以诚？不好说。2. 游戏能代表计算机应用技术的最高水平。2016-07-13情景不同，分类不同。2016-07-12下属（泛指），多看，多听，多想，多做，少说话。2016-07-101. 世上最痛苦的事莫过于对着自己不想看到的人谄媚。2. 不同的时刻，不同的场景，不同的心情，喜好不一样。2016-06-29口吃可能不是遗传的，也可能是婴儿学习过程中的一种畸形。2016-06-231. 何不让自己的人生多些经历。2. 世上大多数的猜忌、争论，都是由于每个人总是认为自己是对的。2016-06-161. 多媒体识别的关键在于提取图像、视频和音频的“特征”（即向量）。2. 我们周围的人是否在演戏？我们是否在戏中？人生入戏，戏如人生。——观《楚门的世界》2016-06-131. 不管变成什么样，问心无愧就好。2. 人越成熟就藏得越深。3. 完全不需要和别人比，只需和昨天的自己比。2016-06-091. 在公共环境（贴吧，评论区等）下发言，首先要做好被喷的准备，网络上从来不缺少键盘侠。2. 眼中世界不同的人，终究会分开。2016-05-27有些东西是让人看到会产生反感的，而有些东西明明被人讨厌，却因为它没有那么张扬的外面，所以很容易被人忽视的。——七月寒风《幻灵》2016-05-201. 不要随便对别人说出你的想法和理解，因为可能在别人看来，你的想法和理解完全就是个笑话和讽点。最后，最重要的是看清他人是不是和你是一个世界的，世界不同，观念，观点很难相同。2. 绝大部分老师只看结课论文的排版如何。2016-05-18儒家治国，道家处事。（※附：以本人2017-12-22的眼光来看有点不敢苟同）2016-05-16人们或多或少都有一种同情弱者的心态，所以有时候适当的处于弱势并不是一件坏事。2016-05-09大学里的成绩更多的是取决于你了不了解老师，你知不知道老师真正想要你写什么，讲什么。2016-05-02看完《浪潮之巅》才明白“软件即服务”，软件提供的实际上是某种功能，某种作用，而这种功能是软件所在平台没有的，但是却是人们使用时不可或缺的，那么企业提供这个软件，就是在提供一种服务。就像饭店里的服务员一样，上菜时饭店提供的一种服务，但不是饭店本身就有的，饭店真正提供的只是一个场所和食物。使用的人数决定市场，不管是付费还是免费，只要能抓住更多的用户，就是胜者。2016-04-29世界上有两种程序员，一种是写技术的，另一种是用技术的。（※附：以本人2017-12-22的眼光来看写者和用者并没有很明确的界线，更像是一种心态吧）2016-04-24真没想到，最近看到“人生若只如初见”才知道是什么意思，高中老师曾出了个作文题就叫这个，当时傻傻的不知道什么意思，呵呵，当年的阅历实在太浅。2016-04-07你强ta越怕，你弱ta越欺。2016-04-02黑色幽默，挺有意思的！比较推荐的有：《黑镜》、《蛮荒故事》。2016-03-311. 两个公司在技术上的竞争，除了人的竞争，就是执行力的竞争。——吴军《浪潮之巅》雅虎、惠普精兵简政2. 托尔斯泰讲，幸福的家庭都是相似的，不幸的家庭都是各有各的不幸。在信息工业中，这句话要反过来讲，成功的公司各有各的绝招，失败的公司到是有不少的共同之处。——吴军《浪潮之巅》思科 留住早期员工2016-03-24有时候，我们想要的东西就在我们面前，我们却因年代久远可能不认得，反而可能亲手毁了ta。——观《SINTEL》2016-03-21每次去以前贾里尼克都要确认我们报告的每一页内容都是已经公开发表过的。原因很简单，IBM有世界最好的科学家和工程师，他们可以用比你还快的速度将你还没发表的想法实现、申请专利并发表。盖茨意识到只要垄断了操作系统，就间接垄断了整个行业。——吴军《浪潮之巅》Microsoft在商业领域，保密性是十分重要的，尤其是一个新颖的想法。在积累了一定的用户量之后，商业化也是很简单的。商业的前提是用户。2016-03-20整个信息技术（Information Technologies，简称IT）产业包括很多领域、很多环节，这些环节之间都是互相关联的。和世界上任何事物同样，IT产业也是不断变化和发展并且有着它自身发展规律的。——吴军《浪潮之巅》IT Law万物发展自有其规律，但这个规律只是一种趋势，趋势总有其临界点，到临界点时将呈现另一种趋势，比如Moore’s Law，功耗就是其临界点。2016-03-20英特尔公司做事情非常专注，直到今天，它一直集中精力于个人微机的处理器，每一代产品的研发都是集中大量的人力和资金，每一次都是只能成功不能失败。——吴军《浪潮之巅》Intel专一，虽然能保证做好，但面太窄，一旦市场发生变化，讲很难应对。2016-03-19时不时调整内部结构，将一些非核心的、长期效益不好的部门卖掉，同时扩大核心的利润高的生意。——吴军《浪潮之巅》IBM认清自己的定位，抓牢自己的核心业务，同时开拓创新。2016-03-19当一个公司没有人对它有完全控制时，它的长期发展就会有问题。——吴军《浪潮之巅》AT&amp;T合则生，分则死。2016-03-19社会在发展，人也在发展，社会的发展体现在人周围事物的变化，而人的发展体现在人自身的变化，这种变化是好是坏，每个人的观点可能不同，没人能预料变化将带来什么，我们唯一所能判断的就是变化给我们现在带来了什么，以此判断以前的变化是好是坏，此时的变化将由未来的人判断。2016-03-19大学生和高中生的本质区别在于大学生更会思考，更加注重自学能力，遇到问题是主动去寻找解决方案，而不是像高中生那样被动的等老师来讲解。2016-03-11时间使人安稳，失去时间将使人迷失，疯狂。2016-02-17别人肯不肯帮忙主要取决于你自身的实力基础。2016-02-03生而不养，养而不教，不如不生。2016-01-26为人子女，与父母相处的机会，其实都是见一次少一次的。——罗森《万界天王》2016-01-24四十多岁的父母是最能包容你的人。（※附：以本人2017-12-22的眼光来看这里有点欠妥）2016-01-23以己度人，更多的是指包容别人的缺点，而不是抱怨别人没有的缺点。2016-01-16人之为人，在于自制。2016-01-08读高中时，我接触到靠自己；读大学时，我逐渐学会靠自己；步入社会时，我将真正靠自己。（※附：以本人2017-12-22的眼光来看是不可能真正靠自己的，总要与外界交互）2015-12-30读大学，选择不同的专业，就是选择不同的圈子，而圈子决定话题。2015-12-281. 很多时候，我们买一件东西只是因为心血来潮，而不是真正需要它。2. 贯彻落实“尽量学习”理念。尽量学习有两个方面：尽量多学和尽量精学。2015-12-07人生充满太多的偶然性。2015-11-09所谓杀心，就是去除仇恨。恨一个人也常常意味着怕这个人，只有克服了“怕”之后，“恨”才能转化为杀心，化为力量。—— 冰临神下《死人经》2015-11-08每天都学一点小知识2015-11-05有没有想过，人类也是一种寄生虫，寄生在地球，依靠于太阳，而太阳和地球也只是宇宙里的一粒微尘。——观《宇宙的奇迹》2015-09-15虽然这不是你理想中的大学，但你可以选择过理想的大学生活。2015-09-05没有对生明的敬畏，就永远无法体会到生命的可怕。2015-09-01因为在乎，所以在意。2015-05-16我虽然现在不知道，但我可以学。（※附：以本人2017-12-22的眼光来看这句话在大部分情况下行不通）2015-05-15唉！这次回去，已是物是人非，院子不再是院子。2015-05-15自杀乃傻之至极。2015-05-151. 不抱怨，不找理由。（面对教、训之终极奥义）2. 一本书，读过之后如果没有思考，相当于没读。3. 前人的言行是我们的指路明灯。2015-05-15鹿角杀死了冰原狼预示着拜拉席恩将导致史塔克的死亡。不会玩的游戏不要硬去玩，否则终将害人害己。当大雪降下，冷风吹起，独行狼死，群聚狼生。夏天时可以争吵，但一到冬天，我们必须保卫彼此，相互温暖，共享力量。——《冰与火之歌：权利的游戏》2015-05-151. 海贼王的海军每个人都有自己坚守的正义。2. 尊重不是别人施舍的，而是自己争取的。3. 环境决定年龄。4. 和平利于知识传播交流，战争利于知识创新突破。2015-05-151. 不要等到老师教，尽量去学自己想学的，要学的。2. 介绍和学习是两码事，介绍可以用PPT，而学习用板书更好。3. 电给人方便，也使人孤独，人与人的联系似存而亡。2015-04-15是为自己而活？还是为他人而活？2015-04-03有时候，人对自己的东西会突然莫名其妙的产生一种厌烦感，从而不想要，从而做错事，但其实这种厌烦感只是暂时的，过一段时间又会恢复成以前那样。2015-03-10人当想人之不能。2014-10-041. 人之成长，取决于见。2. 世风日下，好人难做。3. 在社会这个大染缸里，我只想做我自己。4. 有些雷区是不能碰的，碰，就会惹火上身。5. 每个人的注重点不一样，带出来的人也不一样。2014-09-20How did we escape from the prison? It was the work of generations of searchers who took five simple rules to heart . Question authority. No idea is true just because someone says so. Think for yourself . Question yourself. Don’t believe anything just because you want to. Believing something doesn’t make it so. Test ideas by the evidence gained from observation and experiment. If a favorite idea fails a well-desidned test, it’s wrong! Get over it. Follow the evidence, wherever it leads. If you have no evidence , reserve judgment. And perhaps the most important rule of all…… Rember, you could be wrong. Even the best scientists have been wrong about somethings. Newton, Einstein, and every other great scientist in history, they all made mistakes. of course they did – they were human, Science is a way to keep from fooling ourselves and each other. Have scientists known sin? of course. We have misused science, just as we have every other tool at our disposal, and that’s why we can’t afford to leave it in the hands of a powerful few. The more science belongs to all of us, the less likely it is to be misused. These values undermine the appeals of fanaticism and ignorance. ——《Cosmos: A Spacetime Odyssey》我们如何逃出囚笼？是因为世世代代探索者的不懈努力，并且他们发自内心地遵从这5条简单规则。质疑权威。不轻信人言。独立思考。自我质疑。不因自己想要相信，而相信任何事。相信不代表能成为现实。以依靠观察和实验得来的证据来检验想法。如果自己喜欢的想法没有通过全面的检验，它就是错的！ 乐观一点。遵循证据，无论它指向哪里。如果没有证据，不妄下结论。也许最重要的规则就是，要记住，你也会犯错。牛顿、爱因斯坦，还有历史上每一位伟大的科学家，他们都犯过错，这很正常，是人都会犯错。科学让我们不再欺骗别人和自己。科学家们有罪吗？有的。我们曾滥用科学就像手边的工具一样随意使用，因此我们不能把科学放在少数的掌权者手中。当科学更多的属于全人类时，它就越不会被乱用。科学的价值在于能阻止狂热和无知。 ——纪录片《宇宙时空之旅》2014-09-20Telling someone your goal makes it less likely to happen.告诉别人你的目标反而使目标不能实现。 ——网易公开课《不要公开宣布个人目标》2014-09-14每一个客户都是一群客户。2014-08-22快做眼前事，未来不可知。2014-08-13既然扎根于此，何不刻苦努力！2014-07-31这个世界很大，你总能找到你的伙伴。既然出生到这个世上，你绝不会总是孤身一人的。 ——《One Piece》2014-07-26There’s a time when a man needs to fight and a time when he needs to accept that his destiny’s lost. 人有必须奋战的时刻，也有必须接受现实的时刻。 ——《Big Fish》2014-07-23每个人的一生都是一部独有的长篇小说。2014-07-11就算你讨厌ta，也不要在背后议论ta的是非，毕竟议论是非之事必是是非之人。2014-06-29世事无常，计划赶不上变化，无须太过伤感。2014-06-27大 极，小 极，差，和，无大无小。2014-06-25荣耀只属于特定的时空。2014-06-161. 一个秘密有两个人知道，也便不是秘密。2. 没有做好准备就准备失败。3. 初学计算机语言，多敲代码。4. 不要太在乎别人对你的看法（不管是好是坏），不然你会活的很累。2014-06-11分数是老师给的，东西才是自己学的。2014-06-06参数——来自另一维度的手（上帝之手）（二维中的蚂蚁、三维中的蚂蚁、轻易逃脱囚笼）2014-05-301. 有些话（事）能说（做），有些话（事）不能说（做）。（要会判断）2. 不要在心情极端时做出让自己后悔的事。3. 相比于自律自觉能力，考上一个好大学显得并不是那么重要。4. 在这个人人都装逼的社会，对不对需要自己判断！2014-05-26“取法乎下，得乎下下；取法乎中，得乎其下；取法乎上，得乎其中；取法上上，得乎其上。” —— 《读大学怎么读》2014-05-211. 其实学校是第一个教会我们说谎的地方。2. 成绩只是老师给的，更重要地是在于你自己有没有学到东西，大学注重的不应是分数，而应是你真正学到的东西！2014-05-12每个人都是自己生活的主角。2014-04-211. 闲事为何事，何事为闲事！2. 距离！ 适度！3. 人生总有种种不如意之事，但也会有种种如意之事！4. 一般而言，抄不如乱写，乱写不如不写！2014-04-211. 世上的事很多，只是看你去不去做，所以何来无聊之说！2. 上大学易，读大学难，且读且珍惜！2014-04-19浑浑噩噩的一天，糊糊涂涂的人。2014-04-011. 不去争的话就什么都不会有！2. 因为在意，所以紧张！3. 人生就是一个奋斗的过程，人生也因奋斗而精彩！2014-04-011. 永远都不要以为你的时间很多！2. 深沉一点！3. 真搞不懂为什么这么多人喜欢听假话，假话比真话真的管用吗？也难怪现在有这么多假冒伪劣产品，连个话都是假的好。（※附：以本人2017-12-23的眼光来看在多数情况下假话确实比真话管用，说话也是一门学问啊）2014-04-011. 有些路还是自己走得好！2. 天下哪里有白吃的午餐，只有白痴的人。3. 做人可以懒，但不能傻！以上均为本人当时感想，也算是记录一下本人的心智成长过程吧，有不同意见请保持理智(๑•̀ㅁ•́ฅ)。后记 哪来的后记，本人的这一生还没过完呢(╯°□°）╯︵ ┻━┻，（#-_-)┯━┯ 。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决写上篇文档“Hexo+GitHub搭建个人博客”遇到的问题]]></title>
    <url>posts/7d5bc07b.html</url>
    <content type="text"><![CDATA[超链接网址问题 问题描述：使用正常的 markdown 超链接格式[]()没问题，然而当直接将一个网址链接放入该文档时，它会将该链接后面的文字也当成是该链接的一部分，直接点击链接时，会将后面的文字也放入浏览器地址栏，从而出现网页 404 错误：404: Page could not be found。 解决办法：在网址链接后输入一个空格以隔开网址链接和后面的文字或用&lt;url&gt;将网址括起来。超链接样式问题 问题描述：本人使用的 hexo 主题是基于 spfk 主题稍微修改过的，spfk 主题能自动修改超链接原有的样式，挺好看的 :D，但是当本人在 markdown 中数字编号列表，即有序列表中添加超链接时，其样式并没有修改，还是普通的超链接样式。 解决办法：没有解决。最后只是跳过了这个问题，就用中文的序号表示列表。文本段落问题 问题描述：为了使文本有段落感，一般都会在段落首字前空两格，但是在 markdown 中空两格，用 hexo 发布后并没有空两格，这使得文档没有段落感，阅读体验有点差。 解决办法：将中文输入法由半角切换至全角，在段落首字前输入两个空格即可。显示英文尖括号问题 问题描述：由于上篇文档需要在文档中显示&lt;youname&gt;，但由于 Hexo 可能将其当做一个 xml 标签处理了，所以发布之后的文档没有显示该文字。 解决办法：首先本人尝试了转义字符\，谁曾想它只出现了一个转义字符，该文字还是没显示，本人差点又要跳过这个问题，将其用另一种表示法了。后来本人想到这最后不是会转为 html 吗，本人就直接用 html 中尖括号的表示法不就行啦 :p，于是参考HTML语言中括号(尖括号)的字符编码，用&amp;lt;代替&lt;，用&amp;gt;代替&gt;，最后该文字终于出来了。给文字添加颜色问题 问题描述：本人想给注意事项上的需要注意的问题添加醒目的颜色，但 markdown 本身不支持给文字添加颜色。 解决办法：由于 Hexo 最后会将 markdown 文档转换为 html 文档发布，所以直接将 html 标签写进 markdown 文档，最后自然会出现 html 样式，本人这里参考CSDN-markdown编辑器语法——字体、字号与颜色，给想要变色的文字添加&lt;font color=#FA8072&gt;&lt;/font&gt;标签。参考资料[1] HTML语言中括号(尖括号)的字符编码（http://liuxufei.com/weblog/jishu）[2] CSDN-markdown编辑器语法——字体、字号与颜色（http://blog.csdn.net/testcs_dn）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>posts/d7965b48.html</url>
    <content type="text"><![CDATA[本人系统环境：Win10_x64。前言 本来是想在国内某网站上继续写的，毕竟完全不需要自己管理，只需要负责写好文档就可以了，但某一天，该网站由于响应国家的号召，要实名验证，本来实名验证也没什么，就输入手机号，并填写验证码即可，但该网站实名验证的方式给人的感觉特别不爽，于是就决定自己搭建博客，这样虽然有点麻烦，但由于完全是自己管理，自己完全拥有该文档的所有权，也不用担心哪天别的网站突然出现的各种破问题，相比这种完全自由支配、无比爽快的感觉，管理这种麻烦就是小事了。GitHub + Hexo 个人博客搭建准备篇在 GitHub 上搭建博客的要求： 1、要有 GitHub 账号。（没有怎么办，没有就去注册啊）使用 Hexo 框架的要求： 1、需要安装 node.js。（电脑上没有安装怎么办，没有安装就去下载（https://nodejs.org/en/download/）安装啊） 2、需要安装 git。（没有安装就去下载安装，附 git学习教程）GitHub 篇 满足上文的要求之后，就可以开始搭建了，首先在 GitHub 中新建一个仓库（ New repository ），在 Repository name 下填写 &lt;yourname&gt;.github.io ，其它可默认，点击 Create repository。 新建仓库完成后，点击 Create new file 新建一个 README.md 文件，随便写点什么，比如 “It's my blog website”。 点击上方横条选项中的 Settings ，查看 GitHub Pages 里的设置，上方应该有绿色框，框中“Your site is published at https://&lt;yourname&gt;.github.io”，该网址即为博客主页，Source 应该是 master branch，自此 GitHub 上的设置可以算是完成了，但为了方便和防止误删，一般把 Hexo 文件也放入 GitHub 中，为方便管理，可以新建另一分支专门放 Hexo 文件。 在仓库 code 界面中点击 Branch：master，在出现的框中输入 hexo 新建 hexo 分支，在 branches 中 Change default branch 设置 hexo 为默认分支。Hexo 篇 将刚才新建的仓库克隆到本地：git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git当前在 hexo 分支。在 &lt;yourname&gt;.github.io 文件夹下执行12345npm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --save 按这样一连串执行，如果没出问题的话就会在 &lt;yourname&gt;.github.io 文件夹里生成一个 blog 文件夹，该文件夹有一大堆 Hexo 有关的文件。配置 Hexo Hexo 的配置文件为 blog 文件夹中的 _config.yml 文件。 修改配置文件不要使用 windows 自带的记事本，本人使用的 VS Code，或者 Notepad++ 和 Sublime Text 2 等编辑器都可以，以防文件编码改变，具体修改如下：123456789101112131415# Sitetitle: &lt;你的blog名&gt;author: &lt;作者名称&gt;language: zh-CN&lt;网站所用语言，中国大陆选择zh-CN即可&gt;# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://&lt;yourname&gt;.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git branch: master其它的默认即可，具体参数信息详见 Hexo官方文档。配置 git 用户信息12git config --global user.name "&lt;yourname&gt;"git config --global user.email "&lt;yourname&gt;@xxxxxx.com" 如果是个人电脑的话推荐加上 –global 全局参数，因为这样更加方便，如果不加的话，还要在 \&lt;yourname&gt;.github.io\.deploy_git\.git 中 config 里加入 git 用户信息，不然可能提交会出问题，稍显麻烦。部署 Hexo在 blog 文件夹下执行：123hexo g #generate 生成静态文件hexo d #deploy 部署网站.部署网站前,需要预先生成静态文件hexo s #server 启动服务器或者执行：1hexo g -d快速部署个人 blog。 在浏览器中输入http://localhost:4000/，将会出现 Hexo 的 Hello World 界面，更多 Hexo 命令详见 Hexo官方文档。最后将 Hexo 文件提交到 GitHub 远程仓库，具体提交命令为：123git add .git commitgit push origin hexo 在浏览器中输入https://&lt;yourname&gt;.github.io同样会出现 Hexo 的 Hello World 界面，自此整个个人 blog 的框架已经完全搭好了。其它篇主题选择 主题可以去官网上的主题界面去找，目前比较受欢迎主题有 next 和 yilia，去别人 GitHub 上的主题仓库上去下载或 clone 均可，本人目前用的主题为black-blue，这个主题本人在用的时候还有些问题，或许会换，或许会自己魔改。最后由于术业有专攻，实在不知道该改哪里，所以决定换 black-blue 的原版主题 SPFK ，对照着 black-blue 对 spfk 进行修改。具体换主题的方法为： 先将下载好的主题整个放在 \blog\themes 文件夹中，再修改 blog 文件夹中的配置文件 _config.yml：12# theme: landscapetheme: black-blue black-blue 为打包主题文件并放入 \blog\themes 文件夹中的文件夹名，并不是原主题名，只是本人恰好将其重命名为主题名。文章发布发布文章需要在 blog 文件夹中执行：1hexo new "test" 将会在 _posts 文件夹中生成 test.md 文件，随后编辑 test.md 文件即可，本人使用的 Markdown 编辑器为 Typora。至于给文章打标签和分类什么的，请参考 Hexo官方文档。写完文章之后推送到 GitHub 中，需要执行：123git add .git commit -m "add test.md"git push origin hexoHexo 文件配置同样需要同步一下：123hexo ghexo cleanhexo d插件添加以 RSS 订阅插件为例。首先安装 hexo-generator-feed，在 blog 文件夹下执行：12## rss插件npm install hexo-generator-feed --save安装成功后，修改 blog 文件夹中的配置文件 _config.yml：1234# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed #RSS订阅最后，修改当前主题文件夹中的配置文件 _config.yml，添加 RSS 订阅链接即可：12subnav: rss: "/atom.xml"修改完成后，执行123hexo cleanhexo ghexo d将会在页面中看到 RSS 图标。注意事项1、提交至远程仓库时可能会出现错误。 原因可能是因为没有将 SSH Key 添加到 GitHub 中。 查看当前用户主目录下的 .ssh 文件夹中（ windows 是 C:\Users\&lt;username&gt;\.ssh）是否有id_rsa（私钥）和id_rsa.pub（公钥）这两个文件，若没有，则执行1ssh-keygen -t rsa -C "youremail@example.com" 在 GitHub 中添加 SSH Key 的具体方法为：点击 GitHub 用户头像下的 Settings，选中 SSH and GPG keys，点击 New SSH key，将id_rsa.pub中的内容复制粘贴到 Key文本框中。2、Hexo 生成和部署命令都执行失败。 原因可能是修改配置文件 _config.yml 出错。 将修改的配置文件 _config.yml 复原试试。3、Hexo 部署之后网页没变化。可能需要执行1hexo clean 清除缓存文件 ( db.json ) 和已生成的静态文件 ( public )。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。后记 以后就在这上面写 blog 了，顺便把以前写的一些文档也放上来。参考资料[1] 利用github+hexo搭建自己的博客（http://blog.csdn.net/u012150360/article/category/6765461）[2] Hexo官方文档（https://hexo.io/zh-cn/）[3] GITHUB+HEXO博客轻松更换主题外观（http://www.jianshu.com/nb/10649566）[4] Hexo—正确添加RSS订阅（http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>posts/4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
