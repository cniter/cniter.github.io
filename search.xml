<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Matlab和OpenCV混合编程小结]]></title>
    <url>posts/64889158.html</url>
    <content type="text"><![CDATA[本文所用的 Matlab 版本为 Matlab R2017b，OpenCV 版本为 opencv-3.4.3，C++ IDE 为 Visual Studio 2017，系统环境为 Windows 10_x64。前言 秋招告一段落了，又要回到最初的起点，继续搞（qu）科（hua）研（shui）了，由于前人的代码主要是用 C++ 和 Matlab 混编实现的，而 Shaun 比较熟悉的是 C++ 和 OpenCV，而用 OpenCV 完全重写前人的代码工作量又太大了而且有些 API 不是很好互换，为了方便站在巨人的肩膀上继续前进，所以只能学习一下 OpenCV 和 Matlab 的混合编程了，这样在前人的基础上实现 Shaun 自己的想法相对来说更容易一些。准备篇 由于目前主要用 C++ 实现的是一些小功能，也不需要调试，所以就直接使用 VSCode 进行编程了（或许以后还是会用 VS 进行一些简单的调试），而在没有配置相关环境的前提下，VSCode 无法实现自动补全，所以需要在 VSCode 中配置相应环境。具体添加方法如下：在 VSCode 中点击菜单栏 “查看” ==》“命令面板…” ==》选择 “C/Cpp: Edit Configurations…”==》在出现的 c_cpp_properties.json 文件中 &quot;includePath&quot; 对应的值中添加 OpenCV 的 include 目录和 Matlab 的 include 目录，添加之后的 &quot;includePath&quot; 如下：1234567&#123;"includePath": [ "$&#123;workspaceFolder&#125;/**" , "D:/ProgramFiles/OpenCV/3.4.3/build/include/**" , "C:/Program Files/MATLAB/R2017b/extern/include/**"]&#125;如此就能在 VSCode 中写 OpenCV 和 Matlab 相关函数时实现自动补全了。Matlab 和 C++ 混编篇 由于 Shaun 使用的是 OpenCV 的 C++ 接口，所以需要先知道 Matlab 和 C++ 混合编程如何进行。以实现两个数的加法为例，首先创建一个 mexAdd.cpp 文件，其中 C++ 代码具体如下：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;mex.h&gt; // 必须包含头文件 mex.h#include &lt;iostream&gt;// 检查输入是否合法void checkInputs(int nrhs, const mxArray *prhs[])&#123; if (nrhs != 2) &#123; mexErrMsgTxt("Incorrect number of inputs. Function expects 2 inputs."); &#125; if (!mxIsDouble(prhs[0])) &#123; mexErrMsgTxt("Input number must be double."); &#125;&#125;double add(double x, double y)&#123; return x + y;&#125;/** * nlhs：matlab 函数左边变量个数，即返回值参数个数 * plhs： matlab 函数左边变量，即返回值参数 * nrhs： matlab 右边变量个数，即函数输入参数个数 * prhs： matlab 函数右边变量，即函数输入参数 */void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])&#123; checkInputs(nrhs, prhs); // 输入参数可以不使用指针，但输出参数必须使用指针 double *a = nullptr; // 输出参数 double b = 0.0, c = 0.0; // 两个输入参数 plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL); // 创建1x1的实数矩阵用作输出第一个参数 a = mxGetPr(plhs[0]); // 用指针a指向第一个输出 b = *(mxGetPr(prhs[0])); // b作为第一个输入 c = *(mxGetPr(prhs[1])); // c作为第二个输入 *a = add(b, c); // 计算b、c之和得到a&#125; 若要使用 Matlab 混合编译 C++，必须要添加头文件 mex.h，使用 void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) 函数接收输入输出参数，如此编译完成之后，就和使用普通的 Matlab 函数一样了。具体编译调用方法如下，新建 addTest.m 文件，其中 Matlab 代码如下：123456789clc, clear, close all; % 清空变量和关闭所有打开窗口current_folder = pwd; % 获取当前文件路径addpath(genpath(current_folder)); % 添加matlab临时搜索路径，并包含子文件夹（matlab退出后该路径不存在）mex mexAdd.cpp; % 混合编译C++，得到matlab可识别的函数a = 3.1; b = 2.6;c = mexAdd(a, b);其中 mex mexAdd.cpp 可以直接在 Matlab 命令行窗口下预先执行编译动作，编译成功后会输出一个 mexAdd.mexw64 文件，若是 32 位系统则后缀为 mexw32，之后直接执行 ans = mexAdd(3.1, 2.6); 即可在 Matlab 中调用该函数。在 Matlab 首次执行 mex 命令时，Matlab 会自动选择 VS 编译器作为默认 C++ 编译器，也可以执行 mex -setup 初始化或更换默认编译器。BTW： 最好在安装 Matlab 之前安装 Visual Studio，否则使用 mex 编译时，可能会出现找不到编译器的情况。Matlab 和 OpenCV 混编篇 Matlab 和 OpenCV 混编大体上和 C++ 混编差不多，最大的区别在于如何利用 OpenCV 的 cv::Mat 对象和相关的库函数，Matlab 良心的提供了 OpenCV 接口以实现 mexArray 和 cv::Mat 格式之间的互相转化，使用这些接口需要包含头文件 opencvmex.hpp 。如果不使用 Matlab 提供的这些接口而是自己写转换过程的话有点麻烦，因为 Matlab 的数据是以列优先方式存储的，而 OpenCV 的数据是以行优先方式存储的。至于如何进行混编，主要有以下三种方式：第一种是自己写 make.m 文件，相当于 gcc 编译时需要的 Makefile 文件，需要手动拼接各种编译命令和添加相应的附加依赖库；第二种是通过 Matlab 官方提供的 Computer Vision System Toolbox OpenCV Interface 功能，Matlab 没有默认安装该功能，这个功能需要另外安装，具体安装方法为：在 Matlab 命令行窗口输入 visionSupportPackages，即可弹出“附加功能资源管理器”窗口选择对应附加功能安装即可，安装完之后可通过 mexOpenCV 命令对包含 OpenCV 库函数的 .cpp 文件进行编译，查看 mexOpenCV.m 的源码可知，mexOpenCV 其实是对 mex 命令进行了封装，其调用的 OpenCV 库也是其工具箱自带的 OpenCV，而且有些库还没有包含，有一定的局限性，不过该附加功能自带了些示例程序，可以参考学习一下；第三种是使用第三方的 mexopencv，不过需要安装与该工具对应的 OpenCV 版本，并需要进行一定的配置工作，略显麻烦。 Shaun 这里直接使用的是第一种方式，自己写 make.m 文件，比较灵活，想怎么配置就怎么配置。下面具体以 RGB 转 GRAY 为例，首先新建 mexRGB2GRAY.cpp，其中 C++ 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;opencvmex.hpp&gt;#define _DO_NOT_EXPORT#if defined(_DO_NOT_EXPORT)#define DllExport #else#define DllExport __declspec(dllexport)#endif/** * Usage: [img_matrix] = mexRGB2GRAY('img.jpg'); * Input: a image file; * Output: a matrix of image which can be read by Matlab**/// 检查输入是否合法void checkInputs(int nrhs, const mxArray *prhs[])&#123; if (nrhs != 1) &#123; mexErrMsgTxt("Incorrect number of inputs. Function expects 1 inputs."); &#125; if (mxGetNumberOfDimensions(prhs[0]) != 3) // 获取Matlab图像总的维度个数（灰度图为2维，RGB彩色图为3维） &#123; mexErrMsgTxt("Incorrect number of dimensions. First input must be a RGB image."); &#125; // 检查图像数据类型 if (!mxIsUint8(prhs[0])) &#123; mexErrMsgTxt("Template and image must be UINT8."); &#125;&#125;void exit_with_help()&#123; mexPrintf("Uasge: [image_matrix] = mexRGB2GRAY('image_file.jpg');\n");&#125;static void fakeAnswer(mxArray *plhs[])&#123; plhs[0] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); // 创建一个0x0的空双精度matlab矩阵&#125;cv::Mat RGB2GRAY(const mxArray *prhs[])&#123; cv::Ptr&lt;cv::Mat&gt; img_cv = ocvMxArrayToMat_uint8(prhs[0], true); // 将unit8数据类型的matlab矩阵转换为OpenCV的mat对象智能指针 if (img_cv.empty()) &#123; return cv::Mat_&lt;double&gt;(0, 0); &#125; // 将RGB转化为GRAY图 cv::Mat gray((*img_cv).size(), CV_8UC1); if ((*img_cv).channels() == 3) &#123; cv::cvtColor(*img_cv, gray, CV_RGB2GRAY); &#125; else if((*img_cv).channels() == 4) &#123; cv::cvtColor(*img_cv, gray, CV_RGBA2GRAY); &#125; else &#123; (*img_cv).copyTo(gray); &#125; return gray;&#125;void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])&#123; checkInputs(nrhs, prhs); if (nrhs == 1) &#123; cv::Mat gray = RGB2GRAY(prhs); plhs[0] = ocvMxArrayFromMat_uint8(gray); // 将unit8数据类型的OpenCV的mat对象转换为matlab矩阵 &#125; else &#123; exit_with_help(); fakeAnswer(plhs); return ; &#125;&#125;然后新建 makefile.m 文件，自己配置相关编译环境， Shaun 这里具体如下：12345678910111213141516171819202122232425262728293031function makefile() % 选择相应计算机系统版本 is_64bit = strcmp(computer, 'MACI64') || strcmp(computer, 'GLNXA64') || strcmp(computer, 'PCWIN64'); % 配置OpenCV编译环境，如果系统是64位的，则OpenCV也需要是64位的 out_dir = '.'; % 输出目录,这里为当前目录 CPPFLAGS = ' -O -DNDEBUG -I./ -ID:/ProgramFiles/OpenCV/3.4.3/build/include'; % OpenCV “include” 目录 LDFLAGS = ' -LD:/ProgramFiles/OpenCV/3.4.3/build/x64/vc15/lib -LC:/PROGRA~1/MATLAB/R2017b/extern/lib/win64/microsoft'; % OpenCV “lib” 目录 和 MatLab 附加库目录 LIBS = ' -lopencv_world343 -lmwocvmex'; % 添加OpenCV相关库和Matlab libmwocvmex.lib库 if is_64bit CPPFLAGS = [CPPFLAGS ' -largeArrayDims']; end % 需要编译的 cpp 文件 compile_files = &#123; 'mexRGB2GRAY.cpp' 'mexAdd.cpp' &#125;; % 开始编译 for k = 1 : length(compile_files) str = compile_files&#123;k&#125;; fprintf('compilation of: %s\n', str); str = [str ' -outdir ' out_dir CPPFLAGS LDFLAGS LIBS]; args = regexp(str, '\s+', 'split'); mex(args&#123;:&#125;); end end其中 Matlab 配置路径中的 PROGRA~1 是指 Windows 下的 C 盘中的 Program Files 文件夹，为了使用 Matlab 提供的转换接口，libmwocvmex.lib 是必须要添加的一个库。最后具体使用示例 Matlab 代码如下：1234567891011clc, clear, close all; % 清空变量和关闭所有打开窗口current_folder = pwd; % 获取当前文件路径addpath(genpath(current_folder)); % 添加matlab临时搜索路径，并包含子文件夹（matlab退出后该路径不存在）makefile();image = imread('lena.jpg');I = mexRGB2GRAY(image);figure, imshow(I);也可以将 makefile(); 函数预先执行。※注： 这里如果出现编译报错 “缺少依赖共享库” 的情况可能还需要把 OpenCV 的 bin 目录加到系统环境变量 Path 中，Shaun 这里是路径 D:\ProgramFiles\OpenCV\3.4.3\build\x64\vc15\bin，然后重启 Matlab。后记 这次主要是记录 Matlab 如何调用 C++ 编写的函数，其实还可以用 C++ 调用 Matlab 编写的函数，不过那是另一种混编方式了，以后有机会碰到的话再继续记录吧。参考资料[１] Matlab与C++混合编程（依赖OpenCV）[２] 更改默认编译器[３] OpenCV Interface Support[４] Matlab OpenCV混合编程[５] vc与matlab连接的实用函数简介]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实践小结]]></title>
    <url>posts/be7949e4.html</url>
    <content type="text"><![CDATA[实践环境为：android-studio-bundle-162.4069837-windows（Android Studio 2.3.3 带 Android SDK 版）、该 Android Studio 自带的 JRE，系统环境为 Win10-1607。前言 由于上一届没有更新任何项目文档和学习文档，Shaun 只能自己去网上查找相关的资料，从零开始学习，顺便留下一些文档，正所谓：「代码未动，文档先行」，也算是实践出真知吧。PS： 本次实践的项目主要来自 12.1Android 实战 ：DrySister看妹子应用(第一版) — 项目搭建与简单实现（http://www.runoob.com/w3cnote_genre/android） 以及目前手头上正在维护的项目。布局篇 首先打开 Android Studio ，新建项目，一路默认下去即可，等待片刻，“MainActivity.java” 文件的错误提示就会自然消失，将左侧栏上方的 “Android” 切换为 “Project”，打开 app -&gt; src -&gt; main -&gt; res -&gt; layout -&gt; activity_main.xml，由于其默认是以 “Text” 的模式打开（Android Studio 右侧有个 “Preview” 标签可以进行当前布局预览），这对于小白来说不大好控制布局，所以需要在该文件底部将 “Text” 切换为 “Design”，如此可以进行拖拽式布局，以下正式开始进入 Android UI 的布局。至于具体如何进行布局设置，可以参考 Android ConstraintLayout 使用指南 和 Android实现拖拽式布局开发—-约束性布局 以下两篇资料。 而若要使控件大小根据屏幕大小自适应，一般可使用相对布局，但如今的 Android Studio 默认新建的页面就是一种类似于相对布局的页面，所以直接在控件中设置 android:layout_width=&quot;match_parent&quot; 以及 android:layout_height=&quot;match_parent&quot; 属性即可，再设置 layout_margin 属性进行调整即可，而若要让控件大小随控件内的内容自适应，则只需要将 match_parent 更改为 wrap_content 即可。编码篇 首先新建自己的业务逻辑 java 代码，具体新建方法可参考 Android studio怎么创建一个Java类文件 ，在 MainActivity.java 文件所在目录上鼠标右键 New -&gt; Java Class，新建完成之后即可编写自己的业务逻辑。若要新建文件夹，则在目录上鼠标右键 New -&gt; Package 。若要使级联目录展开，例如 com.example.admin.myapplicationtest，则需要在该目录的父级目录新建一个 com.example.admin.test Package 即可将com.example.admin 目录展开。页面跳转 首先新建一个页面 jump_test_activity，在 \MyApplicationTest\app\src\main\res\layout，即 layout 文件夹上鼠标右键，“New” ==》“Activity” ==》“Empty Activity” （有多种 Activity 样式可供选择，Shaun 这里就以 Empty Activity为例了），随后弹出窗口，在 Activity Name 栏填写页面逻辑控制代码文件名 JumpTestActivity，在 Layout Name 栏填写页面 UI 设计代码文件名 jump_test_activity，在 Package name 以及页面逻辑控制代码文件所在在包名 com.example.admin.myapplicationtest.ui.activity，其它设置为默认即可，这样新建的页面的有个问题就是会有一个丑陋的标题栏，所以还需要去掉该标题栏，具体方法为：在 MyApplicationTest\app\src\main\res\values\styles.xml 文件中添加：1234&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt;将 MyApplicationTest\app\src\main\AndroidManifest.xml 中的 &lt;activity android:name=&quot;.ui.activity.JumpTestActivity&quot;&gt;&lt;/activity&gt; 更改为 &lt;activity android:name=&quot;.ui.activity.JumpTestActivity&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt; ，再次编译运行即可看到标题栏已消失。好了，准备阶段已经搞完，接下来就是正式的页面跳转了，一般页面跳转是用户点击事件发生的，所以需要添加一个具有点击事件的控件，一般而言就是 Button 了，这里设该 button 的 id 为 page_jump_btn；该 button 所在页面为 MyApplicationTest\app\src\main\res\layout\activity_main.xml，则在对应的逻辑控制文件MyApplicationTest\app\src\main\java\com\example\admin\myapplicationtest\ui\activity\MainActivity.java 中的页面跳转代码为：12345678page_jump_btn = (Button) findViewById(R.id.page_jump_btn);page_jump_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, JumpTestActivity.class); MainActivity.this.startActivity(intent); &#125;&#125;);如此，在主界面中点击跳转按钮，即可跳转到新建页面。URL 中的坑 在学 12.2 的时候，由于请求的URL地址中有中文“福利”，所以其返回的字符串为：1234&#123;"error": false,"results": []&#125;可以看到 “results” 的值为空，这显然是错的，后面调试发现需要对 URL 地址转义（这都 8102 年了，为什么 URL 地址中还要有中文，或者说为什么 URL 地址还不支持解析中文 ╮(╯▽╰)╭），具体转义代码如下：123fetch_url = Uri.encode(fetch_url); // 将URL地址转义fetch_url = fetch_url.replace("%3A", ":"); // 将%3A替换为:fetch_url = fetch_url.replace("%2F", "/"); // 将%2F替换为/主要参考资料为：Android url中文乱码问题及解决办法 和 Android URL encode 空格处理 。SQL 语句中的坑 在使用字符串拼写 SQL 语句时，一定要注意 SQL 语句中的空格，要不然拼起来的 SQL 语句可能语法不通而导致 APP 崩溃。如在使用创建表的 SQL 语句时，可能的错误写法（不注意空格）如下：123456789101112String create_table_sql = "CREATE TABLE IF NOT EXISTS" + TableDefine.TABLE_FULI + "(" + TableDefine.COLUMN_ID + "INTEGER PRIMARY KEY AUTOINCREMENT," + TableDefine.COLUMN_FULI_ID + "TEXT," + TableDefine.COLUMN_FULI_CREATEAT + "TEXT," + TableDefine.COLUMN_FULI_DESC + "TEXT," + TableDefine.COLUMN_FULI_PUBLISHEDAT + "TEXT," + TableDefine.COLUMN_FULI_SOURCE + "TEXT," + TableDefine.COLUMN_FULI_TYPE + "TEXT," + TableDefine.COLUMN_FULI_URL + "TEXT," + TableDefine.COLUMN_FULI_USED + "BOOLEAN," + TableDefine.COLUMN_FULI_WHO + "TEXT" + ")";以上写法无法正确建表，甚至会因为错误 SQL 语句而导致 APP 闪退，正确的写法如下：123456789101112String create_table_sql = "CREATE TABLE IF NOT EXISTS " + TableDefine.TABLE_FULI + " (" + TableDefine.COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + TableDefine.COLUMN_FULI_ID + " TEXT, " + TableDefine.COLUMN_FULI_CREATEAT + " TEXT, " + TableDefine.COLUMN_FULI_DESC + " TEXT, " + TableDefine.COLUMN_FULI_PUBLISHEDAT + " TEXT, " + TableDefine.COLUMN_FULI_SOURCE + " TEXT, " + TableDefine.COLUMN_FULI_TYPE + " TEXT, " + TableDefine.COLUMN_FULI_URL + " TEXT, " + TableDefine.COLUMN_FULI_USED + " BOOLEAN, " + TableDefine.COLUMN_FULI_WHO + " TEXT" + ")";调试篇 编码完成之后，一般而言需要进行调试，Android Studio 的调试可参考 【Android 开发入门】android studio 控制台打印输出日志 ，进入调试模式具体方法为：点击上方工具栏中的 Debug ‘app’ 图标，而不是直接 Run ‘app’，进入调试模式之后，点击下方的 “Android Monitor”，切换到 “logcat” 标签，即可查看调试信息。 华为手机打印调试信息可参考 华为手机logcat不出日志解决方案。这里由于 Shaun 还没有对 AndroidManifest.xml 进行修改，所以该 APP 在点击 Button 的时候会直接闪退，调试窗口出现 java.lang.SecurityException: Permission denied (missing INTERNET permission?) 错误信息，参考 android菜瓜笔记之missing INTERNET permission 和 SecurityException: Permission denied (missing INTERNET permission?) 可知，该 APP 没有网络权限，所以需要在 AndroidManifest.xml 中添加网络权限，具体在 manifest 标签中添加语句 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;，如此该 APP 就能正常执行了。PS： 如果是对应用发生闪退或崩溃的原因进行调试，建议直接在 logcat 中搜索 fatal 关键字。附录更换马甲重新发布为另一个 app 即一样的代码却编译出另一个相同的 app，在某些特殊的需求（使两个功能大致一样的 app 共存在一台手机上）上可能需要这个技巧，具体步骤如下（以 MyApplicationTest 更名为 MyApplication 为例）：首先将 MyApplicationTest 文件夹（即 APP 根目录）更名为 MyApplication；（这一步不是刚需）将 MyApplicationTest\app\src\main\res\values\strings.xml 文件中 &lt;string name=&quot;app_name&quot;&gt;MyApplicationTest&lt;/string&gt; 更改为 &lt;string name=&quot;app_name&quot;&gt;MyApplication&lt;/string&gt;；将 MyApplicationTest\app\build.gradle 文件中 applicationId &quot;com.example.admin.myapplicationtest&quot; 更改为 applicationId &quot;com.example.admin.myapplication&quot; 。（这一步是刚需）如此，即可另外安装一个全新 APP，同时保留原有 APP，至于 applicationId 的更多作用和用法可参考 设置应用 ID 。更换 APP 图标只需在 app 文件上鼠标右键， “New” ==》“Image Asset” ，即可弹出设置 app 图标窗口，或者直接更改 AndroidMainfest.xml 文件中的 android:icon 也可。后记 排版可能有点乱，毕竟是随便写的，碰到问题就简单的记录一下，Shaun 这次的实践过程可在 AndroidLearning 中查看，页面跳转的方法来自手头上正在开发维护的一个项目，附录中第一个问题的来源是对方提出的一个特殊需求。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++数组中的坑]]></title>
    <url>posts/fc1165b7.html</url>
    <content type="text"><![CDATA[前言 在写快排的时候偶然发现了 C++ 数组中的一个坑，具体表现为：对数组元素进行无临时变量的自交换时竟然会将数组该元素置为 0，这应该是 C++ 的一个 BUG 了。交换函数篇 据参考资料 [1] 中， C++ 的交换函数可以有如下三种写法：12345678910111213141516171819202122// 第一种：使用模板，创建临时变量template &lt;class T&gt; void swap(T &amp;a, T &amp;b)&#123; T temp(a); a = b; b = temp;&#125;// 第二种：无临时变量，针对int,double等内建数值类型的基本运算（以double为例）void swap(double &amp;a, double &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125;// 第三种：无临时变量，针对int的异或运算void swap(int &amp;a, int &amp;b)&#123; // a ^= b ^= a ^= b; a = a ^ b; b = b ^ a; a = a ^ b;&#125; 其中，第一种是通用的交换方法，无论做什么交换都能用第一种，但需要创建一个临时对象；而第二种不需要创建一个临时对象，只能用在 int，double 等内建数值类型上，且存在溢出的风险；第三种同样不需要创建临时对象，只能用在 int 类型上，由于采用位运算，所以不存在溢出的风险，且效率最高。BUG 复现篇 bug 复现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;template &lt;class T&gt; void swap_1(T &amp;a, T &amp;b)&#123; T temp(a); a = b; b = temp;&#125;void swap_2(int &amp;a, int &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125;void swap_3(int &amp;a, int &amp;b)&#123; a ^= b ^= a ^= b;&#125;int main(int argc, char *argv[])&#123; int data[] = &#123; 0, 3, 8, 2, 9, 4, 6, 1, 7, 5 &#125;; int a = 1, b = 2, c = 3; swap_1&lt;int&gt;(data[a], data[b]); printf("%d\t%d\n", data[a], data[b]); // 输出 8 3 swap_1&lt;int&gt;(data[a], data[a]); printf("%d\t%d\n", data[a], data[a]); // 输出 8 8 swap_2(data[a], data[b]); printf("%d\t%d\n", data[a], data[b]); // 输出 3 8 swap_2(data[a], data[a]); printf("%d\t%d\n", data[a], data[a]); // ***输出 0 0*** swap_3(data[b], data[c]); printf("%d\t%d\n", data[b], data[c]); // 输出 2 8 swap_3(data[b], data[b]); printf("%d\t%d\n", data[b], data[b]); // ***输出 0 0*** std::swap(data[4], data[5]); printf("%d\t%d\n", data[4], data[5]); // 输出 4 9 std::swap(data[4], data[4]); printf("%d\t%d\n", data[4], data[4]); // 输出 4 4 return 0;&#125; 目前没有找到什么好的解决方案，只能老老实实的用第一种创建一个临时变量的交换方法，或者在交换之前先判断一下是不是同一个元素，若不为同一个元素，才进行交换，否则不交换，即避免自交换。后记 刚开始出现这个问题的时候，Shaun 还纳闷了，怎么写个快排把数组元素都改变了，刚开始根本没想到这茬，还以为是 Shaun 代码的问题，倒着检查了好几遍，换第一种交换方式以及换个冒泡排序用一样的交换方式进行排序输出结果都没问题，后面使出终极调试法，一个个的输出看看才知道原来是自交换的锅。 如果有大佬知道为什么会出现这个问题还望不吝赐教 ◔ ‸◔?。参考资料[1] 谈谈C++中的swap函数]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发环境配置]]></title>
    <url>posts/cafdd60d.html</url>
    <content type="text"><![CDATA[由于一些历史原因，本篇配置的 Android 开发环境所需的软件对应版本号为：jdk-7u80-windows-x64、android-studio-bundle-162.4069837-windows（Android Studio 2.3.3 带 Android SDK 版），系统环境为 Win10-1607。前言 没想到，时隔两年之后又要重新捡起 Java，还要学基本没怎么做过的 Android，而且还是在这节骨眼上，真是造化弄人 _(´ཀ`」 ∠)_。Java 环境篇 先在 Oracle Java Archive 下载对应的 Java 版本，下载完成后去 这里 校验对应的 Hash 值（若是其它 JDK 版本，则只需将 url 末尾的 7u80 改成相应的版本号即可），并安装，安装时需要注意，在安装完 JDK 之后，该安装器还会继续弹出让安装 JRE 的窗口，此时直接点取消即可，因为 JDK 中已包含 JRE ，所以没必要也不需要再继续安装，安装了之后，就相当于有两个 JRE ，还可能会为以后的工作造成一些麻烦。具体系统环境变量配置如下（若没有相应的变量名则新建）：变量名变量值JAVA_HOMEC:\Program Files\Java\jdk1.7.0_80 （PS：此为JDK安装目录，后面不能加分隔符分号）CLASSPATH.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （PS：最前面的 .; 必须要有）Path%JAVA_HOME%\bin;%JAVA_HOME%\jre;配置完之后，键入 Win+R ==》cmd ==》 Enter，在终端输入 “java -version”，“java”，“javac” ，这几个命令，若有正确的响应，则表示配置成功。Android 篇※注： 在安装和配置 Android Studio 时最好先自行找好梯子，这其中有一些步骤可能需要连接外网。 自然还是先在这里（http://www.android-studio.org/）下载安装 Android Studio ，为避免再下载安装配置 SDK 的麻烦，推荐直接下载带 SDK 版本的 Android Studio 。直接默认安装，其中安装 SDK 的时间略长。安装完成之后，推荐把 SDK 目录下的 tools 和 platform-tools 子目录也添加到系统的 PATH 环境变量中。 在第一次打开 Android Studio 的时候，可能需要连接外网以更新 SDK ，所以需要自行设置好代理，更新又要花一段时间 ╮(╯▽╰)╭，当然也可以选择不更新，不更新的办法为：在AS启动前，打开安装目录，请先将bin目录的idea.properties文件中增加一行：disable.android.first.run=true就行了，避免第一次打开AS时自动重新下载SDK。 第一次运行时，首先需要配置 SDK 路径和 JDK 路径，配置 SDK 路径方法为：“Configure” —&gt; “SDK Manager”，编辑 “Android SDK location” ，其会自动找到安装的 SDK 路径；配置 JDK 路径方法为：“Configure” —&gt; “Project Defaults” —&gt; “Project Structure”，编辑 “JDK location”（这里它有个默认内置的 jre，但推荐还是使用自己的 JDK）。 Android Studio 默认的编辑器方案无法更改字体（若真想在默认的方案上更改字体，可以先将其另存为一个新方案），而且个人认为其默认的主题（配色，字体等）不好看，所以推荐自行去 Color Themes 选择合适的主题。最终 Shaun 选择 Wombat 主题。至于导入主题的方法为：“Configure” —&gt; “Import Settings”，将下载好的 jar 包导入即可。 为了测试方便，就直接装了个 网易MuMu模拟器 ，用起来感觉还可以，至于 Android Studio 连接 MuMu 模拟器的方法为：先打开 MuMu 模拟器，在 Android Studio 底下的 Terminal（终端） 中输入命令：adb connect 127.0.0.1:7555 ，响应 connected to 127.0.0.1:7555 则说明连接成功，这时就能愉快的使用 MuMu 模拟器调试 Android app 了。后记 以后有碰到什么坑再继续记录吧 ╮(╯▽╰)╭。参考资料[1] Android Studio安装配置、环境搭建详细步骤及基本使用[2] 第一次使用Android Studio时你应该知道的一切配置（http://www.cnblogs.com/smyhvae/category/587732.html）[3] Android Studio连接不到MuMu模拟器]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows实用技巧]]></title>
    <url>posts/27a4c8b6.html</url>
    <content type="text"><![CDATA[前言 本篇主要用来记录在 Windows 下使用命令行能做到的一些特殊技巧。Windows 粉碎文件技巧 有时候 Windows 下会莫名出现文件无法删除的现象，即使通过 Shift+Delete 组合键也还是无法删除，这时可能需要通过一种 “文件粉碎机” 的工具才能删除，但是为了偶尔出现的这种现象而安装一个这样的工具又略显麻烦，这时只需要新建一个 Windows 批处理文件，即新建一个 txt 文本文件，并将后缀改为 .bat 即可，文件内容输入：12DEL /F /A /Q \\?\%1RD /S /Q \\?\%1其中DEL 表示删除文件，命令参数为： del /?/F：表示强制刪除/A：选择文件的属性/Q：静默模式，在删除时不会弹出提示信息RD 表示刪除目录，命令参数为： rd /?/S：连带删除子目录下的文件/Q：静默模式，在删除时不会弹出提示信息 具体用法为将待删除的文件拖拽到该 .bat 文件图标上，用该 .bat 文件打开待删除的文件即可。Windows 校验文件技巧 为确保从网络上下载的文件为原文件，一般需要对其进行 hash 校验（如 SHA1、SHA256、SHA384、SHA512、MACTripleDES、MD5、RIPEMD160 值等），一般随原文件一起释放的比较常见的 hash 值有 SHA1、SHA256 或 MD5 等，但是为了校验下载文件的 hash 值可能需要专门的第三方工具，但其实 Windows 、Linux 和 macOS 都自带了校验 hash 值的命令，通过这些命令可以直接对文件的 hash 值进行校验，而不需要使用额外的第三方工具，这里只介绍 Windows 的哈希值校验命令，其命令为 Get-FileHash，具体使用方法如下：12# []内为待校验的文件 和 所用的hash算法Get-FileHash [文件路径及名称] -Algorithm [校验的Hash值类型]| Format-List 如果觉得每次这样输入比较麻烦，可以使用参考资料[2]提供的注册表文件（.reg 后缀），双击运行，即可在鼠标右键菜单添加「文件哈希校验」，如此可以通过鼠标右键直接对文件进行 hash 校验。附其中代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\文件哈希校验]&quot;SubCommands&quot;=&quot;MACTripleDES;MD5;RIPEMD160;SHA1;SHA256;SHA384;SHA512&quot;&quot;MUIVerb&quot;=&quot;文件哈希校验&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MACTripleDES]@=&quot;MACTripleDES&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MACTripleDES\command]@=&quot;PowerShell Get-FileHash -Algorithm MACTripleDES \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MD5]@=&quot;MD5&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MD5\command]@=&quot;PowerShell Get-FileHash -Algorithm MD5 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\RIPEMD160]@=&quot;RIPEMD160&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\RIPEMD160\command]@=&quot;PowerShell Get-FileHash -Algorithm RIPEMD160 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA1]@=&quot;SHA1&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA1\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA1 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA256]@=&quot;SHA256&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA256\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA256 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA384]@=&quot;SHA384&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA384\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA384 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA512]@=&quot;SHA512&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA512\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA512 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;Windows 隐写文件技巧 在 Windows 下可以通过 copy 命令实现简单的文件合并，即隐写，例如：将压缩文件隐写入 jpg 文件中，将 txt 文件隐写入 jpg 文件中。这样在没改后缀名的情况下，该文件是以图片形式存在，若要恢复原有隐写文件信息，则只需要将 jpg 后缀名更改为相应文件后缀名，例如：若隐写的是 rar 文件，则只需将后缀名 .jpg 改为 .rar ，再用解压缩软件打开即可，也可以直接用解压缩软件打开相应 jpg 文件；若隐写的是 txt 文件，则需要用记事本打开该文件，通过 ctrl+end 组合键让光标定位到文件最末尾，即可看到隐写的 txt 文件内容。具体命令如下：1234567891011# 将 b.txt 隐写进 a.jpg 中，并输出为 c.jpgcopy/b a.jpg+b.txt c.jpg# 将当前目录下 2.rar 隐写进 1.jpg 中，并输出为 3.jpgcopy /b ./1.jpg + ./2.rar ./3.jpg# 将 b.txt 隐写进 a.jpg 中，并输出为 c.jpgcopy a.jpg /b + b.txt /a c.jpg# 将 b.rar 隐写进 a.jpg 中，并输出为 c.jpgcopy a.jpg /b + b.rar c.jpg※注：图片文件要放在前面，需要隐写的信息放在后面，不然输出的图片无法正常查看和显示。 其中参数 /b 表示以二进制格式复制、合并文件，在合成图片和压缩文件等二进制文件时必须使用该参数，不然会丢失信息，从而造成合成失败，当然合成 txt 文本文件时也可以使用该参数；参数 /a 表示以 ASCII 码格式复制、合并文件，参数 /a 只适用于 txt 文本文件合并。 至于其它需要注意的就是：1、要合成的两个文件最好放在同一目录下，不然输入路径有点麻烦； 2、txt 文本文件前面最好空三行，这样它头部的内容就不会丢失。 输出的图片 c.jpg 和原图片 a.jpg 显示是一样的，看起来就是同一张图片，因此达到隐写的目的。Win10 开启休眠方法 不知道巨硬是怎么肥事，居然 Win10 中默认电源选项中没有「休眠」选项，需要手动开启。虽然睡眠和休眠有重叠的地方，但是休眠是完全关机，再次开机时会恢复原有工作状态，更多的情况是必须要关机（因为需要考虑电量情况），相反如果有充足电力的情况下，还不如使用锁定代替睡眠，从这里的需求看还不如在默认电源选项中去掉「睡眠」选项。好了，抱怨吐槽的话就说这么多了，具体开启「休眠」的方法为：只需要在命令行（需要以管理员身份打开「命令提示符」）中输入一下命令：1powercfg /H on回车 执行即可在电源选项中发现「休眠」选项。Windows 新建用户命令 前一段时间电脑系统升级之后崩了，资源管理器损坏，没有任务栏，没有桌面，Win 键都无法使用，还好可以使用任务管理器，通过任务管理器调出 cmd，输入以下命令新建一个用户：12345# 添加用户tmp、密码123 net user tmp 123 /add # 设置tmp为管理员 net localgroup administrators tmp /add 通过 tmp 用户可以正常使用电脑，因此猜测应该是原来的用户系统配置文件（例如注册表文件，系统设置文件等等）损坏。系统损坏之后捣鼓了两天，这没办法修复了，即使新建用户也还是有些软件没法使用，还不如直接重装系统（系统出现问题果然重装系统才是最快的解决方案），还好可以新建用户以备份原有系统盘文件，不然就是真 gg 了。既然新建命令记录了，也顺便记录一下删除命令吧，删除用户 tmp 命令为：net user tmp /del 。后记 如果以后碰到更多有意思的小技巧再继续和大家分享吧 ↖(^ω^)↗。参考资料[1] windows文件夹删不掉怎么办[2] 巧在Win10右键菜单添加校验文件Hash值命令（MD5、SHA1/256等）[3] 【命令行copy命令】将txt文档与jpg图片合并[4] 升級Win10後，為何筆電專有的休眠選項消失了[5] CMD命令（添加删除管理员账户）]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg剪切与合并命令使用小结]]></title>
    <url>posts/6315717b.html</url>
    <content type="text"><![CDATA[前言 前面有一段时间需要对视频做一些简单的处理，所以就去查了一下一些常用的视频处理工具，因为不想再另外装个什么软件，所以就决定直接采用 FFmpeg 了，毕竟其它的一些视频处理软件也极有可能只是对 FFmpeg 进行一些图形化界面的封装而已。 而在查找 FFmpeg 相关资料的时候，也同时发现了 Libav ， 对于 FFmpeg 和 Libav Shaun 只想说，开源界的战争总是这么莫名其妙，有各种各种一些奇怪的原因（或许大佬们都是各有各的脾性吧 ╮(╯▽╰)╭），像两个小飞机的战争也是如此，不过神仙打架，凡人享福也好 ~\(≧▽≦)/~。神仙们的想法我等凡人是无法揣测了，不过这种事还是少出点为好，不然下次变为小鬼遭殃就不好了。 使用 FFmpeg 而不是 Libav 是因为 FFmpeg 的相关资料相对来说要多很多；而且Libav 更新的特性，FFmpeg 全都支持；更重要的是 FFmpeg 是更新特别频繁，差不多是日更了，几乎每天都会发布一个稳定版；而且从两者的下载页面来看， FFmpeg 好像更会照顾跨平台用户一点。下文主要是对 FFmpeg 的部分命令进行记录总结。Shaun 的系统环境为 Win10 1607，测试的 FFmpeg 版本为 ffmpeg-20180429-19c3df0-win64-static。 在 Win10 下使用 FFmpeg 前首先需要配置系统环境变量，Windows 下 FFmpeg 的安装是下载完 Windows 版编译好的 FFmpeg 压缩包后直接解压即可，将解压后的 FFmpeg 文件夹中的 bin 目录添加到系统环境变量 Path 中，不然系统会无法找到 ffmpeg 命令。剪切命令 FFmpeg 的剪切命令的参数很多，因此可以使用不同参数排列组合达到不同的剪切效果，具体如下：1234567891011121314151617# （1）快速剪切video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将剪切结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -to 00:02:00 -c copy cut.mp4# （2）快速剪切video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将剪切结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -t 00:02:00 -c copy cut.mp4# （3）快速剪切video.mp4从第一分钟开始到第二分钟的视频，并将剪切结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -to 00:02:00 -c copy -copyts cut.mp4# （4）精确剪切video.mp4从第一分钟开始到第二分钟的视频，并将剪切结果输出为cut.mp4ffmpeg -i video.mp4 -ss 00:01:00 -to 00:02:00 -c copy cut.mp4# （5）精确剪切video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将剪切结果输出为cut.mp4ffmpeg -i video.mp4 -ss 00:01:00 -t 00:02:00 -acodec copy -vcodec copy cut.mp4# （6）快速剪切video.mp4从第三分钟开始持续60秒的视频，即到第四分钟，并将剪切结果输出为cut.mp4ffmpeg -ss 00:03:00 -i video.mp4 -t 60 -c copy -avoid_negative_ts 1 cut.mp4以下为各参数的含义：-i：用法为 -i INPUT_VIDEO，代表输入的视频，该视频应为 MPEG 编码（h.264, MPEG4/divx/xvid, MPEG2; MP2, MP3, AAC） ；-ss：用法为 -ss START_TIME，代表剪切的开始时间，时间格式有两种写法：1、纯数字格式，以秒为单位（eg: -ss 90，代表从第90秒开始剪切）；2、时:分:秒 格式（eg: -ss 00:01:30，代表从 0 时 1 分 30 秒开始剪切）；-to：用法为 -to STOP_TIME，代表剪切的结束时间，时间格式同样有两种写法：1、纯数字格式，以秒为单位（eg: -to 180，代表第180秒结束剪切）；2、时:分:秒 格式（eg: -to 00:03:00，代表 0 时 3 分 00 秒结束剪切）；-t：用法为 -t DURATION_TIME，代表剪切的持续时间，时间格式同样有两种写法：1、纯数字格式，以秒为单位（eg: -to 180，代表剪切持续180秒）；2、时:分:秒 格式（eg: -to 00:03:00，代表剪切持续 0 时 3 分 00 秒）；-c：用法为 -c CODEC，代表音视频编码格式（若 CODEC 为 copy 则代表输出视频的音视频编码格式与原视频一样），其实 -c 是 -codec 的缩写，其中包含音频编码参数 -acodec 和 视频编码参数 -vcodec ；-copyts：保持原有时间戳，即使当 -ss 在 -i 之前时，仍使 -t 和 -to 保持原有效果，不会被同化；-avoid_negative_ts：当开启该参数时，剪切视频会找到首尾的相邻关键帧（这样会造成剪切时间不精确），补全视频，当 -ss 在 -i 之前时该参数默认开启；-accurate_seek：使剪切时间更精确，在转码时该参数默认启用。更多参数可参考：Format-Options 。※注： 1、-t 和 -to 不能同时使用，若同时使用，将以 -t 为准； 2、当 -ss 在 -i 之前时，可以实现快速剪切，但剪切的时间点不精确，此时-to 和 -t 的效果一样，都表现为 -t ，此时可以加上 -copyts 参数使两者效果不一样； 3、当 -ss 在 -i 之后时，剪切的时间点比较精确，但剪切速度比较慢。 以上命令（1）、（2）是一样的剪切结果，命令（3）的 -t 和 -to 会产生不一样的结果，（6）的 -t 和 -to 会产生一样的结果。因此若只考虑速度，可以使用命令（3），若需使剪切时间精确，则需使用命令（4）和（5）。PS：当然还有一种更精确的方式，通过命令 ffmpeg -i input.mp4 -strict -2 -qscale 0 -intra output.mp4 将输入视频由原来的帧间编码转换为帧内编码，使每一帧都成为关键帧，如此转换之后再进行剪切，可使剪切时间十分精确，但该转换方式会造成视频文件空间成倍增大。合并命令 FFmpeg 的合并命令大概有 4 种，可参考： FFMpeg无损合并视频的多种方法 。这里主要介绍两种：方法一：使用 FFmpeg concat 分离器（推荐） 该方法使用命令为：ffmpeg -f concat -i filelist.txt -c copy output.mp4，其中 filelist.txt 文件最好和待合并的视频在同一个文件夹中，文件中内容就是待合并的视频的描述，具体内容如下：12file &apos;input1.mp4&apos;file &apos;input2.mp4&apos;或12file ./input1.mp4file ./input2.mp4※注： 待合并的视频文件名最好由英文、数字、连接符（-）或下划线（_）组成，且中间最好不要有空格，不然可能会因为文件名而在合并时出现一些奇怪的错误。方法二：利用中间格式合并 所谓利用中间格式进行合并是因为可能有些待合并的视频编码不一致，这时采用方法一可能无法进行合并，这时需要对待合并的视频的进行统一转码，都转成同一个编码格式。若要采用这种方法，建议都转成 mpg 格式，因为 mpg 格式可以直接 cat 命令进行合并，具体如下：12345678# 将input1.avi转成intermediate1.mpg,输出视频质量为1ffmpeg -i input1.avi -qscale:v 1 intermediate1.mpg# 将input2.mp4转成intermediate2.mpg,输出视频质量为1ffmpeg -i input2.mp4 -qscale:v 1 intermediate2.mpg# 合并intermediate1.mpg和intermediate2.mpg，输出合并结果intermediate_all.mpgcat intermediate1.mpg intermediate2.mpg &gt; intermediate_all.mpg# 将intermediate_all.mpg转成output.avi,输出视频质量为2ffmpeg -i intermediate_all.mpg -qscale:v 2 output.avi 其中参数 -qscale 是指使用固定的视频量化标度 ，取值范围为 0.01 ~ 255 ，越小代表质量越好，一般推荐取值为 2 ~ 5，实际使用不能超过 50， -qscale:v 代表设置视频输出质量。PS： 方法一为无损合并，方法二为有损合并。后记 以后有用到新的命令再继续记录吧 ↖(^ω^)↗ 。参考资料[1] ffmpeg Documentation（https://ffmpeg.org/documentation.html）[2] FFmpeg wiki: Seeking（http://trac.ffmpeg.org/wiki）[3] FFmpeg：视频转码、剪切、合并、播放速调整[4] 通过 ffmpeg 无损剪切/拼接视频[5] 使用ffmpeg合并视频文件的三种方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决VSCode使用Cmder作为默认终端问题]]></title>
    <url>posts/fd823bf9.html</url>
    <content type="text"><![CDATA[前言 Shaun 最近想换换新口味，想尝试用 Cmder 作为 VSCode 下的默认终端，不想再继续使用 git-bash 了，因为 git-bash 有时会出现一些乱码问题。但是在用 VSCode 集成 Cmder 时出现了几个问题。问题篇 如果在 VSCode 用户设置文件中直接添加 Cmder.exe 及其路径，那么在使用 VSCode 终端时会重新打开一个 Cmder 窗口，而不是直接显示在 VSCode 的「终端」里。Shaun 想要的是 Cmder 就是 VSCode 的终端，就在 VSCode 里，就和原有cmd 终端一样，在 VSCode 下的终端可以直接输入相关命令，而不是另外弹出一个命令行窗口。解决方案篇方法一将 Cmder 放进一个文件夹中，文件夹名不带空格，比如 Shaun 所有的绿色软件全部放在 D:\ProgramFiles 下，在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k D:\\ProgramFiles\\Cmder\\vendor\\init.bat"],方法二一部分用户可能有点强迫症 ๑乛◡乛๑，硬是要把绿色软件还放入系统盘中的 Program Files 文件夹里，这样在 VSCode 里配置 Cmder 作为默认终端时就会出现问题。主要是因为 Program Files 文件夹名中有空格（这里吐槽一下带空格的文件名真鸡儿坑爹，命令行中根本无法访问，这应该是巨硬的历史遗留问题了， 特立独行的支持带空格的路径名，想显摆一下自己，但以目前的情况看，这种支持简直无力吐槽，造成了一堆问题，和 Windows 路径名中的 \ 有的一拼，都是逼死现代程序员的设计 _(´ཀ`」 ∠)_）。好了，吐槽的话也就说到这里了，如果配置路径里无法避免 Program Files 文件夹，这里有三种解决方案：Windows 在支持带空格的长文件名的同时，也会分配一个短名称，可以称为该文件夹的别名，通过这个别名就可以在命令行中访问该文件夹，获取这个别名的方法有：在命令行中输入 dir /X ，即可在文件夹名之前的一列的看到该别名，若没有别名则为空白，若要添加别名则需要加入 /N 参数。Shaun 这里显示别名如下：123456789101112$ dir /X 驱动器 C 中的卷是 System 卷的序列号是 XXXX-XXXX C:\ 的目录.........2018/05/16 19:21 &lt;DIR&gt; PROGRA~1 Program Files2018/05/17 15:14 &lt;DIR&gt; PROGRA~2 Program Files (x86)..........由上面可知 Program Files 文件夹的别名为 PROGRA~1，而 Program Files (x86) 文件夹的别名为 PROGRA~2，在配置路径时只需要用别名替换相应的文件夹名即可，如下：123456&#123; "terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe", "terminal.integrated.shellArgs.windows": [ "/k C:\\PROGRA~1\\Cmder\\vendor\\init.bat" ]&#125;通过转义符添加 &quot; &quot; 使 Program Files 作为一个整体，如下：12"terminal.integrated.shell.windows": "cmd.exe","terminal.integrated.shellArgs.windows": ["/k", "C:\\\"Program Files\"\\Cmder\\vendor\\init.bat"],直接在系统环境变量中新建一个变量，将 Cmder 的根目录加进去，如下：变量名变量值CMDER_ROOTC:\Program Files再在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\system32\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k %CMDER_ROOT%\\vendor\\init.bat"]通过以上几种方法（推荐直接使用方法一），就能成功在 VSCode 中集成 Cmder，可以直接在 VSCode 的终端里享受 Cmder 了。后记 没有什么好说的了，该吐槽也已经吐槽完了。方法二 Shaun 没试过，只是感觉应该可行，有问题的小伙伴可以在下方留言（这是不可能的，这辈子都不会有人留言的，反正也没人会看到的 ╮(╯▽╰)╭）。以上解决方案全部来自网络，Shaun 只是做个总结记录，万一以后碰到类似问题至少有多种方案可以尝试。参考资料[1] How to use Cmder in Visual Studio Code?[2] Setting Cmder.exe as integrated shell still opens in separate window[3] IntelliJ idea webstrom Visual Studio Code vscode 设置cmder为默认终端 Terminal]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图割算法之NCuts浅见]]></title>
    <url>posts/fddd1e17.html</url>
    <content type="text"><![CDATA[前言 图割算法主要有两个发展方向，一个是 Shaun 上次写过的 Graph Cuts ，通过边界项和区域项（有的可能还会添加一个约束项，或者叫标签项）之和建立能量方程，并利用一定程度的交互式构建一个 S/T 图，最后采用最大流/最小割（Max-flow/Min-cut ）算法寻找 S/T 图的最小“割”，从而对图像进行分割；而另一个方向就是 NCuts（Normalized Cuts），中文一般叫规范割、标准割等等，该方法主要出自：Shi J, Malik J. Normalized cuts and image segmentation[J]. IEEE Transactions on pattern analysis and machine intelligence, 2000, 22(8): 888-905. 。提到 NCuts，就不得不提「谱聚类」，因为 NCuts 可以说是谱聚类的一个应用。谱聚类篇谱聚类（Spectral Clustering， SC）是一种基于图论的聚类方法——将无向带权图划分为两个或两个以上的最优子图(sub-Graph)，使子图内部尽量相似，而子图间距离尽量远，以达到常见的聚类的目的。在了解谱聚类之前需要先了解两个概念：拉普拉斯矩阵（Laplace Matrix）和瑞利熵（Rayleigh quotient）。拉普拉斯矩阵拉普拉斯矩阵的定义如下：设 \(W\) 为无向带权图 \(G=(V,E)\) 的邻接矩阵，\(D\) 为无向带权图 \(G\) 的度矩阵，（所谓的度矩阵即为图中各顶点邻接的所有边权值之和构成的矩阵，是一个对角矩阵，若设顶点 \(i\) 和顶点 \(j\) 之间的权值为 \(w(i,j)\)，则度矩阵对角线上的元素 \(d_{i,i}=\sum \limits_{j=1}^n w(i,j)\) ），则拉普拉斯矩阵 \(L=D-W\)。如下图：若图的邻接矩阵：\(\mathbf{W}=\begin{pmatrix} 0 &amp; 0.1 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0 \\ 0.1 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0.1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 &amp; 0.4 \\ 0 &amp; 0.5 &amp; 0.3 &amp; 0 &amp; 0 &amp; 0.1 \\ 0.2 &amp; 0.1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.4 &amp; 0.1 &amp; 0 &amp; 0 \end{pmatrix}\) ，其中图中不连通的顶点之间的权值为 0；则对应的度矩阵为：\(\mathbf{Ｄ}=\begin{pmatrix} 0.3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0.7 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.7 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0.9 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5 \end{pmatrix}\)则拉普拉斯矩阵 \(L\) 为：\(\mathbf{L}=\mathbf{D}-\mathbf{W}=\begin{pmatrix} 0.3 &amp; -0.1 &amp; 0 &amp; 0 &amp; -0.2 &amp; 0 \\ -0.1 &amp; 0.7 &amp; 0 &amp; -0.5 &amp; -0.1 &amp; 0 \\ 0 &amp; 0 &amp; 0.7 &amp; -0.3 &amp; 0 &amp; -0.4 \\ 0 &amp; -0.5 &amp; -0.3 &amp; 0.9 &amp; 0 &amp; -0.1 \\ -0.2 &amp; -0.1 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 \\ 0 &amp; 0 &amp; -0.4 &amp; -0.1 &amp; 0 &amp; 0.5 \end{pmatrix}\)以上三个矩阵都为实对称矩阵。对于拉普拉斯矩阵，由 $L* [1,1,1,1,1,1]^T =0* [1,1,1,1,1,1]^T= $ 可知其一定存在一个特征值为 0，对应的特征向量为 \([1,1,1,1,1,1]^T\) 。拉普拉斯矩阵是半正定的，且对应的 n 个实数特征值都大于等于 0，即 \(0=λ_1≤λ_2≤\cdots≤λ_n\)， 且最小的特征值为 0 。至于拉普拉斯矩阵的更多性质，可参考：Laplacian matrix 。瑞利熵 瑞利熵的公式形如：\(R(M,x)=\frac{x^*Mx}{x^*x}\) ，其中 M 是厄米特矩阵（Hermitian matrix），满足 \(M=M^H\) ，即矩阵 \(M\) 与其共轭转置矩阵相等，\(x\) 为非 0 向量，\(x^*\) 是指 \(x\) 向量的共轭转置向量。对于实数而言，厄米特矩阵就是对称阵 \(M=M^T\)，\(x^*\) 就是 \(x\) 向量的转置向量 \(x&#39;\) 或 \(x^T\)。 若设 \(x^*x=c\)，其中 \(c\) 为一个常数，则 \(R(M,x)=\frac{x^*Mx}{c}\) ，则其极值问题可转化为：\(\min R(M,x) = \min x^*Mx \qquad s.t.\ x^*x=c\) ，可利用拉格朗日乘数法求取 \(x^*Mx\) 的极值。 具体求法如下： \[ \mathcal{L}(x) = x^T M x -\lambda \left (x^Tx - c \right) \\ \begin{align} &amp;\frac{d\mathcal{L}(x)}{dx} = 0 \\ &amp;\Rightarrow x^TM - \lambda x^T = 0 \\ &amp;\Rightarrow Mx - \lambda x = 0 \\ &amp;\Rightarrow M x = \lambda x \end{align} \\ \therefore R(M,x) = \frac{x^T M x}{x^T x} = \lambda \frac{x^Tx}{x^T x} = \lambda. \]瑞利熵有如下几个性质：R 的最大值就是 M 最大特征值，R 的最小值就是 M 最小特征值 ；x 的解，就是 M 对应的特征向量。至于瑞利熵的更多性质，可参考：Rayleigh quotient 。 以上只是一般意义上的普通瑞利熵，还有一个广义瑞利熵（generalized Rayleigh quotient ），其定义为：\(R(M,D;x)=\frac{x^*Mx}{x^*Dx}\) ，即在分母上添加一个 D 矩阵相乘，其中 D 为 Hermite 正定矩阵 ，满足 \(D=D^*\)，普通瑞利熵是广义瑞利熵中 D 矩阵为单位矩阵时的情况。广义瑞利熵可以通过以下变换转换为普通瑞利熵： \[ \begin{equation} \begin{aligned} R(M,D;x) &amp;= \frac{x^*Mx}{x^*Dx} \xlongequal{x=D^{-\frac{1}{2}}y} \frac{(D^{-\frac{1}{2}}y)^*M(D^{-\frac{1}{2}}y)}{(D^{-\frac{1}{2}}y)^*D(D^{-\frac{1}{2}}y)} \\ &amp;= \frac{y^*(D^{-\frac{1}{2}})^*M(D^{-\frac{1}{2}}y)}{y^*(D^{-\frac{1}{2}})^*D(D^{-\frac{1}{2}}y)}=\frac{y^*D^{-\frac{1}{2}}MD^{-\frac{1}{2}}y}{y^*D^{-\frac{1}{2}}DD^{-\frac{1}{2}}y} \\ &amp;= \frac{y^*(D^{-\frac{1}{2}}MD^{-\frac{1}{2}})y}{y^*y} \end{aligned} \end{equation} \]只需要求出矩阵 \(D^{-\frac{1}{2}}MD^{-\frac{1}{2}}\) 的特征值和特征向量即可。好了，这两个概念介绍完了，就可以真正介绍谱聚类了。 上面说了，谱聚类是一种基于图论的聚类方法，既然有图，则必有相应的邻接矩阵。设图 G 的顶点被聚类成两类，即将图 G 分割为子图 A 和 B，则所要断开的边的权值之和为代价函数（也叫损失函数），类似于“Graph Cuts”中的能量方程。割边 Cut(A,B) 的具体表示为：\(Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j)\) 。 设图 \(G\) 中共有 \(n\) 个顶点，则需要构建一个 \(n \times n\) 的邻接矩阵 \(W\)，其相应的度矩阵为 \(D\)，对应的拉普拉斯矩阵为 \(L=D-W\)，令 \(p_i = \begin{cases} l_1 &amp; i \in A \\ l_2 &amp; i \in B\end{cases}\) ，则 \[ Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j) = \frac{\sum \limits_{i=1}^n \sum \limits_{j=i}^n w(i,j) (p_i-p_j)^2}{(l_1-l_2)^2}= \frac{\sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i-p_j)^2}{2(l_1-l_2)^2} \]当且仅当 \(i\) 和 \(j\) 不属于同一子图时，\((p_i-p_j)^2/(l_1-l_2)^2=1\)，否则 \((p_i-p_j)^2/(l_1-l_2)^2=0\)，（为什么采取这种计算方式，是因为在无法直接确定割边时，用这种计算方式能确保全部割边且只有割边会被加入权重之和），至于为什么等式最后还要除以 2 ，是因为等式最后的那种写法每条边会被遍历两次，每条割边权值会被计入两次，所以还要除以2。而： \[ \begin{equation} \begin{aligned} &amp; \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i-p_j)^2 = \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i^2-2p_ip_j+p_j^2) \\ &amp;= \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i^2) + \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_j^2) - \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (2p_ip_j) \\ &amp;= \sum \limits_{i=1}^n p_i^2 (\sum \limits_{j=1}^n w(i,j)) + \sum \limits_{j=1}^n p_j^2 (\sum \limits_{i=1}^n w(i,j)) - 2\sum \limits_{i=1}^n \sum \limits_{j=1}^n p_iw(i,j) p_j \\ &amp;= p^TDp+p^TDp-2p^TWp = 2p^T(D-W)p = 2p^TLp \end{aligned} \end{equation} \]则：\(Cut(A,B)=\frac{p^TLp}{(l_1-l_2)^2}\) ，当 \(l_1=1,l_2=-1\) 时， \(\min Cut(A,B) = \min p^TLp \qquad s.t.\ p^Tp=n\) ，n 为图的顶点个数。由上可知，该最小割问题即是一个瑞利熵问题，只需求取 \(L\) 的特征值和特征向量。 对 \(L\) 的特征值进行从小到大排列（即取最小 k 个特征向量），若要分成 k 类，则需要取前 k 个特征值（除 0 以外）对应的特征向量，并归一化，将每一个特征向量按列排列构成一个 \(n \times k\) 的特征矩阵，对特征矩阵的行向量使用 k-means 或其它聚类算法，将 n 个行向量聚成 k 类，每一行都属于某一类，根据聚类结果为每个顶点分配相应的类标签，从而完成谱聚类。所以利用谱聚类求的解相当于是一个近似解，它将连续的 n 维问题离散化为 k 维问题，p 是一个 n 维的标签向量，标签值为 \(\{1,2,\cdots,k\}\) ，而 \(L\) 的特征向量中的元素并不是离散化的 \(\{1,2,\cdots,k\}\) ，无法直接用 \(L\) 的特征向量作为标签向量，所以需要将其离散化，对特征矩阵的行向量进行聚类，从而近似的生成标签向量；由于只取前 k 个特征向量，所以在对特征矩阵进行聚类时被聚类的 n 条数据只有 k 维，而本来 \(L\) 的特征向量至少有 n 个，即被聚类的 n 条数据至少有 n 维，所以从某种程度上，谱聚类同时也对数据进行了降维处理。※注： 推荐使用 SVD 代替特征值和特征向量的求取。至于谱聚类的更多性质，可参考：Spectral clustering。 因为有时候简单的全局最小割，可能并不是最优割，所以需要对割做一个归一化，即 Normalized Cuts ，简称 NCuts。图篇 同样，Shaun 还从图的构造开始，NCuts 所需要构造的图就是最普通的无向带权图，图的顶点由图像中像素点构成，相邻的像素点之间互相连接构成图的边。边的权值计算公式为： \[ w(i,j) = e^{\dfrac{-\|\mathbf{F}(i)-\mathbf{F}(j)\|_2^2}{\sigma_I}} * \begin{cases} e^{\dfrac{-\|\mathbf{X}(i)-\mathbf{X}(j)\|_2^2}{\sigma_X}} &amp; \text{if } \|\mathbf{X}(i)-\mathbf{X}(j)\|_2 &lt; r \\ 0 &amp; \text{otherwise}. \end{cases} \] 其中 \(\mathbf{X}(·)\) 是指该顶点的空间位置向量，即图像中像素点的坐标； \(\mathbf{F}(·)\) 可指像素点的强度（灰度）值，颜色向量或纹理值；\(\|\mathbf{X}(i)-\mathbf{X}(j)\|_2\) 表示向量的「2-范数」，即欧氏距离。当 \(\mathbf{F}(·)\) 表示强度（灰度）值时，NCuts 分割的是灰度图；当 \(\mathbf{F}(·)\) 表示颜色向量（一般在 HSV 颜色空间，有 \((h,s,v)\) 三个颜色分量）时，NCuts 分割的是彩色图。对于这个权值的计算说人话就是：当两个像素点之间的距离大于一个人为指定的 \(r\) 时（其实也就用这个 \(r\) 判断到底是连接 4 邻域还是连接 8 邻域，一般不会连接 8 邻域之外的像素点），就不连接，此时权值设为 0 ；否则，则计算两像素点颜色向量的 RBF 核的值和两像素点坐标向量的 RBF 核的值，并取其乘积作为权值。好了，Ncuts 的图的构成大致就是这样。接下来就是它的割法了。割篇 NCuts 中定义割 \(Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j)\) ，定义 \(assoc(A,V)=\sum\limits_{i \in A,t \in V}w(i,t)\) 为子图 A 内所有像素点连接的所有边权重之和，最终的 NCuts 目标函数如下： \[ Ncut(A,B)= \frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)} \] 即通过除以两个子图内所有像素点连接的所有边权值之和对割做了个归一化处理。 令 \(\mathbf{W}\) 为图的邻接矩阵， \(\mathbf{D}\) 为其对应的度矩阵，\(L=D-W\) 为其对应的拉普拉斯矩阵，令 \(S_1 = assoc(A,V) = \sum\limits_{i \in A}D_{ii}\)，\(S_2 = assoc(B,V) = \sum\limits_{i \in B}D_{ii}\)，则 \(S = S_1+S_2=\sum\limits_{i \in A}D_{ii}+\sum\limits_{i \in B}D_{ii}=\sum D_{ii}= \sum \limits_{i=1}^n\sum \limits_{j=1}^n w(i,j)\) ，则：\(NCut(A,B)=\frac{p^TLp}{(l_1-l_2)^2}*(\frac{1}{S_1}+\frac{1}{S_2})\) ，其中向量 \(p\) 为 \(N=|V|\) 维的标签向量， \(p_i = \begin{cases} l_1 &amp; i \in A \\ l_2 &amp; i \in B\end{cases}\) ，令 \(l_1 = \sqrt{\frac{S_2}{S_1S}},l_2=-\sqrt{\frac{S_1}{S_2S}}\) ，则 \(NCut(A,B)=p^TLp\) ，此时 \(p^TDp=\sum p_i^2D_{ii}=\sum\limits_{i \in A}l_1^2D_{ii}+\sum\limits_{i \in B}l_2^2D_{ii}=l_1^2S_1+l_2^2S_2=1\) ，则可化为 \(NCut(A,B)=\frac{p^TLp}{p^TDp}\) ，即 \(\min NCut(A,B) = \min p^TLp \qquad s.t.\ p^TDp=1\) ，该式即为一个广义瑞利熵，只需要求出矩阵 \(D^{-\frac{1}{2}}LD^{-\frac{1}{2}}\) 的特征值和特征向量，按照谱聚类最后的聚类方式将顶点（像素点）聚成 k 类，从而完成图像的分割。而 NCuts 有个特殊的变换，具体如下： \[ \begin{equation} \begin{aligned} NCut(A,B) &amp;=\frac{p^TLp}{p^TDp}\xlongequal{p=D^{-\frac{1}{2}}x} \frac{x^T(D^{-\frac{1}{2}}LD^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= \frac{x^T(D^{-\frac{1}{2}}(D-W)D^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= \frac{x^T(D^{-\frac{1}{2}}DD^{-\frac{1}{2}})x}{x^Tx} - \frac{x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= I - \frac{x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x}{x^Tx} \end{aligned} \end{equation} \] 使用该变换可得出：\(\min NCut(A,B) = \max x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x \qquad s.t.\ x^Tx=1\) ，这样可不求出拉普拉斯矩阵，直接求出 \(D^{-\frac{1}{2}}WD^{-\frac{1}{2}}\) 的特征值和特征矩阵即可，而此时在谱聚类最后聚类的时候要将其特征值从大到小排列（即取最大 k 个特征向量），取前 k 个特征值对应的特征向量构造特征矩阵进行聚类。附录 Ratio Cuts（RCuts） 和 NCuts 的目标函数差不多，两者间的差异就是：RCuts 是除以子图内顶点的个数；NCuts 是除以子图内所有顶点的边权值之和；最后变换完之后 RCuts 是个普通瑞利熵，而 NCuts 是个广义瑞利熵。具体的 RCuts 割法等以后有机会用到再写吧，毕竟子图顶点个数多不代表所占权重就大，而且在割时一般是基于权重的，所以一般而言 NCuts 的结果要比 RCuts 的结果要好。总结 由上文中应该可以看出 NCuts 与 Graph Cuts 需要构造的图是不一样，所使用的能量方程从形式上看也是完全不一样的（虽然本质上都是求“最小割”），其构成的图主要差别在于 Graph Cuts 多了 S 和 T 两个顶点，而这两个顶点由交互式获取，NCuts 不需要交互式，因此也没有这两个顶点，Ncuts 构造的图就相当于只由 Graph Cuts 的普通顶点和边界项 n-links 构成图，因此 Ncuts 没有 Graph Cuts 所谓的区域项 t-links ，也不需要求区域项 t-links 的权值。而这两种方法边界项 n-links 的权值求法都是差不多的，都是用 （高斯）RBF 核函数进行相似性度量，即 \(w_{\{i,j\}} \propto exp\left(-\frac{(I_i-I_j)^2}{2\sigma^2}\right)\) 。后记 后面查阅资料发现图割其实还有好几个方向（井底之蛙了o(╯□╰)o），等有机会把用图割做超像素分割的那篇论文看一下吧 😜 。 5 月份的时候自己抽空实现了一下该算法，发现效果很糟糕，分割效果很不理想，当然不排除 Shaun 代码有 BUG 的原因，或者是还有一些步骤或 trick 漏掉了 ╮(╯▽╰)╭。而且不管是用 svds 还是 eigs 其分割结果都是随机的，只能保证邻域内像素点大概在一起，但具体谁和谁在一起这就是随机的了，这导致每次运行程序都可能有不同的分割结果 _(´ཀ`」 ∠)_ ，后面发现分割结果随机应该是 k-means 的锅（与 svd 和 eig 无关），原因是因为 k-means 每次初始化 k 个种子点时都是随机的，这自然会导致每次分割结果不完全一致 o(╯□╰)o。参考资料[1] 【聚类算法】谱聚类(Spectral Clustering)[2] 谱聚类算法(Spectral Clustering)[3] 拉普拉斯矩阵（Laplace Matrix）与瑞利熵（Rayleigh quotient）（http://www.cnblogs.com/xingshansi/category/958994.html）[4] Normalized cuts and image segmentation 简单实现[5] 谱聚类（spectral clustering）原理总结 （http://www.cnblogs.com/pinard/category/894692.html）]]></content>
      <categories>
        <category>Study</category>
        <category>DigitalImageProcessing</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>segmentation</tag>
        <tag>clustering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图割算法之Graph Cuts浅见]]></title>
    <url>posts/c42ff8d4.html</url>
    <content type="text"><![CDATA[前言 以后可能需要用图割算法做一些事情，所以就简单阅读了一下图割算法中最基础的一篇论文，Boykov Y Y, Jolly M P. Interactive graph cuts for optimal boundary &amp; region segmentation of objects in ND images. Computer Vision, 2001. ICCV 2001. Proceedings. Eighth IEEE International Conference on. IEEE, 2001, 1: 105-112. 。图篇 图割算法（Graph Cuts），顾名思义，是基于图的一种图像分割方法，这里的图既是指数据结构中的图结构也是指数学中的图论，毕竟数据结构中的图结构也来自于数学中图论。既然是图，必然离不开图的构建，论文中图的构建如下，可以简称为 S/T 图：论文中图结构和普通的无向图 \(G=(V,E)\) 一样，该图也是由顶点集合 \(V\) 和边集合 \(E\) 构成，不一样的是，该图有两种顶点和两种边：第一种顶点是普通顶点。由图像中各像素点组成，每个顶点对应于图像中每个像素点。每两个邻域顶点，对应于图像中每相邻两个像素点（对2维图像来说，是8邻域；对3维图像来说，是26邻域），的连接就是一条边，这种边叫做 n-links (neighborhood links)。第二种顶点是两个终端顶点，代表目标（object）的 source terminal（简称 S）和代表背景（background）的 sink terminal（简称 T），每个终端顶点都与所有普通顶点相连，这种相连构成的边叫做 t-links (terminal links)。 设图像 \(P\) 中每个像素点为 \(p\)，则 \(p \in P\)，目标终端顶点 \(S\)，背景终端顶点 \(T\) ，则构建的图 \(G\) 中顶点集合可表示为：\(V = P \cup \{S,T\}\) ；每个 \(p\) 都有两种 t-links 边，分别为 \(\{p,S\}\) 和 \(\{p,T\}\) ，每个 \(p\) 与其邻域内像素 \(q\) 构成的 n-links 边为 \(\{p,q\}\) ，设 \(N\) 代表 n-links 边集合，即邻域边集合，则 \(\{p,q\} \in N\) ，则构建的图 \(G\) 中边集合可表示为：\(E = N \bigcup\limits_{p \in P} \{\{p,S\},\{p,T\}\}\) 。因为这构建的是一个无向带权图，所以还需要设定边的权值，论文中边的权值设定如下：边权值（代价，能量）区域\(\{p,q\}\)\(B_{\{p,q\}}\)\(\{p,q\} \in N\)\(\{p,S\}\)\(\lambda \cdot R_p(&quot;bkg&quot;)\)\(p \in P, p \notin O \cup B\)\(\{p,S\}\)\(K\)\(p \in O\)\(\{p,S\}\)0\(p \in B\)\(\{p,T\}\)\(\lambda \cdot R_p(&quot;obj&quot;)\)\(p \in P, p \notin O \cup B\)\(\{p,T\}\)0\(p \in O\)\(\{p,T\}\)\(K\)\(p \in B\)其中集合 \(O\) 代表确定为目标的像素点的集合，即在交互时手动标注为目标的像素点；集合 \(B\) 代表确定为背景的像素点的集合，即在交互时手动标注为背景的像素点；\(B_{\{p,q\}}\) 可以表示 {p,q} 不连续的惩罚因子，其正比于一个指数函数，具体为：\(B_{\{p,q\}} \propto exp\left(-\frac{(I_p-I_q)^2}{2\sigma^2}\right) \cdot \frac{1}{dist(p,q)}\) ，其中 \(I_p\) 和 \(I_q\) 代表像素 \(p\) 和像素 \(q\) 的像素值，\(dist(p,q)\) 代表其两像素点之间的距离。从 \(B_{\{p,q\}}\) 对应的函数中可以看出当两像素点之间的差异越大时，其权值越小；两像素点之间距离越大时，权值越小（这里对于二维图像来说，一般只考虑周围 8 邻域内像素点，因此可以简单认为相邻两像素点之间距离为 1）。\(R_p(&quot;bkg&quot;)\) 和 \(R_p(&quot;obj&quot;)\) 分别是指像素 p 分配给背景和前景目标的惩罚因子，该惩罚因子与像素 p 属于前景目标的概率 \(Pr(I|O)\) 和背景的概率 \(Pr(I|B)\) 有关，一般取概率的负对数值，具体如下：\(R_p(“obj”) = −lnPr(I_p|O)\) 和 \(R_p(“bkg”) = −lnPr(I_p|B)\) 。至于概率的计算方法可以用简单的直方图概率模型，因为 \(O\) 和 \(B\) 为手动标注的确定的前景目标和背景的像素点集合，因此可以分别统计其灰度直方图，再对直方图频数进行归一化得到分布概率直方图，将像素 p 与 背景分布概率直方图和前景目标概率分布直方图进行对比，即可得到其属于背景的概率和属于前景目标的概率（当然更好的一种计算前景和背景概率的方法是用高斯混合模型）。\(K\) 表示整个无向带权图中最大的权值，具体计算方法如下：\(K=1+\max\limits_{p \in P} \sum \limits_{q:\{p,q\} \in N} B_{\{p,q\}}\) ，即取图像中像素点邻域边权值之和的最大值再加 1 （对于二维图像而言，邻域边权值之和是指 8 邻域边权值之和，图像中每个像素点都有其邻域边权值之和，取所有像素点中的最大值），至于为什么要令 K 为整个无向带权图中权值最大值？请详见下文。至于其中的参数 \(\lambda\) 和 \(\sigma\) 论文中没有明确指定，在初始计算时可以将其置为 1，随后再慢慢调整。至此，整个 Graph Cuts 算法中关于图的构建已经完全确定，接下来就是割（cut）的算法了。割篇 割（cut）是构建的无向带权图中边集合 \(E\) 的一个子集 \(C\)，即割 \(C \subset E\) ，该 cut 的 代价（cost）可表示为：\(|C|=\sum \limits_{e \in C} W_e\)，即该割边集合的所有边权值之和。如果一个割，其包含的所有边的权值之和最小，那么这个割就称为最小割，也就是图割的结果。在图分割里，是要求两个终端顶点被分离开的，即最小割把图的顶点划分为两个不相交的子集 \(S\) 和 \(T\) ，其中 \(s∈S\)，\(t∈T\)，\(T=V/S\)。事实上，这两个子集对应于图像的前景像素集和背景像素集，也就相当于完成了图像分割。 割相关的算法有很多，eg：Max-flow/Min-cut、GrabCut、One cut、 Normalized cut、Ratio cut 等等，但是其最关键的地方在于能量方程（或称 代价函数，损失函数）的优化，能量优化的目的在于最小化能量函数，而最小化能量函数时取得割就是最小割，即图割的结果。论文中能量方程的定义如下： \[ E(A)= \lambda \cdot R(A)+B(A) \] 其中： \[ R(A)= \sum_{p \in P} R_p(A_p) \\ B(A)= \sum_{\{p,q\} \in N} B_{\{p,q\}} \cdot \delta(A_p,A_q) \\ 其中 \delta(A_p,A_q) = \begin{cases} 1 &amp; \text{if } A_p \neq A_q \\ 0 &amp; \text{otherwise}. \end{cases} \]其中令 \(A=(A_1,\cdots,A_p,\cdots,A_{|P|})\) 为二值向量，每个 \(A_p\) 可赋值为 “obj”（可用 1 表示前景） 或 “bkg”（可用 0 表示背景）；\(R(A)\) 表示区域项，即上文中的两种 t-links 边相连的图像像素点权值，代表像素点分配给 “obj” 或 “bkg” 的惩罚项，对应于 \(R_p(&quot;obj&quot;)\) 和 \(R_p(&quot;bkg&quot;)\) ，求和后即可得到 \(R(A)\) 。当像素点 p 属于前景目标的概率 \(Pr(I|O)\) 大于背景的概率 \(Pr(I|B)\) 时，由上文 \(R_p(A_p) = −lnPr(I_p|A_p)\) 可知，此时 \(R_p(&quot;obj&quot;)\) 小于 \(R_p(&quot;bkg&quot;)\) ，即当像素 p 更有可能属于目标时，将 p 归类为目标就会使能量 \(R(A)\) 小，也因此要取概率的负对数值，由此，如果所有像素点都能正确划分为前景和背景，则总能量会达到最小。当像素点 p 已经人为手动标注为确定的前景目标时，这时其与顶点 \(S\) 相连的边的权值为 K，为整个无向带权图中最大的权值，即能量也最大，此时就不可能被分割，这就是为什么要令 K 为整个无向带权图中权值最大值，而其与顶点 \(T\) 相连的权值为 0 ，能量也为 0，此时一定会被分割。\(B(A)\) 表示边界项，即上文中 n-links 边的权值，代表邻域像素点 \({p,q}\) 不连续的惩罚，当其差异越大时， \(B(A)\) 越趋近于 0，即当邻域像素点差异越大时，由上文 \(B_{\{p,q\}} \propto exp\left(-\frac{(I_p-I_q)^2}{2\sigma^2}\right) \cdot \frac{1}{dist(p,q)}\) 可知其权值越小，能量 \(B(A)\) 也越小，则越应该被分割。参数 \(\lambda\) 用来表示区域项和边界项的重要性，初始计算时同样可以将其置为 1。至于 \(\delta(A_p,A_q)\) 的个人理解为：当邻域像素点 \(p,q\) 被分配的二值变量不同时，即一个是前景另一个是背景，这时在进行能量计算时需要考虑连接亮点的边 \(\{p,q\}\) 的权值，否则可以不考虑其权值。最后，本文割的具体实施是采用基于「最大流/最小割」算法进行的，而「最大流/最小割」算法针对的是有向图，所以需要把本文 S/T 图的每条无向边都转化为一去一回的两条有向边。附录 该论文还有一个有意思的地方就是其证明了能量函数 E(A) 的值只与割 \(C\) 有关，最小割与最小化能量函数对应。证明过程如下：由上文可知，对于图像中每个像素点，割 \(C\) 切断且仅切断一条 t-links 边，即要么切断 \(\{p,S\}\) 边，要么切断 \(\{p,T\}\) 边，毕竟一个像素点不可能同时属于前景和背景，也不可能既不属于前景也不属于背景；不属于同一终端顶点相连的 n-links 边也会被割 \(C\) 切断，因为如果不断开，则整个图还是相连的，而如果属于同一终端顶点相连的 n-links 边不应该被割 \(C\) 切断，否则，该割就不是最小割。对于任意割 \(C\) ，可定义其对应的图像分割结果向量 \(A(C)\) ，如下： \[ A_p(C) = \begin{cases} &quot;obj&quot; &amp; \text{if } \{p,T\} \in C \\ &quot;bkg&quot; &amp; \text{if } \{p,S\} \in C \end{cases} \] 因此当 C 确定之后，分割结果 A 也就确定了。利用上文给出的边的权值计算方法结合定义的 A 可得出割的代价（cost）： \[ \begin{align} |C| &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) + \sum_{p \in O} \lambda \cdot R_p(A_p(C)) + \sum_{p \in B} \lambda \cdot R_p(A_p(C)) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \\ &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) +0 + 0 + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \end{align} \] 这里是因为 \(O \cap B = \emptyset\) ，而且如果确定像素点 p 属于前景或背景，则其割边的权值必为 0，相应的代价也为 0，eg：设 p 确定为前景，则必定断开 {p,T} 边，而 {p,T} 边的权值为 0。又因为：\(E(A) = \lambda \cdot R(A) + B(A)\) ，则： \[ \begin{align} E(A(C)) &amp;= \lambda \cdot R(A(C)) + B(A(C)) \\ &amp;= \sum_{p \in P} \lambda \cdot R_p(A_p(C)) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \\ &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) + \sum_{p \in O} \lambda \cdot R_p(&quot;obj&quot;) + \sum_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \end{align} \] 所以：\(|C| = E(A(C)) - \sum \limits_{p \in O} \lambda \cdot R_p(&quot;obj&quot;) - \sum \limits_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;)\)又因为对于标注确定的前景和背景，任意割 C 的 \(\sum \limits_{p \in O} \lambda \cdot R_p(&quot;obj&quot;)\) 和 \(\sum \limits_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;)\) 都是完全确定不变的，可以令其为 const，则 \(E(A) = |C| + const\) ，当 \(C\) 取最小时，对应的 \(E(A)\) 也最小，即当割最小时，能量函数也最小。后记 虽说关于 Graph Cuts 网上已经有了无数篇博客对其进行描述，但其中或多或少感觉还是有些令人困惑的地方，于是写下本文将那些个人感觉有些困惑的地方重新梳理一下，再改变一下原论文的行文思路，个人感觉更好理解一点，不然一上来就是神马能量方程，简直一脸懵逼 (･ัω･ั) 。参考资料[1] Interactive Graph Cuts for Optimal Boundary and Region Segmentation of Objects in N-D ImageS[2] Graph Cuts[3] 图像分割之（二）Graph Cut（图割）[4] 图像分割算法——Graph Cuts[5] Interactive Graph Cuts for Optimal Boundary &amp; Region Segmentation of Objects in N-D Images 阅读笔记]]></content>
      <categories>
        <category>Study</category>
        <category>DigitalImageProcessing</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中static用法小结]]></title>
    <url>posts/b93d943b.html</url>
    <content type="text"><![CDATA[前言 static 是 C++ 中很常用的一个关键字，它的用法也很多，时常会将其弄混，索性做个小结，以免以后忘记了或者继续弄混 (｡･ω･｡)。预备篇 首先要了解程序中数据的存储形式，一般而言数据的存储形式有三种：栈区（stack）—— 由编译器自动分配释放，一般用来存放函数的参数值，局部变量的值等；堆区（heap）—— 由程序员分配释放，对应于对象的 new 或 malloc 和 delete 或 free，若程序员忘记释放，则在程序完全退出之后由操作系统回收；静态存储区（static）—— 在编译时由编译器分配，在程序完全退出时由操作系统回收，一般用来存放全局变量和 static 变量。 一般1声明的变量默认（如果变量类型，eg: int, double, … 等，前不加 static 或其它关键字）都是 auto 2的，其一般存放在栈区，生存周期就只在包围其的 { } 内，在包围其的 { } 外就无法使用该变量。而 static 存放在静态存储区，其生存周期是全局的，它要等整个程序完全退出时才会销毁，在程序运行过程中，每次调用 static 变量都保持上一次调用结束后的值。类中篇静态成员变量 类中的静态成员变量被该类的所有实例共享，也可以不通过类的实例使用，在使用时首先需要对其初始化，也必须对其进行初始化，因为类中的静态成员变量只是声明，而且，类中的静态成员变量和普通静态变量一样是在程序初始化的时候分配的，在程序完全退出时由操作系统回收。具体用法如下：12345678class Test&#123;private: static int s_value; // 注意，这里不能初始化！因为其不属于类对象，只属于类作用域，独立于该类的任何实例&#125;;// 在cpp中或类定义体外必须对它进行定义和初始化，因为在程序编译时首先执行的就是对其初始化并分配内存：int Test::s_value = 0; // 注意，这里没有static的修饰！总而言之就是：类中的静态成员变量可以简单理解为一个名为 Test::s_value 的全局变量，被所有该类的实例共用，但独立于该类的任何实例，只属于该类作用域，在类的定义中能且只能被声明，不能在类定义体中进行初始化，必须要在类定义体外被定义和初始化。静态成员函数 类中的静态成员函数和类中的静态成员变量有点类似，其在实现时不需要再加 static 修饰，同样能被该类的所有实例复用，同样只属于类作用域中的全局函数，同样不需要类的实例即可调用。类中的静态成员函数不能访问类的普通成员变量，只能访问类的静态成员变量（可以参考 C++静态成员函数访问非静态成员的几种方法 中的小 trick 访问普通成员变量，但非特殊情况不建议这么做）。具体用法如下：12345678910111213141516class Test&#123; private: static void func(int i); // 静态成员函数调用非静态成员变量方法 static void staticTest(Test *t) &#123; t-&gt;value += 1; &#125;private: int value;&#125;;// 在cpp中可以不通过类的实例进行调用：void Test::func(int);总而言之就是：类中的静态成员函数可以简单理解为一个名为 Test::func(int) 的全局函数，能被该类的所有实例复用，但独立于该类的任何实例，只属于该类作用域，可以不通过类的实例进行调用，也可以像普通成员函数一样通过类的实例进行调用。特定范围篇 为了使全局变量或函数只在特定 cpp 文件中起作用，需要在 cpp 文件中相应变量或函数前添加static 修饰，如下表：类型.h 文件中.cpp 文件中全局变量不使用 static 修饰，使用 extern 修饰使用 static 修饰全局函数不使用 static 修饰使用 static 修饰如果在头文件中声明 static 全局变量，则在包含该头文件的每个 .cpp 文件中都会生成一个独立的同名变量，而这种写法没有任何意义；如果在 .cpp 文件中不使用 static 声明全局变量，则该全局变量可能会被其它 .cpp 文件共享，也可能不会，造成该变量的不确定性；所以如果该全局变量要被所有 .cpp 文件共享，则需要在头文件中声明 extern 全局变量（eg：extern int g_value; // 注意，不要初始化值！），再在某个 .cpp 文件中单独进行定义和初始化（仅一次）（eg：int g_value = 0; // 不要extern修饰！），如此即可在每个 .cpp 文件中共享该全局变量；而若只想在单个 .cpp 文件中使用全局变量，则需要在该 .cpp 文件中全局范围类声明和定义 static int g_value = 0;，如此可保证该变量能且只能被该 .cpp 文件使用。如果在 .cpp 文件中不使用 static 声明全局函数，则该全局函数可能会被其它 .cpp 文件共享，也可能不会，这样在别的 .cpp 文件调用同名函数时可能会出现问题；而在头文件中使用 static 声明全局函数同样没有任何意义；所以如果要被多个 .cpp 文件复用，就将其声明移到头文件中，且不需要 static 修饰，而若只想在特定 .cpp 文件中使用该全局函数，则需要在声明时添加 static 修饰。最后，若是在 .hpp 文件中，则需要去除全局对象，将全局函数封装为类的静态方法。 PS：若在函数中使用 static 修饰变量，则该函数无法做到线程安全，在程序运行过程中，每次调用该函数，函数内的 static 变量都将保持上一次调用结束后的值，所以在函数中慎用 static 变量，除非需要这个特性。后记 写这篇文章的初衷在于时常需要 static 时老是忘记或弄混它的用法，不得不去网上查找，虽说网上的相关资料也有很多，但在找的时候还是有点麻烦，毕竟有很多不是自己需要的，而且自己总结一下对其理解又更深一些，下次要用时也能马上找到自己所需。参考资料[1] c/c++ static 用法总结（三版本合一）[2] C++中static的用法总结[3] C++ 类中的static成员的初始化和特点[4] C++静态成员函数访问非静态成员的几种方法这里的一般是指局部变量，若为全局变量则默认为 extern ，局部变量没有默认初值，其初值不确定，一般需要人为明确的赋初值，而全局变量默认初值为 0 ，一个比较好的编程习惯是声明一个变量就对其进行初始化（赋初值），尽量少用全局变量，全局变量显示声明 extern。↩※注：这里的 auto 与 C++11 中的意义不同，这里的 auto 指的是变量的存储形式，而不是 C++11 那种可以当做任意的变量类型，eg: int, double, std::vector&lt;std::vector&lt;double&gt;&gt;, …… ，与其对应的还有 extern 和 register 关键字，其中 register 关键字基本不用 。↩]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列的三种写法]]></title>
    <url>posts/8fb9f004.html</url>
    <content type="text"><![CDATA[前言 本文预示着 Shaun 开始着手准备找工作的事了，初步计划是先把『剑指Offer』上的题先做一遍，对照着 牛客网 上的题进行测试，尽量争取先把书上的题都能 AC 。一般定义的斐波那契数列数列为：0,1,1,2,3,5,8……（对应 \(F(0)=0, F(1)=1, F(2)=1, \cdots \cdots\)），用数学公式表示即为：\(F(n)=F(n-1)+F(n-2)\)。以下代码均用 C++ 实现，且均通过牛客的测试。循环写法1234567891011int fibonacci_loop(const unsigned int &amp;n)&#123; int fn = 0, f1 = 0, f2 = 1; for (int i = 0; i &lt; n; i++) &#123; fn = f1 + f2; f2 = f1; f1 = fn; &#125; return fn;&#125;递归写法123456789101112131415int fibonacci_recursive(const unsigned int &amp;n)&#123; if (n == 0) &#123; return 0; &#125; else if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2); &#125;&#125; ※注：这里 Shaun 在牛客上进行测试的时候，如果把 || n == 2 去掉的话，就没法通过，可见多递归一次花费的时间并不是线性增长的。尾递归写法 说来惭愧，这个概念还是在一个小学弟那里得知的，后面才逐渐了解并学会使用。 尾递归，简而言之就是最后会且仅会调用函数本身，递归调用函数之后没有其它的语句需要执行。就像上面的递归，它在递归调用之后还会执行加法运算，而尾递归在执行递归调用之后就没有其它的运算了。1234567891011int fibonacci_tailRecursive(unsigned int n, unsigned int f1 = 1, unsigned int fn = 0)&#123; if (n == 0) &#123; return fn; &#125; else &#123; return fibonacci_tailRecursive(n - 1, fn, fn + f1); &#125;&#125;总结 循环和尾递归花费的时间和空间都差不多，都要比普通的递归要小，普通的递归优势在于便于理解，代码好写，在不强调性能的前提下，用递归写法的代码可读性可能要好些。参考资料[1] 递归与尾递归总结（http://www.cnblogs.com/Anker/category/436371.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>posts/982ff584.html</url>
    <content type="text"><![CDATA[前言 Shaun 一直以为自己的搜索能力还可以，基本上自己想要的东西都能搜到，但是自从接触到这个世界，才知道自己大概只是个入门的水平（或者说连入门都说不上 /つ∇T)），和网上的一些大神相比还有比较大的差距，此文只是网上一些资料的整理，方便 Shaun 熟练使用，提高驾驶技巧，毕竟信息检索能力还是很重要的。搜索篇Google 可以通过添加一些字符优化搜索结果，如：搜索需求对应字符搜索社交媒体在用于搜索社交媒体的字词前加上 @。例如：@twitter。从搜索结果中排除特定字词在您要排除的字词前加上 -。例如：jaguar speed -car搜索完全匹配的结果为字词或短语加上引号。例如：&quot;tallest building&quot;。搜索通配符或未知字词在字词或短语中您要放置占位符的地方加上 *。例如：&quot;largest * in the world&quot;。在某个数字范围内执行搜索在两个数字之间加上 ..。例如：camera $50..$100组合搜索在各个搜索查询之间加上“OR”。例如：marathon OR race搜索特定网站在相应网站或域名前加上“site:”。例如：site:youtube.com或 site:.gov搜索相关网站在已知网址前加上“related:”。例如：related:time.com查找链接到某个特定网页的网页在已知网址前加上“link:”。例如：link:chongbuluo.com，就能查到哪些网页中包含链接chongbuluo.com查找在URL地址里有搜索关键词的页面在已知网址前加上“inurl:”。例如：inurl:chongbuluo，就能查到哪些网页 url 中包含链接chongbuluo查找在网页标题里有搜索关键词的页面在已知网址前加上“intitle:”。例如：intitle:chongbuluo，就能查到哪些网页标题中包含链接chongbuluo查找在网页正文里有搜索关键词的页面在已知网址前加上“intext:”。例如：intext:chongbuluo，就能查到哪些网页正文中包含链接chongbuluo查找pdf,xml,xls,txt,doc,csv等特定格式的结果在特定文件格式前加上filetype:。例如 filetype:pdf查找关键词的定义在关键词前加上define:。例如 define:搜索 经 Shaun 实测，以上大部分字符对百度搜索引擎同样适用。当然，最好的搜索方式是使用高级搜索，高级搜索可以进行一系列设置，比如时间范围，从而使搜索结果更精确，更容易得到想要的结果，不过在不十分确定的时候，不要做太多限制，不然可能会过滤掉关键信息。 Google 和百度对英文字符大小写都不敏感，搜索 QQ 与 qq 所得到的结果是一样的。搜索是否成功最关键的地方还是在于关键词的选取，关键词的选取这没什么好说的，只能提高搜索熟练度及对问题的把握程度了。 哦，还有一点忘记说了，就是在 Google 中如果要搜索那个的话，必须要在搜索设置里面关闭安全搜索功能，如果简体中文不能关闭安全搜索功能的话，就在搜索设置里将语言更换到繁体中文或英语应该就能关闭安全搜索功能。技巧篇 有时候第一个页面没有想要的结果，于是需要看第二个、第三个页面的结果，是不是觉得翻页很麻烦？（如果不觉得麻烦可以直接跳过🙄），但是设置增加搜索结果条目又会提高显示延迟，这时可以使用 Super_preloaderPlus_one 脚本（Chrome 中可以使用 AutoPagerize 插件），只需鼠标继续往下滚轮就会自动加载下页搜索结果，无需点击翻页。 当点击网页链接却出现404错误或无法显示页面的错误时，这个时候可以使用搜索引擎的「网页快照」功能，Google的这个功能点击搜索结果页面标题下的 绿色小三角 即可看到，百度的这个叫 百度快照，在搜索结果 url 地址的末端，即结果最后面。快照功能最强大的是 互联网档案馆（Internet Archive），又叫『网站时光倒流机器』（Wayback Machine），在知道链接的情况下，将链接输入到 Internet Archive 点击搜索就能查看历史快照了。 如果要查找某个网页出现的关键词，可以利用 Chrome 和 Firefox 的网页搜索功能，一般可以通过 Ctrl + F 去检索。也可以通过 F12 或「鼠标右键」（Firefox 点击「查看元素」，Chrome 点击「检查」，都是右键弹框最后一个选项）进入浏览器控制台开发工具，Chrome 中还要通过 Ctrl + F 才能检索元素，而 Firefox 可以直接搜索 HTML，输入要查找的关键词，回车即可。专项篇 图像搜索：这个一般用 Google 和百度的以图搜图就可以了，不过也有些特殊的图像搜索引擎，如 TinEye 等，当然，图像搜索最好还是安装相应的插件，在 Chrome 中可以安装一个叫 二箱 的插件，在 Firefox 中可以安装一个叫 Search by Image 的插件。 音乐搜索：这个如果能听出歌词的话就直接去搜索引擎上搜听到的歌词，如果无法听出歌词的话，可以尝试各大音乐软件的「听歌识曲」功能。 当然更精确的专项搜索一般只存在于特定的网站，这就要看对整个互联网的了解程度了，这里强推「虫部落-快搜」，不管是日常搜索需求还是特殊搜索需求基本都能满足。后记 尽量优先使用 Google，百度或许能找到自己想要的，但太浪费时间了，浪费时间就是浪费生命，不过能看到本文的看官，应该也是能熟练使用 Google 的了。参考资料[1] 如何在 Google 中进行搜索(https://support.google.com/websearch/#topic=3081620)[2] 优化网页搜索[3] 提高搜索能力的关键技巧（如何查找可靠出处）[4] 谷歌搜索技巧：搜索语法+隐藏彩蛋+高级设置]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17年走了，18年来了]]></title>
    <url>posts/7cebf0ee.html</url>
    <content type="text"><![CDATA[17 年走了，18 年也过了一个月，从这一个月看，18 年好像并没有对那个傻逼好一点。 17 年，也算是 Shaun 人生的一个转折点吧，既然是转折点，况且人也这么大了，不能像以前那样浑浑噩噩的过了，所以总要留下点什么东西吧。 17 年，从本科升入研究生，学校变了，所在城市却没变，所接触到的人好像变了，也好像没变，人还是那样的人。虽然早知读研是个坑，但还是转身继续扎入象牙塔中，但此时的象牙塔已不再是四年前的象牙塔，如果说四年前的象牙塔是白色的，那现在的就是黑色的，虽然是黑色的，但总比外面无尽的黑暗要好一点吧（或许有一点光明），至少是个塔，至少还稍微有点保护作用（心里安慰罢了）。黑色象牙塔和白色象牙塔最大的区别在于黑色象牙塔里有 boss，更NB的是 boss 拥有生杀予夺的权利，而且这种权利没人监管，也无法申述（或许是 Shaun 不知道？），除非有玉石俱焚的决心，否则很难反抗 。进入这黑色的象牙塔是为了逃避黑暗还是大势所趋， Shaun 认为自己或许两者皆有，在这黑色的象牙塔待两年，一来能在将来真正进入黑暗之前稍微接触一点黑暗，做好心理准备，起到一个缓冲的作用；二来能趁这两年提升一下自己，为自己在将来在黑暗中寻找那 些微光明 提供一点帮助，而且外界的黑暗也对黑色象牙塔中走出来的人好像更重视，这样不管是硬实力，还是软实力都能得到提升，这在黑暗中行走就更有的底气了，而且也更会有后劲，这样的话走进光明是不是更容易些？ 17 年，不管是求知方面还是视界方面都得到了一定程度的提升和扩大，或许在外面那无尽的黑暗中能提升的更快，扩大的更多也说不好。要说 Shaun 真正进入计算机的世界，应该是在大三上的时候吧，那时候才算是真正入门了，以前只能说是上过计算机的基础课，有什么问题还是没办法解决，还处在混沌阶段，没有方向，只能瞎摸。入门了之后感觉学计算机相关的东西就轻松多了，大多数问题都能找准方向，并一步一步的解决，当然最快的解决方案还是在 Google 上。大四做毕设的时候，从没接触过 OpenCV 的 Shaun ，借助网上的资料和书本，花了两个月的时间，还是勉强做了简单的手势识别系统，等以后时间把这个系统还是记录一下吧，好歹这其中基本上把经典计算机视觉中数字图像处理和传统机器学习结合的流程走了一遍，做完这个系统，Shaun 的计算机视觉也算是正式入门了。至于目前火热的深度学习，因为设备的原因，暂时还无法实践，不得不说这是一大憾事。 17年，人或许没接触到更多，但事倒是见得更多了。主要是因为接触到了一些更有趣的世界，或者说圈子，这其中强推 「Solidot」 ，该站点的资讯确实更新的很及时，科技界的一些大事都能及时公布出来，还有一个就是 「虫部落」，其快搜资源的聚合简直无敌了。网络如此之大，不知道还有多少有趣的事物等着 Shaun 去发现，每发现这些有趣的东西，就像是找到一个宝藏一样，想想就觉得很开心呢 🙃。 17 年，以一种看客的心态看了很多场戏。番茄界的用户资源之争，人肉的厉害之处，本是同根生，相煎何太急，最后有一人只能黯然退出，不知道是好是坏，毕竟 Shaun 也没用过那个工具及其提供的相关服务（或许以后会用到吧），但一家独大总归不是什么好事。在网上看到这样一句话：「鲁迅已逝，阿Q 重生」，『暴走大事件』对时事的调侃虽然很尖锐，但三观基本很正，坚持这样不容易啊，望其能唤醒一些 阿Q 吧。『新浪微博』，可以说是当前中国最大的信息聚合平台了，什么样的东西总能在微博上找到，国内大部分的戏也能在微博上看到，尤其是评论区更是有趣，但其信息和用户太杂了，良莠不齐，信息的价值密度比较低，总而言之，微博这种东西是需要带着脑子去逛的，微博上有些东西，Shaun 无法辨别，但借用鲁迅先生的一句话，「我向来是不惮以最坏的恶意来揣测中国人」。至于『知乎』，『V2EX』等，仁者见仁智者见智吧。 17 年，在网上看到这样一句话：“你可以不关心政治，但政治会来关心你”。政治上的事，无非是民主自由，但出于某些不可描述的原因就不谈了，无知是福 （๑乛◡乛๑）。但知道一些人和政策总是有好处的，虽然暗地里可能会违背，但估计没人敢明目张胆的违背吧，通过知道这些事，总能做点趋利避害的事吧。 17 年，已在实验室待了半年，还好有音乐这种东西可以麻痹一下，不然这两年就难熬喽。17 年，总归还是或知道或学会了很多有趣的东西。世界总的来说还是美好的，但这些美好的东西又有多少人能亲身经历，亲身享受。Shaun 能做的只有向这些美好的东西前进，接近，享受，顺便看看路上的风景，不管是好的还是坏的。17 年获得技能：视界开拓17 年获得成就：打开新世界的大门]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵的应用之图像仿射变换]]></title>
    <url>posts/e124baa1.html</url>
    <content type="text"><![CDATA[前言 好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，Shaun 这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。预备篇 首先需要了解的是图像中坐标系和数学课本中常用的坐标系略有不同，图像中坐标系是以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴；而数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴。所以由图像中坐标 \((x,y)\) 转数学课本中常见的坐标 \((x&#39;,y&#39;)\) 的公式为 $x’ = x - C/2; y’ = -y + R/2; $ 其中 \(C\) 表示原图像总列数，即原图像宽度，\(R\) 表示原图像总行数，即原图像高度。X 轴Y 轴X 轴Y 轴数学坐标系图像坐标系 ※注：值得注意的是因为 MATLAB 和 OpenCV 的像素索引坐标形式为 (行坐标，列坐标) ，所以若以本文这样定的图像坐标，则图像中坐标 \((x,y)\) 对应的像素值为 \(f(y,x)\)。变换篇据 OpenCV 文档所说：一个任意的仿射变换都能表示为 乘以一个矩阵 (线性变换) 接着再 加上一个向量 (平移).综上所述, 我们能够用仿射变换来表示:旋转 (线性变换)平移 (向量加)缩放操作 (线性变换)你现在可以知道, 事实上, 仿射变换代表的是两幅图之间的 关系 .我们通常使用 矩阵来表示仿射变换. 考虑到我们要使用矩阵 和 对二维向量 做变换, 所以也能表示为下列形式: or 而在冈萨雷斯的《数字图像处理_第三版》里有：最常用的空间坐标变换之一是仿射变换，其一般形式如下： \[ \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \textbf{T} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \begin{bmatrix} t_{11} &amp; t_{12} &amp; 0 \\ t_{21} &amp; t_{22} &amp; 0 \\ t_{31} &amp; t_{32} &amp; 1 \end{bmatrix} \] 其中 \((v,w)\) 为原坐标，\((x,y)\) 为变换后的坐标，可根据变换矩阵 \(\textbf{T}\) 中的元素选择的值，对一组坐标点做尺度、旋转、平移或偏移变换。一些常见的变换矩阵及作用如下表：变换名称仿射变换矩阵\(\textbf{T}\)坐标公式恒等变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=w \end{cases}\)尺度变换\(\begin{bmatrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vc_x , \\ y=wc_y \end{cases}\)旋转变换（以逆时针为正）\(\begin{bmatrix} cos(\theta) &amp; sin(\theta) &amp; 0 \\ -sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)-wsin(\theta) , \\ y=vsin(\theta)+wcos(\theta) \end{cases}\)旋转变换（以顺时针为正）\(\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)+wsin(\theta) , \\ y=-vsin(\theta)+wcos(\theta) \end{cases}\)平移变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+t_x , \\ y=w+t_y \end{cases}\)偏移变换（水平）\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_h &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+ws_h , \\ y=w \end{cases}\)偏移变换（垂直）\(\begin{bmatrix} 1 &amp; s_v &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=vs_v+w \end{cases}\)仿射变换的实现由两种方式：一种是 前向映射（Forward Mapping）：直接采用利用原图像坐标 \((v,w)\) 通过 \(\begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}\) 得到变换后的坐标 \((x,y)\)，使用前向映射会导致一些问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的花纹状）；更好的一种方式是采用 反向映射（Inverse Mapping）：扫描输出图像的位置 \((x,y)\)，通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)（其中 \(\textbf{T}^{-1}\) 为 \(\textbf{T}\) 的逆矩阵）计算输入图像对应的位置 \((v,w)\)，通过插值方法决定输出图像该位置的灰度值。 本文这里采取冈萨雷斯的《数字图像处理_第三版》的变换矩阵方式，毕竟所学的矩阵论也是将变换矩阵放在后面作为第二个因子。虽然仿射变换都有现成的 API 可以调用，而且速度一般要比自己写的要快，但是知其然终究也要知其所以然。 下面就以旋转变换为例了，因为尺度变换和平移变换只需要相应的缩放图像即可，而旋转变换不仅需要更改图像大小，还要确定旋转中心，而旋转中心一般以图像中心为标准。旋转变换 旋转变换首先需要确定旋转中心，若以图像左上角为旋转中心，则只需要像做尺度变换和平移变换那样通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\) 做普通的变换即可。而以图像中心为旋转中心，首先需要做坐标变换，将以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴的图像坐标系转换为以图像中心为原点，水平向右为 X 轴，垂直向下为 Y 轴的数学坐标系；再做正常的旋转变换；随后再将数学坐标系转换为图像坐标系，所以图像中心为旋转中心的旋转变换总共需要做三次变换。这里就以图像中心为旋转中心为例，由于有三次变换，所以应该有三个变换矩阵相乘，设 图像坐标系==》数学坐标系的变换矩阵为 T1，旋转变换矩阵为 T2，数学坐标系==》图像坐标系的变换矩阵为 T3，设顺时针旋转角度为 \(\theta\) ，原图像宽度为 \(C\)，高度为 \(R\)，旋转后图像宽度为 \(W\)，高度为 \(H\)，则： \[ T1=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ -0.5C &amp; 0.5R &amp; 1 \end{bmatrix} T2=\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} T3=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0.5W &amp; 0.5H &amp; 1 \end{bmatrix} \] 则旋转变换最终形式为：\(\begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}=\begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix}T1*T2*T3\)。※BTW：旋转变换中，旋转后图像宽度 \(W\)，高度 \(H\) 与 原图像宽度 \(C\)，高度 \(R\) 的关系为： \[ \begin{cases} H = |R*cos(\theta)| + |C*sin(\theta)| , \\ W = |C*cos(\theta)| + |R*sin(\theta)| \end{cases} \]插值篇 因为经过采用反向映射1方式的仿射变换之后，得到的原图像坐标 \((v,w)\) 往往不是整数值，所以无法知道其对应的像素值 \(f(w,v)\)，这时需要采取插值的方式近似估计该坐标位置的像素值。 常用的插值方法有最近邻插值（nearest neighbor interpolation）、双线性插值（bilinear interpolation）和双三次插值（bicubic interpolation），其中双三次插值在保持图像细节方面最好，但花费时间也最多，PS 中的消除锯齿和羽化效果好像就采用了双三次插值。 最近邻插值只考虑相邻最近的像素，双线性插值考虑相邻的 4 个像素点，双三次插值则考虑相邻的 16 个像素点。最近邻插值 最近邻插值最简单，将变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，直接对 \((v,w)\) 进行四舍五入得到相应的整数坐标 \((⌊v+0.5⌋,⌊w+0.5⌋)\)2，用该整数坐标的像素值近似估计 \((v,w)\) 的像素值，令 \(f(y,x)=f(⌊w+0.5⌋,⌊v+0.5⌋)\) ，从而得到变换后图像每个像素点的像素值。双线性插值 双线性插值是线性插值方法的一种扩展，它是 X 和 Y 两个方向上线性插值的组合。X 轴Y 轴P1P2P3P4Z1Z2P(v,w)如上图，设变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，即点 \(P\) 正好处于四个像素点 \(P1(v_0, w_0)\)、\(P2(v_0+1, w_0)\)、\(P3(v_0+1, w_0+1)\)、\(P4(v_0, w_0+1)\) 的中间，其中 \(v_0=⌊v⌋\)，\(w_0=⌊w⌋\) ，点 \(P\) 对应的像素值为 \(f(P)\) 因为双线性插值即在 \(X\) 和 \(Y\) 两个方向进行线性插值，首先计算 \(X\) 方向的插值： \[ \begin{cases} \frac{f(P2)-f(P1)}{P2.x-P1.x}=\frac{f(Z1)-f(P1)}{Z1.x-P1.x} , \\ \frac{f(P3)-f(P4)}{P3.x-P4.x}=\frac{f(Z2)-f(P4)}{Z2.x-P4.x} \end{cases} \] 即： \[ \begin{cases} f(Z1)=\frac{Z1.x-P1.x}{P2.x-P1.x}f(P2)+\frac{P2.x-Z1.x}{P2.x-P1.x}f(P1) =(v-v_0)f(P2)+(v_0+1-v)f(P1), \\ f(Z2)=\frac{Z2.x-P4.x}{P3.x-P4.x}f(P3)+\frac{P3.x-Z2.x}{P3.x-P4.x}f(P4) =(v-v_0)f(P3)+(v_0+1-v)f(P4) \end{cases}\tag{1} \] 然后计算 \(Y\) 方向的插值： \[ \begin{equation} \frac{f(Z2)-f(Z1)}{Z2.y-Z1.y}=\frac{f(P)-f(Z1)}{P.y-Z1.y} \end{equation} \] 即： \[ \begin{equation} f(P)=\frac{P.y-Z1.y}{Z2.y-Z1.y}f(Z2)+\frac{Z2.y-P.y}{Z2.y-Z1.y}f(Z1) =(w-w_0)f(Z2)+(w_0+1-w)f(Z1) \end{equation}\tag{2} \] 结合式（1）和式（2）可得： \[ \begin{equation} f(P)=(v_0+1-v)(w_0+1-w)f(P1)+(v-v_0)(w_0+1-w)f(P2)+(v-v_0)(w-w_0)f(P3)+(v_0+1-v)(w-w_0)f(P4) \end{equation} \] 用矩阵形式可表示为： \[ f(P)=\begin{bmatrix} v_0+1-v &amp; v-v_0 \end{bmatrix} \begin{bmatrix} f(P1) &amp; f(P4) \\ f(P2) &amp; f(P3) \end{bmatrix} \begin{bmatrix} (w_0+1-w) \\ (w-w_0) \end{bmatrix} \] 即： \[ f(y,x)=f(w,v)=\begin{bmatrix} ⌊v⌋+1-v &amp; v-⌊v⌋ \end{bmatrix} \begin{bmatrix} f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) \\ f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) \end{bmatrix} \begin{bmatrix} (⌊w⌋+1-w) \\ (w-⌊w⌋) \end{bmatrix} \]双三次插值X 轴Y 轴P11P(v,w) 如上图，双三次插值需要考虑相邻16个像素（4×4），用双三次插值重采样的图像更平滑并且更能保留图像细节，在这三种插值算法中，双三次插值效果最好，但处理速度最慢。同样设变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，与其左上角相邻最近的 点P11 坐标则为 \((⌊v⌋,⌊w⌋)\) ，该插值方法需要选取一个合适的插值基函数，参照维基百科 Bicubic interpolation 的一般为： \[ W(x) = \begin{cases} (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{for } |x| \leq 1, \\ a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{for } 1 &lt; |x| &lt; 2, \\ 0 &amp; \text{otherwise}, \end{cases} \] 其中 \(a\) 一般取 -0.5 、-0.75 或 -1；则：\(f(y,x)=f(w,v)=A*B*C\) ，其中： \[ A=\begin{bmatrix} W( v-(⌊v⌋-1) ) &amp; W(v-⌊v⌋) &amp; W( (⌊v⌋+1)-v ) &amp; W( (⌊v⌋+2)-v ) \end{bmatrix} \\ B=\begin{bmatrix} f(⌊w⌋-1,⌊v⌋-1) &amp; f(⌊w⌋,⌊v⌋-1) &amp; f(⌊w⌋+1,⌊v⌋-1) &amp; f(⌊w⌋+2,⌊v⌋-1) \\ f(⌊w⌋-1,⌊v⌋) &amp; f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) &amp; f(⌊w⌋+2,⌊v⌋) \\ f(⌊w⌋-1,⌊v⌋+1) &amp; f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) &amp; f(⌊w⌋+2,⌊v⌋+1) \\ f(⌊w⌋-1,⌊v⌋+2) &amp; f(⌊w⌋,⌊v⌋+2) &amp; f(⌊w⌋+1,⌊v⌋+2) &amp; f(⌊w⌋+2,⌊v⌋+2) \end{bmatrix} \\ C=\begin{bmatrix} W( w-(⌊w⌋-1) ) \\ W(w-⌊w⌋) \\ W( (⌊w⌋+1)-w ) \\ W( (⌊w⌋+2)-w ) \end{bmatrix} \]即：\(f(y,x)=f(w,v)= \sum\limits_{row=-1}^2\sum\limits_{col=-1}^2f(⌊w⌋+row,⌊v⌋+col)W(row-(w-⌊w⌋))W(col-(v-⌊v⌋))\)另附：网上也有人中间那个矩阵 \(B\) 是本文中间矩阵 \(B\) 的转置，经过下文实践，感觉效果差不多，但从理论上来说，应该本文这样写才是对的吧🤔。实践篇 本次实践采用 Matlab R2016b，具体 matlab 实现代码为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849clc;clear;close all;img = imread('lena_gray.jpg'); % 读取图像[R, C] = size(img); % 获取图像大小theta = 45 * pi / 180.0; % 旋转角度H = ceil(abs(R*cos(theta)) + abs(C*sin(theta))); % 变换后图像的高度W = ceil(abs(C*cos(theta)) + abs(R*sin(theta))); % 变换后图像的宽度res = zeros(H, W); % 构造结果矩阵。每个像素点默认初始化为0（黑色）T1 = [1 0 0; 0 -1 0; -0.5*C 0.5*R 1]; % 将原图像坐标映射到数学笛卡尔坐标T2 = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; 0 0 1]; % 数学笛卡尔坐标下顺时针旋转的变换矩阵T3 = [1 0 0; 0 -1 0; 0.5*W 0.5*H 1]; % 将数学笛卡尔坐标映射到旋转后的图像坐标T = T1*T2*T3;inv_T = inv(T); % 求逆矩阵% inv_T = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; -0.5*W*cos(theta)-0.5*H*sin(theta)+0.5*C 0.5*W*sin(theta)-0.5*H*cos(theta)+0.5*R 1];for y = 1 : H % 变换后图像的纵坐标，行，高 for x = 1 : W % 变换后图像的横坐标，列，宽 original_coordinate = [x y 1] * inv_T; % 矩阵乘法 v = original_coordinate(1); % 原图像的横坐标，列，宽 w = original_coordinate(2); % 原图像的纵坐标，行，高 % 变换后的位置判断是否越界 if v&gt;=1 &amp;&amp; w&gt;=1 &amp;&amp; v&lt;=C &amp;&amp; w&lt;=R res(y, x) = img(round(w), round(v)); % 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） % ------------- 双线性插值（bilinear interpolation）----------------- left = floor(v); right = ceil(v); top = floor(w); bottom = ceil(w); dC = v-left; % 列偏差 dR = w-top; % 行偏差 res(y, x) = (1-dC)*(1-dR)*img(top, left) + dC*(1-dR)*img(top,right) + (1-dC)*dR*img(bottom, left) + dC*dR*img(bottom, right); % ------------- 双三次插值（bicubic interpolation） ------------------------- if left&gt;=2 &amp;&amp; top&gt;=2 &amp;&amp; left&lt;=(C-2) &amp;&amp; top&lt;=(R-2) img = double(img); MA = [bicubic(1+dC) bicubic(dC) bicubic(1-dC) bicubic(2-dC)]; MB = [img(top-1,left-1) img(top,left-1) img(top+1,left-1) img(top+2,left-1); img(top-1,left) img(top,left) img(top+1,left) img(top+2,left); img(top-1,left+1) img(top,left+1) img(top+1,left+1) img(top+2,left+1); img(top-1,left+2) img(top,left+2) img(top+1,left+2) img(top+2,left+2)]; % MB = MB'; % 求转置矩阵 MC = [bicubic(1+dR); bicubic(dR); bicubic(1-dR); bicubic(2-dR)]; res(y, x) = MA*MB*MC; end end endend;figure, imshow(uint8(res)); % 显示图像BiCubic 基函数 Matlab 代码为：1234567891011121314function W = bicubic(x)%bicubic 双三次插值基函数a = -1; % 默认取a为-1x1 = abs(x);x2 = x1*x1;x3 = x1*x2; if x1 &lt;= 1 W = 1 - (a+3)*x2 + (a+2)*x3;elseif x1&gt;1 &amp;&amp; x1&lt;=2 W = -4*a + 8*a*x1 - 5*a*x2 + a*x3;else W = 0;end 旋转变换中感觉插值的作用没体现出来，以肉眼来看感觉三种插值方法的效果差不多，可能是 Shaun 选取的示例不好，为了体现插值效果，应该采用尺度变换（缩放变换）的。以上代码改为尺度变换也简单，自定义图像缩放后的宽高，以两倍为例，H = R * 2; W = C * 2;，再将旋转变换矩阵改为尺度变换矩阵，尺度变换矩阵中 \(c_x=W/C；c_y=H/R\)。为了便于理解，Shaun 对代码就不进行优化了（其实是你懒吧 _(:з」∠)_）。后记 本文算是数字图像处理中最基础的知识了，但 Shaun 在写时还是查阅了大量相关的资料，有些地方理解的还不是很透彻，行文思路有点混乱 ╮(╯▽╰)╭。本来是不想使用图片的，但本文不用图片很难理解清楚，又为了不使用外部图，最后只得参考 SVG 教程 和 如何创建SVG箭头和polymarker——marker元素 采用 SVG 绘制相应图片了。等有时间再把用 OpenCV 实现的 C++ 代码也贴上吧。最后再感叹一下 Matlab 确实是做科研的好工具（°Д°）Ъ，吐槽一下 MathJax 排版好痛苦啊，太多需要转义符\的地方了吧。，搞错了 Σ(ﾟдﾟ;)，这主要和 markdown 渲染有关，hexo 默认的 markdown 渲染插件 hexo-renderer-marked 太普通了，有些东西根本没办法渲染或者渲染有问题 （╯‵□′）╯︵┴─┴，Shaun 最后决定使用 hexo-renderer-pandoc 插件渲染 markdown，这样就完美了 (๑•̀ㅂ•́)و✧ 。 至于具体怎么使用 hexo-renderer-pandoc 替换默认的渲染器可参考：如何禁止 hexo 在 html 代码里插入&lt;br&gt;标签?。具体如下：12345# 1、安装 Pandoc，可以不顺带安装 MiKTex# 2、卸载默认渲染器npm uninstall hexo-renderer-marked --save# 3、安装 hexo-renderer-pandocnpm install hexo-renderer-pandoc --save附录 挖的坑总是要填的，呐，这就是用 OpenCV 实现的旋转变换，实现语言为 C++ ：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;opencv2/opencv.hpp&gt;#define M_PI 3.14159265358979323846double bicubic(double x)&#123; // bicubic 双三次插值基函数 int a = -1; // 默认取a为 - 1 double x1 = fabs(x); double x2 = x1*x1; double x3 = x1*x2; if (x1 &lt;= 1) &#123; return 1 - (a + 3)*x2 + (a + 2)*x3; &#125; else if (x1 &gt; 1 &amp;&amp; x1 &lt;= 2) &#123; return -4 * a + 8 * a*x1 - 5 * a*x2 + a*x3; &#125; else &#123; return 0; &#125;&#125;int main(int argc, char *argv[])&#123; cv::Mat img = cv::imread("../Data/lena_gray.jpg", 0); // 以灰度模式读取图片 int R = img.rows; // 获取原图像高度 int C = img.cols; // 获取原图像宽度 double theta = 45 * M_PI / 180.0; // 旋转角度 int H = ceil(fabs(R*cos(theta)) + fabs(C*sin(theta))); // 变换后图像的高度 int W = ceil(fabs(C*cos(theta)) + fabs(R*sin(theta))); // 变换后图像的宽度 cv::Mat res = cv::Mat::zeros(H, W, CV_8UC1); // 构造结果矩阵。每个像素点默认初始化为0（黑色） cv::Mat T1 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1, 0, 0, 0, -1, 0, -0.5*C, 0.5*R, 1); // 将原图像坐标映射到数学笛卡尔坐标 cv::Mat T2 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, 0, 0, 1); // 数学笛卡尔坐标下顺时针旋转的变换矩阵 double t3[3][3] = &#123; &#123; 1, 0, 0 &#125;, &#123; 0, -1, 0 &#125;, &#123; 0.5*W, 0.5*H, 1 &#125; &#125;; // 将数学笛卡尔坐标映射到旋转后的图像坐标 cv::Mat T3 = cv::Mat(3, 3, CV_64FC1, t3); cv::Mat T = T1*T2*T3; cv::Mat inv_T = T.inv(); // 求逆矩阵 //cv::Mat inv_T = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, -0.5*W*cos(theta) - 0.5*H*sin(theta) + 0.5*C, 0.5*W*sin(theta) - 0.5*H*cos(theta) + 0.5*R, 1); for (int y = 0; y &lt; H; y++) &#123; for (int x = 0; x &lt; W; x++) &#123; cv::Mat point = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; x, y, 1); cv::Mat original_coordinate = point * inv_T; // 矩阵乘法 double v = original_coordinate.at&lt;double&gt;(0, 0); // 原图像的横坐标，列，宽 double w = original_coordinate.at&lt;double&gt;(0, 1); // 原图像的纵坐标，行，高 // 变换后的位置判断是否越界 if (v &gt;= 0 &amp;&amp; w &gt;= 0 &amp;&amp; v &lt;= C - 1 &amp;&amp; w &lt;= R - 1) &#123; res.at&lt;uchar&gt;(y, x) = img.at&lt;uchar&gt;(round(w), round(v)); // 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） // ------------ - 双线性插值（bilinear interpolation）---------------- - int left = floor(v), right = ceil(v), top = floor(w), bottom = ceil(w); double dC = v - left; // 列偏差 double dR = w - top; // 行偏差 res.at&lt;uchar&gt;(y, x) = (1 - dC)*(1 - dR)*img.at&lt;uchar&gt;(top, left) + dC*(1 - dR)*img.at&lt;uchar&gt;(top, right) + (1 - dC)*dR*img.at&lt;uchar&gt;(bottom, left) + dC*dR*img.at&lt;uchar&gt;(bottom, right); // ------------ - 双三次插值（bicubic interpolation）------------------------ - if (left &gt;= 1 &amp;&amp; top &gt;= 1 &amp;&amp; left &lt;= (C - 3) &amp;&amp; top &lt;= (R - 3)) &#123; cv::Mat MA = (cv::Mat_&lt;double&gt;(1, 4) &lt;&lt; bicubic(1 + dC), bicubic(dC), bicubic(1 - dC), bicubic(2 - dC)); cv::Mat MB = img(cv::Rect(left - 1, top - 1, 4, 4)); // 提取当前相邻区域16个像素点做插值 MB.convertTo(MB, CV_64FC1); // 变换为浮点型数据 MB = MB.t(); // 求转置矩阵 cv::Mat MC = (cv::Mat_&lt;double&gt;(4, 1) &lt;&lt; bicubic(1 + dR), bicubic(dR), bicubic(1 - dR), bicubic(2 - dR)); cv::Mat result = MA*MB*MC; res.at&lt;uchar&gt;(y, x) = static_cast&lt;uchar&gt;(result.at&lt;double&gt;(0, 0)); &#125; &#125; &#125; &#125; cv::imshow("result", res); // 显示变换后图像 cv::waitKey(0); return 0;&#125; 以上 C++ 代码在 VS2013 下能完美运行，不管是用 OpenCV-2.4.11 还是 OpenCV-3.2.0。其实完全理解的话，不管用什么工具都能实现，只是看哪个工具方便一点而已，就这个而言，感觉 Matlab 要方便很多，Shaun 就不继续挖 Python 的坑了，毕竟如果要用 Python 实现其实还是用 OpenCV，只是用 OpenCV Python 版的接口而已。参考资料[１] 第4章 图像几何变换[２] 图像旋转原理及实现[３] 仿射变换（http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html）[４] 图像处理常用插值方法总结[５] Wikipedia Bilinear interpolation[６] 双线性插值算法的详细总结[７] Wikipedia Bicubic interpolation[８] 双三次插值(bicubic interpolation)原理及MATLAB源码实现[９] 图像缩放】双立方（三次）卷积插值（https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95）为啥不说前向映射呢？这是因为若原图像坐标 \((v,w)\) 通过前向映射方式得到变换后图像的坐标 \((x,y)\) ，而且这个坐标为小数的话，一般采用四舍五入的方式得到变换后图像对应的整数坐标 \((⌊x+0.5⌋,⌊y+0.5⌋)\)，令 \(f(⌊y+0.5⌋,⌊x+0.5⌋)=f(w,v)\) 。↩\(⌊x⌋\) 表示向下取整，称为 Floor，指的是小于或等于 \(x\) 的最大整数；\(⌈x⌉\) 表示向上取整，称为 Ceil，指的是大于或等于 \(x\) 的最小整数，\(eg：⌊5.6⌋ = 5，⌊-5.6⌋ = -6；⌈5.6⌉ = 6，⌈-5.6⌉ = -5。\)↩]]></content>
      <categories>
        <category>Study</category>
        <category>DigitalImageProcessing</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本人常用小工具安利]]></title>
    <url>posts/aef52be2.html</url>
    <content type="text"><![CDATA[前言 由于 Shaun 目前使用最多的是 Windows 系统，所以以下推荐的软件基本都是 Windows 下的软件，全凭 Shaun 主观感觉推荐，也算是个人备份吧。 首先推荐的自然是装机软件 ULTRAISO，下个绿色版就好，只有 1M 多一点 或者 Rufus 好像也不错。下载 Windows 镜像的地方推荐为：MSDN，I Tell You。接下来就是正式的软件推荐篇了：大众篇 首先推荐浏览器：首选的自然是 Chrome 和 Firefox，还有一个比较偏门的是 Tor Browser（如果在一些特殊时段，各种番（fang）茄（qiang）工具都失效的情况下，这个可以临时用用）。推荐完浏览器，自然也要玩浏览器，这里极为推荐的是脚本管理插件：Tampermonkey（支持多种浏览器），有 Tampermonkey 和没 Tampermonkey 是两种浏览体验，会用 Tampermonkey 和没用 Tampermonkey 的是两个世界的人（ᖗ乛◡乛ᖘ），Tampermonkey 是通过 Javascript 改变浏览器的，顺便推荐几个常用的脚本：1、护眼脚本；2、Super_preloaderPlus_one；3、解除百度云大文件下载限制（这个配合 IDM 食用效果最佳）；4、贴吧全能助手；5、破解VIP会员视频集合；6、Cat Mouse Translation；7、解除B站区域限制；8、bye-flash-hello-html5 | 再见flash 你好html5；９、网页限制解除(改)。再顺便说一下这两个浏览器中一些比较好用的插件和好看的主题吧。Firefox 最新版的插件 Shaun 目前还没发现几个好用的，但是 Adblock Plus 绝对是必须要装的，Firefox 的主题 Shaun 目前在用为 Blue space 2 ；而 Chrome 中好用的插件就有很多了，首先自然也是 Adblock Plus，有一个 AutoPagerize 插件可以替代 Super_preloaderPlus_one 脚本，还有一个 划词翻译 可以替换 Cat Mouse Translation 脚本，由于 Chrome 没有撤销关闭的标签按钮，只能通过快捷键 Crtl+Shift+T 操作，对于 Shaun 这种习惯用 Firefox 恢复按钮的人来说这很不人性化，所以只能使用 SimpleUndoClose 插件来代替了，当然番茄之所以推荐使用 Chrome 有很大一部分原因在于 Chrome 中有一代理神器 Proxy SwitchyOmega，好像也正在开发 Firefox 版的 Proxy SwitchyOmega，已经在 Firefox 测试版上使用了，Chrome 的主题 Shaun 目前在用的为 Blue Space Sunset Chrome Theme ，浏览器相关的东西就推荐到这里了，接下来推荐下载工具吧。附浏览器使用小技巧，有时点击链接不会新建标签页，只是在原标签页刷新，这不符合国人的使用习惯，这时可按住 Crtl 键再点击链接，这时会强制使用新标签页打开链接。 下载工具首推的自然是 IDM，全称是：Internet Download Manager；种子和磁力链接的下载工具推荐 μtorrent 或者 BitTorrent，好像还有一个 qBittorrent ；至于迅雷，勉强推荐个极速版吧，最后一版为 ThunderSpeed1.0.35.366。还有一款免费的下载工具 Free Download Manager 也还不错，可以一定程度上替代 IDM。 解压缩工具首推的是 Bandizip（ta家的图片浏览器 Honeyview 也还不错），其次 7-Zip，最后是 WinRAR（主要是最近版本的广告太恼火，好像 5.2 版本没广告），BTW：IDM 下载百度云的大文件可能会造成部分文件损坏，这时可能需要 WinRAR 的修复工具去修复受损的压缩文件（具体操作为用 WinRAR 打开损坏的压缩文件，选中菜单栏的“工具”==》“修复压缩文件”），才能解压出正常文件。※附：其实 WinRAR 官方也有无广告版的，只是下载链接被隐藏，这位大佬：武文隹山发现了，具体可参考：WinRAR官方不带弹窗广告的简体中文版，其隐藏的链接为：WinRAR5.4官方无广告简体中文版64位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exeWinRAR5.4官方无广告简体中文版32位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exeWinRAR5.5官方不带弹窗广告的简体中文版，具体链接为：WinRAR v5.50 简体中文官方版（试用版，注册后没有广告弹窗！）32位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/wrar550sc.exe64位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/winrar-x64-550sc.exe列位看官应该从下载链接中发现了其中的规律（๑乛◡乛๑）。 拼音输入法，Shaun 使用的是 搜狗拼音智慧版，搜狗拼音的皮肤 Shaun 选择 雨后莲色，不过有人说 Win10 自带的微软拼音也还行。 至于清理垃圾的可以用 Advanced SystemCare（ASC），也可以用 CCleaner ，至于 Win10 不需要装杀毒软件，国内的的什么 360 全家桶、百度全家桶、腾讯全家桶（诶，好像就差阿里全家桶了，什么时候阿里再来一个，就装个 BAT 全家桶 （๑乛◡乛๑））可以丢了 （(╯°□°）╯︵ ┻━┻）。 QQ 还是用 TIM 版吧。 播放器推荐的是 Potplayer。不过有一款解码工具叫 终极解码，可以充当播放器（很多人确实把它当播放器用，比如 Shaun （๑乛◡乛๑））。 音乐软件 Shaun 用 网易云音乐（等升到 10 级就把它卸了，只听本地音乐）。 PDF 阅读器还是推荐 Adobe Acrobat_DC，毕竟能和 Office 联合使用，有时 Word 转 PDF 需要加密就靠它了。 截图工具推荐 FastStone Capture（FSCapture），国人的 Snipaste 也非常不错。小众篇 远程控制工具当然推荐 TeamViewer。 文件管理相关强推 搜索工具 Everything 和文件资源管理器（即 Windows 快捷键「Win+E」打开的「我的电脑」）增强工具 Listary （有个开源实现的同类产品 Wox ，还有国产的 火萤酱 也很不错，而且功能更全且附带一些实用小工具），这两个工具有重叠的地方，如果硬要只装一个的话推荐后者。还有一个文件管理器增强工具 QTTabBar ，可以为文件管理器增加标签页，类似于浏览器标签页那种，当然还有其它一些功能。当然 Windows 下最强的文件管理器当属 Total Commander，只是学习成本略高。 快捷键程序快速启动工具 RunAny ，修改配置文件可以通过快捷键快速启动任意程序，以任意程序打开文件，该工具集成 Everything 和支持 AutoHotkey 热键格式。 Office Tabs 给 Microsoft Office 添加标签页界面，类似于浏览器标签页那种，以实现文档快速切换。再推荐一些程序员的工具吧。 首先当然是编辑器（可别和编译器搞混了），Shaun 就不加入 Vim 和 Emacs 的党争了，就直接推荐 VS Code吧（巨硬出品，必属精品（^_^））。 Windows 下的命令行没一个好用的，要真矮子里面挑高个的话，只能推荐 Git Bash 了，其实以前有个 Babun 也挺好用的，可惜早已停止更新。但是 Git Bash 有时输出中文会乱码，Windows 下真正的命令行神器是 Cmder，完整包直接集成 Git for Windows，也就是包含 Git Bash，mini 包只包含基本命令行工具，关于 Cmder 的一些设置和用法可参考 Win下必备神器之Cmder，解压之后为了方便通过右键菜单使用 Cmder，需要在配置好之后以管理员方式执行 Cmder.exe /REGISTER ALL 命令。 Markdown 编辑器推荐的是 Typora，不过现在还是 Beta 版，也还能使用，期待正式版，希望到时即使收费的话也能继续推出一个免费版。（推出正式版看看效果怎么样吧，如果真的很不错就去支持一下，如果改进不大的话我还是老老实实继续用 beta 版吧）。 在 VS 下写 C++ 自然少不了 Visual Assist X 这款插件，用 OpenCV 的自然少不了 ImageWatch（ VS2017版ImageWatch ）这款神器。 编程的字体 Shaun 目前在用是 Arial monospaced for SAP(优化版)（http://www.vimer.cn/archives/396.html/comment-page-1），背景颜色使用护眼色：R: 204，G: 232，B: 207。 代理工具：Shaun 使用的是 XX-Net 和 Lantern，非特殊情况还是很好用的，还有比较推荐的是 赛风。偏门篇 鼠标手势软件 WGestures，可以利用鼠标手势做一些前进后退，复制粘贴搜索等简单操作。 Tickeys，让打字发出音效。 Windows 系统优（mei）化工具 Dism++ ，桌面美化工具可以用雨滴桌面 Rainmeter，或软媒魔方绿色版（※注：软媒魔方一定要是绿色版），桌面美化工具需要占用一定的配置，配置不高的老电脑还是别用比较好。后记如果以后碰到更多有意思的小东西再和大家分享吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决无法打开某个网页问题]]></title>
    <url>posts/376168c6.html</url>
    <content type="text"><![CDATA[前言 Shaun 最近在某台 Win10 的电脑中打开网页 https://www.typora.io/ 时出现了问题，一直出现无法连接现象。问题篇Chrome 中出现：未连接到互联网请试试以下办法：检查网线、调制解调器和路由器重新连接到 Wi-Fi 网络运行 Windows 网络诊断DNS_PROBE_FINISHED_NO_INTERNETFirefox 中出现：我们无法连接至 www.typora.io 的服务器。 如果确定此网址正确，您可以尝试：过会儿再重试。检查您的网络连接是否正常。如果您部署有网络防火墙，请检查 Firefox 是否已被授权访问网络。手机和其它设备在同一网络下能正常连接，打开 host 文件也没发现域名被劫持的情况，挂代理也能连接上。解决方案篇Shaun 尝试过的方法：刷新 DNS 缓存：在命令行界面中输入 ipconfig /flushdns，无效；改 DNS 服务器：把电脑的 dns 修改为首选 8.8.8.8，备用 114.114.114.114，和将首选改成 8.8.4.4 均无效；Disable Path MTU discovery，具体操作方法为：单击“开始”，单击“运行”，键入 regedit，然后单击“确定”。在注册表中找到下面的项： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters找到EnablePMTUDiscovery，将其值改为 0，如果没找到，则在“编辑”菜单上，指向“新建”，然后单击“DWORD 值”，键入 EnablePMTUDiscovery，然后按 Enter，在“编辑”菜单上，单击“修改”，在“数值数据”框中，键入 0，然后单击“确定”。退出注册表编辑器，然后重新启动计算机。设置 MTU 值，将其调小，完美解决。具体操作方法为：以管理员身份运行命令提示符，在命令行界面输入 netsh interface ipv4 show subinterfaces，查看传入字节和传出字节的接口，修改对应接口的 MTU 的值，具体命令为：netsh interface ipv4 set subinterface &quot;对应接口名&quot; mtu=值 store=persistent，其中 对应接口名 和 值 需要替换成相应修改的东西。后记 将 MTU 值调小，可能会造成网速变慢，但 Shaun 又无法去改变其它的东西，既然不能改变其它，只能改变自己喽 ╮(╯﹏╰)╭。但 Shaun 这里觉得奇怪的是：别人的电脑设置默认 MTU 的值为 1500 也能访问啊，无奈 （╯‵□′）╯︵┴─┴。参考资料[1] 电脑上部分网页打不开，但是手机可以，如何解决？[2] mtu值怎样设置才网速最快]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5使用小结]]></title>
    <url>posts/5f54aa2c.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，PyQt5 版本为 pyqt5-5.9.1，OpenCV 版本为 opencv-python-3.3.0.10 和 opencv-contrib-python-3.3.0.10，TensorFlow 版本为 tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 本文是上一篇（TensorFlow Object Detection API使用小结）的后续，因为那个 project 还需要一个界面，所以 Shaun 使用 PyQt 做了这么个界面，其中借用 OpenCV 的图像数据显示。准备篇 首先使用 pip 安装所需库，由于上一篇已经安装了 tensorflow，所以本文其实只需要安装 pyqt5 和 opencv-python 就可以了，安装 pyqt5 指令为：pip install pyqt5，相关依赖关系解决办法在上一篇中已提到，这里不再赘述，然后再使用指令 pip install opencv-python 安装 opencv，这里 Shaun 发现在 python 中配置 OpenCV 简直不要太轻爽 O(∩_∩)O~~，就一个 pip 就解决了，哪有 C++ 那么麻烦，以后可能还会继续使用 python 版的 opencv，所以就顺便把它 python 版的扩展包也顺便一起装上，安装指令为：pip install opencv-contrib-python。至此所需环境库安装完毕。 ※注：相对于上文中使用 pip 在线安装的方式，还有另一种使用 pip 进行离线安装的方式，在 Unofficial Windows Binaries for Python Extension Packages上下载离线包，即 XXXXXX.whl 文件，文件名一般包含库名称和对应版本、python 版本以及是 64 位还是 32 位的等信息，这里以离线包 numpy-1.13+mkl 为例，首先下载适合自己的库版本，适合 Shaun 的当然是 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl（这适合 64 位的 python3.6 安装），将命令行目录切换至 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 文件所在目录，输入指令 pip install numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 即可离线安装 numpy-1.13+mkl 库。相比在线安装，这种离线安装更加灵活，而且能够安装一些在线安装无法安装的库，像上文中的 numpy-1.13+mkl 库只能采取离线安装的方式，在线安装只能安装不带 mkl 的 numpy 库。采用离线安装方式也可以直接安装带扩展包的 opencv-python库：opencv_python‑3.3.1+contrib‑cp36‑cp36m‑win_amd64.whl ，不需要像在线安装那样装两个库。实践篇 以前有用过 Qt 的基础，所以这次使用 PyQt5 感觉上手很快，毕竟这里面的语法有很多是相通的，再加上网上的资料也有很多，所以很快就做了个简陋的界面。不过直接用代码控制界面的布局确实很麻烦，每改下布局都要重新运行一下看看，而且启动时间还有点长 ╮(╯﹏╰）╭。网上有种说法是：可以先通过QtDesigner设计UI，然后通过Qt提供的命令行工具pyuic5将.ui文件转换成python代码，具体用法是：若ui文件名称为firstPyQt5.ui，则在命令行界面中输入指令：pyuic5 -o firstPyQt5.py firstPyQt5.ui，即可将firstPyQt5.ui文件转换成python代码文件firstPyQt5.py不过 Shaun 这里由于界面比较简陋，没有几个控件，所以就直接将其用 python 代码控制了，没去尝试这个命令行工具 pyuic5 了，下次有机会再尝试吧 ↖(^ω^)↗。 Shaun 做的这个小界面实现的功能是：1、可以选择已经训练好的模型来检测选定图片中的目标；2、可以播放选定的视频；3、还有打开摄像头，显示摄像头拍摄的视频。其中由于 Shaun 电脑无法实时检测目标，所以在视频和摄像头拍摄中就没有添加检测的代码，只有选择图片时才会执行检测功能，有需要的童靴可以自行添加(•̀ᴗ•́)。附完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import osimport sys from PyQt5.QtCore import * from PyQt5.QtWidgets import *from PyQt5.QtGui import * import numpy as npimport cv2import tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = './model/hand_model_faster_rcnn_resnet101.pb' # 选择模型文件 self.PATH_TO_LABELS = r'./model/hands_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() # 加载模型 self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) return imageclass DetectUI(QWidget): def __init__(self): super().__init__() self.initUI() self.detector = Detector() self.cap = cv2.VideoCapture() def initUI(self): self.timer = QTimer(self) # 初始化一个定时器 self.timer.timeout.connect(self.showFrame) # 计时结束调用showFrame()方法 self.show_pic_label = QLabel(self) self.show_pic_label.resize(640, 480) self.show_pic_label.move(10, 10) self.show_pic_label.setStyleSheet("border-width: 1px; border-style: solid; border-color: rgb(255, 170, 0);") self.show_filename_lineEdit = QLineEdit(self) self.show_filename_lineEdit.resize(200, 22) self.show_filename_lineEdit.move(10, 500) self.select_img_btn = QPushButton('Select File', self) self.select_img_btn.clicked.connect(self.selectImg) self.select_img_btn.resize(self.select_img_btn.sizeHint()) self.select_img_btn.move(218, 500) self.open_camera_btn = QPushButton('Open Camera', self) self.open_camera_btn.clicked.connect(self.openCamera) self.open_camera_btn.resize(self.open_camera_btn.sizeHint()) self.open_camera_btn.move(292, 500) self.select_model_btn = QPushButton('Select Model', self) self.select_model_btn.clicked.connect(self.selectModel) self.select_model_btn.resize(self.select_model_btn.sizeHint()) self.select_model_btn.move(366, 500) self.show_modelname_lineEdit = QLineEdit(self) self.show_modelname_lineEdit.setText('hand_model_faster_rcnn_resnet101.pb') self.show_modelname_lineEdit.resize(200, 22) self.show_modelname_lineEdit.move(450, 500) self.setGeometry(200, 100, 660, 530) self.setWindowTitle('Hand Detector') self.show() def showImg(self, src_img, qlabel): src_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2RGB) # src_img = self.detector.detect(src_img) # 检测目标 height, width, bytesPerComponent = src_img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(src_img.data, width, height, bytesPerLine, QImage.Format_RGB888) qlabel.setPixmap(QPixmap.fromImage(q_image).scaled(qlabel.width(), qlabel.height())) def showFrame(self): if(self.cap.isOpened()): ret, frame = self.cap.read() if ret: self.showImg(frame, self.show_pic_label) else: self.cap.release() self.timer.stop() # 停止计时器 def selectImg(self): if self.cap.isOpened(): self.cap.release() file_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "Image Files (*.jpg *.png *.bmp *.tif);;Video Files (*.avi *.mp4)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 # print(file_name,file_type) if file_type.find("Image") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) img = cv2.imread(file_name, cv2.IMREAD_COLOR) cv2.cvtColor(img, cv2.COLOR_BGR2RGB, img) img = self.detector.detect(img) # 检测目标 height, width, bytesPerComponent = img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888) self.show_pic_label.setPixmap(QPixmap.fromImage(q_image).scaled(self.show_pic_label.width(), self.show_pic_label.height())) if file_type.find("Video") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) self.cap.open(file_name) self.timer.start(30) # 设置时间隔30ms并启动 def openCamera(self): self.cap.open(0) # 默认打开0号摄像头 self.timer.start(30) # 设置时间隔30ms并启动 def selectModel(self): model_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "model Files (*.pb);;All Files (*)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 if model_name: self.show_modelname_lineEdit.setText(os.path.split(model_name)[1]) self.detector.PATH_TO_CKPT = model_name self.detector.detection_graph = self.detector._load_model() # 重新加载模型 if __name__ == '__main__': app = QApplication(sys.argv) dtcui = DetectUI() sys.exit(app.exec_())后记 初次使用 Python 做一个小东西，其语法确实简洁，不过对于 Shaun 这种习惯用 C++ 的人来说确实还有点不太习惯 (˘•ω•˘)。参考资料[1] 用PyQt5+Caffe+Opencv搭建一个人脸识别登录界面[2] PyQt5学习笔记09—-标准文件打开保存框QFileDialog[3] PyQt5教程——第一个程序（2）（http://www.cnblogs.com/archisama/tag/PyQt5/）[4] PyQt5应用与实践[5] PyQt5系列教程(二)利用QtDesigner设计UI界面（http://www.cnblogs.com/tkinter/tag/pyqt5/）[6] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Images[7] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Videos[8] python3.3 分割路径与文件名 小例]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>python</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Object Detection API使用小结]]></title>
    <url>posts/82d3b275.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，TensorFlow 版本为tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 很久没写过东西了，主要原因是最近研究生课程开始陆续结课，Shaun 也要忙于应付各种结课时的考试、论文、project 等一堆麻烦事。这不深度学习结课时需要做个 project，Shaun 也顺便将做这个 project 的过程记录下来。准备篇 该 project 主要利用 TensorFlow 中的 Object Detection API 进行训练和检测。在开始使用该 API 之前需要安装配置 Python 环境。 既然是 Python 首先需要 下载安装Python，安装完之后，为了顺利使用 pip 需要配置环境变量，在 Windows 系统环境变量中 Path 末尾添加：变量名变量值Path;C:\Users\admin\AppData\Local\Programs\Python\Python36\; C:\Users\admin\AppData\Local\Programs\Python\Python36\Scripts\其中 C:\Users\admin\AppData\Local\Programs\Python\Python36 为 python-3.6.2 默认安装目录。 然后为了方便使用命令行工具，下载安装git，安装方式一路默认即可。 接下来利用 pip 安装 TensorFlow，鼠标右键桌面空白处，点击“Git Bash Here”，打开 bash 命令行，输入 pip install tensorflow，其中一些依赖关系可能需要手动解决，手动解决的办法就是用 pip install 相关依赖库，这是 CPU 版的 TensorFlow，若要使用 GPU，则需要安装 GPU 版的 TensorFlow，安装命令为：pip install tensorflow-gpu，以同样方式解决依赖关系。由于 Shaun 电脑没 N 卡，所以没安装 GPU 版的 TensorFlow，所以如果想使用 GPU 版的 TensorFlow 请另行尝试。 然后安装 TensorFlow Object Detection API 依赖库，在命令行中输入：1234pip install pillowpip install lxmlpip install jupyterpip install matplotlib 因为 tensorflow 并没有默认自带 Object Detection API，所以该 API 需要自行下载，下载地址为：https://github.com/tensorflow/models ，下载之后解压，Shaun 解压目录为：D:\ProgramFiles\PythonLibs\tensorflow，解压完之后需要配置环境目录，在系统环境目录中添加：变量名变量值PYTHONPATHD:\ProgramFiles\PythonLibs\tensorflow\models; D:\ProgramFiles\PythonLibs\tensorflow\models\research; D:\ProgramFiles\PythonLibs\tensorflow\models\research\slim; 下载配置 Object Detection API 完之后需要安装 Protoc，进入 Protoc下载页，下载 protoc-3.4.0-win32.zip，解压之后将 bin 文件夹内的 protoc.exe 拷贝到 C:\windows\system32 目录下（用于将 protoc.exe 所在的目录配置到环境变量当中）,当然也可以在系统环境变量 Path 中添加该 bin 文件夹路径。 最后在命令行中切换目录至：D:\ProgramFiles\PythonLibs\tensorflow\models\research 文件夹，即 object_detection 文件夹所在目录，在命令行中输入：1protoc object_detection/protos/*.proto --python_out=.编译 object_detection/protos 文件夹下的 proto 文件，生成对应的 python 文件。 至此，Windows 下 TensorFlow中 的 Object Detection API 的使用配置全部完成，至于 Ubuntu 下的配置可参考其官方文档。 至于如何验证，可以在命令行中切换目录至 object_detection，输入：jupyter notebook，稍等一会，浏览器将自动打开 http://localhost:8888/tree jupyter 界面，点击 object_detection_tutorial.ipynb 文件，进入打开的新标签，点击“Cell”中的“Run All”，耐心等待几 ~ 十几分钟（因为它需要下载相应的模型），将会在浏览器下方显示检测结果。 截止本文完成前，该API公开的有以下几个模型：Model nameSpeed (ms)COCO mAP1Outputsssd_mobilenet_v1_coco3021Boxesssd_inception_v2_coco4224Boxesfaster_rcnn_inception_v2_coco5828Boxesfaster_rcnn_resnet50_coco8930Boxesfaster_rcnn_resnet50_lowproposals_coco64Boxesrfcn_resnet101_coco9230Boxesfaster_rcnn_resnet101_coco10632Boxesfaster_rcnn_resnet101_lowproposals_coco82Boxesfaster_rcnn_inception_resnet_v2_atrous_coco62037Boxesfaster_rcnn_inception_resnet_v2_atrous_lowproposals_coco241Boxesfaster_rcnn_nas183343Boxesfaster_rcnn_nas_lowproposals_coco540Boxes 根据上述模型可推知，利用该 API 可能只能训练 Faster-RCNN、R-FCN 和 SSD 三种算法的模型。接下来介绍如何使用该 API 来训练自己的模型进行物体检测。实践篇数据准备篇 既然要训练自己的模型，当然要准备相应的数据，而 TensorFlow 有其独特的输入数据格式 TFRecord，所以通常还要将自己的数据转换成 TFRecord 格式以输入 TensorFlow 中进行训练。以 datitran/raccoon_dataset 数据集为例，该作者在 Google image 上收集了 200 张 Raccoon 图片，用 LabelImg 对这些图片进行标记，并将标记以 PASCAL VOC 格式保存为 xml 文件。作者在文中也提到了另一个图片标记工具 FIAT (Fast Image Data Annotation Tool) 。保存为 PASCAL VOC 格式的 xml 文件之后，可以使用 object_detection 文件夹中的 create_pascal_tf_record.py 文件将数据转化为 TFRecord 格式，用法为：123./create_pascal_tf_record --data_dir=/home/user/VOCdevkit \ --year=VOC2012 \ --output_path=/home/user/pascal.record当然也可以使用 datitran 作者提供的 xml_to_csv.py 文件将 xml 文件先转化为 csv 文件，再利用 generate_tfrecord.py 文件将 csv 文件转化成 TFRecord 格式文件。 注意，使用 xml_to_csv.py 和 generate_tfrecord.py 其文件结构应该是这样的：.├── annotations├── generate_tfrecord.py├── images└── xml_to_csv.py2 directories, 2 files其中 images 文件夹存的是 jpg 图片，annotations 文件夹存的是 xml 标签文件。generate_tfrecord.py 文件中的：12345def class_text_to_int(row_label): if row_label == 'raccoon': return 1 else:None其中的 raccoon 注意要改成自己的类别标签。如此，数据的问题就解决了。训练篇 然后就是正式开始训练了，以 Faster-RCNN 算法为例。首先准备相应的数据，Shaun 准备的数据文件结构如下：TensorFlowObjectDetectionAPITest├── data│ ├── model.ckpt.data-00000-of-00001│ ├── model.ckpt.index│ ├── model.ckpt.meta│ ├── object_label_map.pbtxt│ ├── test.record│ └── train.record├── eval├── eval.py├── export_inference_graph.py├── faster_rcnn_resnet101_coco.config├── model├── train└── train.py4 directories, 10 files其中，TensorFlowObjectDetectionAPITest 为项目文件夹，该 project 在此文件夹下运行；data 文件夹中三个 model.ckpt 文件：model.ckpt.data-00000-of-00001、model.ckpt.index 和 model.ckpt.meta 来自 faster_rcnn_resnet101_coco 模型，用来初始化网络参数；object_label_map.pbtxt 文件内容如下：item { ​ id: 1 ​ name: ‘raccoon’ }将其中的 raccoon 改成自己的类别标签，如果有多个类别标签则可以参考 object_detection\data 文件夹中的 pascal_label_map.pbtxt 文件格式；test.record 和 train.record 是生成的 TFRecord 数据，分别为待输入的测试数据和训练数据；eval 文件夹为空文件夹用来输出测试结果；train 文件夹为空文件夹用来输出训练结果（包括checkpoint文件和最终的模型文件）；faster_rcnn_resnet101_coco.config 为配置文件，包括各种参数和输入输出数据的配置，其来自 object_detection\samples\configs 文件夹中 faster_rcnn_resnet101_coco.config 文件，在使用时需对其做如下修改：首先是 num_classes，这是待检测的类别数目，如果只要检测一种，则将其值改为 1；fine_tune_checkpoint: &quot;PATH_TO_BE_CONFIGURED/model.ckpt&quot;，将 PATH_TO_BE_CONFIGURED 改为 ./data；123456train_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_train.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot;&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_train.record 改为 ./data/train.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；123456789eval_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_val.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot; shuffle: false num_readers: 1 num_epochs: 1&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_val.record 改为 ./data/test.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；至于其它的参数可以选择默认，不对其进行修改；train.py 为训练代码，其来自 object_detection/ 文件夹中的 train.py，直接复制出来使用即可，具体用法为：1python train.py --logtostderr --train_dir=./train --pipeline_config_path=faster_rcnn_resnet101_coco.config其在运行过程中会在 train 文件夹生成一系列训练过程文件，比如 checkpoint、model.ckpt-{num}（{num} 代表训练过程保存的第几个网络模型，一般从 0 开始，包括 .index、.meta和 .data 三个文件）等文件。eval.py 为评估代码，其来自 object_detection/ 文件夹中的 eval.py，直接复制出来使用即可，具体用法为：1python eval.py --logtostderr --checkpoint_dir=./train --eval_dir=./eval --pipeline_config_path=./faster_rcnn_resnet101_coco.config其在运行过程中会在 eval 文件夹生成一系列评估文件，每个文件对应一个测试 image。export_inference_graph.py 为导出 pb 模型代码，其来自 object_detection/ 文件夹中的 export_inference_graph.py，直接复制出来使用即可，具体用法为：1python export_inference_graph.py --input_type image_tensor --pipeline_config_path ./faster_rcnn_resnet101_coco.config --trained_checkpoint_prefix ./train/model.ckpt-18298 --output_directory ./model其中 model.ckpt-18298 表示使用第 18298 次保存的网络模型导出 pb 模型文件，导出的模型文件保存在 model 文件夹，主要有一下几个文件：- graph.pbtxt- model.ckpt.data-00000-of-00001- model.ckpt.info- model.ckpt.meta- frozen_inference_graph.pb其中 frozen_inference_graph.pb 就是训练成功用来检测目标的模型。 TensorFlow 训练时可以随时查看训练过程，如损失函数的值下降曲线等，所用命令为：在命令行中切换目录至 project 运行目录，即 train.py 所在文件夹，Shaun 这里即 TensorFlowObjectDetectionAPITest 文件夹，输入：tensorboard --logdir=./，等待片刻，在浏览器地址栏输入：http://localhost:6006/，即可看到训练过程曲线。检测篇 检测结果使用 opencv 窗口显示（至于 python 中 opencv 的使用详见下一篇（PyQt5使用小结）），具体调用自己训练的模型进行检测的 Python 代码（该代码为 eli 大佬参考 object_detection 文件夹中的 object_detection_tutorial.ipynb（该文件可在 jupyter 中查看）改的）为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import cv2import numpy as npimport tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = r'./model/frozen_inference_graph.pb' # 选择模型 self.PATH_TO_LABELS = r'./data/object_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) cv2.namedWindow("detection", cv2.WINDOW_NORMAL) cv2.imshow("detection", image) cv2.waitKey(0)if __name__ == '__main__': image = cv2.imread('./test_img.jpg') # 选择待检测的图片 detector = Detector() detector.detect(image)后记 经过这次 TensorFlow 训练，感觉深度学习 真tm 吃硬件，费时间，也难怪神经网络理论出来几十年之后才火，当年的硬件根本无法支持这么大的计算量。附录最后附上 datitran 作者提供的 xml_to_csv.py 文件源码和 generate_tfrecord.py 文件源码：xml_to_csv.py 源码如下：1234567891011121314151617181920212223242526272829303132333435import osimport globimport pandas as pdimport xml.etree.ElementTree as ETdef xml_to_csv(path): xml_list = [] for xml_file in glob.glob(path + '/*.xml'): tree = ET.parse(xml_file) root = tree.getroot() for member in root.findall('object'): value = (root.find('filename').text, int(root.find('size')[0].text), int(root.find('size')[1].text), member[0].text, int(member[4][0].text), int(member[4][1].text), int(member[4][2].text), int(member[4][3].text) ) xml_list.append(value) column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax'] xml_df = pd.DataFrame(xml_list, columns=column_name) return xml_dfdef main(): image_path = os.path.join(os.getcwd(), 'annotations') xml_df = xml_to_csv(image_path) xml_df.to_csv('raccoon_labels.csv', index=None) print('Successfully converted xml to csv.')main()generate_tfrecord.py 文件源码 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798"""Usage: # From tensorflow/models/ # Create train data: python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=train.record # Create test data: python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=test.record"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_importimport osimport ioimport pandas as pdimport tensorflow as tffrom PIL import Imagefrom object_detection.utils import dataset_utilfrom collections import namedtuple, OrderedDictflags = tf.app.flagsflags.DEFINE_string('csv_input', '', 'Path to the CSV input')flags.DEFINE_string('output_path', '', 'Path to output TFRecord')FLAGS = flags.FLAGS# TO-DO replace this with label mapdef class_text_to_int(row_label): if row_label == 'raccoon': return 1 else: Nonedef split(df, group): data = namedtuple('data', ['filename', 'object']) gb = df.groupby(group) return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]def create_tf_example(group, path): with tf.gfile.GFile(os.path.join(path, '&#123;&#125;'.format(group.filename)), 'rb') as fid: encoded_jpg = fid.read() encoded_jpg_io = io.BytesIO(encoded_jpg) image = Image.open(encoded_jpg_io) width, height = image.size filename = group.filename.encode('utf8') image_format = b'jpg' xmins = [] xmaxs = [] ymins = [] ymaxs = [] classes_text = [] classes = [] for index, row in group.object.iterrows(): xmins.append(row['xmin'] / width) xmaxs.append(row['xmax'] / width) ymins.append(row['ymin'] / height) ymaxs.append(row['ymax'] / height) classes_text.append(row['class'].encode('utf8')) classes.append(class_text_to_int(row['class'])) tf_example = tf.train.Example(features=tf.train.Features(feature=&#123; 'image/height': dataset_util.int64_feature(height), 'image/width': dataset_util.int64_feature(width), 'image/filename': dataset_util.bytes_feature(filename), 'image/source_id': dataset_util.bytes_feature(filename), 'image/encoded': dataset_util.bytes_feature(encoded_jpg), 'image/format': dataset_util.bytes_feature(image_format), 'image/object/bbox/xmin': dataset_util.float_list_feature(xmins), 'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs), 'image/object/bbox/ymin': dataset_util.float_list_feature(ymins), 'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs), 'image/object/class/text': dataset_util.bytes_list_feature(classes_text), 'image/object/class/label': dataset_util.int64_list_feature(classes), &#125;)) return tf_exampledef main(_): writer = tf.python_io.TFRecordWriter(FLAGS.output_path) path = os.path.join(os.getcwd(), 'images') examples = pd.read_csv(FLAGS.csv_input) grouped = split(examples, 'filename') for group in grouped: tf_example = create_tf_example(group, path) writer.write(tf_example.SerializeToString()) writer.close() output_path = os.path.join(os.getcwd(), FLAGS.output_path) print('Successfully created the TFRecords: &#123;&#125;'.format(output_path))if __name__ == '__main__': tf.app.run()参考资料[1] 对于谷歌开源的TensorFlow Object Detection API视频物体识别系统实现教程[2] TensorFlow学习——Tensorflow Object Detection API（win10，CPU）[3] How to train your own Object Detector with TensorFlow’s Object Detector API[4] TensorFlow 之 物体检测（http://rensanning.iteye.com/category/374992）See MSCOCO evaluation protocol.↩]]></content>
      <categories>
        <category>Study</category>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中整型提升问题]]></title>
    <url>posts/2a3d46b0.html</url>
    <content type="text"><![CDATA[前言 今天有人问了 Shaun 一个移位的问题，就是下面这段 C 语言代码：12unsigned short a = 0xffff;printf("%#hx\n", a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4);你认为会输出什么结果？ ੧ಡ ⌣ ಡ੭解答篇 正确答案是：0xfff0。恐怕有一部分会像 Shaun 一样觉得答案就是 0xff0 才对，还像模像样的给出对应的说法：看 a 首先向左移四位，即去掉最左边的 f，右边补 4 个 0 变成这样 0xfff0；然后再向右移 8 位，a 将会变成这样 0x00ff；最后向左移四位，得到 0x0ff0，所以应该输出 0xff0。但是，正确答案终究是正确答案。之所以会输出正确答案，是因为这里面还有一个整型提升。所谓的整型提升就是：在一个表达式中，如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成unsigned int型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。 所以在 a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4 中，会先将 a 提升为 int 型，即 a 会变成 0x0000ffff，接着向左移四位，a 变成 0x000ffff0，再向右移 8 位，变成 0x00000fff，最后向左移 4 位，变成 0x0000fff0，最后为了输出，再做一个隐式的类型转换（由 int 转 unsigned short），得到 0xfff0，所以最后输出 0xfff0。后记 这个问题是一个刚入大学的童靴问 Shaun 的，刚问 Shaun 时 Shaun 还没反应过来，后来才想起有整型提升这么回事 o(╯□╰)o。btw，这位童靴主要是想去掉高 4 位和低 4 位只取中间 8 位的值，其实最简单的办法就是直接 a &amp; 0x0ff0，这样管它有没有整型提升，肯定能得到中间 8 位的值 (╯▽╰)。参考资料[1] C语言进阶：整型提升（http://blog.csdn.net/mishifangxiangdefeng/article/category/1058873）[2] 对 unsigned char 先左移 后右移 可以出现两种结果]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TXT数据转OpenCV中的Mat数据]]></title>
    <url>posts/dece8eba.html</url>
    <content type="text"><![CDATA[前言 本文是以前做的一个小东西的处理前奏，当时也记录过，现在把它翻出来重新看看。那个东西需要利用深度图，Shaun 当时还没拿到 Kinect，就在网上下了一些数据（http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm），该数据集包含了彩色图及对应的深度图，但是该数据集没有以图像形式存储深度值，而是用 txt 文本以行列形式存储真正的深度值（单位为 mm），所以并不能直观的看到深度图像，Shaun 需要把这些深度值从 txt 文本提取出来并把它以图像的形式呈现出来，由于需求比较特殊，网上没看到现成的解决的方案，所以 Shaun 只有用现成的轮子自己做一个了。思路篇 程序的基本思路是：先找到目录及子目录下的所有 txt 文件路径；再根据路径分别读取 txt 文件，按行读取之后再进行字符串分割提取其中的深度值；为了便于以图像形式显示，将深度值归一化至 0~255 存入 8 位单通道的 Mat 类型数据中，最后以 png 图像形式保存至各个目录。实现篇 因为当时还在用 opencv-2.4.11，所以本文所实现的代码是基于 opencv-2.4.11，不过应该只要在 opencv-2.0 版本及以上只要有 Mat 数据结构的都能用，毕竟 Shaun 只用到了 OpenCV 中的 Mat 数据结构。Talk is cheap, show you the code（代码很乱，估计也只用这么一次，所以就没怎么注意了 :-P）。具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;io.h&gt; #include &lt;direct.h&gt; #include &lt;fstream&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;// ******************************************************************// @refer to [C++文件读写操作（二）逐字符读取文本和逐行读取文本](http://blog.csdn.net/wangshihui512/article/details/8921924)// [字符串分割(C++)](http://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html)// [C++读取文件夹中所有的文件或者是特定后缀的文件](http://blog.csdn.net/adong76/article/details/39432467)// [C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用](http://blog.csdn.net/u012005313/article/details/50688257)// [Split a string in C++?](http://stackoverflow.com/questions/236129/split-a-string-in-c)// [Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取](http://blog.csdn.net/zouxy09/article/details/8151044)// [Depth Map Tutorial](http://www.pages.drexel.edu/~nk752/depthMapTut.html)// ******************************************************************// ----- 逐个字符读取文件 --------void testByChar() &#123; fstream testByCharFile; char c; testByCharFile.open("./test.txt",ios::in); while(!testByCharFile.eof()) &#123; testByCharFile&gt;&gt;c; cout&lt;&lt;c; &#125; testByCharFile.close(); &#125; // -------- 逐行读取文件 -------------------void testByLine() &#123; char buffer[256]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 256, '\n');//getline(char *,int,char) 表示该行字符达到256个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; &#125; outFile.close(); &#125; // ------- 分割字符串 --------------void splitString() &#123; char buffer[1280]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 1280, '\n');//getline(char *,int,char) 表示该行字符达到1280个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; const char *d = " ,*"; char *p; p = strtok(buffer, d); while(p) &#123; printf("%s\n", p); p=strtok(NULL, d); &#125; &#125; outFile.close(); &#125; // 获取文件夹下指定格式所有文件名void getAllFormatFiles( string path, string format, vector&lt;string&gt;&amp; files ) &#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string pathName; if((hFile = _findfirst(pathName.assign(path).append("/*." + format).c_str(),&amp;fileinfo)) != -1) &#123; do &#123; //如果是目录,迭代之 //如果不是,加入列表 if((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if(strcmp(fileinfo.name,".") != 0 &amp;&amp; strcmp(fileinfo.name,"..") != 0) &#123; //files.push_back(p.assign(path).append("/").append(fileinfo.name) ); getAllFormatFiles( pathName.assign(path).append("/").append(fileinfo.name), format, files); &#125; &#125; else &#123; files.push_back(pathName.assign(path).append("/").append(fileinfo.name) ); &#125; &#125;while(_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; // http://stackoverflow.com/questions/236129/split-a-string-in-c// ---- stackoverflow上大神的C++版本分割字符串 --------------------std::vector&lt;std::string&gt; split(const std::string&amp; text, const std::string&amp; delims)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = text.find_first_not_of(delims), end = 0; while((end = text.find_first_of(delims, start)) != std::string::npos) &#123; tokens.push_back(text.substr(start, end - start)); start = text.find_first_not_of(delims, end); &#125; if(start != std::string::npos) tokens.push_back(text.substr(start)); return tokens;&#125;// 创建文件夹及子文件夹void makeDir(const string &amp;path)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = 0, end = 0; while ((end = path.find('/', start)) != std::string::npos) &#123; if (end != start) &#123; tokens.push_back(path.substr(0, end)); &#125; start = end + 1; &#125; if (end != start) &#123; tokens.push_back(path); &#125; vector&lt;string&gt;::const_iterator itp = tokens.begin(); while (itp != tokens.end()) &#123; if (access(itp-&gt;c_str(), 0) == -1) // 判断文件夹是否存在 &#123; cout&lt;&lt;*itp&lt;&lt;" is not existing"&lt;&lt;endl; cout&lt;&lt;"now make it"&lt;&lt;endl; if (mkdir(itp-&gt;c_str()) == 0) // 不存在则创建，只能一级一级的创建 &#123; cout&lt;&lt;"make successfully"&lt;&lt;endl; &#125; &#125; cout &lt;&lt; *itp++ &lt;&lt;endl; &#125;&#125;// Txt文件转opencv Mat（txt文件中存的是以行列形式的深度值）cv::Mat Txt2DepthMat(const string &amp;txtname)&#123; cv::Mat result(480, 640, CV_8UC1, cv::Scalar(0)); char buffer[12800]; // 按行读取文件 fstream outFile; const char *d = ","; // 以,为分割点 char *p; // 分割出的子串 outFile.open(txtname, ios::in); for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) &#123; p = strtok(buffer, d); for (int j = 0; p &amp;&amp; j &lt; result.cols; j++) &#123; int realDepth = (atoi(p) &amp; 0xfff8) &gt;&gt; 3; //提取距离信息，高13位 int depth = (int)(256 * realDepth / 0x0fff); //因为提取的信息是距离信息，为了便于显示，这里归一化为0-255 result.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(depth); p = strtok(NULL, d); &#125; &#125; outFile.close(); return result;&#125;// 以颜色表示深度信息，越暖（红色）越近，越冷（蓝色）越远cv::Mat Depth2Color(const cv::Mat &amp;depth)&#123; cv::Mat result(depth.size(), CV_8UC3, cv::Scalar::all(0)); int tempDepth, depthRed, depthGreen, depthBlue; for (int i = 0; i &lt; result.rows; i++) &#123; for (int j = 0; j &lt; result.cols; j++) &#123; tempDepth = 255 - depth.at&lt;uchar&gt;(i, j); if(tempDepth &lt; 43) &#123; depthRed = tempDepth * 6; depthGreen = 0; depthBlue = tempDepth * 6; &#125; if(tempDepth &gt; 42 &amp;&amp; tempDepth &lt; 85) &#123; depthRed = 255 - (tempDepth - 43) * 6; depthGreen = 0; depthBlue = 255; &#125; if(tempDepth &gt; 84 &amp;&amp; tempDepth &lt; 128) &#123; depthRed = 0; depthGreen = (tempDepth - 85) * 6; depthBlue = 255; &#125; if(tempDepth &gt; 127 &amp;&amp; tempDepth &lt; 169) &#123; depthRed = 0; depthGreen = 255; depthBlue = 255 - (tempDepth - 128) * 6; &#125; if(tempDepth &gt; 168 &amp;&amp; tempDepth &lt; 212) &#123; depthRed = (tempDepth - 169) * 6; depthGreen = 255; depthBlue = 0; &#125; if(tempDepth &gt; 211 &amp;&amp; tempDepth &lt; 254) &#123; depthRed = 255; depthGreen = 255 - (tempDepth - 212) * 6; depthBlue = 0; &#125; if(tempDepth &gt; 253) &#123; depthRed = 255; depthGreen = 0; depthBlue = 0; &#125; if (tempDepth == 255) &#123; depthRed = 0; depthGreen = 0; depthBlue = 0; &#125; result.at&lt;Vec3b&gt;(i, j)[0] = depthBlue; result.at&lt;Vec3b&gt;(i, j)[1] = depthGreen; result.at&lt;Vec3b&gt;(i, j)[2] = depthRed; &#125; &#125; return result;&#125;int main(int argc, char *argv[])&#123; string filePath = "C:/Users/XXXXXX/Downloads/NTU-Microsoft-Kinect-HandGesture Dataset/Depth"; vector&lt;string&gt; files; //读取所有文件 string format = "*"; // 不知道为什么在我电脑读不了特定文件？ getAllFormatFiles(filePath, format, files); for (int i = 0; i &lt; files.size(); i++) &#123; cv::Mat tempMat = Txt2DepthMat(files[i]); files[i].replace(0, 66, "../data"); files[i].replace(files[i].find(".txt"), files[i].length() - 1, ".png"); cout&lt;&lt; files[i] &lt;&lt; endl; string tempString = files[i].substr(0, files[i].find_last_of("/")); makeDir(tempString); cv::imwrite(files[i], tempMat); &#125; cout &lt;&lt; "File Size: " &lt;&lt; files.size() &lt;&lt; endl; //cv::imshow("test", Depth2Color(Txt2DepthMat("./1.txt"))); cv::waitKey(0); return 0;&#125;2018-01-01 BTW：以上代码在 VS2010+Win7 下编译运行通过，在 VS2013+Win10 下 for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) 会报错，可能需要改成 for (int i = 0; outFile.getline(buffer, 12800, '\n') &amp;&amp; i &lt; result.rows; i++) ，即去掉后面的 != NULL。后记 正如前言所说，本文是以前记录过的，一些细节也快忘记，这次重写算是回顾一下吧，这段程序可能也确实只用这么一次，但其中用到了不少 C++ 处理字符串和读写文件等相关知识，而这些知识，在以后有极大的可能会再次用到，因此记录 ↖(^ω^)↗。参考资料[1] C++文件读写操作（二）逐字符读取文本和逐行读取文本（http://blog.csdn.net/shihui512/article/category/1397194）[2] 字符串分割(C++)（http://www.cnblogs.com/MikeZhang/category/345894.html）[3] C++读取文件夹中所有的文件或者是特定后缀的文件（http://blog.csdn.net/adong76/article/category/1632029）[4] C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用（http://blog.csdn.net/u012005313/article/category/5586103）[5] Split a string in C++?（http://stackoverflow.com/questions/236129/split-a-string-in-c）[6] Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取（http://blog.csdn.net/zouxy09/article/category/1273380）[7] Depth Map Tutorial（http://www.pages.drexel.edu/~nk752/depthMapTut.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中滑动条和鼠标事件响应操作的使用小结]]></title>
    <url>posts/e8b35736.html</url>
    <content type="text"><![CDATA[前言 既然在上一篇中提到了回调函数，Shaun 就干脆把 OpenCV 中较常使用的两个使用回调函数的函数使用方法也一并记录下来吧。说明篇OpenCV 中使用回调函数的两个函数为：鼠标事件响应操作函数：void cv::setMouseCallback(const string&amp; winname, MouseCallback onMouse, void* userdata = 0);参数浅解：const string&amp; winname：窗口名称，对名为winname的窗口执行鼠标事件响应操作；MouseCallback onMouse：鼠标响应事件回调函数，监听鼠标的点击，移动，松开，判断鼠标的操作类型并做出相应处理；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);参数浅解：int event：鼠标滑动（CV_EVENT_MOUSEMOVE）、左键单击（CV_EVENT_LBUTTONDOWN）、右键单击（CV_EVENT_RBUTTONDOWN ）等10种鼠标点击事件的int型代号；int x, int y：鼠标位于窗口的（x，y）坐标位置，窗口左上角默认为原点，向右为x正轴，向下为y正轴；int flags：鼠标左键拖拽（CV_EVENT_FLAG_LBUTTON）、右键拖拽（CV_EVENT_FLAG_RBUTTON）等6种鼠标拖拽事件的int型代号；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。创建滑动条函数：int cv::createTrackbar(const string&amp; trackbarname, const string&amp; winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0);参数浅解：const string&amp; trackbarname：创建的滑动条名称；const string&amp; winname：所在窗口名称，对名为winname的窗口添加滑动条；int* value：滑块的位置，其初始值对应滑块的初始位置；int count：滑块可达到的最大位置的值，滑块最小位置的值总为0；TrackbarCallback onChange：滑动条事件回调函数，当滑动条上位置改变的时，则执行该回调函数；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);参数浅解：int pos：滑动条的位置对应的值；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。※注：本文的函数说明采用的是 opencv-2.4.11 的函数声明，与 opencv-3.2.0 的函数声明区别在于 string 类型，opencv-3.2.0 采用的是其自己实现的一个 String 类。实例篇Show u the code，具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;// ---------------- 鼠标事件回调函数 ---------------------------------static cv::Mat src_img; // 原始图像全局变量static void mouseCallback(int event, int x, int y, int flags, void *)&#123; bool selected = false; static cv::Point left_top_vertex, right_down_vertex; // 左上角顶点和右下角顶点 // When the left mouse button is pressed, record its position and save it in corner1 if (event == CV_EVENT_LBUTTONDOWN) // 左键按下 &#123; left_top_vertex.x = x; left_top_vertex.y = y; std::cout &lt;&lt; "Corner 1 recorded at " &lt;&lt; left_top_vertex &lt;&lt; std::endl; &#125; // When the left mouse button is released, record its position and save it in corner2 if (event == cv::EVENT_LBUTTONUP) // 左键弹起 &#123; // Also check if user selection is bigger than 20 pixels (jut for fun!) if (abs(x - left_top_vertex.x) &gt; 10 &amp;&amp; abs(y - left_top_vertex.y) &gt; 10) &#123; right_down_vertex.x = x; right_down_vertex.y = y; std::cout &lt;&lt; "Corner 2 recorded at " &lt;&lt; right_down_vertex &lt;&lt; std::endl &lt;&lt; std::endl; selected = true; &#125; else &#123; std::cout &lt;&lt; "Please select a bigger region" &lt;&lt; std::endl; &#125; &#125; // Update the box showing the selected region as the user drags the mouse if (flags == CV_EVENT_FLAG_LBUTTON) // 左键拖拽 &#123; cv::Point pt; pt.x = x; pt.y = y; cv::Mat local_img = src_img.clone(); rectangle(local_img, left_top_vertex, pt, cv::Scalar(0, 0, 255)); imshow("Cropping app", local_img); &#125; // Define ROI and crop it out when both corners have been selected if (selected) &#123; cv::Rect box; box.width = abs(left_top_vertex.x - right_down_vertex.x); box.height = abs(left_top_vertex.y - right_down_vertex.y); box.x = cv::min(left_top_vertex.x, right_down_vertex.x); box.y = cv::min(left_top_vertex.y, right_down_vertex.y); // Make an image out of just the selected ROI and display it in a new window cv::Mat crop(src_img, box); cv::namedWindow("Crop"); imshow("Crop", crop); &#125;&#125;// ---------- 响应鼠标事件 ------------------------------------void setMouseCallbackTest()&#123; src_img = cv::imread("../data/lena.jpg", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("Cropping app"); imshow("Cropping app", src_img); // Set the mouse event callback function cv::setMouseCallback("Cropping app", mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// -------------- 滑动条回调函数 ------------------------static void thresholdCallback(int slider_value, void* gray)&#123; //static_cast&lt;&gt;用于安全转换指针 cv::Mat *tmp_gray = static_cast&lt;cv::Mat *&gt;(gray); cv::Mat tmp = *tmp_gray; cv::Mat dst; threshold(tmp, dst, slider_value, 255, CV_THRESH_BINARY); //显示效果图 cv::imshow("Trackbar Demo", dst);&#125;// ------------ 创建滑动条 ----------------------------------void createTrackbarTest()&#123; cv::Mat src_gray = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Trackbar Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_gray); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_gray); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// ------- 将两个函数在同一个窗口执行 ------------void callbackTest()&#123; src_img = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Callback Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_img); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_img); // 鼠标事件响应 cv::setMouseCallback(window_name, mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;int main(int argc, char *argv[])&#123; //setMouseCallbackTest(); //createTrackbarTest(); callbackTest(); while (char(cv::waitKey(30)) != 'q') &#123;&#125; return 0;&#125; 经 Shaun 测试，上面示例程序在 Win10 的 VS2013 中 opencv-2.4.11 和 opencv-3.2.0 下都能完美运行。后记 本来这两个函数都已经写（chao）好了，但为了更好的体现示例程序，又稍作了修改：添加鼠标左键拖拽事件及不使用全局变量等。参考资料[1] opencv2 使用鼠标绘制矩形并截取和保存矩形区域图像（http://www.cnblogs.com/lidabo/category/516776.html）[2] Opencv中添加进度条及回调函数（http://blog.csdn.net/weixin_35738542/article/category/6337413）[3] OpenCV2中滑动条（Trackbar）回调函数的小发现（http://blog.csdn.net/u014291399/article/category/3097955）[4] OpenCV GUI基本操作，回调函数，进度条，裁剪图像等（http://blog.csdn.net/wangyaninglm/article/category/1653815）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用回调函数计算函数运行时间]]></title>
    <url>posts/b6fb6109.html</url>
    <content type="text"><![CDATA[前言 曾有一段时间在写一个小程序，由于其对运行时间有要求，所以每写一段代码就要测试一下运行时间，如果超出就需要优化一下代码或换一种方法和算法。但是每次都需要插在某两个位置插两段代码感觉有点烦，也有点浪费时间，毕竟浪费时间就是浪费生命，本着保尔柯察金关于生命的言论，Shaun 不愿虚度年华，所以只得寻找一个方便简洁的方法计算运行时间（说了这么多，说到底其实就是懒吧 */ω\*）。后面就想到了回调函数，将想要计算运行时间的代码段放入一个函数中，并将其作为回调函数，用事先写好的计算时间函数调用它，从而方便计算该代码段的运行时间。正文Show u the code，具体 C++ 实现代码为：12345678910111213141516171819202122232425262728#include &lt;ctime&gt;#include &lt;cstdio&gt;#define _CALLED_ printf("The function %s", __FUNCTION__);// 使用回调函数计算一段代码执行时间void computeTotalTime(void(*processingCallback)() = 0)&#123; clock_t start_time = clock(); processingCallback(); clock_t end_time = clock(); printf(" takes: %fs.\n", (double)(end_time - start_time) / CLOCKS_PER_SEC);&#125;void test()&#123; for (int i = 0; i &lt; 1000; i++) &#123; printf("Hello World!\n"); &#125; _CALLED_;&#125;int main(int argc, char *argv[])&#123; computeTotalTime(test); return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 本来是想在网上找一个的，谁知道并没有找到，就只有自己动手实现一个了 ╮(╯_╰)╭。后面使用了一下该函数，发现好像并没有提高生产力 o(╯□╰)o，所以就没人放在网上？-_-!，不过确实从实现过程中学到了一些东西 ↖(^ω^)↗。参考资料[1] C/C++之回调函数（http://www.cnblogs.com/danshui/category/345046.html）[2] c/c++在windows下获取时间和计算时间差的几种方法总结（http://blog.csdn.net/coder_xia/article/category/837943）[3] (转)用宏获取函数名（http://www.cnblogs.com/steady/category/264974.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论如何科学的上网]]></title>
    <url>posts/df943c4f.html</url>
    <content type="text"><![CDATA[科学式上网推荐组合：Chrome，Proxy SwitchyOmega，Lantern 等代理工具。前言 所谓的科学式上网，懂的自然懂，Shaun 也就不做过多解释了。本来一直在用别人免费提供的 pac 代理，但最近可能别人关掉了，上不了 google 了，就只能另寻他路了。所谓的另寻他路也就是尝试云端框架网站站长 枂下 提供的另外几种科学式上网攻略。本文只是对 枂下 站长的攻略做一下试验记录，若想看原滋原味的攻略，还请移步 云端框架。科学的上网方法 尽量使用 Chrome 进行科学式上网，因为其有一个代理管理插件 Proxy SwitchyOmega，该插件称之为代理切换神器也不为过，网上大量的教程和配置文件也是基于该神器做的。使用 Proxy SwitchyOmega 需要进行配置，这对初学者有一定的难度，这里 Shaun 推荐直接使用站长 枂下 提供的配置文件，至于 SwitchyOmega 的配置文件可以去站长的 云端框架 网站上去下，也可以联系 Shaun 。至于代理工具请看下文，Shaun 目前也只尝试过使用以下几种工具。lantern 其实 Shaun 最先尝试的工具是 XX-NET，但是其配置起来稍显繁琐，而且在第一步的时候必须处在科学式上网环境，而 Lantern 就比较简单了，只要装上之后再稍微动动手脚就可以了，所以就把 lantern 写在第一位了。从站长 枂下 那下载【蓝】灯电脑破解版压缩包，不过 Shaun 觉得应该随便在哪里下载个原版 lantern-2.2.5 安装都可以，只要后续的破解方法一样即可。 具体破解方法为：主要是令 lantern 一直保持在 2.2.5 版本不变。但是一般来说 lantern 在安装之后会自动更新到最新版（Shaun 在两台电脑上都安装过 lantern，其中一台安装完之后打开 lantern 安装文件夹发现其已更新，而另一台却没有更新，这就有点玄学了 -_-!），至于判断 lantern 有没有更新的办法是：首先进入 lantern 的安装文件夹：C:\Users\XXX\AppData\Roaming\Lantern（将XXX改成自己的用户名），1、看 lantern.exe 文件的修改日期，如果还是 2016 年的，就说明其还没更新；2、显示隐藏文件，看有没有 .lantern.exe.old 文件，如果没有，则也还没更新。如果已经更新了，参考站长 枂下 的说法：删除lantern.exe文件，修改.lantern.exe.old为lantern.exe这样就又可以回退至 lantern-2.2.5 版。如果没更新的话就不用进行删除回退这一步，直接进行下一步。 下一步为修改 lantern-2.2.5.yaml 文件中的更新路径 updateserverurl，使 lantern 永远不再更新，一直维持在 2.2.5 版本不变。具体更改方式为：将其中的updateserverurl: https://update.getlantern.org修改为updateserverurl: https://pic.black1ce.com修改完之后保存退出。这里 Shaun 觉得可以随便将其修改成其它路径即可，毕竟只是让其不更新而已，这个路径应该除了更新就没有其它作用了，这纯属 Shaun 拙劣的猜测，有（ai）兴（gao）趣（shi）的童靴可以试试 :-P。 原本以为到这一步就完成了，但是 枂下 站长后来又补发了一步，就是上面几步只是让 lantern 不再更新，而 500M 流量之后限速的问题仍然存在（Shaun 目前还没超过 500M，所以不知道这个问题，但抱着有备无患的心态先把 枂下 站长的攻略记一下 O(∩_∩)O~），所以接下来才是上正菜，破解“限制500M流量”问题的具体方法为：当使用 lantern 流量超过 500M 时，打开 lantern 的安装目录，打开 lantern-2.2.5.yaml 文件，修改其中第九行的设备号，随意更换一个数字或者字母即可。按 枂下 站长的说法是 8 位随机字母数字大小写均可，只是为方便起见推荐只改动某位即可。eg：Shaun 目前第 9 行为：deviceid: Gu25Sfoz，一旦 500M 流量用完了，Shaun 就只需要将其修改为 deviceid: Gu25Sfoa 即可。到这一步 lantern 的破解算是基本完成了吧，如果 枂下 站长有新的更新且被 Shaun 看到的话再进行实验更新吧。XX-NET 该工具应该是 Shaun 尝试配置的首款代理工具，不得不说其配置和 lantern 相比实在是太复杂了，而且其中有一步还必须处在科学式网络环境中，Shaun 还是借助别人的 VPN 上的（当时还没用 lantern，所以没用其 500M 免费不限速的流量 ~o(&gt;_&lt;)o~）。Shaun 经过实测 XX-NET 无法在 Firefox 中用 google 搜索，一用 google 搜就会报错：您的连接并不安全www.google.com 的网站管理员未正确配置网站。为避免您的信息被窃，Firefox 没有与该网站建立连接。此网站采用了 HTTP 严格传输安全（HSTS）机制，要求 Firefox 只能与其建立安全连接。正因如此，您也不能将此证书加入例外列表。www.google.com 使用了无效的安全证书。 该证书因为其颁发者证书未知而不被信任。 该服务器可能未发送相应的中间证书。 可能需要导入一个额外的根证书。 错误代码: SEC_ERROR_UNKNOWN_ISSUERhttps://www.google.com/search?q=test&amp;ie=utf-8&amp;oe=utf-8对等端的证书颁发者不受认可。HTTP 严格传输安全（HSTS）：false HTTP 公钥钉扎：true证书链：—–BEGIN CERTIFICATE—– MIIDkzCCAnugAwIBAgIQSu4RvcIwnqiEQE6Z68FlaDANBgkqhkiG9w0BAQsFADBz MQswCQYDVQQGEwJDTjERMA8GA1UECAwISW50ZXJuZXQxDzANBgNVBAcMBkNlcm5l dDEQMA4GA1UECgwHR29BZ2VudDEVMBMGA1UECwwMR29BZ2VudCBSb290MRcwFQYD VQQDDA5Hb0FnZW50IFhYLU5ldDAeFw0xNzA5MTYxNDIzMjRaFw0yNzA5MTQxNDMz MjRaMHgxCzAJBgNVBAYTAkNOMREwDwYDVQQIDAhJbnRlcm5ldDEPMA0GA1UEBwwG Q2VybmV0MRcwFQYDVQQLDA5Hb0FnZW50IEJyYW5jaDEVMBMGA1UEAwwMKi5nb29n bGUuY29tMRUwEwYDVQQKDAwqLmdvb2dsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDL3K1OgwalKOJPtO4urpAiu+lioGNax/EIaYR1D2kH66AJ lpal0pYFhXF6MOYCUNfpZIqP5qAQs7JGuRmFdo7rWaLHZ+3S+TlIHdZkoLvyYBcX ENVBcLQvZ7IL7DDUZObK/R7OOKz82dEoITQnT+q/lecR9wQ7QNdNVNqn0xS0NPt7 bS76irMxkJcO2q7Lu4R56ImCox/G7dUEepjL0Po516l6fLKG3qi5org2z6ap0yl2 Etu8cRfqiqaqhO0HI1Twz+Rbp/8KUdUBgnNkjcod83HE+jJKxIUDmn18+l7J8sBi a0JvWSIYy2ccFXoR8L4lfvIa8PhTuMmpxyDkwDdPAgMBAAGjHjAcMBoGA1UdEQEB /wQQMA6CDCouZ29vZ2xlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEADiM6yWCaGNLn ggirjN0b34j5JmjgYYx3bRaKDe4We2emjlLsdskBo2ztkd/tPBfUa7DWExgFPvVq B2FeEf85Zj72kMmc2JikJBtPF1qK9fa4O1gST4VE0xIF99zGrgkDhGaYd1ocElWS qfBNQfzwsO+nl2OQf99ATMqMSCGacN7z+LJBLn65de+ODzYUkIHzhU5/xJMian3y fQzNFCAgK8OMf16excqRUcX8zfGPfvtAafDrdOYEXcGayLIvt4tGr8T+tii+MtCR O5hXK8/ABMLGI74zgLYloVFjJv21VsLrNCvvD43T5E3c+8d1MENozdEnsyzWkTkp knP4aEiLOQ== —–END CERTIFICATE—–Shaun 不知道为什么 (+﹏+)~。所以为了能正常使用科学式网络，还是老老实实的用 Chrome 吧，何况其还有 Switchyomega 神器，并且建议把 Chrome 设置为默认浏览器。具体配置流程如下： 从 枂下 站长那下载 XX-NET（Shaun 其实最先是直接在 GitHub 上下载最新的 XX-NET，但 Shaun 由于在 Firefox 上尝试失败了，当时也没在 Chrome 上尝试，以为最新版 XX-NET 有问题，后来用上 枂下 站长那下的 XX-NET 在 Chrome 上试了下可以，而 Firefox 不行，就知道可能是 Firefox 的问题，而既然已经能用了，Shaun 也没用最新的 XX-NET 在 Chrome 上尝试了），直接解压到某个文件夹，然后将 XX-Net-3.3.6 文件夹重命名为 XX-Net，即去掉末尾的版本号，据 枂下 站长说法是为了减少后续 XX-NET 出错（Shaun 这里老老实实的照 枂下 站长说的做了，所以也不知道如果没去掉版本号会有什么后果）。接着以管理员身份运行 XX-Net 目录下的 start.vbs 文件（这里右键是没有“以管理员身份运行”选项的，要想以管理员身份运行就只有使用 Windows 命令行了，具体做法就是以管理员身份运行“命令提示符”，再在其中运行 start.vbs 文件即可），运行成功后将弹出已经导入GoAgent证书,请重启浏览器.点击确定即可。再次启动默认（Chrome）浏览器，将打开 127.0.0.1:8085 页面，即为 XX-NET 的配置界面。将看到 GAEProxy 状态信息（可能是由于 google 取消了公共 APPID，所以 Shaun 看到的不是“您正在使用公共APPID，….”这条消息，而是另外一条消息（具体什么消息 Shaun 忘记了 o(╯□╰)o）），打开显示详细信息（其实也没用，Shaun 并看不懂这么多 -_-|||），先放这里吧，部分信息以后再说，先进入正式配置步骤。首先点击左边的“高级”选项，据枂下站长说，将自动调整扫描线程数关掉，最大扫描线程数设为 200，点击提交（可能这样连接速度更快一些）。Shaun 这里这里没有照做，而是保持默认设置，Shaun 只是要求能上就可以了，对速度要求可以稍微放松一点（或许以后会调成站长推荐的配置）。接下来点击“部署服务端”选项，填写 AppID，点击“开始部署”。但是这一步，Shaun 并没有 AppID，所以只能上 google 申请，这样最麻烦的一步就来了。照着 枂下 站长的指引，Shaun 一步步的申请了 AppID。具体申请步骤如下（这一步需要登录 google 账号，必须处于科学式网络环境）：点击 打开Appid申请页面，登录 google 账号，创建项目，并在新建项目中修改项目 ID（这就是第一个 AppID ），为方便，建议直接以“项目名-00”的方式按顺序命名 AppID，创建成功后继续点击“Google Cloud Platform”旁的一个小三角，点击弹框的“+”，按上述方式进行创建新的 AppID，如此重复，Shaun 总共创建 10 个 AppID，10 个之后会提示配额已用完，硬是要创建只会覆盖掉第一个 AppID。接下来就是需要选择语言和地区，只有为每个 AppID 选择语言和地区之后，该 AppID 才会生效。语言和地区的选择界面可以从“App Engine”界面中进入，也可以直接在添加 AppID 界面的那个弹框中点击相应的 AppID 进入，当然如果是第一个 AppID 选择语言可以直接点击界面上的“选择一种语言” 。语言选择 Python，地区选择亚洲（asia-northeast1），选错了后果自负（当然可以覆盖掉该 AppID 重新设置）。其实可以照 枂下 站长那样设置完第一个 AppID 的语言和地区之后直接修改浏览器的地址栏的 url 以快速设置 AppID 的语言和地区。具体修改方法为：将 url 地址末尾的 project 参数的值改为你想要设置的下一个 AppID，eg: Shaun 当前 AppID 为 test-00，对应的浏览器 url 地址末尾的参数为 lang=python&amp;project=test-00，Shaun 想设置的下一个 AppID 为 test-01，则只需将其修改为 lang=python&amp;project=test-01 回车即可快速设置 test-01 的语言和地区。如此重复，就可以设置完全部的 AppID 语言和地区。设置完之后，这些 AppID 就能进行部署了（据说每个 AppID 每天有 1G 的流量可以使用，并于每天下午三点更新，也就是 Shaun 每天有 10G 流量，一般是够用了 :-D）。将上文申请并设置完成的 AppID 放入“GAE AppID”文本框中，多个 AppID 可以按这样的格式放入：test-01|test-02|test-03，两个 AppID 以|分隔即可。点击“开始部署”，会弹出一个登录 google 账号的标签页，登录并允许即可，等待 2~5 分钟，可发现日志页面出现 Done!和Deploy 10 appid successed. 等字样即表示服务端部署成功。点击“部署”选项，将上面部署服务端的 AppID 以相同格式输入“GAE AppID”文本框中，点击“保存”即可。保存完之后，即可在状态信息界面显示详细信息中 Appid 发现当前工作 AppID 就是部署的 AppID ，至于那个配置下的监听代理就是设置代理的地址和端口。这样 XX-NET 就算是配置完成了，至于 枂下 站长说的扫描 ip，Shaun 就没做实验了，因为这样配置完就可以科学式上网了。 以上代理工具配置完成后，即可在 Chrome 中畅游 Internet 了，但是正确的科学式上网姿势应该是：国内的网站走本地连接，而国外被屏蔽的网站才走代理。这就需要 Proxy SwitchyOmega 这款插件了，它能按照一定的规则自动选择走本地还是走代理，这样既不会浪费流量，也能使国内的网站联网速度不受影响。导入前文推荐的配置文件后，就可选择对应的代理方式。这里当然是选择自动切换，至于虚拟切换是选择 Lantern for 8787 还是 XXNET for GAE 就随便个人的喜好了（在走代理的时候别忘了把相应的代理工具开启）；如果直接选择其中一种代理方式就相当于全局代理，这也就失去这款插件的作用，只有自动切换加上虚拟切换才能充分发挥这款神器的真正作用。匿名网络 要想使用匿名网络，当然少不了专用的浏览器：Tor Browser，下载并安装（下载时需要身处科学式网络环境，安装时最好改变一下目录，而且路径中最好不要有中文）。接下来就是配置了 Tor 网络了。具体配置流程如下： 首先，它问直接连接 Tor 网络还是配置网桥或代理，这里当然是选择配置；其次它问互联网服务提供商( ISP )是否对 Tor 网络连接进行了封锁或审查，这里选否，据枂下站长所说因为国内网桥大部分已失效，连接网桥没有意义还会拖慢速度；然后它问是否本地代理访问互联网，这里当然选择是；最后填写本地代理配置，这里需要注意，枂下站长提供的部分代理配置是：SSR/SS Socks5//127.0.0.1 : 1080Seed HTTP//127.0.0.1 : 1080Lantern Socks5//127.0.0.1 : 8287（2系列），三系列的在Lantern设置页面查看Psiphon 可以在配置页面自定义 其中经 Shaun 实测，上面 Lantern 的代理配置是连接不上的，Shaun 后来参考 SwitchyOmega 配置文件中 Lantern 的代理为 HTTP//127.0.0.1 : 8787，经尝试如此配置可以连接 Tor 网络，所以 Lantern 的正确配置应为：Lantern HTTP//127.0.0.1 : 8787（2系列），三系列的在Lantern设置页面查看设置完成后等待片刻就能连上 Tor 网络了，最好就保持原来的 DuckDuckGo 搜索引擎，不要更改，接下来就可随心所欲的畅游 Internet 了。 至于想访问暗网，可以参考Hacking/整理的暗网网址Tor.txt和Working Links to the Deep Web或者直接用站长枂下给的网址：torlinkbgs6aabns.onion和xmh57jrzrnw6insl.onion。据枂下站长回答：XX-Net可以作tor的前置代理吗？不行的，xx-net是假http协议所以 XX-NET 不能用作 Tor 的代理配置。 最后再简要记录一下 Chrome 调用 Tor Browser 的代理吧。Shaun 没有像 枂下 站长那样用命令行去实验，只是享受了一下 ta 的试验成果（O(∩_∩)O谢谢）。总而言之，还是利用 SwitchyOmega，代理方式选择 Tor for 9150，就可以在 Chrome 中调用 Tor Browser 的代理，畅游 Internet 了。更新于：2017-11-27 时久达期间及之后，lantern 的那种破解方式从时灵时不灵，到完全失效，而 XX-NET 则一开始就失效了，这见证了 Google 和 GFW 的斗智斗勇（๑乛◡乛๑），但很明显，google 失败了，事实证明没有 GFW 封不了的，只是看它想不想封 (๑•ั็ω•็ั๑)。至于 lantern 和 XX-Net 的复活方式请移步 枂下 站长的网站，Shaun 这里就不再赘述了。这里需要更新的一点是：Tor 的网桥配置采用“meet-amazon”（亚马逊的云计算平台）或者“meet-azure”（微软的云计算平台）传输也能实现科学式上网，但速度很慢，仅能浏览网页而已，可以当做备选临时用用。更新于 2017-12-24：今天使用了下 赛风（Psiphon），其操作完全傻瓜式，简直不要太好用，而且为单个绿色文件，携带也方便，用的时候只要设置一下端口就行。不出意外的话，妈妈再也不用担心 Shaun 搞科研了（؏؏☝ᖗ乛◡乛ᖘ☝؏؏）。更新于 2018-03-14：现在最新版的 Firefox 59.0 也有 Proxy SwitchyOmega 插件了，虽然还是测试版，但还是能够正常使用，既然 Firefox 有了这款神器，Shaun 也就有动力将 Firefox 使用 XX-Net 连接 Google 搜索出现的问题解决了，首先进入 Firefox 的 「选项」或设置 ==》「隐私安全」，下滑到最下面的「证书」，点击「查看证书」，在弹框中选中「证书机构」，点击「导入」，添加 XX-Net\data\gae_proxy目录下的 CA.crt 证书，在导入中出现的弹框全部选中信任，将会在上方的证书栏中出现 GoAgent XX-Net 证书，这样就能解决上文出现的问题，参考自：【已解决】Firefox报错：github.com 使用了无效的安全证书。 证书因为未提供证书发行链信而不被信任。 （错误码： sec_error_unknown_issuer）后记 最后的匿名网络是 Shaun 弄着好玩的，像暗网这种东西 Shaun 这种遵纪守法的好公民才不会访问呢 (ಡωಡ)。等以后时机到了再去买个国外 VPS 自己搭建一个科学式上网环境吧。最后感谢 枂下 站长的无私分享。附录 原本还以为 Shaun 搭建的 Hexo+GitHub 个人博客站点还是个深网，没想到搞完科学式上网后用 google 搜索竟然能搜到，虽然 Shaun 没做什么，但 google 仍然能搜到，google 的蜘蛛还挺厉害的，不过如果百度的蜘蛛没被 GitHub 屏蔽的话百度可能也能搜到（从某些原因上来说，GitHub 把百度屏蔽掉也好 O(∩_∩)O~）。既然已经被 google 收录了，Shaun 也就不去搞那个站点地图了，等以后想搞 SEO 了再去做吧。参考资料[1] Switchyomega超详细教程之Chrome与Firefox版本[2] 【蓝】灯电脑破解版之2系列禁止自动升级最终办法[3] XX-NET史上最详细完整教程[4] XX-NET史上最详细完整教程之第一部分：Appid创建部分[5] Tor Browser在国内Windows平台下的超详细教程[6] Chrome等其他程序如何完美调用Tor Browser的代理来上网[7] “如何翻墙”系列：TOR 已复活——meek 流量混淆插件的安装、优化、原理（https://program-think.blogspot.com/search/label/IT）[8] 如何翻墙？——写在 BlogSpot 被封之后 {2015-08-28}]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>gfw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的SPFK主题修改小记]]></title>
    <url>posts/b1e9411b.html</url>
    <content type="text"><![CDATA[前言 Shaun 一直在对 Hexo 的 SPFK 主题进行持续修改以符合 Shaun 自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。修改篇1、修改 aboutme 排版问题修改日期：2017-09-16需求描述：Shaun 为了使 aboutme 排版好看一点，使“关于我”的内容更有段落感，Shaun 尝试在主题配置文件中 aboutme 对象的内容添加各种换行转义符号均于事无补，如 \n、\r\n、&amp;#13;、&amp;#10;、&lt;br /&gt; 等，站点不仅不会换行，还会直接将转义符号都显示出来 (╯﹏╰）。解决办法：既然 Shaun 基本把所有的换行方法都试过了，还没有任何作用，那就只能是问题出在其它地方了。Shaun 首先找到显示 aboutme 内容的地方，其位于主题文件夹下 \layout\_partial\left-col.ejs，显示 aboutme 内容的代码为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%=theme.aboutme%&gt;&lt;/div&gt;，查阅相关资料，具体为 与大家分享ejs源码阅读心得，其中有这样一段话：关于ejs模板的五种模式对应几种指令ejs主要提供了如下几种指令:&lt;%, 该指令主要通过js中的eval来执行js代码, 如上模板代码&lt;% [1,2].forEach(function(v){ %&gt;将通过eval编译成; [1,2].forEach(function(v){即直接可执行的js代码, 并且不会存放到__output函数中输出.&lt;%=, 该指令主要用于输出变量内容, 如上模板代码&lt;%= v %&gt;将通过escape函数编译成__append(escape(v)), 可以看到该指令用于输出变量内容, 最后将通过__output输出内容.&lt;%-, 该指令与&lt;%=区别是, &lt;%=指令使用escape函数来对特殊字符进行编码, 如将&gt;转为%3E, 查看关于escape函数.&lt;%#, 该指令主要用于模板内注释, 既不会执行也不会输出.&lt;%%, 主要用于输出字面值%.关于以上各个指令对应的解析, 可参考ejs源码根目录lib/ejs.js文件中的scanLine函数.从中可得知 &lt;%= 指令会将变量内容中一些特殊字符先转义，再原封不动的输出，所以 Shaun 无论怎么修改主题配置文件中 aboutme 对象的值，其输出内容都会是原封不动的 aboutme 对象的值。为了让其输出内容可以有相应的特殊格式，就不能让其转义，只能用 &lt;%- 指令，将其修改为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%-theme.aboutme%&gt;&lt;/div&gt;，这样就能使输出内容可以自定义特殊格式，Shaun 最后在 aboutme 对象的内容中需要换行的地方添加了 &lt;br /&gt;，实测如此修改后可以换行。2、给左栏添加滚动条修改日期：2017-09-18需求描述：SPFK 主题是双栏的主题。因为左栏主要是用来显示一些菜单和头像等内容，这些内容也不多，所以原作者就没有添加滚动条。但是由于 Shaun 添加了个本地搜索功能，在刚开始文章少的时候还不受影响，但是随着文章的增多，搜索功能就会影响左栏的布局，这是就必须添加一个滚动条了。本以为添加滚动条很简单，就是添加一个 overflow: auto;，谁知道还没这么简单 ╮(╯﹏╰）╭。解决办法：Shaun 对问题的定位没问题，就是修改主题文件夹下的 \source\css\_partial\main.styl 文件中 .left-col 样式，问题在于怎么修改，本想直接在其中加入 overflow: auto;，按道理说问题就能解决的，但是 Shaun 去搜索试试，发现搜索框上方的头像，文字等全部消失了，滚动条没起到作用，而下方的菜单可以通过滚动条看到。于是 Shaun 觉得可能是 div 上界没撑开，而超出的地方却隐藏了，但下界为什么能撑开，Shaun 这里还是很不明白 ?_?。既然是这里隐藏了，Shaun 就去看相关标签有没有 overflow: hidden; 属性，谁知道要么是没有，要么是即是关闭了也没有作用，那问题应该不是出在这里。就只能是这些元素所在的子 div 里了，Shaun 找到其子 div 属性 .intrude-less，其中虽有 overflow: auto; 但没设置 height 属性，所以就不能发挥其作用，Shaun 于是给它加上 height 属性，搜索后发现有两个滚动条，这显然不简约，于是 Shaun 把 .intrude-less 的 overflow: auto; 属性注释掉，没想到居然能完美解决问题，可能是因为加上高度属性之后就能撑大父元素 div 了吧（来自某业余前端的猜测 (⊙_⊙)）。后面为了更美观，Shaun 把下方菜单区域的 div 样式 .switch-area 高度 min-height 改小了一点，顺便也把主题文件夹下的 \layout\_partial\left-col.ejs 文件中首行注释掉 &lt;!-- &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; --&gt; 。Shaun 也曾想把 height 改为 min-height，谁知道又出现相同的问题，不得不又改回去。虽然这次已经解决了问题，但有些细节问题还是不太明白，只有等以后前端水平上去了再去想了，如有大佬知道还望不吝赐教 (^人^)。3、更换鼠标指针修改日期：2017-9-26 ~ 2017-9-27需求描述：Shaun 在玩《Ori and the Blind Forest》这款游戏的时候觉得其鼠标指针很酷炫，于是想把其鼠标指针放在 Shaun 的博客站点中 (๑´ڡ`๑) 。解决办法：要想更改指针，首先需要找到对应的指针文件，最终在万能的贴吧得到指引，在 RealWorld Graphics 上找到两个 ori指针 文件，一个是 动态的 ani指针文件，还有一个是 静态的 cur指针文件（好像该游戏的作者也在 steam 上的评论中提供了游戏中的指针文件，详见：I wanna use this games cursor. ）。既然已经找到了指针文件，就可以开始更换炫酷的鼠标指针 (•̀ᴗ•́)。具体更改方法如下：将下好的指针文件放在主题文件下的 \source\img 文件夹中，在主题配置文件中添加 cursor 属性：12345# set cursor | 设置鼠标指针图标cursor: on: true cursor_0: img/cursor.ani # 首选指针 cursor_1: img/cursor.cur # 备选指针其中 cursor_0 和 cursor_1 代表使用哪个指针，因为 firefox 和 chrome 不支持 ani文件 的指针（好像是 ani 文件有很大的漏洞），所以 ani 动态指针是用不了的，只能用 cur 格式的静态指针，而 IE 是可以加载 ani 格式的动态指针，所以 Shaun 这里就将两个指针文件全放上去了，首选加载动态指针；最后增加相应的代码调用 cursor 属性，加载指针文件，在主题文件夹下 /layout/_partial/background.ejs 文件末尾添加：12345678&lt;% if (theme.cursor.on)&#123; %&gt; &lt;style&gt; body&#123; background: #3f3f3f; cursor: url(&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_0 %&gt;), url(&quot;&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_1 %&gt;&quot;), auto; &#125; &lt;/style&gt;&lt;% &#125; %&gt;如此更新站点之后即可使用新鼠标指针样式，可能需要先进行 hexo clean 再发布。BTW：这次修改是一个月之前的了，当时不知怎么的忘记记录了，还好 Shaun 的 git 提交记录比较详细，对应的提交记录为：add a function – change cursor和update set cursor function 。4、修改打赏问题修改日期：2017-10-13问题描述：Shaun 突然想玩一下那个打赏小东西，但照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性，没有任何作用，于是去主题文件夹搜索 reward 属性相应的代码，结果是“找不到结果”（坑爹了这是，摔！（╯‵□′）╯︵┴─┴ ）。解决办法：既然 reward 属性找不到就只有搜索 reward_type 属性，最终在主题文件夹下 \spfk_c\layout\_partial\article.ejs 文件中找到这样一条语句 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index){ %&gt;，其下面就是打赏相关的代码，查看 SPFK 主题原作者介绍信息（Hexo 主题：SPFK）发现 toc 属性是用来显示目录的（一个用来打赏的代码怎么与文章目录相关了 -_-#），所以上面的 toc 应该改成 reward，修改后的代码为 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;，这时照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性就能在相应的文章后面看到一个大大的“赏”字。本来写到这里应该打赏这玩意应该完结了，但 Shaun 无意中在该文件的下面发现这样一段代码：123&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; &lt;%- partial(&apos;_partial/toc&apos;) %&gt;&lt;% &#125; %&gt;这是和 toc（即文章目录）真正相关的代码，功能大概就是判断是否加载文章目录相关的代码，如果在文章开头设置 toc: false，则该文章不会显示目录，但是如果在文章中不加 toc 属性，也会显示文章目录，但上面的打赏却不会显示，看起来 post.toc != false 和 post.toc 应该逻辑差不多，这里是 Shaun 感到十分奇怪的一个地方？后面查阅相关资料（JavaScript undefined 属性）得知:注释：null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。而本文这里因为没有在文章开头设置 toc 属性，所以其为 undefined，其既不为 false 也不为 true，只为 undefined，当在 if 语句中做判断，会执行 else 分支，作 ! 运算，结果则为：true。所以 if(post.toc) 不能执行其下代码，因为 post.toc 为undefined，不为 true 也不为 false，而 if(post.toc != false) 能执行其下代码，因为 post.toc != false 为真。至于 javascript 中 if(a == ture) 和 if(a) 的区别具体为：前一种是 a 必须为 1 或者 true 才执行；而后一种只要 a 不为 false undefined null 0 -0 NaN &quot;&quot; 这 7 个字符中的其中任何一个都能执行。5、交换内容栏和左侧栏位置修改日期：2017-11-22 ~ 2017-11-23需求描述：Shaun 最近逛网站时发现，好像一些博客网站基本都是把内容放在左侧，百度和 google 的搜索结果也是在左侧，可能是内容在左侧要好一点吧，于是 Shaun 略微修改之后，将内容放在左侧，而原来的左侧栏放到最右侧，好像是顺眼了一点（不排除是心理作用 (ಡωಡ)），如果以后还觉得不错的话，再把相关的变量名换掉吧（此次修改仅仅是将 CSS 相关的值改变，div 类名没变）。解决办法：首先当然是定位左侧栏 .left-col，它在主题文件夹下 source/css/_partial/main.styl 文件中，为其添加 right: 0px; 属性，使左侧栏靠右侧停放；在定位内容栏 .mid-col ，将 right:0; 改成 left:0;，将 left: 300px; 改成 right: left-col-width;，使内容栏靠左侧停放，同时使其距离右侧有左侧栏的宽度。最后就是再修改其他一些小东西（比如目录按钮和目录内容 div 等）的 css 值，关于这个 Shaun 就不细述了，反正也就是更改 left、right、bottom 以及 top 属性及其值，具体修改了哪些内容可以见 Shaun github 提交记录。BTW：诶呀呀！昨天忘记测试手机端，今天用手机打开一看，手机端页面也距右边 left-col-width 宽度，这使得内容全挤在一起了，完全没法看 ರ_ರ …。所以不得不添加手机端样式，定位手机端 .mid-col，它在主题文件夹下 /source/css/_partial/mobile.styl 文件中，为其添加 right: 0; 属性值；后面看见回到顶部、回到底部的导航栏也有点问题，就在该文件中 /*导航*/ 下面 .scroll 上面添加：123#scroll&#123; right: 0;&#125;使得该导航栏靠右停靠。6、更新站点部分 CSS 文件和代码结构修改日期：2017-12-04 ~ 2017-12-06更新日志：Shaun 将 left-col 相关的东西（比如 css 样式和 ejs 文件）全部重名为 right-col，毕竟经过几天的适应，感觉放在右侧还不错，就干脆也将其重命名算了，所以原左侧栏 left-col 从现在开始就完全变成右侧栏 right-col 了；原来的本地搜索框有两个 .search 样式，本次修改将两个 .search 样式合并了，删除重复的样式，只留下一个合并后的 .search 样式；Shaun 同时还优化了一下本地搜索功能的结构，将原来主题配置文件中的 search_box 属性删掉，给 search 属性添加一个 on 的属性来代替 search_box 属性，这样让结构不那么混乱，只由一个 search 属性决定本地搜索功能的开启和关闭及功能的实现，而不是像以前那样由 search_box 属性决定右侧栏搜索框的显示，而 search 属性决定本地搜索功能的实现；更改右侧栏 right-col 的 overflow 样式，原来是右侧栏 right-col 垂直超出滚动，水平超出隐藏，这样在屏幕比较窄的情况在右侧会出现两条滚动条，很不美观。现在 Shaun 将 overflow 样式改成 &amp;:hover {overflow-y: auto; overflow-x: hidden;} ，这样只有在鼠标指针悬浮在右侧栏 right-col 上时才会再右侧栏出现滚动条，这样虽然不能从根本上解决问题，但稍微缓解了一下，等以后再看能不能彻底解决滚动条的问题 ರ_ರ …；Shaun 以前添加 RevolverMaps 这个小部件的时候只是简单粗暴的添加 div 及对应的样式，完全没考虑到主题的扩展性和易修改性。于是 Shaun 将其改成配置文件的形式，在主题配置文件中添加 visual_visitor 属性，只要将其值设置为 RevolverMaps官网 获取的那串 script code，eg：&lt;script type=&quot;text/javascript&quot; src=&quot;//ra.revolvermaps.com/0/0/8.js?i=0lpycb5p234&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt;，即可在右侧栏菜单下的访问情况中看到一个 3D 地球实时显示访客的位置信息，Shaun 为了优化异步访问信息，将其中的 async=&quot;async&quot; 改成 defer=&quot;defer&quot;，这样好像能优化加载次序。这两者的区别可参考 defer和async的区别，好像是都能异步加载，只是 async 是该 script 加载完立即执行，而 defer 是该 script 加载完之后在整个页面结束加载之前执行，也就是最后执行的；最后还修改了 MathJax 的 CDN 地址及配置属性。MathJax 的配置属性可参考 加载和配置MathJax，具体如下：第一种配置Mahtjax的方法就是使用配置文件。MathJax附带了很多种预制配置文件。它们存储在MathJax/config 目录。主要有其中以下几个：default.js：这个文件包含了所有MathJax可用的配置选项，并附有注释和说明，你可以编辑它们来满足你的需要。TeX-AMS-MML_HTMLorMML.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS_HTML.js：允许使用 TeX 或者 LaTeX 符号书写公式。使用Html和Css渲染。MML_HTMLorMML.js：允许使用 MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。AM_HTMLorMML.js：允许使用 AsciiMath 符号书写。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS-MML_SVG.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。使用SVG产生输出。TeX-MML-AM_HTMLorMML.js：允许使用 TeX, LaTeX,MathML,或者 AsciiMath 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。第一个文件是提供给你修改的。它基本上包含了MathJax的所有配置选项，同时有注释解释。其他的文件就是我们联合配置文件。它们不仅仅配置Mathjax,还预加载了一些配置所需的文件。这些文件内容在 联合配置 中有详细的解释。原来的 CDN 地址 cdn.mathjax.org 已经在 2017-04-30 日关闭，所以必须更新 CDN 地址，其推荐的 CDN 地址为 cdnjs.cloudflare.com/ajax/libs/mathjax，而新的 MathJax 也提供一种一种新的配置文件 TeX-MML-AM_CHTML（允许使用 TeX, LaTeX,MathML或者 AsciiMath 符号书写公式，使用 CommonHTML 产生输出），新的 MathJax 推荐使用的就是这种配置文件，因为它计划在 V3.0 将 HTML-CSS 输出格式丢弃，只留下 CommonHTML 和 SVG 这两种输出格式。而且新的 CDN 地址不支持 /latest/MathJax.js 这种格式，必须指定一个确定的版本，截止 Shaun 此次修改日期之前，最新的版本为 2.7.2，所以比较推荐的一种加载格式为：&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 。7、添加 404 页面和一些插件等修改日期：2017-12-09 ~ 2017-12-10更新日志：修改文章内 a 标签的高度，即 .article-entry p a 中 padding 的上下边距。文章内的 a 标签在外面加个虚线框本来就很突出了，还设置上下 padding 为 8px，这就显得有点浮夸了 :) 。最后将其上下边距设为 0px；添加 404 页面，具体参考自：在 Hexo 中创建匹配主题的404页面，启动 Git Bash，进入 Hexo 所在文件夹，输入 hexo new page 404 ；打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md；在顶部插入一行，写上permalink: /404，这表示指定该页固定链接为 http://&quot;主页&quot;/404.html12345title: 404 Not Found：该页面无法显示toc: falsecomments: falsepermalink: /404---添加 hexo-abbrlink 插件，使文章生成唯一永久链接。这个插件最好是在建站之初就加上，不然写了很多文章之后又都得重新生成链接，搜索引擎需要再次抓取新链接，不利于 SEO，Shaun 这里也就只有等 Google 慢慢抓取更新，还好写的不多，不算太迟。安装完之后 Shaun 在站点配置文件中添加：1234permalink: posts/:abbrlink.html # 需安装hexo-abbrlink插件abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex※BTW：需要将原来的 permalink 注释掉或直接删除。更多设置可参考 hexo-abbrlink 。添加 hexo-all-minifier 插件，快速压缩代码，分别对 html、css、js、images 进行优化。Shaun 这里就直接使用推荐的配置了，直接在站点配置文件中添加：1all_minifier: true # 需安装hexo-all-minifier插件更多设置可参考 hexo-all-minifier 。原来文章标题不可点击，反而日期可点击，这有点奇怪 ◔ ‸◔?。本次修改之后，点击文章标题即为刷新页面。更新日期：2017-12-19 ~ 2017-12-19具体修改内容：主要更新了 404 页面上面的动图，个人偏好喜欢一些星系漩涡之内的动图，偶然发现这个东西（HTML5+Three.js实现的3D可拖拽银河星系旋转动画特效源码），于是将它的源码略作修改放进 Shaun 的 404 页面，将相关的 js 文件放入主题文件夹中 \source\js 文件夹里，最初时是将相关 js 文件引入路径当成相对路径引入，没想到这样造成有的 404 页面会显示旋转动图，而有的 404 页面则不会显示，后面参考网上资料（解惑页面中的相对路径和绝对路径）了解到：html 中引入的资源（包括js、css、img）相对路径：相对的是 网页本身的 URL ；绝对路径：相对的是 网页 URL 的根路径 ；css 中引入的资源相对路径：相对的是 css 文件本身的 URL ；绝对路径：相对的是 网页 URL 的根路径；结论： html 中引入资源的相对路径与 网页的 URL 有关，而css中则与 css 资源本身 URL 有关。但使用绝对路径时，不管是在 html中，还是css中，都只与 网页 URL的根路径有关。将相对路径改为绝对路径，即可在 Shaun 博客域名下所有 404 页面正常显示旋转动图。8、添加 Gitalk 评论系统修改日期：2017-12-16 Gitalk 是一款类似 gitment 的评论系统，Shaun 先是照着它提供的配置添加之后，发现居然与 spfk 主题中的 require-2.1.6,jquery-1.9.1.min.js 冲突，显示不了 Gitalk，Shaun 以为是 bug，所以就去提了个 issue，作者 booxood 还是挺认真负责的（°Д°）Ъ，耐心的解决 Shaun 的问题，原来是 Shaun 的引用方式有问题，需要用 require 方式引用，大佬就是大佬 ○|￣|_，小白还是小白，萌新完全没见过还有这种操作，也算是开眼界了 ✪ω✪。由于大佬解决完问题之后就直接把 issue 关闭了，所以 Shaun 就只有在这里表示感谢了 /つ∇T)。Shaun 最后添加 gitalk 的 ejs 代码如下：123456789101112131415161718&lt;div id=&quot;comments&quot; class=&quot;gitalk&quot;&gt; &lt;div id=&quot;gitalk-container&quot; class=&quot;article article-inner article-entry&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&apos;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&apos;], function (Gitalk) &#123; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%= theme.gitalk.client_id%&gt;&apos;, clientSecret: &apos;&lt;%= theme.gitalk.client_secret%&gt;&apos;, id: window.location.pathname, repo: &apos;&lt;%= theme.gitalk.repo%&gt;&apos;, owner: &apos;&lt;%= theme.gitalk.owner%&gt;&apos;, admin: &apos;&lt;%= theme.gitalk.admin%&gt;&apos;, // facebook-like distraction free mode distractionFreeMode: true &#125;) gitalk.render(&apos;gitalk-container&apos;) &#125;) &lt;/script&gt;&lt;/div&gt;还有其它的一些修改也是仿照 gitment 的代码添加的，我这上面没有添加 css 文件是因为 gitalk 原有的 css 文件与 Shaun 的主题不相符，所以就稍微修改了一下。※BTW：上次修改文章内a标签的高度后突然发现打赏的“赏”字背景圆形变成椭圆了 o(╯□╰)o，后面发现原来它也继承文章内 a 标签的属性，没有自己的 padding，后面只有给 .dashang 添加个独立的 padding: 8px;。9、Fix Bugs修改日期：2017-12-20修复bug：鼠标悬浮 a 标签之上会出现显示 a 标签 title 内容的气泡，当 title 内容过多时，会造成气泡位置下调，从而遮住相应 a 标签内容的 bug。解决方案为：定位气泡文件为主题文件夹下 \layout\_partial\post\TipTitle.ejs 文件，将其中气泡出现的位置改变，原来气泡的位置确定由 top 和 left 决定，现改为 bottom 和 left，毕竟气泡是出现在 a 标签上方，如果将 top 确定，则 title 内容过多时，其只能向下扩张，造成气泡位置下移现象，从而遮住原来的 a 标签内容，改为 bottom 确定之后，气泡只会向上扩张，气泡位置相对稳定，不会遮住原来的 a 标签内容。具体修改内容为，将 top: offset.top - a.outerHeight() - 15 替换为 bottom: window.innerHeight - offset.top + 10 ，其它内容保持不变。修改日期：2017-12-26BUG描述：由于 spfk 主题启用的是百度分享，而原作者没有为其添加邮件分享，Shaun 为了好玩就添加个邮件分享，但是在添加过程中，Shaun 发现了个 BUG，就是为其添加的 title 属性没有作用，它会自动更改 title 内容，而 spfk 主题有显示 title 的气泡 TipTitle，所以不需要用默认的东西显示 title 内容，但是，这个百度分享还是强制默认显示，TipTitle 并不能消除其 title 内容。解决方案：定位百度分享强制添加 title 的代码，其位于主题文件夹下\source\static\api\js\view\share_view.js 中，具体代码如下：1234function(e)&#123; var i=e.partners,s=i[n]?"\u5206\u4eab\u5230"+i[n].name:""; !r(t).attr("title")&amp;&amp;s&amp;&amp;r(t).attr("title",s)&#125;因为 TipTitle 会首先将 title 去掉，所以这里会强制添加百度分享自己的 title，所以需要将其注释掉，具体注释代码为：/*&amp;&amp;r(t).attr(&quot;title&quot;,s)*/。本来这样就可以了，但是 Shaun 发现添加邮件分享之后，布局又不对，所以定位主题文件夹下 \source\css\_partial\baidushare.styl 文件，发现它的居中布局居然是有宽度决定的，于是 Shaun 为其添加 text-align: center; 谁知还是没变，不能自动居中，后来在主题文件夹下找到 \source\static\api\css\share_style2_24.css 文件，发现 .bdshare-button-style2-24 a 设置了浮动样式，难怪（⊙﹏⊙），最后将其注释掉就能自动居中了。最后还需要更改移动端 \source\css\_partial\mobile.styl 中 .bdshare-button-style2-24 的样式设置为自动居中就可以了。10、使文章目录可折叠修改日期：2017-12-28首先声明，本次修改完全参考：为 Hexo 添加可折叠的文章目录，所用代码也来自其文（Shaun 只是做了点微不足道的修改），在此表示感谢 Yelee 主题的作者 MOxFIVE 👍 。具体修改如下：首先在主题文件夹下 \layout\_partial\toc.ejs 中添加 js 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- 折叠目录 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; // -------------添加小图标-------------- var $itemHasChild = $(&quot;#toc .toc-item:has(&gt; .toc-child)&quot;); var $titleHasChild = $itemHasChild.children(&quot;.toc-link&quot;); $itemHasChild.prepend(&quot;&lt;i class=&apos;fa fa-caret-down&apos;&gt;&lt;/i&gt;&lt;i class=&apos;fa fa-caret-right&apos;&gt;&lt;/i&gt;&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); $iconToExpand.addClass(&quot;hide&quot;); // --------------点击小图标-------------- var clickIcon = function () &#123; $(&quot;#toc .toc-item &gt; i&quot;).click(function () &#123; $(this).siblings(&quot;.toc-child&quot;).slideToggle(100); $(this).toggleClass(&quot;hide&quot;); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) &#125;() // 默认展开目录，所以隐藏掉表示“目录已展开”的图标（向下的小三角） var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); $iconToExpand.addClass(&quot;hide&quot;); // ------------点击大标题----------------- var clickTitle = function () &#123; $titleHasChild.dblclick(function () &#123; $(this).siblings(&quot;.toc-child&quot;).hide(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) // After dblclick enent $titleHasChild.click(function () &#123; var $curentTocChild = $(this).siblings(&quot;.toc-child&quot;); if ($curentTocChild.is(&quot;:hidden&quot;)) &#123; $curentTocChild.show(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125; &#125;) &#125;() // ---------点击总标题----------------- var clickTocTitle = function () &#123; var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $subToc = $titleHasChild.next(&quot;.toc-child&quot;); var $tocTitle = $(&quot;#toc .toc-title&quot;); // 当包含多级目录时再执行 if ($titleHasChild.length) &#123; $tocTitle.addClass(&quot;clickable&quot;); $tocTitle.click(function () &#123; if ($subToc.is(&quot;:hidden&quot;)) &#123; $subToc.show(150); $iconToExpand.removeClass(&quot;hide&quot;); $iconToFold.addClass(&quot;hide&quot;); &#125; else &#123; $subToc.hide(100); $iconToExpand.addClass(&quot;hide&quot;); $iconToFold.removeClass(&quot;hide&quot;); &#125; &#125;) &#125; &#125;()&lt;/script&gt;然后添加相应的 css 样式，在主题文件夹下 \source\css\_partial\article.styl 中 #toc 样式里添加 css 样式：1234567891011121314151617181920212223242526ol.toc li.toc-item i &#123; display: inline-block; margin-left: -0.9em; width: 0.9em; color: #b3b3b3; font-weight: bold; cursor: pointer; &amp;:hover &#123; color: #000; &#125; &amp;.hide &#123; display: none; &#125;&#125; .toc-title.clickable &#123; cursor: pointer; &amp;:hover &#123; color: #88acdb; &#125; &amp;:active &#123; color: #d3d3d3; &#125;&#125;以上两步做完之后，点击目录前的小三角符号或双击目录名就能折叠相应目录，点击“文章目录”就能折叠所有目录。待续。。。后记 先就写到这里，如后续修改中发现问题再继续记录吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题]]></title>
    <url>posts/22c3daf1.html</url>
    <content type="text"><![CDATA[前言 曾写过一个程序，需要有一个界面，但 Shaun 不想使用 MFC，因缘巧合，在网上看到 Qt，就尝试用了一下，遂有此文。Shaun 的 Qt 版本为 qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的 Qt 可以通过 Visual Studio 2013 开发 Qt 程序（各位看官猜的没错，Shaun 并没有直接使用 Qt Creator 开发 Qt 程序，而是通过 VS 开发 Qt 程序的 \(^o^)/），一来是熟悉 VS 开发，对 Qt Creator 完全没用过；二来是已经在 VS 配好全套的开发环境了（画外音：说白了就是懒嘛 ╭(╯^╰)╮）。但是在 VS 中开发 Qt 程序还需要一些其它的配置。准备篇 在 VS 中开发 Qt 程序首先需要安装一个 addin 外接程序，下载并安装 qt-vs-addin-1.2.5.exe（http://download.qt.io/archive/vsaddin/），（网上说该程序已不支持 VS2013 及以上版本的 VS，原因是 VS2013 及其以上版本的 VS 都不支持该种类型的插件，新版本的 VS 需要安装新型插件 qt-vs-tools-msvc2013-2.1.1.vsix 或 qt-vs-tools-msvc2015-2.1.1.vsix），但是经 Shaun 实测，Shaun 的 VS2013-update5 英文旗舰版通过 qt-vs-addin-1.2.5 编写 Qt 程序完全没问题，不过 VS2015 就不知道了，可能真需要安装新型插件。下载安装好相应的软件之后需要在 VS 中配置 Qt 环境，虽然不配置也能正常编译，但是会在 Qt 相关的语句下面出现红色波浪线，Shaun 轻微强迫症表示不能忍 ╭(╯^╰)╮。具体配置如下：选中“VC++目录”，在“包含目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\include在“库目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\lib配置完成之后即可发现红色波浪线已消失。使用篇 VS 中如何开发 Qt 程序请详见参考资料，懒癌发作，不想写了 =_=（其实是因为要写的话只能贴图了，Shaun 表示不想使用图片 (╯﹏╰) ）。问题篇问题描述：Shaun 在用 Qt 显示 OpenCV 的 Mat 数据图像时，有时会发生扭曲现象（图像从对角线分开，两边颠倒，扭曲），有时却不会，为了撤了解决问题，查阅了相关资料，终于发现症结所在，原来是图片数据格式不符合 Qt 的图片数据格式。解决办法：正文来喽 ~\(≧▽≦)/~，就不说废话了，“Talk is cheap. Show you the code”，具体完整正确显示C++代码为：123456789101112131415161718192021222324void showMatWithQtQlabel(const cv::Mat &amp;img, QLabel *label)&#123; // [Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决](http://lovelittlebean.blog.163.com/blog/static/11658218620125208212189/) QImage q_img; if(img.channels() == 3) // RGB image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB888).rgbSwapped(); &#125;else if (img.channels() == 4) // RGBA image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB32); &#125;else // gray image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_Indexed8); &#125; // -------------- 图片自适应label ------------------- QImage q_label_img = q_img.scaled(label-&gt;size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 图片自适应label大小 label-&gt;setPixmap(QPixmap::fromImage(q_label_img)); // 将图片显示到label上 // -------------- label自适应图片 ------------------- /*label-&gt;setPixmap(QPixmap::fromImage(q_img)); // 显示在label中 label-&gt;resize(label-&gt;pixmap()-&gt;size()); // 改变label的尺寸以自适应图像 label-&gt;show(); */&#125; rgbSwapped() 函数是为了使 Qt 中显示图形颜色更自然，因为 OpenCV 的 Mat 数据 RGB 图像是以 BGR 的顺序排列，而 Qt 中是以 RGB 的顺序排列，所以需要 rgbSwapped() 交换一下颜色通道排列顺序。附录1、摄像头数据采集问题注意：如果是从摄像头实时采集显示图像，在显示时需先判断图像有没有数据1234567if (image.data)&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;或1234567if (!image.empty())&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;具体原因可参考 Shaun 的一篇文章 解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题 。2、信号与槽的连接函数问题Qt4 中信号与槽的连接函数语法为：1connect(&amp;theTimer,SIGNAL(timeout()),this,SLOT(getFrame())); // 超时就去取下一帧而 Qt5 中信号与槽的连接函数新语法为：1connect(&amp;theTimer, &amp;QTimer::timeout, this, &amp;QtTest::getFrame); //超时就去取下一帧推荐使用 Qt5 新语法，具体原因可参考 qt5中信号和槽的新语法 。个人粗浅理解：信号函数一般是 Qt 中控件的库函数，比如按钮控件 QButton 的 QButton::clicked () 函数，定时器 QTimer 的 QTimer::timeout () 等函数；而槽函数是响应函数，一般由用户自己编写，也可以使用 Qt 中库函数。 使用 Qt 中可能会遇到的一些错误请参考 使用VS2010开发Qt程序的一点经验（http://www.cnblogs.com/csuftzzk/category/445772.html）。后记 本来其实就想把问题篇写出来的，毕竟主要就是想记录一下那个显示函数，但是感觉有点没头没尾，就把 VS 集成 Qt 开发环境也稍微写了一下，而使用篇确实是因为参考资料已经写的很详细了，所以就直接一笔带过了。参考资料[1] QT +openCV 实现摄像头采集以及拍照功能（http://blog.csdn.net/llh318724/article/category/930663）[2] VS2010 + QT5.2+ QT-VS-Addin1.2.2开发环境配置（http://blog.csdn.net/qqmindyourwill/article/category/5990841）[3] Qt+OpenCV界面（http://blog.csdn.net/fm0517/article/category/1110960）[4] Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决（http://blog.csdn.net/loveaborn/article/category/1164072）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题]]></title>
    <url>posts/509ee93b.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-2.4.11，编程语言为 C++。前言 本文其实是以前在刚学 OpenCV 时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。问题篇问题描述：使用 OpenCV-2.4.11 调用摄像头显示拍摄视频时报 runtime error，控制台窗口出现 OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file ……...cpp, line 261。解决办法：在显示图片时先判断是否有图像数据，如下：1234if (!image.empty()) &#123; imshow("window", image);&#125;或1234if (image.data) &#123; imshow("window", image);&#125;原因可能是：用 imshow() 显示图像时，其 image 必须有数据，如果它为空则程序会报错，而一般打开摄像头会有一定时间的延迟，这时程序已经启动，而摄像头由于启动延迟，不一定能及时获取图像，造成要显示的 image 为空，因此报错。个人粗浅理解，板砖轻拍 ⊙﹏⊙b。而网上有人也认为：我也是遇到这个问题，不过看到一个帖子写得不错（英文的），里面给出了一个可能的理由，就是我们用 opencv 打开视频的时候，会自动先监测摄像头有没有读到帧，如果没有，就会报错，然后再执行你的程序，加一个if判断就是跳过系统自己的判断，直接执行我们的程序。来自：https://zhidao.baidu.com/question/1831122325089024420.html有人说的原因是在 VideoCapture 刚开始获取摄像头视频流的过程不返回信号，所以判断 Mat 是否为空，并不断循环去获取 Mat。来自：http://www.cnblogs.com/tiny656/p/3538115.html附最终完整示例程序：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;// 调用摄像头void videoCaptureTest()&#123; //cv::VideoCapture cap(0); // 打开默认摄像头，参数0代表默认摄像头的ID cv::VideoCapture cap; cap.open(0); // 设置摄像头 cap.set(CV_CAP_PROP_FRAME_WIDTH,640); cap.set(CV_CAP_PROP_FRAME_HEIGHT,480); // 确认是否成功打开摄像头 if (!cap.isOpened()) &#123; printf("打开摄像头失败，退出！\n"); exit(-1); &#125; cv::namedWindow("Capture", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO); while (1) &#123; cv::Mat frame; cap &gt;&gt; frame; // 获取帧 // 对摄像头获取的帧进行各种处理 if (!frame.empty()) // 最好加上该判断，并在该判断中对帧进行处理 &#123; cv::imshow("Capture", frame); &#125; if(cv::waitKey(30) &gt;= 0) break; // 每30ms取一帧 &#125;&#125;int main(int argc, char *argv[])&#123; videoCaptureTest(); return 0;&#125; 其实也可以通过在获取帧时，反复获取帧，直到取到的帧有数据为止，这样就不需要判断语句了，直接显示即可，具体代码如下：123456do&#123; cap &gt;&gt; frame;&#125;while(frame.empty());cv::imshow("Capture", frame);参考自：https://stackoverflow.com/a/9285151 。后记 本文还是当初在国内某平台写博客时写的，但现在再回头看，又稍微有了点新的思路，温故确实能知新 (*^__^*) 嘻嘻……。参考资料[1] OpenCV2.3使用摄像头和视频（http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html）[2] OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, fi 这个问题怎么办？[3] OpenCV打开摄像头出现运行错误OpenCV Error：Assertion failed (size.width&gt;0&amp;&amp;size.height&gt;0)in cv::imshow，……（http://blog.csdn.net/czl389/article/category/6381887）[4] [OpenCV]获取摄像头视频（http://www.cnblogs.com/tiny656/category/550972.html）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加各种小部件]]></title>
    <url>posts/3bc0decc.html</url>
    <content type="text"><![CDATA[前言 Shaun 目前还在使用对 Hexo 的主题 SPFK 自行魔改的那个主题（所谓的魔改也就是对照着 black-blue 主题修改了部分 CSS，然后又添加了一个站内搜索功能 (&gt;^ω^&lt;)），主题 SPFK 主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。添加 QQ 邮箱联系添加日期：2017-9-15 进入 QQ邮箱开放平台，点击“获取邮我按钮”，登录 QQ 之后继续点击该按钮，因为 Shaun 不需要其样式，只需要其链接即可，所以就默认样式，直接点击“获取代码”即可，Shaun 默认的“HTML代码”为：1&lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" style="text-decoration:none;"&gt;&lt;img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_01.png"/&gt;&lt;/a&gt;提取其中的 href，即http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ，将该链接添加到 主题配置文件 中，具体如下：12subnav: mail: "http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ"重新部署站点即可发现对应的邮箱图标，点击该图标可直接给 Shaun 发邮件。添加 QQ 交谈链接添加日期：2017-9-15 进入 QQ推广，点击上方的“推广工具”，若没登录 QQ 则先登录 QQ，组件样式同样默认即可，这里需要注意的是，需要点击左边的“设置”，下滚页面，找到“安全级别设置”，如下安全级别设置完全公开（推荐商家，客服等用户使用，代码中显示QQ号码，易于推广）安全加密（推荐博主，论坛用户等使用，代码中不显示QQ号码）选中“安全加密”，不然该选项默认的为完全公开，这样 QQ 号码就直接会显示在代码中，不利于隐私保护，选中之后，点击“保存”。保存之后，再次点击“推广工具”，即可发现下方的复制代码区域的 HTML 代码已看不到明码显示的 QQ 号，（若还是能看到 QQ 号，没有任何变化，可关闭该界面，重启浏览器重新进入该界面），Shaun 的“复制这段代码并将其粘贴到您的网页上”下方区域的默认的代码为：1&lt;a target="_blank" href="http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422"&gt;&lt;img border="0" src="http://wpa.qq.com/imgd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422&amp;pic=52" alt="点击这里给我发消息" title="点击这里给我发消息"/&gt;&lt;/a&gt;提取其中的 href，即http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422，将该链接添加到 主题配置文件 中，具体如下：12subnav: QQ: "http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12"重新部署站点即可发现对应的 QQ 图标，点击该图标可直接给 Shaun 发临时 QQ 消息。添加用户访问统计信息小工具 —— RevolverMaps添加日期：2017-10-12 由于 Shaun 暂时不想搞 SEO，所以就没有搞站点地图，更没有将 Shaun 的站点提交到百度和 Google 的站长平台上。但 Shaun 又想查看用户访问信息（是不是很矛盾 o(╯□╰)o），而正好 Shaun 看到有个很酷炫的 3D地球 能满足 Shaun 的需求（其实很酷炫才是主要原因 O(∩_∩)O~），所以 Shaun 决定将其加入 Shaun 的站点中（当做一部分装饰品 ๑乛◡乛๑）。该插件的名称为 RevolverMaps，具体样式可以去其官网看，Shaun 就不贴图了。设置完前三步之后，第四步让用户复制代码到自己的站点上，注意第四步会让你选“new map”还是“update”，由于 Shaun 是初次使用，当然是选择默认的“new map”，如果是以前使用过，就选择“update”，并将原来使用的 script 代码输入出现的文本框并提交，这样就只是更改 3D 地球样式而不会丢失用户访问信息数据。 具体添加方法为：将复制的 script 代码放入想显示的某个 div 中。Shaun 得到的 script 代码为：&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 由于 Shaun 的博客是双栏的，Shaun 当然是把 RevolverMaps 放入左栏中，Shaun 刚开始是把得到的 script 代码放入主题文件夹下 \layout\_partial\left-col.ejs 文件末尾的12 &lt;/header&gt; &lt;/div&gt;&lt;/header&gt; 标签之前（即在 header 的最下端显示 RevolverMaps ），但实际用起来有点不好看；Shaun 又想干脆另外创造一个 div 放置地球，具体思路为：在 birdhouse 图标旁创建一个新的地球图标，再做一个像 birdhouse 图标一样的动画，鼠标移到地球图标时，出现一个 div，该 div 用来放置 RevolverMaps，这一步做到一半（即将一个新的地球图标并排放在 birdhouse 图标旁）发现这个效果感觉更不好看了，如果要改就需要大改了，有点麻烦 o(︶︿︶)o唉；于是 Shaun 看到鼠标放在 birdhouse 图标出现的菜单栏上，想到何不如将该菜单栏在添加一栏，创建一个 div 用来显示 RevolverMaps？事不宜迟，马上就动手添加该 div，具体添加步骤如下：首先当然是添加一个“访问情况”的列表名称，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;ul class=&quot;tips-inner&quot;&gt; 下最后一个 &lt;li&gt; 后即 &lt;/ul&gt; 前添加 &lt;li&gt;访问情况&lt;/li&gt;；接着像其它的列表一样（点击该列表 birdhouse 图标就会改变成相应的图标），点击“访问情况”会将 birdhouse 图标改变成一个地球小图标，经查阅相应的 css 文件，其它的列表对应的图标好像是利用 div 的边框属性画出来的（某业余前端的猜测+_+），Shaun 目前还没有这样的才能，就只有投机的采用 Font Awesome 中的 globe 图标了。在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;icon-ctn&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;div class="icon-wrap icon-globe hide" data-idx="4"&gt; &lt;i class="fa fa-globe fa-spin fa-2x" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt;这样点击“访问情况”会将 birdhouse 图标变成一个旋转的地球小图标了；接下来就需要创建“访问情况”对应的 div 了，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;switch-wrap&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;section class="switch-part switch-part5"&gt; &lt;script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49" async="async"&gt;&lt;/script&gt;&lt;/section&gt;这样点击“访问情况”就能出现酷炫的 3D 地球了，才怪 :p。这样只能让 3D 地球出现在菜单界面，还需要添加修改相应的 css；最后就是改 css 样式了，本以为这一步很简单，没想到这一步花费 Shaun 最多时间 ╮(╯_╰)╭，修改的样式位于主题文件夹下 \source\css_partial\main.styl 文件中，首先为 switch-part5 添加对应的样式，在 .switch-part4 样式后添加：123456.switch-part5&#123; left: 400%; width: 100%; //height: 200px; //margin-left: 47px; &#125;做完这一步会发现 3D 地球显示不完全，下面会缺一点，所以还需要继续修改，修改过程如下：Shaun 曾将该 width 减小（如上面代码中的注释），这样确实能让 3D 地球显示完全，但有点小，不是很好看；后面想到没显示完全可能是上层 div（.switch-area）太小且设置了 overflow: hidden;，于是这里 Shaun 首先增加了 .switch-area 的高度，这样确实能解决问题，但会使左栏的滚动条显示出来；所以 Shaun 接着尝试将 .switch-area 的 overflow: hidden; 注释掉，谁想注释掉之后出现了横向滚动条，这样更不好了，于是 Shaun 又更改为 overflow-x: hidden; ，谁想 .switch-area 又出现了竖直滚动条（感觉像拆东墙补西墙 -_-|||），查阅相关资料（CSS-overflow特性及总结）得知若 overflow-x 为 hidden，overflow-y 不为 hidden，则 overflow-y 将会自动重置为 auto，所以这里不能这样改，但 overflow: hidden; 还是得注释掉，不然上层 div 撑不开，而且不增加高度的话，还是不能完全显示 3D 地球，因为超出就隐藏了嘛；因为注释掉之后会出现横向滚动条，而又不能修改 .switch-area 的 overflow-x，所以就只能改更上层的 div，这里 Shaun 突然想起上次给左栏添加滚动条时，在 .left-col 下添加了 overflow: auto;，这次不如还修改这里，毕竟 Shaun 只想要竖直滚动条（其实不要滚动条却能滚动最好，但 Shaun 目前还没找到好的解决方案 (╯﹏╰)b），不要横向滚动条，于是将其修改为：12overflow-y: auto;overflow-x: hidden;没想到这样也能解决问题，虽然还是会在左栏出现滚动条，但这样感觉比增加 .switch-area 的高度要好（嗯，应该要好吧 (～ o ～)Y）。看以后能不能改成点击“访问情况”时才出现滚动条，点击其它列表则不出现滚动条（其实把滚动条隐藏最好，但网上那个两个 div 嵌套的方法 Shaun 尝试过会出现一些奇怪的问题，等以后再试试吧 ↖((^ω^)↗）。待续。。。后记 目前就添加这些小组件，以后应该会陆续添加一些其它的小东西 ↖(^ω^)↗。参考资料[1] 如何在自己网站上或者博客上放置QQ邮箱联系反馈（http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1）[2] 如何在自己的博客添加QQ组件（http://www.29mo.com/category/wltg）[3] 一步一步教你给自己博客添加QQ在线（http://www.feizl.com/feizhuliu/QQbaodian/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中显著性检测算法的使用]]></title>
    <url>posts/fd0f8195.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV 中实现了两种显著性检测算法，分别为 Spectral Residual 算法,出自 Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on, pages 1–8. IEEE, 2007. 和 Fine Grained Saliency 算法,出自 Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In Image and Vision Computing, Vol. 28 Issue 3, pages 391–402. Elsevier, 2010.。这两种算法同样是在扩展包 opencv_contrib-3.2.0 中，也是由于 opencv 官方示例程序对初学者不友好（主要是 Shaun 境界不够 o(╯□╰)o），所以 Shaun 对照其官方文档重新整理了一下。说明篇 使用 OpenCV 中实现的显著性检测算法进行显著性检测十分方便简洁，利用以下三个函数就可以：创建 Spectral Residual 算法显著性检测对象：static Ptr&lt;StaticSaliencySpectralResidual&gt; cv::saliency::StaticSaliencySpectralResidual::create();Spectral Residual 算法计算显著性图：bool cv::saliency::StaticSaliencySpectralResidual::computeSaliency(InputArray image, OutputArray saliencyMap);Fine Grained Saliency 算法显著性检测对应的函数声明同 Spectral Residual 算法类似。计算显著性图的二值图：bool cv::saliency::StaticSaliency::computeBinaryMap(InputArray _saliencyMap, OutputArray _binaryMap) ;具体使用方法可参考实例篇。实例篇 使用 OpenCV 中的显著性检测算法需要包含头文件#include &lt;opencv2/saliency.hpp&gt;，具体示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/saliency.hpp&gt;//******************************************************// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)////Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)//&#123;// if (saliencyType == "SPECTRAL_RESIDUAL")// return makePtr&lt;StaticSaliencySpectralResidual&gt;(); //computeSaliency返回的是32FC1// else if (saliencyType == "FINE_GRAINED")// return makePtr&lt;StaticSaliencyFineGrained&gt;(); //computeSaliency返回的是8UC1// else if (saliencyType == "BING")// return makePtr&lt;ObjectnessBING&gt;();// else if (saliencyType == "BinWangApr2014")// return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();// return Ptr&lt;Saliency&gt;();//&#125;//// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）//*****************************************************void spectralResidualTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入最真实的原始图像 cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); // [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687) if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Mat planes[] = &#123; cv::Mat_&lt;float&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;; cv::Mat complex_img; //复数矩阵 merge(planes, 2, complex_img); //把单通道矩阵组合成复数形式的双通道矩阵 dft(complex_img, complex_img); // 使用离散傅立叶变换 //对复数矩阵进行处理，方法为谱残差 cv::Mat magnitude, phase_angle, mag_mean; cv::Mat real_part, imaginary_part; split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; //实部 imaginary_part = planes[1]; //虚部 cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值 phase(real_part, imaginary_part, phase_angle); //计算相角 float *pre, *pim, *pm, *pp; //对幅值进行对数化 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = log(*pm); pm++; &#125; &#125; blur(magnitude, mag_mean, cv::Size(5, 5)); //对数谱的均值滤波 magnitude = magnitude - mag_mean; //求取对数频谱残差 //把对数谱残差的幅值和相角划归到复数形式 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pre = real_part.ptr&lt;float&gt;(i); pim = imaginary_part.ptr&lt;float&gt;(i); pm = magnitude.ptr&lt;float&gt;(i); pp = phase_angle.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = exp(*pm); *pre = *pm * cos(*pp); *pim = *pm * sin(*pp); pre++; pim++; pm++; pp++; &#125; &#125; cv::Mat planes1[] = &#123; cv::Mat_&lt;float&gt;(real_part), cv::Mat_&lt;float&gt;(imaginary_part) &#125;; merge(planes1, 2, complex_img); //重新整合实部和虚部组成双通道形式的复数矩阵 idft(complex_img, complex_img, cv::DFT_SCALE); // 傅立叶反变换 split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; imaginary_part = planes[1]; cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值和相角 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = (*pm) * (*pm); pm++; &#125; &#125; GaussianBlur(magnitude, magnitude, cv::Size(7, 7), 2.5, 2.5); cv::Mat invDFT, invDFTcvt; normalize(magnitude, invDFT, 0, 255, cv::NORM_MINMAX); //归一化到[0,255]供显示 invDFT.convertTo(invDFTcvt, CV_8U); //转化成CV_8U型 cv::namedWindow("SpectualResidual", CV_WND_PROP_ASPECTRATIO); cv::imshow("SpectualResidual", invDFTcvt); cv::Mat thresholded; cv::threshold(invDFTcvt, thresholded, 0, 255, CV_THRESH_OTSU); cv::namedWindow("Thresholded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded Image", thresholded); cv::Mat eroded; // 纵向腐蚀 cv::erode(thresholded, eroded, cv::Mat(5, 1, CV_8UC1, cv::Scalar(1)), cv::Point(-1, -1), 3); // cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心 cv::namedWindow("eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("eroded Image", eroded); //cv::Mat thresholded; cv::threshold(eroded, thresholded, 60, 255, CV_THRESH_BINARY); cv::namedWindow("Thresholded eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded eroded Image", thresholded);&#125; // 显著性检测算法基类void saliencyTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create("SPECTRAL_RESIDUAL"); // FINE_GRAINED为Fine Grained Saliency算法 cv::Mat saliency_map; if (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map)) // 计算显著性图 &#123; cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", saliency_map); cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1); normalize(saliency_map, saliency_map_show, 0, 255, CV_MINMAX); //归一化到[0,255]供显示 saliency_map_show.convertTo(saliency_map_show, CV_8U); //转化成CV_8U型 cv::namedWindow("saliency_map_show", CV_WND_PROP_ASPECTRATIO); cv::imshow("saliency_map_show", saliency_map_show); cv::Mat binary_map; cv::saliency::StaticSaliencySpectralResidual spec; if (spec.computeBinaryMap(saliency_map, binary_map)) // 对显著性图进行二值化 &#123; cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); &#125; &#125;&#125;// Fine Grained Saliency算法void FGSTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create(); cv::Mat fgs_saliency_map; fgs-&gt;computeSaliency(src_img, fgs_saliency_map); cv::namedWindow("FGS saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("FGS saliency map", fgs_saliency_map); //cv::imwrite("../data/T_S.png", fgs_saliency_map); cv::Mat binary_map; cv::threshold(fgs_saliency_map, binary_map, 0, 255, CV_THRESH_OTSU); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); //cv::imwrite("../data/T_S_B.png", binary_map);&#125;// Spectral Residual算法void SRTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create(); cv::Mat sr_saliency_map; sr-&gt;computeSaliency(src_img, sr_saliency_map); cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", sr_saliency_map); cv::Mat binary_map; sr-&gt;computeBinaryMap(sr_saliency_map, binary_map); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map);&#125;int main(int argc, char *argv[])&#123; //spectralResidualTest(); //saliencyTest(); //FGSTest(); SRTest(); while (cv::waitKey(0) != 27) &#123; &#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。 这里面有个小东西需要注意，就是 computeBinaryMap() 函数，看其文档描述其中使用 K-means 算法和 Otsu 算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV 中 Spectral Residual 算法 computeSaliency() 返回的结果为浮点数，而 Fine Grained Saliency 算法 computeSaliency() 返回的结果却是整型数据，所以这一点需要注意 Fine Grained Saliency 算法返回的结果不能直接使用 computeBinaryMap() 函数，一般对其结果直接使用 OTSU 算法进行阈值分割即可。后记 本文使用的这两种算法在 Shaun 的电脑上运行时间都较长，基本不可能用来处理视频流，而且在 Shaun 的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过 OpenCV 中也有用来处理视频流的显著性检测算法，其为 BING 算法,出自Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In IEEE CVPR, 2014.，实际上这是一种快速提取目标候选框的算法。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中Selective Search算法的使用]]></title>
    <url>posts/35132cb7.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV-3.2 中的 Selective Search 算法是在其扩展包中，所以要想使用该算法需自行编译 opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（Shaun 编程水平有限，粗浅评价，勿怪 (*^__^ *) 嘻嘻……），所以 Shaun 参考其官方文档及其官方示例程序写下此文。说明篇 该算法是选取 region proposal（一般翻译成候选区域 / 区域建议）领域中当时的 state-of-the-art。其算法具体思想出自 Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154–171, 2013.，若英文水平不够，还想了解其中文思想请参考文末参考资料。 OpenCV中实现的相应函数：void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addGraphSegmentation(Ptr&lt;GraphSegmentation&gt; g);：添加相应的图割算法；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addImage(InputArray img) ; ：添加待处理的图片；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addStrategy(Ptr&lt;SelectiveSearchSegmentationStrategy&gt; s); ：添加相应的策略（颜色相似度、纹理相似度、尺寸相似度和填充相似度）；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::process(std::vector&lt;Rect&gt; &amp;rects);：结合图割算法和相应策略进行处理，返回候选框。实例篇 使用 Selective Search 算法需包含#include &lt;opencv2/ximgproc.hpp&gt;，完整示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/ximgproc.hpp&gt;void SSTest()&#123; // [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入原始图像 cv::namedWindow("src_img", CV_WINDOW_KEEPRATIO); cv::imshow("src_img", src_img); //// 转换为灰度图 //cv::Mat gray_img; //cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY); // 图割算法 cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation(); cv::Mat graph_segmented; gs-&gt;processImage(src_img, graph_segmented); normalize(graph_segmented, graph_segmented, 0, 255, CV_MINMAX); // 归一化到[0,255]供显示 graph_segmented.convertTo(graph_segmented, CV_8U); // 数据类型转化成CV_8U型 // cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR); cv::namedWindow("graph_segmented", CV_WINDOW_KEEPRATIO); imshow("graph_segmented", graph_segmented); // 为selective search算法添加图割算法处理结果 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;addGraphSegmentation(gs); ss-&gt;addImage(src_img); // 添加待处理的图片 // 自定义策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(); // 颜色相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(); // 纹理相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(); // 尺寸相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(); // 填充相似度策略 // 添加策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill); // 合并以上4种策略 ss-&gt;addStrategy(sss); std::vector&lt;cv::Rect&gt; regions; ss-&gt;process(regions); // 处理结果 // 显示结果 cv::Mat show_img = src_img.clone(); for (std::vector&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r) &#123; cv::rectangle(show_img, *it_r, cv::Scalar(0, 0, 255), 3); &#125; cv::namedWindow("show_img", CV_WINDOW_KEEPRATIO); imshow("show_img", show_img); // -------忽略上述步骤，直接采用方便算法提取候选区域------------------------ /*************************************************************************** cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;setBaseImage(src_img); // 采用switch* functions提取候选区域 ss-&gt;switchToSelectiveSearchFast(); // 快速提取区域 std::vector&lt;cv::Rect&gt; rects; ss-&gt;process(rects); int nb_rects = 10; char c = (char)cv::waitKey(); while (c != 'q') &#123; cv::Mat wimg = src_img.clone(); int i = 0; for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it) &#123; if (i++ &lt; nb_rects) &#123; cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3); &#125; &#125; cv::namedWindow("Output", CV_WINDOW_KEEPRATIO); imshow("Output", wimg); c = (char)cv::waitKey(); if (c == 'd') &#123; nb_rects += 10; &#125; if (c == 'a' &amp;&amp; nb_rects &gt; 10) &#123; nb_rects -= 10; &#125; &#125; ********************************************************/&#125;int main(int argc, char *argv[])&#123; SSTest(); while (cv::waitKey(0) != 27) &#123;&#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法 switchToSelectiveSearchFast() 的参数。Shaun 的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在 Shaun 电脑上略显长。GitHub 上也有大神自己用 opencv 实现了该算法，参考 watanika/selective-search-cpp，该算法的参数感觉比 OpenCV 自带的 Selective Search 算法要好调一些，但优化效果没有 opencv 好，其运行时间在 Shaun 电脑上更长，毕竟 OpenCV 是 Intel 的亲儿子，Intel 肯定针对处理器对 OpenCV 底层做了一定的优化。参考资料[1] 论文笔记：Selective Search for Object Recognition（http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/）[2] Selective Search for Object Recognition(阅读)（http://blog.csdn.net/langb2014/article/category/5772811）[3] 论文笔记 《Selective Search for Object Recognition》（http://blog.csdn.net/csyhhb/article/category/6048588）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10以树形结构显示文件目录结构]]></title>
    <url>posts/c3f26b1.html</url>
    <content type="text"><![CDATA[前言 本文其实可以算是标题党，Windows本身并不能以树形结构显示文件目录结构，一般需要借助第三方工具（后面去网上搜索了一下，发现 Windows 居然也有一个 tree 命令 o(╯□╰)o），Windows 虽然能用命令行显示树形结构文件目录，但不像 Linux 那样可以输入一些参数控制其输出。Win10 有个特殊的功能，就是可以使用 Ubuntu 的 bash，只需要开启这个有趣的功能，就可以将 Win10 当 Ubuntu 使用，从而像 Linux 那样只输入相关命令即可显示树形结构文件目录。*注：值得注意的是 Win10 中的 bash 目前不支持中文输入，只能切换到英文输入才能正常输入。准备篇首先需要在 Win10 下开启 bash 功能。具体开启方法为：打开 Win图标 ==》 设置 ==》 更新和安全 ==》 针对开发人员（左侧），选中开发人员模式，打开 Win图标 ==》 设置 ==》 应用 ==》 应用和功能（左侧） ==》 程序和功能（最下面的相关设置中） ==》 启用或关闭Windows功能（左侧），选中适用于Linux的Windows子系统(Beta)后点击确定。重启计算机。打开 bash，打开 bash 的方法很多，这里列出三种：1、直接在微软小娜中输入关键字“bash”搜索 Bash on Ubuntu on Windows；2、Win键+R，输入 bash，点击确定即可打开 bash；3、Win键+R，输入 cmd，在 cmd 中输入 bash，回车即可打开 bash。打开 bash 后将会提示你是否下载安装 Ubuntu on Windows，输入 y 继续，稍等片刻即可完成下载安装。设置篇 安装完成后系统将会提示你设置用户名和密码。（如果这一步设置成功可以直接跳过设置篇直接看使用篇）。不知道怎的，Shaun 这一步没有完成，每次系统都是直接以 root 用户登录，而且没有密码，为了安全考虑，也幸好登录时是 root 用户，可以自由对系统修改。所以 Shaun 需要对 root 密码进行修改，并创建新的用户。具体过程需执行以下命令：root 用户下，修改用户密码：1passwd 用户名 (修改密码) 由于 Shaun 需要修改 root 密码，所以该用户名即为 root，执行之后需要输入新密码（在 *nix 哲学中，密码是不会显示在输入屏幕中的，所以如果在输入密码时发现屏幕没有任何变化是没关系的，只管输入即可 ↖(^ω^)↗），两次输入完成后会显示密码更新成功。接下来需要创建新的普通用户，在 root 用户下执行：1adduser xxx # 这样的命令会在home目录下添加一个帐号或者1useradd xxx #仅仅是添加用户，不会在home目录添加帐号 推荐使用前者，这样可以很明确已经成功创建新用户，而且如果用户需要存放一些文件也更安全和方便。 在 *nix 中，绝对不推荐直接使用root用户对系统执行各种命令，毕竟其权限太大，一旦误操作将造成无法挽回的后果。有些命令普通用户可能没有权限执行，这时需要提高其权限，普通用户临时获取 root 权限的方法为：在需要执行的命令前添加sudo，像上文中如果普通用户需要创建新用户 xxx 则需要执行sudo adduser xxx，执行以上命令后同样需要输入新用户的密码。使用篇 先切换至普通用户，执行su xxx切换用户，即可发现 shell 提示符由#变为$，前面的用户名由root变为xxx；执行cd ~切换至用户目录。由于 Ubuntu 系统中本身没有 tree 这个命令，需要执行以下命令安装 tree 命令工具：1sudo apt install tree 直接输入tree命令，系统将会自动以树形结构列出当前目录中所有文件及文件夹；执行tree -L N 命令，以树形结构查看当前 N 级的目录和文件，eg：以树形结构查看当前目录二级文件结构，则执行tree -L 2。若想将输出的2级文件结构保存至上一层文件的tree.txt文件中，可执行tree -L 2 &gt; ../tree.txt，进入上一层目录cd ..，打开 tree.txt 即可发现该目录的文件结构。后记 遇事还是需要多查证一下啊，想当然果然是会出问题的，文章开头差点就犯错误了 ~\(≧▽≦)/~。本文其实是在写 Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 时，为了方便显示输出文件结构而查找的相关资料。参考资料[1]linux tree命令以树形结构显示文件目录结构（http://jingyan.baidu.com/tag?tagName=linux）[2] win tree命令 tree导出目录 tree显示树形结构（http://jingyan.baidu.com/tag?tagName=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F）[3] win10下linux系统的安装（开启）和使用[4] Ubuntu建立和删除用户[5] linux修改root密码和linux忘记root密码后找回密码的方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACGN作品个人印象简评]]></title>
    <url>posts/68065b99.html</url>
    <content type="text"><![CDATA[前言 Shaun 无意向任何人推荐任何东西，毕竟那个年纪已经过去了，有些东西还是独自品味比较好，写这些东西只是单纯的想留个纪念。本文主要是分享一下 Shaun 看过的一些 ACGN 作品及相应的感觉感受，也算是记录一下，以免雁过不留痕，看过的就这样看过了。以下作品只是简单排列，没有的所谓的排名之分，只凭个人当时主观印象深浅，简单来说就是想到哪就写到哪。※注：本文所指的 ACGN 只是单纯的指 Animation（动画）、Comic（漫画）、Game（游戏）、Novel（小说）四个独立并列的部分，不是通俗意义上霓虹国的那种紧密联系的一个整体。Animation 篇 动画，真正接触霓虹国的动画还是在中学时代吧，那时也是在同学的推荐下入坑了「火影」（直到现在都还没去看结局，虽然前年就完结了），当时完全接受不了「海贼王」的画风，还是后来画了一个暑假追上来的。『海贼王』。Shaun 偏向于「海贼王」这个译名，个人感觉顶上战争之前和顶上战争之后完全是两部作品，还是觉得顶上战争之前比较好看，之前就像是游戏里打怪升级，能过些热血的瘾，但之后变成了只打怪不升级，而且感觉怪是强行被画败的 ╮(╯▽╰)╭，海贼王里还有个奇怪的现象，好像几乎不死人，不过也可能是侧重点不同，死人的场景没必要画出来了。『CLANNAD』。CL 或许能称作为人生，但人生却不是一部 CL，毕竟人生不可能有光玉存在，看完『AIR』之后，Shaun 并没有什么很强烈的感触，所以直接又接着看了 CL，没想到着实让 Shaun 这堂堂七尺男儿好生体验了把热泪盈眶的感觉。另，CL 和 Air 的音乐也很赞，麻枝准真提莫的不负其大魔王的称号 （°Д°）Ъ。『天降之物』。算是 Shaun 的入宅作了吧，没想到当时霓虹国的肉番也能做的这么精良，这里不得不赞一下「天降之物」的制作组，实在是太良心了，都破产了，还硬是把结局用 屁屁踢 形式放出来了，对比隔壁的『约会（pao）大作战』，可以说是有生之年了 ╮(╯▽╰)╭，不过还是比现在的肉番要好，现在的肉番只剩下肉了，还不如直接出里番 ๑乛◡乛๑ 。『进击的巨人』。Shaun 只能说制作组的经费别烧的那么快啊，不然可能又是一个有生之年，感觉每一帧都在烧钱。坐等同样制作精良的今年4月番『东京喰种』第三季 (๑´ڡ`๑) ，坐等个屁啊，『东京喰种』第三季这屎一样的剧情和画风 （╯‵□′）╯︵┴─┴，做成这样宁愿是个有生之年，还是滚去看看漫画是什么样子吧，希望 7 月番的「巨人」不要这样。『龙珠』系列。童年回忆啊，虽然目前还在更「龙珠超」，但是已经找不到童年时的感觉了。『犬夜叉』。虽说中学时代就听童靴讨论过，但 Shaun 真正接触还是在本科时代，剧情设计的很好，音乐也很赞。『死神』。感觉打完蓝染之后直接结束还是一部很好的作品。『新世纪福（quan）音（qian）战士』。以当时的社会环境看应该是很黄很暴力了，如果没看过TV版的EVA，直接看剧场版就行，剧场版差不多就是TV版的高清重制，虽然重制的画面很良心，但这也改变不了其圈钱的本质，你要出个正儿八经的完结篇或者对剧情进行完善补充该多好。『浪客剑心』。个人觉得TV版打败志志雄就可以结束了，「追忆篇」也十分不错，「巴」和「熏」都可以说是剑心的救赎者。『钢之炼金术师FA』。Shaun 没看过 03 版的钢炼，只能说 FA 不管是音乐还是剧情都堪称完美（Shaun 不知道真正的完美应该是什么样子），塑造的人物都有血有肉。『噬魂师』。这部动画的结局骨头社也做的太水了 o(︶︿︶)o，不然也是一部上佳之作。『瑞克和莫蒂』。很有意思的美漫，各种天马行空的想象，对一些事物的毒舌吐槽也无敌了 (≧ω≦)。『魔法少女小圆』。其实一开始要 Shaun 看魔圆， Shaun 是拒绝的，因为一听名字就以为是什么少女漫 (#-_-)，后面看了一下又没法接受那奇诡的画风，尤其是魔女出来的时候，卧槽，这 TM 是啥么鬼 (⊙_⊙)？后面无聊的时候看了几集勉强就能接受了，不过说好的要做「爱的战士」呢？结局就这样？(╯°□°）╯︵ ┻━┻，还好剧场版稍微补充了一下，音乐也很好听。美好的事物表面可能隐藏着最深的邪恶，丑陋的事物表面也可能隐藏着无尽的美好，当然，对于宇宙维稳来说，QB 的做法没错，但对于马猴烧酒来说，这就很残忍了，但人类也不会在意蝼蚁的想法吧，所以与其说是悲剧，不如说是真实，正如结局魔女是不存在了，但其它的魔物出现了。『零之使魔』。其实 Shaun 是看完「夏娜」第一季之后看的，虽说夏娜和露易丝的都是钉宫配的，但个人感觉还是露易丝萌一点呢 ～(￣▽￣～)，才人万人斩那里的 BGM 实在是斯巴拉西，最后居然不是后宫，啊啊啊 🔥，可惜了蒂法那么大的欧派了，说好的 naizi 即正义呢 _(:з」∠)_。『Angle Beats!』。AB 是曾经的一个室友推荐看的，说实话不知道是 Shaun 没看懂还是咋的，没看出什么名堂啊，只能说 OP 很赞。『潜行吧！奈亚子』。吐槽能力很有意思啊，还有全宇宙最长的呆毛，可以说很萌了，搞不懂为啥会被禁，难道是奈亚子表达爱意的方式太露骨了 (ಡωಡ)。『夏洛特』。网易云音乐推荐的，ED 很好听啊，看了动画只记得主角好像把全世界的超能力都吸收了，其它的剧情也不记得了，初次看到奈绪的图片还以为是奈亚子（雾）。『紫罗兰永恒花园』。个人还是有点无法体会剧中的感情，只能说画面做的很精致。一开始还以为是神马科幻战争片，毕竟女主的手摆在哪里 （雾）。『少女终末旅行』。也是网易云推荐的，主要是第五集的插曲很好听呢，以一种轻松的心态看这种沉重的番另有一番滋味。emmm……，知道漫画的结局之后还是感觉很沉重，（哇的一声就哭了 😭），这或许就是最深的绝望了吧，堪比「迷雾」，想必漫画作者的刀片应该收了不少呢，（突然黑化 ヾ(▼ﾍ▼；)ｵｲｺﾗ）。其实第 9 集的ED也很好听，可惜 OST 没有收录，MMP，只能截取音频听听了。『来自深渊』。不行，刚看完「末旅」，心情太沉重了，要看点稍微轻松的冷静一下，抚慰一下 Shaun 受伤的心灵，「深渊」虽然相比日常番还是沉重一些，但至少不绝望，感觉还是有 “希望” 的，期待下一季。『宝石之国』。骨肉魂的设定很有意思，只记得第九集台词老师说：“强大的力量总伴随着孤独”，也正如「B站」下的某个评论所说：“或许这就是成长所需要的代价”。个人感觉人的成长也是如此，成长意味着不再天真，不再给别人添麻烦，但这中间会失去许多，人与人之间的隔阂也越来越大，至于是好事还是坏事就只有自己知道了，有些东西只有直接接触之后才知道是好是坏。成长之后就会自然而然的开始求真，当然有很大一部分人会在求真之路上迷失自我，继续浑浑噩噩，却又不似初始的天真，而是成为一种活死人状态，成为社会这个大机器上的一个微小零件，少一个不少，多一个也不多。如果说第一季是成长之路，那下一季应该就是求真之路了。『滑头鬼之孙』。百鬼夜行时的 BGM 很赞呀！只怕是天国的第三季了。『Kill La Kill』（又名双斩少女、斩服少女）。emmm，这中文名怎么说呢，其实还挺符合剧情的，但总感觉哪里不对。作为一部热血番，剧情 bug 一点也可以理解，想必「真子」为这番拉了不少人气（官方鬼畜代表，好萌 ╭(╯3╰)╮）。『恶魔人 Crybaby』。地狱空荡荡，恶魔在人间，达成成就在恶魔人里看恶魔人，音乐很带感，rap 也很棒，愚昧的人做出的恶行更让人感到可悲。『NEW GAME!』。作为一名即将成为社畜的秃头人，希望能碰到不错的上司和同事吧。Comic 篇 漫画，Shaun 看的比较少，了解也不多，就不做评价了。印象里比较深的就是『伊藤润二』系列中的「漩涡」了，看完这个 Shaun 只能感叹作者的奇思妙想了。还有就是当年在追三大民工漫的时候，有时为了提前了解剧情，也会去看一下其漫画。当然偶尔也会看一下那个，，，那种漫画 (⁄ ⁄•⁄ω⁄•⁄ ⁄) ，毕竟刺激性更强，画面感更强，像那个「搞笑漫畫日和」什么的（诶，在想什么呢 (￣ε(#￣)☆╰╮(￣▽￣///)）。Game 篇 游戏，Shaun 也玩的比较少，小时候在小伙伴家里偶尔会蹭一下 FC 游戏，中学时陪同学玩街机，也两下子就把游戏币给玩没了 Σ(ﾟдﾟ;)，大学时玩通两三个单机，专注的玩了一个手游，至于什么网络游戏就根本没玩过，Shaun 还是偏向于动作冒险类游戏。『奥日与黑暗森林』（Ori and the Blind Forest）。巨硬出品，必属精品，不管是画质，画风，音乐都是五星好评，但是手残党伤不起啊，有些关卡的难度简直是阶跃性的 /つ∇T)。期待续作『奥日与精灵意志』（Ori and the Will of the Wisps）。『鬼泣』系列（Devil May Cry）。这个系列 Shaun 没一个通关的，只是稍微玩过一下，不得不说卡普空公司虽然经常炒冷饭，但是其制作也确实精良，可以说是动作类游戏的代表作了，打击感和连招特效都超带感，dei劲，以后有时间再给它通关。『艾希ICEY』。算是国产游戏的佳作了，只是碍于其独立游戏的经费，最大的不足之处就是其体量也太小了吧，两个小时打通绰绰有余，而且通关之后就没有欲望玩第二次了，玩法比较单一。『菲斯 Fez』。「纪念碑谷」就是受到这款游戏的启发，其中的一些玩法和游戏元素也借鉴了这款游戏，这款游戏简直太斯（sang）巴（xin）拉（bing）西（kuang），还有依靠 BGM 解谜的，这种操作还真没见过（也有可能是 Shaun 游戏玩的太少了 o(╯□╰)o），这是 Shaun 玩的第一个多周目游戏，每周目都会有新的体验，而且这游戏的世界观真是惊人，数学中的维度在这游戏里面会有一种非常直观的体验，尤其是每周目结束时的剧情动画。Novel 篇 小说，也算是中学时代入的坑吧，在本科前两年达到顶峰，目前处于逐渐退坑的状态，一来确实是没有什么小说吸引 Shaun 了；二来是没那么多时间看小说了。『驭兽斋』，作者：雨魔。可以算是 Shaun 这么多年的网络小说生涯的入坑之作了，现在虽然剧情忘记了，但当年看的如痴如醉的感觉却没忘。『仙逆』，作者：耳根。还是当年在小白时代看的，可以说印象非常深了，个人感觉「凡人修仙传」和它没法比。『幽冥仙途』，作者：减肥专家。这个是 Shaun 渡过小白时代书荒的时候在书荒吧看到别人推荐的，这简直是暗黑系的典范，或许李珣的人生才是人生该有的样子。『贩罪』，作者：三天两觉。很有意思的写法，各种插叙蒙太奇手法，画面感极强，作者的吐槽能力MAX啊。『死人经』，作者：冰临神下。Shaun 武侠小说看得极少，像什么金庸、古龙等人的小说 Shaun 一部也没看看过，只是看过相关的影视作品，但这部小说确实 Shaun 痴迷的看完了，虽然以当前的眼光看其好像还是有点金庸那种 “掉进悬崖就能得到绝世武功” 的味道，但是主角却还是慢慢成长变化的，并不是一触而就的状态。『亵渎』，作者：烟雨江南。这本书还是 Shaun 入坑时期看的，所以一些剧情完全忘记了，只记得有一只很有意思的骷髅。回想当年看书真是不挑剔啊，无论什么书，只要知道个名字就会去看完，也是在那段时间，把番茄、唐三、辰东等的作品都看完了，也逐渐脱离小白时代，不得不说，当年这些作品对 Shaun 三观的形成还是有很大影响的。另外以现在的眼光来看就是感觉这些作者的作品只需要选择一本代表作看看就行（eg：唐三（斗罗大陆）、土豆（斗破苍穹）、番茄（盘龙）、辰东（神墓）），毕竟一个作者的风格确实很难改变，其它的也是差不多的套路，一般来说一个作者因一部作品封神之后，很难再写出超越之作，从某种意义上来说这并不是江郎才尽，而只是人只有在特定的时候才能有特定的想法，发挥比较好而已。『 无极魔道』，作者：逆苍天。后期书荒时偶然看到的，没想到还是一部很不错的作品，快意恩仇，最后居然把所有人都坑杀了。『庆余年』，作者：猫腻。也是后期书荒看，本来 Shaun 是不大想看这种架空历史小说的，但是看了之后感觉里面的权谋很有意思。『紫川』，作者：老猪。这本书 Shaun 没读完，主要是当时的状态不适合看这本书，里面有些情节以当时的状态实在是没法看下去。『佣兵天下』，作者：说不得大师。这本书也是 Shaun 小白时代看的，记得这本书当年好像是在看完「静官」的『兽血沸腾』之后看的，当时只感叹其友情。『诛仙』，作者：萧鼎。以 Shaun 现在的眼光来看感觉有点名过其实。『鬼吹灯』，作者：天下霸唱。这本书 Shaun 也没看完，其实 Shaun 是先看的『盗墓笔记』，后面才去看鬼吹灯，所以也稍微了解了一下这两部作品的渊源，个人感觉，盗墓笔记还是很大一部分借鉴了鬼吹灯，而且盗墓笔记感觉后面有点胡乱写的味道。『恶魔法则』，作者：跳舞。Shaun 小白时代看的作品，剧情也全都忘记了，不做评价，依稀记得好像有点搞笑。『七界传说』，作者：心梦无痕。算是 Shaun 看的第一本这种风格的小说——主人公刚出山就差不多是无敌之姿了，后期的对手也不是庸人，感觉十分有意思。『升邪』，作者：豆子惹的祸。读起来感觉很轻松的一本小说。『宠魅』，作者：鱼的天空。记得当时看这本小数是为了找一本类似于 驭兽斋 描写宠物的小说，于是就找到了这本，感觉结局还是有点虐心，现在想起来还是有点不好受。『长生不死』，作者：观棋。里面的计谋还是很有意思，居然用传销之法颠覆一个国家的经济，好像是的吧。『风姿物语』，作者：罗森。不愧是誉为“现代玄幻小说鼻祖”的网文，后面玄幻小说的模式或多或少都能在这里看到影子。作者也真是个人才，不仅正经的网文写的不错，而且小 h 书也写的很溜，像小黄书中的典范，「阿里布达年代祭」和「六朝」系列等。『星空倒影』，作者：弦歌雅意。很有意思的写作角度，从旁观者的角度见证英雄的大起大落，虽说整个故事和其它的西幻套路差不多，但胜在短小精悍，角度新颖。『仙路烟尘』，作者：管平潮。很有古典仙侠意味的一部的小说，作者的文采也是一流的，但对主角性格把控的不是很到位，导致有些章节读起来有点突兀，不是那么连贯。后记 以后有看过或回想起看过的作品再继续更新吧 （↖(^ ω ^)↗）。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加站内本地搜索]]></title>
    <url>posts/4f6225b7.html</url>
    <content type="text"><![CDATA[前言 虽然 Shaun 博客目前数量不多，质量也不高，但抱着搞事的心态，先弄它一个站内本地搜索再说。准备篇 要想使用本地搜索功能，首先需要安装相应的搜索插件 hexo-generator-searchdb，网上可能大多数用的是 hexo-generator-search 这个插件，也有都装的，但 Shaun 就只安装这一个了，好像 hexo-generator-searchdb 更完善一点，由于 Shaun 前端接触的极少，所以就没有一一对比了，网上也没查到具体对比情况，有兴趣的童靴可以试试 (╯▽╰)。至于具体安装如下，在站点根目录执行：1npm install hexo-generator-searchdb --save 安装完之后重新生成页面，将会发现 public文件夹 下多出一个 search.xml 文件。然后在配置文件 _config.yml 中添加：1234# 站点本地搜索search: path: search.xml field: all其中：path - 指定生成的索引数据的文件名。默认为 search.xml 。field - 指定索引数据的生成范围。可选值包括：post - 只生成博客文章（post）的索引（默认）；page - 只生成其他页面（page）的索引；all - 生成所有文章和页面的索引。 至于是在 主题配置文件，还是在 站点配置文件 中添加，个人觉得都没关系，附：Shaun 是在主题配置文件中添加的。接下来就需要修改原主题的代码了。改码篇 由于 Shaun 博客主题是基于 SPFK 对照着 black-blue 进行修改的，而且因为 black-blue 是有搜索的（Shaun 不知道 black-blue 主题的作者是如何完成的，借助了什么技术），所以 Shaun 就看 black-blue 的搜索功能是修改了 SPFK 哪个地方，再将相应的代码添加至 SPFK 中（其中相应的代码来自让 Hexo 博客支持本地站内搜索），从而逐渐完成本次搜索功能。首先找到 spfk 主题下的 left-col.ejs 文件，对其修改如下：123456789101112&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot;&gt; &lt;/form&gt; --&gt; &lt;form id=&quot;search-form&quot;&gt; &lt;!-- 搜索框相关 --&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;Search...&quot; class=&quot;search form-control&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot;/&gt; &lt;i class=&quot;fa fa-times&quot; onclick=&quot;resetSearch()&quot;&gt;&lt;/i&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;/form&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;p class=&apos;no-result&apos;&gt;No results found &lt;/p&gt; &lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt; &lt;%&#125;%&gt;其次找到 spfk 主题下的 after-footer.ejs 文件，将其修改如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125; &lt;/script&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 激活搜索框时才搜索 var inputArea = document.querySelector(&quot;#local-search-input&quot;); var getSearchFile = function()&#123; // 调用搜索函数 var search_path = &quot;&lt;%- config.search.path %&gt;&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;&lt;%- config.root %&gt;&quot; + search_path; searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;); &#125; inputArea.onfocus = function()&#123; getSearchFile() &#125; // 搜索重置 var $resetButton = $(&quot;#search-form .fa-times&quot;); var $resultArea = $(&quot;#local-search-result&quot;); inputArea.oninput = function()&#123; $resetButton.show(); &#125; resetSearch = function()&#123; $resultArea.html(&quot;&quot;); document.querySelector(&quot;#search-form&quot;).reset(); $resetButton.hide(); $(&quot;.no-result&quot;).hide(); &#125; // 屏蔽回车 inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125; // 无搜索结果 $resultArea.bind(&quot;DOMNodeRemoved DOMNodeInserted&quot;, function(e) &#123; if (!$(e.target).text()) &#123; $(&quot;.no-result&quot;).show(200); &#125; else &#123; $(&quot;.no-result&quot;).hide(); &#125; &#125;) // 搜索函数 var searchFunc = function(path, search_id, content_id) &#123; &apos;use strict&apos;; $.ajax(&#123; url: path, dataType: &quot;xml&quot;, success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( &quot;entry&quot;, xmlResponse ).map(function() &#123; return &#123; title: $( &quot;title&quot;, this ).text(), content: $(&quot;content&quot;,this).text(), url: $( &quot;url&quot; , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function()&#123; var str=&apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;/&quot;+ data_url +&quot;&apos; class=&apos;search-result-title&apos; target=&apos;_blank&apos;&gt;&quot;+ &quot;&gt; &quot; + data_title +&quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace(regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot;+keyword+&quot;&lt;/em&gt;&quot;); &#125;) str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content +&quot;...&lt;/p&gt;&quot; &#125; &#125; &#125;) $resultContent.innerHTML = str; &#125;) &#125; &#125;) &#125; &lt;/script&gt;&lt;%&#125;%&gt;最后找到 spfk 主题下的 main.styl 文件，在其末尾添加：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*搜索框*/.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid #d3d3d3; border-radius: 2px; opacity: 0.65; background: none;&#125;.search:hover &#123; border: 2px solid #d3d3d3; opacity: 1; box-shadow: 0 0 10px rgba(0,0,0,0.3);&#125;/*搜索重置按钮*/#search-form .fa-times &#123; display: none; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0,0,0,0.15); cursor: pointer; color: #4094c7;&#125;#search-form .fa-times:active &#123; background: #d3d3d3;&#125;#search-form .fa-times:hover &#123; zoom: 1.1; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0,0,0,0.25);&#125;/*搜索结果区*/#local-search-result &#123; //margin: auto -12% auto -6%; margin: 0; font-size: 0.9em; text-align: left; word-break: break-all; box-shadow: 4px 4px 6px rgba(0,0,0,0.46);&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*单条搜索结果*/#local-search-result li &#123; margin: 0.5em auto; border-bottom: 2px solid #d3d3d3;&#125;#local-search-result .search-result-list li:hover &#123; background: rgba(47,46,46,0.8); box-shadow: 0 0 5px rgba(0,0,0,0.2);&#125;/*匹配的标题*/#local-search-result a.search-result-title &#123; line-height: 1.2; font-weight: bold; color: #4094c7;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; line-height: 1.2em; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #ffffffb3;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 1em;&#125;/*无匹配搜索结果时显示*/p.no-result &#123; display: none; margin: 2em 0 2em 6%; padding-bottom: 0.5em; text-align: left; color: #808080; font-family: font-serif serif; border-bottom: 2px solid #d3d3d3;&#125; 这里请注意，当对 main.styl 文件做以上修改时，可能会发现有两个 .search 样式，而且相差不大，这时，不要对其原有的 .search 进行修改，更不要去注释掉它，只做上述修改就不用管了，不然可能会发生一些奇怪的事 o(&gt;﹏&lt;)o。Shaun 当时做以上修改时，将其原有的 .search 样式注释掉之后，整个页面的 css 布局全部都乱了 (╯﹏╰)，不知道为什么 (⊙_⊙?)，这两个同名样式看起来明明差不多的，最后只能维持现状了，等以后有机会再看看吧，业余前端伤不起啊! ╮(╯_╰)╭。 至此整个站内本地搜索功能基本完成，勉强可以使用站内搜索功能了。问题篇 *注：以下问题于 2018-03-02 都已经解决 ╮(╯▽╰)╭。1、搜索函数返回的 url 地址有问题。 问题描述：当点击搜索结果时，新弹出的标签页地址栏中 url 地址会有部分乱码情况；当鼠标移到搜索的结果列表上时，浏览器左下角显示的 url 地址虽然没有乱码情况，但其中有一个重复的/符号。所幸这两个问题并没有造成浏览器解析错误，浏览器还是可以正常显示页面的。================= 修改日期：2018-03-02 ================= 解决办法：将 \blog\node_modules\hexo-generator-searchdb\templates\xml.ejs 文件中的 &lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;/url&gt; 修改为 &lt;url&gt;&lt;%- encodeURI(post.path) %&gt;&lt;/url&gt; ，使其中一些 url 中常见的字符（如：&amp;, ?, /, =）不被十六进制的转义序列进行替换。参考：escape,encodeURI,encodeURIComponent有什么区别? 和 JavaScript encodeURIComponent() 函数 。=====================================================2、搜索结果区布局有问题。 问题描述：当显示搜索结果时，搜索结果区会上下扩张，从而将其上下本来存在的一些布局挤开，造成布局混乱。这其实不算是一个 spfk 主题或者新添加的搜索功能的问题，而是新添加的一个东西又没有相应的和原本布局结合的布局文件，那就极大可能会有布局混乱的问题，至于这个要和原本布局契合的搜索结果区布局文件就只有等 Shaun 以后有机会有时间再完善去喽 ╮(╯▽╰)╭。3、搜索框激活问题。 问题描述：搜索框激活延迟很大，有时过很久或者需要切换站内页面它才能激活，给人的感觉就是好像没有搜索功能似的。添加搜索框激活功能据作者 MOxFIVE 所说是为了不让索引文件影响页面加载速度，MOxFIVE 同时也在文末指出了一些不足之处，如果索引文件太大，可能还是会造成一些问题，但 Shaun 的博客数量又不多，所以估计还是 Shaun 的代码混合问题，而且 MOxFIVE 的博客搜索功能好像没这个问题（至少 Shaun 目前没发现）。这个问题同样只有等以后再说了 (*^__^*) 嘻嘻……。后记 本文添加的本地搜索还很粗糙，还有很多地方需要以后去完善。但这好歹是一个好的开始，搜索功能至少勉强能够正常使用，总比以前是个空壳要好，以后有机会再慢慢去去完善吧 ↖(^ω^)↗。参考资料[1] jQuery-based Local Search Engine for Hexo（http://www.hahack.com/categories/codes/）[2] 让 Hexo 博客支持本地站内搜索（http://moxfive.xyz/tags/Hexo/）[3] Hexo博客添加站内搜索（https://www.ezlippi.com/categories/hexo/）[4] Hexo本地搜索及部分SEO优化 （https://www.oyohyee.com/categories/Note/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用OpenCV显示OpenGL图形]]></title>
    <url>posts/302a6244.html</url>
    <content type="text"><![CDATA[前言 本文就是一个小实验，试验 OpenCV 到底能不能支持 OpenGL 图形显示。正文 如果在 OpenCV 用 CMake 编译时勾选 WITH_OPENGL 且编译一切顺利的话，编译和配置的具体步骤和情况可以看 Shaun 写的一篇文档：Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 ，那么就可以用 OpenCV 窗口显示 OpenGL 图形。 在 VS 下使用 Windows 原有的 OpenGL 函数需要包含以下头文件和库文件：123456#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib") 在 OpenCV 中显示 OpenGL 图形需要 cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL)，在 namedWindow 函数中添加 cv::WINDOW_OPENGL 参数说明该窗口支持 OpenGL 图形。附示例程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;opencv.hpp&gt;#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib")static const float vertex_list[][3] =&#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;;// 将要使用的顶点的序号保存到一个数组里面 static const GLint index_list[][2] =&#123; &#123; 0, 1 &#125;, &#123; 2, 3 &#125;, &#123; 4, 5 &#125;, &#123; 6, 7 &#125;, &#123; 0, 2 &#125;, &#123; 1, 3 &#125;, &#123; 4, 6 &#125;, &#123; 5, 7 &#125;, &#123; 0, 4 &#125;, &#123; 1, 5 &#125;, &#123; 7, 3 &#125;, &#123; 2, 6 &#125;&#125;;static float rotate = 0;static int times = 0;GLint windowWidth = 800;GLint windowHeight = 800;GLfloat xRotAngle = -75.0f;GLfloat yRotAngle = 0.0f;GLfloat zRotAngle = -135.0f;float MIN_X = -200;float MAX_X = 200;float MIN_Y = -200;float MAX_Y = 200;float MIN_Z = -200;float MAX_Z = 200;GLfloat coordinatesize = 200.0f;GLfloat ratio = 1;void drawLine(float x1, float y1, float z1, float x2, float y2, float z2)&#123; glBegin(GL_LINES); glVertex3f(x1, y1, z1); glVertex3f(x2, y2, z2); glEnd(); glFlush();&#125;// 绘制立方体void DrawCube(void)&#123; int i, j; glBegin(GL_LINES); for (i = 0; i &lt; 12; ++i) // 12 条线段 &#123; for (j = 0; j &lt; 2; ++j) // 每条线段 2个顶点 &#123; glVertex3fv(vertex_list[index_list[i][j]]); &#125; &#125; glEnd(); glFlush();&#125;void reshapeOperate()&#123; glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (ratio &lt; 1) glOrtho(-coordinatesize, coordinatesize, -coordinatesize / ratio, coordinatesize / ratio, -coordinatesize, coordinatesize); else glOrtho(-coordinatesize*ratio, coordinatesize*ratio, -coordinatesize, coordinatesize, -coordinatesize, coordinatesize); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void reshape(int w, int h) &#123; if ((w == 0) || (h == 0)) return; glViewport(0, 0, w, h); ratio = (GLfloat)w / (GLfloat)h; reshapeOperate();&#125;GLfloat AngleX = 45.0f;GLfloat AngleY = 315.0f;void reshape1(int w, int h)&#123; GLfloat aspect = (GLfloat)w / (GLfloat)h; GLfloat nRange = 100.0f; glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式 glLoadIdentity(); //设置三维投影区 if (w &lt;= h) &#123; glOrtho(-nRange, nRange, -nRange * aspect, nRange * aspect, -nRange, nRange); &#125; else &#123; glOrtho(-nRange, nRange, -nRange / aspect, nRange / aspect, -nRange, nRange); &#125;&#125;void onDraw(void*)&#123; // Draw something using OpenGL here //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清除所有的像素 //glMatrixMode(GL_MODELVIEW); //glLoadIdentity(); //glPushMatrix(); ////glTranslatef(-0.2, 0, 0); // 平移 ////glScalef(2, 1, 1); // 缩放 //glRotatef(xRotAngle, 1.0f, 0.0f, 0.0f); //glRotatef(yRotAngle, 0.0f, 1.0f, 0.0f); //glRotatef(zRotAngle, 0.0f, 0.0f, 1.0f); //glColor3f(1, 0, 0); //drawLine(0, 0, 0, MAX_X, 0, 0); //x轴 //glColor3f(0, 1, 0); //drawLine(0, 0, 0, 0, MAX_Y, 0); //y轴 //glColor3f(0, 0, 1); //drawLine(0, 0, 0, 0, 0, MAX_Z); //z轴 //times++; //if (times &gt; 1) //&#123; // times = 0; //&#125; //if (times % 1 == 0) //&#123; // rotate += 0.3; //&#125; //glRotatef(rotate, 0, 1, 0); //glRotatef(rotate, 1, 0, 0); //glColor3f(0, 1, 1); //DrawCube(); //glPopMatrix(); reshape1(windowWidth, windowHeight); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); AngleX++; AngleY++; glPushMatrix(); &#123; glRotatef(AngleX, 1.0f, 0.0f, 0.0f); glRotatef(AngleY, 0.0f, 1.0f, 0.0f); glBegin(GL_POLYGON); //前表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)0);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)255);//颜色设置为白色 glVertex3f(-50.0f, 50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //后表面 glColor3f(0.0f, 1.0f, 1.0f);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3f(0.0f, 1.0f, 0.0f);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //上表面 glColor3d(0.0, 1.0, 1.0);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3d(1.0, 1.0, 1.0);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3d(1.0, 0.0, 1.0);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3d(0.0, 0.0, 1.0);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //下表面 glColor3ub(0u, 255u, 0u);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub(255u, 255u, 0u);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub(255u, 0u, 0u);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub(0u, 0u, 0u);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //左表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)255);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)0);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //右表面 glColor3f(1.0f, 0.0f, 1.0f);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(1.0f, 0.0f, 0.0f);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glEnd(); &#125; glPopMatrix();&#125;void opencvWithOpenGLTest()&#123; std::string openGLWindowName = "OpenGL Test"; cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL); cv::resizeWindow(openGLWindowName, windowWidth, windowHeight); cv::setOpenGlContext(openGLWindowName); cv::setOpenGlDrawCallback(openGLWindowName, onDraw, NULL); while (cv::waitKey(30) != 27) &#123; cv::updateWindow(openGLWindowName); // when needed &#125;&#125;int main(int argc, char *argv[])&#123; opencvWithOpenGLTest(); return 0;&#125;运行成功后可看到一个旋转的彩色立方体。结论 从实验结果来看，OpenCV 确实能支持 OpenGL 图形的显示，但其不足之处也很明显：没有提供鼠标和键盘的交互操作（可能是 Shaun 还没发现，毕竟只是尝试一下看它能不能显示），仅仅只是提供一个显示窗口。如果真想用 OpenGL 做一些好玩的东西，还是用 glut 和 glew 吧，不过 glut 已经停止更新许久，glew 在调试时可能会出现一些莫名其妙的错误，所以网上有人用 freeglut 代替 glut，glee 代替 glew，具体的东西 Shaun 也没试过，Shaun 目前还没做过 OpenGL 相关的事，这次用 OpenCV 显示 OpenGL 图形纯粹是为了好玩 (*^__^ *) 嘻嘻……。后记 本篇文档也是上次编译配置完 OpenCV-3.2 后做的一次小实验，但当时并没有记录，所以还有一些参考资料也已经不知道了 :-(。参考资料[1] OpenCV学习笔记（六十一）——建立支持OpenGL的OpenCV工程“Master OpenCV”chp.3（http://blog.csdn.net/yang_xian521/article/category/910716）[2] 几个opengl立方体绘制案例（http://blog.csdn.net/bcbobo21cn/article/category/3104565）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>opengl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0]]></title>
    <url>posts/7df528b4.html</url>
    <content type="text"><![CDATA[Shaun 的系统环境：Win10_x64 英文企业版；VS2013-update5 英文旗舰版；CMake-3.6.3-win64-x64 免安装版；Qt-opensource-windows-x86-msvc2013-5.6.2。 *注：Shaun 写的这篇文档主要用来编译 x86 版的动态 debug 库，想编译其它类型的库请自行参考其它资料，做相关改变。（ 其实如果想编译 x64 版的可以在用 VS2013 编译时将上方的 Win32 平台选择 x64 平台；想编译 release 版的可以在用 VS2013 编译时将上方的 Debug 模式选择 Release 模式；想编译静态库的可以在用 CMake 生成时取消勾选 BUILD_SHARED_LIBS 选项即可。:-P ）前言 因为 OpenCV-3.2 官方的 release 版只有支持 VS2015 的库，而且不包括扩展包（ opencv_contrib ）中的库，而由于某些历史原因，Shaun 目前使用的编译器还是 VS2013，又想用用扩展包中一些有趣的算法，在加上上个月 opencv-3.3 还没有正式 release，所以上个月 Shaun 就利用 VS2013 对 opencv-3.2 进行编译。具体编译过程如下：准备篇 先在 GitHub 上下载对应的 opencv 源码包：opencv-3.2.0 和 opencv_contrib-3.2.0（https://github.com/opencv），扩展包版本一定要和 opencv 版本相同。Shaun 为了添加 Qt 后端显示支持（为了好看和方便 :-P），所以还下载安装了支持 VS2013 的 Qt-5.6.2（http://download.qt.io/archive/qt/）。再下载 CMake-3.6.3-win64-x64 免安装版（https://cmake.org/files/）。至于微软的东西，推荐直接去 MSDN 我告诉你去下载。 由于网上有的资料（具体是哪篇文章 Shaun 忘记了 o(╯□╰)o）说编译时的文件结构可能会影响编译是否成功，再加上为了方便编译管理，Shaun 编译时的文件结构为：opencv-3.2.0_build├── build└── sources​ ├── opencv-3.2.0​ └── opencv_contrib-3.2.04 directories, 0 files其中 opencv-3.2.0 用来装 opencv-3.2.0.zip 解压后的源码；opencv_contrib-3.2.0 用来装opencv_contrib-3.2.0.zip 解压后的源码；build 用来装 CMake 编译完成后的文件。编译篇 打开 /cmake-3.6.3-win64-x64/bin/cmake-gui.exe，在 Where is the source code 文本框中选择 /opencv-3.2.0_build/sources/opencv-3.2.0；在 Where to build the binaris 文本框中选择 /opencv-3.2.0_build/build，点击 Configure，在弹出的编译器选择框中选择 Visual Studio 12 2013，一直 Configure 直到红色的条变白。 网上有人在这一步可能会出现ffmpeg not downloaded和“ippicv_windows_20151201.zip”not downloaded这两个问题，Shaun 没出现这两个问题，所以没有机会验证 cmake-gui和vs2013编译opencv和opencv_contrib源码 中的解决办法是否正确。 接下来就是添加扩展包，在白色条中找到 OPENCV_EXTRA_MODULES_PATH 文本框，在其中选择 opencv_contrib 源码中 modeles 所在路径：/opencv-3.2.0_build/sources/opencv_contrib-3.2.0/modules。 至于想要支持 OpenGL 和 Qt 就需要勾选 WITH_OPENGL 和 WITH_QT 并 Configure 后选择好 Qt 的安装目录，如果配置好 Qt 的环境变量 Cmake 将会自动选择好 Qt 所在路径。 随后再次反复 Configure 直到界面不再出现红色背景，之后单击 Generate。不出意外的话，你会看到 Configure done 和 Generate done。 Shaun 在这一步出现了 VS2013_CMake_opencv3.1动态库与静态库的配置与编译 中的问题，原因是同时勾选了同时勾选了 BUILD_opencv_world 和 BUILD_opencv_contirb_world，Shaun 的解决办法是将它们全部取消勾选，再次 Configure 和 Generate。 如果上面一切顺利的话就可以进行下一步了：使用 VS2013 编译 OpenCV。打开 /opencv-3.2.0_build/build 目录，将会看到一大堆文件和文件夹，双击 /opencv-3.2.0_build/build 目录下的 OpenCV.sln，用 VS2013 打开。找到 CMakeTargets 中的 INSTALL ，然后右键选择“Project Only”–&gt;“Build Only INSTALL”。漫长的等待。。。。。。 (╯﹏╰)b Shaun 在这一步出现了一个问题，具体问题和解决方法详见问题篇。 一切顺利的话，应该会比 Shaun 下面的库多两个，Shaun 最后生成的 Debug 库为：opencv_aruco320d.libopencv_bgsegm320d.libopencv_bioinspired320d.libopencv_calib3d320d.libopencv_ccalib320d.libopencv_core320d.libopencv_datasets320d.libopencv_dnn320d.libopencv_dpm320d.libopencv_face320d.libopencv_features2d320d.libopencv_flann320d.libopencv_fuzzy320d.libopencv_highgui320d.libopencv_imgcodecs320d.libopencv_imgproc320d.libopencv_line_descriptor320d.libopencv_ml320d.libopencv_objdetect320d.libopencv_optflow320d.libopencv_phase_unwrapping320d.libopencv_photo320d.libopencv_plot320d.libopencv_reg320d.libopencv_rgbd320d.libopencv_saliency320d.libopencv_shape320d.libopencv_stereo320d.libopencv_stitching320d.libopencv_structured_light320d.libopencv_superres320d.libopencv_surface_matching320d.libopencv_text320d.libopencv_tracking320d.libopencv_video320d.libopencv_videoio320d.libopencv_videostab320d.libopencv_xfeatures2d320d.libopencv_ximgproc320d.libopencv_xobjdetect320d.libopencv_xphoto320d.lib共41个。配置篇 因为 Shaun 只编译了 x86 版动态 debug 库，所以以下环境配置都只针对 x86 版动态 debug 库。（其实要配置 x64 的库就只需将 x86 换成 x64 即可；要配置 release 模式的库就只需在添加附加依赖项中的库文件选择 release 模式的库（即数字后没有 d的 lib）；若要配置静态库就需要选择静态库文件夹以及在附加依赖项中添加相应的静态库文件。:-P） 首先把 /opencv-3.2.0_build/build/install 中的文件都提取出来，这和 OpenCV 官方 release 的 opencv 文件结构差不多，具体两层结构如下.├── bin│ └── opencv_waldboost_detectord.exe├── etc│ ├── haarcascades│ └── lbpcascades├── include│ ├── opencv│ └── opencv2├── LICENSE├── OpenCVConfig.cmake├── OpenCVConfig-version.cmake└── x86​ └── vc129 directories, 4 filesx86 文件夹就是 VS2013 生成的对应 VS 版本 32位 的各种库，include 文件夹就是 opencv 的各项模块。Shaun 将其中提取出的文件全部放入了 C:\Program Files\OpenCV\3.2.0\build 文件夹中。 首先配置环境变量，系统（或用户）环境变量如下：变量名变量值PathC:\Program Files\OpenCV\3.2.0\build\x86\vc12\binOPENCVC:\Program Files\OpenCV\3.2.0\build不然可能会报错：程序“XXXXXX”已退出，返回值为 -1073741701 (0xc000007b)。其中下面那行可以选择不要添加。 然后在 VS 中配置环境。新建工程，然后在“属性管理器”中对应项目下 Debug | Win32 文件夹右键“添加新项目属性表”。（方便一次配置，多次使用，以后再使用只要在相应项目下右键“添加现有属性表”即可），Shaun 新项目属性表取名为：opencv-3.2.0_msvc2013_x86d.props。接下来就是真正的 VS 环境配置了： 双击打开刚才新建的属性表，选中“VC++目录”，注意在进行以下配置时建议都勾选左下角的“从父级或项目默认设置继承”“可执行文件目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin“包含目录”中添加：C:\Program Files\OpenCV\3.2.0\build\includeC:\Program Files\OpenCV\3.2.0\build\include\opencvC:\Program Files\OpenCV\3.2.0\build\include\opencv2“库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib选中“链接器” –&gt; “常规”，“附加库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib“链接器” –&gt; “输入”，“附加依赖项”中添加 C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib 中数字后带 d 的库文件，即编译篇中 Shaun 最后生成的 41 个库文件。 配置完之后不要忘了右键该属性表进行保存处理，以便下个项目直接使用，不需要再重复进行配置。最后附示例程序：1234567891011#include &lt;opencv2/opencv.hpp&gt; int main(int argc, char *argv[])&#123; cv::Mat lena = cv::imread("lena.jpg"); //载入图像到Mat，jpg文件和该cpp在同一文件夹 cv::namedWindow("lena"); //创建一个名为 "lean"的窗口 cv::imshow("lena", lena); //显示名为 "lena"的窗口 cv::waitKey(5000); // 只对窗口机制起作用（显示5000ms，随后返回-1，即窗口关闭），若在此期间有按键按下，则马上返回按键的ASCII码。 //system("pause"); return 0;&#125;这里必须在 imshow 后加入 waitkey，因为 WaitKey 不止是 Wait Key 而已，它其实还涉及到消息响应，有这个函数 cv 内部的 WndProc 函数才能起作用，才会更新窗口。 最后程序运行成功并显示 lena 图，则说明编译和配置没问题。问题篇1、用 VS2013 编译 OpenCV 在漫长的等待阶段出现的问题。 问题描述：CVV 模块报错，TS 模块编译不出来，好在这两个模块都不是很重要，可以忽略，Shaun 强迫症也没到这种程度 O(∩_∩)O~。 解决办法： 在 CVV 模块报错后可在 CMake（不知道具体是 INSTALL 下的 CMake Rules 中的 INSTALL_force.rule，还是 ALL_BUILD 下的 CMakeLists.txt，忘记了 o(╯□╰)o）中添加 -DBUILD_opencv_cvv=OFF 忽略 CVV 模块，从而正常编译其它模块。参考 errors on build opencv with cvv module and qt5 #577。如果实在不行的话就在 CMake 生成的时候取消勾选出错模块，若是用 CMake 重新生成的话不要忘了先把 /opencv-3.2.0_build/build 目录下的文件全部删除干净。后记 这是以前写的两篇文档，现在再来整理成一篇。附录 既然能看到这里，说明是想在 VS 下使用 OpenCV，这里推荐一款 VS 下 OpenCV 开发调试神器：Image Watch，效果谁用谁知道。Image Watch 是 VS 的一个插件，不过它只支持 VS2012 及以上版本。使用方法为先设置断点（ F9 ），随后在调试（ F5 ）模式下，鼠标指针悬停在 cv::Mat 类型变量上，即可出现 ，点击查看图标即可显示相应图像。参考资料[1] cmake-gui和vs2013编译opencv和opencv_contrib源码（http://livezingy.com/category/opencv/）[2] VS2013_CMake_opencv3.1动态库与静态库的配置与编译（http://livezingy.com/category/opencv/）[3] 使用VS2015编译以及静态编译opencv3记录[4] errors on build opencv with cvv module and qt5 #577[5] VS2013中Image Watch插件的使用(OpenCV)（http://blog.csdn.net/fengbingchun/article/category/721609）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyThoughts]]></title>
    <url>posts/17017530.html</url>
    <content type="text"><![CDATA[前言 本篇主要用来记录 Shaun 的心路历程。Thoughts日期Thought2019-01-08不要抢话，适当保持沉默。2018-06-09从维度的角度来解析信号，不愧是卡尔·萨根，或许有一天阻碍人类科技发展的事物就是维度吧。 ——观《超时空接触》2018-06-031. 白色巨塔，尸骨成堆，在通往理想之路上，医者的信念并无对错；2. 想改变什么，必先提升自己，但在提升自己之后，又很可能忘记自己的初心；3. 能屈能伸终究还是对人来说的，阶级层次之间终究有别；4. 呀吧哩钱和权才是永恒的话题，但只有生命才是最真实的。 ——观《白色巨塔》2018-05-18「暴漫」死亡的原因应该是用户基数太大，而且又不合作。嗯，大概是这样吧 ╮(╯▽╰)╭ ，至于真相是。。。。。。2018-03-14曾看到一句类似这样的话：“死刑最可怕的不是它本身，而是其漫长的等待过程”。——观《大卫·戈尔的一生》2018-03-06吃饭抢单，一如既往的高质量反转。——观《九号秘事》S03E032018-02-06每件事都有其价值，做的事不同，得到的也不同，有些人辛劳一生，却穷困潦倒，有些人游手好闲，照样荣华富贵。这取决于你的爹和你做的事。2018-01-30重复的事情总有一天都会被机器取代。2018-01-10真正的真相只掌握在少数人手里。2018-01-06老师终究只是一种职业，而学校服务的对象以老师为主，学生明明是被约束自由的一方，却还要给学校支付相应的费用，这感觉有点不正常啊。仔细想想又挺正常的，毕竟学校本身没逼你去，是你自己去的，既然要去一个本身不属于你的地方，当然要先缴各种服务费，即使物非所值。那为啥要去呢？2017-12-24当隐私荡然无存，你又会如何 🤔。——观《 菲利普·K·迪克的电子梦》S01E012017-12-21世界很渺小，差的只是一个引路人。2017-12-20无知是福，不谈国是 :）。2017-12-07社会工程学，有意思的领域。——观《我是谁：没有绝对安全的系统》2017-11-29知道的越多，不知道的也越多。2017-11-15我所理解的编程就是用尽可能简单的方法得到想要的变量值。2017-10-24读研究生两个月，最大的改变就是对人对事都比以前有更大的耐心了 :）。2017-10-21无论什么事，当ta成为一种任务的时候，都是一种负担。2017-10-20键盘侠就该看看《黑镜》S03E06，真看热闹不嫌事大啊 😒。2017-10-19人类基因组计划，真不知道是好是坏，希望是好的吧 😶。——观《黑镜》S03E052017-10-15镇定，面不改色；节奏很快，就一个晚上的事，音乐和光影也很赞 👍。——观《暗花》2017-10-07国家意志啊，让人不由得想起那年春夏之交（5月35日）的一场风波╮(╯▽╰)╭。——观《出租车司机》2017-10-04什么时候能控制情绪了，什么时候就成熟了。——观《头脑特工队》2017-10-03所谓的朋友（ta）只是在正确的时间正确的地点遇到的正确的人。2017-09-291. 有些事不知道比知道要好，但真相总还是知道要好。2. 不同层次的人心态不同，难以相互理解。2017-09-28各大（网络）小说家的风格真的很难改变啊！ 😪2017-09-231. 你想成为什么样的人，必须自己决定。——《虫师》2. 情感是最不可控的。——观《宝莱坞机器人之恋》3. 人或许只有善恶，没有好坏。2017-08-29科研之上，如何能成为一个挖坑人（开创性的结果）？ 😕2017-08-11学生最重要的两种能力是学习能力和解决问题的能力。2017-08-10爱情是需要理由的。2017-08-05无能是万恶之源。2017-07-20有些话，自己心里明白就行，绝对不能说出来，否则可能存在某种未知的危险。2017-07-18很多东西是不能向别人推荐的，比如音乐，电影，小说等自己喜欢的东西。2017-07-14有些事是交给别人判断的，自己心里知道就行；有些事是交给自己判断的，自己心里知道就行。2017-07-11走进一个学科之前，最先应该知道的是该学科的研究对象、研究方法，以及当前研究中的热点难点问题，而不应该被广告一样的花哨演示糊弄住。——《上海交通大学学生生存手册》2017-04-09真正的独立，应该是离开任何人你都能活的好好的；真正的自由，应该是任何人都不能让你做违背你意志的事。2017-02-08小提琴，悠扬，忧伤。2017-01-27唉！渐行渐远╮(╯▽╰)╭。2017-01-18不能飞的猪，就只是猪而已。——《红猪》2016-12-30梦想还是要有的，万一实现了呢，试一下又不吃亏。——观《百日梦想家》2016-12-26过去的如果就这么过去了，那以后只会越来越糟。——《驴得水》2016-12-25只有人才是最重要的。2016-12-10与人相处之道，不外乎尊重和坚强。2016-11-06烈日灼心，片如其名。——观《烈日灼心》2016-11-04后来我发现，教授们貌似不喜欢有自己想法的学生，他们更希望找到愿意“打下手”的学生，帮助实现他们自己的想法。——《王垠：我和权威的故事》2016-10-31为何总要责怪自己？为何要为没必要的人改变自己？不需要做老好人，做好自己，随便别人。——观《被嫌弃的松子的一生》2016-10-303~7的小孩的自主谎言最可怕，撒谎乃人之天性，远离无脑之人。——观《狩猎》2016-10-27世界上有三种人，一种是人渣，一种愚漠的人，还有一种是所谓的好人。第二种人最多，参考正态分布。——观《熔炉》2016-10-22面对长者（诸如领导，老师等），要多听他们说，自己尽量少说，绝对不要找理由，要多说嗯，是的，对的，没错，明白，可以等肯定语句，绝对不要说由于，因为等原因语句。更重要的是尽量少说自己不知道，忘记了，了解一点等否定语句，不要把自己差的一面表现出来；要说自己会，行，知道等肯定语句，一定要把自己好的一面表现120%出来。（※附：以 Shaun 2017-12-21的眼光来看这段话还是不妥）2016-10-02平静中的悲和喜，最悲痛。——观《那年夏天，宁静的海》2016-09-22韩国好的电影对人性的把握比较到位，但有时为了突出人性好的一面，而做的有点婊了，为了剧情而剧情。——观《摩天楼》《流感》《铁线虫入侵》《釜山行》2016-09-13这世上有很多事，不试一下永远不会知道结果。2016-09-05公式本就存在，就等有天赋的人去感知并发现它。——观《知无涯者》2016-09-03管理者需要心平气和，更要沉得住气，有耐心。2016-08-12自紧力，自紧扳手，和初中做的物理实验：把两本书夹在一起后，无论怎么用力向两边拉都拉不开，估计有点类似吧。（※附：以 Shaun 2017-12-21的眼光来看这个事感觉有点玄学）2016-08-10为什么人们总认为小孩（弱者）说的是对的？有没有想过，有时候小孩并不小，弱者并不弱。2016-08-09《人工智能》，好可怖的一个世界。——观《人工智能》2016-08-06一起做一件事能很好的增进感情。（※附：以 Shaun 2017-12-21的眼光来看也有可能增加矛盾╮(╯▽╰)╭）2016-08-04尽量不要去接手别人已经做了一部分的事物。（※附：以 Shaun 2017-12-21的眼光来看如果别人做的很好理解的话接手也可以）2016-08-021. 有时候很难理解他人，只是因为没有和他人类似的经历而已。2. 让人的本性被改变咋就这么难？读大学是掉噶果？（※附：以 Shaun 2017-12-21的眼光来看ta确实老了，也变了，或许时间能改变一切吧）2016-07-29《计算机：一部历史》，很有意思的一本计算机史。2016-07-26人们总是习惯于用固有的标准看待新事物。2016-07-24《妖尾》的世界观简直不敢苟同，世界上真有那种人，杀了或要杀自己朋友的人还能做伙伴？每遇到boss第一次总被秒杀，第二次才能完胜？这尼玛是什么逻辑。2016-07-171. 不要嘲笑别人的梦想，也不要轻易说出自己的梦想。2. 看完《活着》，心情有点沉重，难道生命的意义就在于为活着而活着？或者还是太年轻了。2016-07-161. 是待人以诚，人待以诚，还是人待以诚，待人以诚？不好说。2. 游戏能代表计算机应用技术的最高水平。2016-07-13情景不同，分类不同。2016-07-12下属（泛指），多看，多听，多想，多做，少说话。2016-07-101. 世上最痛苦的事莫过于对着自己不想看到的人谄媚。2. 不同的时刻，不同的场景，不同的心情，喜好不一样。2016-06-29口吃可能不是遗传的，也可能是婴儿学习过程中的一种畸形。2016-06-231. 何不让自己的人生多些经历。2. 世上大多数的猜忌、争论，都是由于每个人总是认为自己是对的。2016-06-161. 多媒体识别的关键在于提取图像、视频和音频的“特征”（即向量）。2. 我们周围的人是否在演戏？我们是否在戏中？人生入戏，戏如人生。——观《楚门的世界》2016-06-131. 不管变成什么样，问心无愧就好。2. 人越成熟就藏得越深。3. 完全不需要和别人比，只需和昨天的自己比。2016-06-091. 在公共环境（贴吧，评论区等）下发言，首先要做好被喷的准备，网络上从来不缺少键盘侠。2. 眼中世界不同的人，终究会分开。2016-05-27有些东西是让人看到会产生反感的，而有些东西明明被人讨厌，却因为它没有那么张扬的外面，所以很容易被人忽视的。——七月寒风《幻灵》2016-05-201. 不要随便对别人说出你的想法和理解，因为可能在别人看来，你的想法和理解完全就是个笑话和讽点。最后，最重要的是看清他人是不是和你是一个世界的，世界不同，观念，观点很难相同。2. 绝大部分老师只看结课论文的排版如何。2016-05-18儒家治国，道家处事。（※附：以 Shaun 2017-12-22的眼光来看有点不敢苟同）2016-05-16人们或多或少都有一种同情弱者的心态，所以有时候适当的处于弱势并不是一件坏事。2016-05-09大学里的成绩更多的是取决于你了不了解老师，你知不知道老师真正想要你写什么，讲什么。2016-05-02看完《浪潮之巅》才明白“软件即服务”，软件提供的实际上是某种功能，某种作用，而这种功能是软件所在平台没有的，但是却是人们使用时不可或缺的，那么企业提供这个软件，就是在提供一种服务。就像饭店里的服务员一样，上菜时饭店提供的一种服务，但不是饭店本身就有的，饭店真正提供的只是一个场所和食物。使用的人数决定市场，不管是付费还是免费，只要能抓住更多的用户，就是胜者。2016-04-29世界上有两种程序员，一种是写技术的，另一种是用技术的。（※附：以 Shaun 2017-12-22的眼光来看写者和用者并没有很明确的界线，更像是一种心态吧）2016-04-24真没想到，最近看到“人生若只如初见”才知道是什么意思，高中老师曾出了个作文题就叫这个，当时傻傻的不知道什么意思，呵呵，当年的阅历实在太浅。2016-04-07你强ta越怕，你弱ta越欺。2016-04-02黑色幽默，挺有意思的！比较推荐的有：《黑镜》、《蛮荒故事》。2016-03-311. 两个公司在技术上的竞争，除了人的竞争，就是执行力的竞争。——吴军《浪潮之巅》雅虎、惠普精兵简政2. 托尔斯泰讲，幸福的家庭都是相似的，不幸的家庭都是各有各的不幸。在信息工业中，这句话要反过来讲，成功的公司各有各的绝招，失败的公司到是有不少的共同之处。——吴军《浪潮之巅》思科 留住早期员工2016-03-24有时候，我们想要的东西就在我们面前，我们却因年代久远可能不认得，反而可能亲手毁了ta。——观《SINTEL》2016-03-21每次去以前贾里尼克都要确认我们报告的每一页内容都是已经公开发表过的。原因很简单，IBM有世界最好的科学家和工程师，他们可以用比你还快的速度将你还没发表的想法实现、申请专利并发表。盖茨意识到只要垄断了操作系统，就间接垄断了整个行业。——吴军《浪潮之巅》Microsoft在商业领域，保密性是十分重要的，尤其是一个新颖的想法。在积累了一定的用户量之后，商业化也是很简单的。商业的前提是用户。2016-03-20整个信息技术（Information Technologies，简称IT）产业包括很多领域、很多环节，这些环节之间都是互相关联的。和世界上任何事物同样，IT产业也是不断变化和发展并且有着它自身发展规律的。——吴军《浪潮之巅》IT Law万物发展自有其规律，但这个规律只是一种趋势，趋势总有其临界点，到临界点时将呈现另一种趋势，比如Moore’s Law，功耗就是其临界点。2016-03-20英特尔公司做事情非常专注，直到今天，它一直集中精力于个人微机的处理器，每一代产品的研发都是集中大量的人力和资金，每一次都是只能成功不能失败。——吴军《浪潮之巅》Intel专一，虽然能保证做好，但面太窄，一旦市场发生变化，讲很难应对。2016-03-19时不时调整内部结构，将一些非核心的、长期效益不好的部门卖掉，同时扩大核心的利润高的生意。——吴军《浪潮之巅》IBM认清自己的定位，抓牢自己的核心业务，同时开拓创新。2016-03-19当一个公司没有人对它有完全控制时，它的长期发展就会有问题。——吴军《浪潮之巅》AT&amp;T合则生，分则死。2016-03-19社会在发展，人也在发展，社会的发展体现在人周围事物的变化，而人的发展体现在人自身的变化，这种变化是好是坏，每个人的观点可能不同，没人能预料变化将带来什么，我们唯一所能判断的就是变化给我们现在带来了什么，以此判断以前的变化是好是坏，此时的变化将由未来的人判断。2016-03-19大学生和高中生的本质区别在于大学生更会思考，更加注重自学能力，遇到问题是主动去寻找解决方案，而不是像高中生那样被动的等老师来讲解。2016-03-11时间使人安稳，失去时间将使人迷失，疯狂。2016-02-17别人肯不肯帮忙主要取决于你自身的实力基础。2016-02-03生而不养，养而不教，不如不生。2016-01-26为人子女，与父母相处的机会，其实都是见一次少一次的。——罗森《万界天王》2016-01-24四十多岁的父母是最能包容你的人。（※附：以 Shaun 2017-12-22的眼光来看这里有点欠妥）2016-01-23以己度人，更多的是指包容别人的缺点，而不是抱怨别人没有的缺点。2016-01-16人之为人，在于自制。2016-01-08读高中时，我接触到靠自己；读大学时，我逐渐学会靠自己；步入社会时，我将真正靠自己。（※附：以 Shaun 2017-12-22的眼光来看是不可能真正靠自己的，总要与外界交互）2015-12-30读大学，选择不同的专业，就是选择不同的圈子，而圈子决定话题。2015-12-281. 很多时候，我们买一件东西只是因为心血来潮，而不是真正需要它。2. 贯彻落实“尽量学习”理念。尽量学习有两个方面：尽量多学和尽量精学。2015-12-07人生充满太多的偶然性。2015-11-09所谓杀心，就是去除仇恨。恨一个人也常常意味着怕这个人，只有克服了“怕”之后，“恨”才能转化为杀心，化为力量。—— 冰临神下《死人经》2015-11-08每天都学一点小知识2015-11-05有没有想过，人类也是一种寄生虫，寄生在地球，依靠于太阳，而太阳和地球也只是宇宙里的一粒微尘。——观《宇宙的奇迹》2015-09-15虽然这不是你理想中的大学，但你可以选择过理想的大学生活。2015-09-05没有对生明的敬畏，就永远无法体会到生命的可怕。2015-09-01因为在乎，所以在意。2015-05-16我虽然现在不知道，但我可以学。（※附：以 Shaun 2017-12-22的眼光来看这句话在大部分情况下行不通）2015-05-15唉！这次回去，已是物是人非，院子不再是院子。2015-05-15自杀乃傻之至极。2015-05-151. 不抱怨，不找理由。（面对教、训之终极奥义）2. 一本书，读过之后如果没有思考，相当于没读。3. 前人的言行是我们的指路明灯。2015-05-15鹿角杀死了冰原狼预示着拜拉席恩将导致史塔克的死亡。不会玩的游戏不要硬去玩，否则终将害人害己。当大雪降下，冷风吹起，独行狼死，群聚狼生。夏天时可以争吵，但一到冬天，我们必须保卫彼此，相互温暖，共享力量。——《冰与火之歌：权利的游戏》2015-05-151. 海贼王的海军每个人都有自己坚守的正义。2. 尊重不是别人施舍的，而是自己争取的。3. 环境决定年龄。4. 和平利于知识传播交流，战争利于知识创新突破。2015-05-151. 不要等到老师教，尽量去学自己想学的，要学的。2. 介绍和学习是两码事，介绍可以用PPT，而学习用板书更好。3. 电给人方便，也使人孤独，人与人的联系似存而亡。2015-04-15是为自己而活？还是为他人而活？2015-04-03有时候，人对自己的东西会突然莫名其妙的产生一种厌烦感，从而不想要，从而做错事，但其实这种厌烦感只是暂时的，过一段时间又会恢复成以前那样。2015-03-10人当想人之不能。2014-10-041. 人之成长，取决于见。2. 世风日下，好人难做。3. 在社会这个大染缸里，我只想做我自己。4. 有些雷区是不能碰的，碰，就会惹火上身。5. 每个人的注重点不一样，带出来的人也不一样。2014-09-20How did we escape from the prison? It was the work of generations of searchers who took five simple rules to heart . Question authority. No idea is true just because someone says so. Think for yourself . Question yourself. Don’t believe anything just because you want to. Believing something doesn’t make it so. Test ideas by the evidence gained from observation and experiment. If a favorite idea fails a well-desidned test, it’s wrong! Get over it. Follow the evidence, wherever it leads. If you have no evidence , reserve judgment. And perhaps the most important rule of all…… Rember, you could be wrong. Even the best scientists have been wrong about somethings. Newton, Einstein, and every other great scientist in history, they all made mistakes. of course they did – they were human, Science is a way to keep from fooling ourselves and each other. Have scientists known sin? of course. We have misused science, just as we have every other tool at our disposal, and that’s why we can’t afford to leave it in the hands of a powerful few. The more science belongs to all of us, the less likely it is to be misused. These values undermine the appeals of fanaticism and ignorance. ——《Cosmos: A Spacetime Odyssey》我们如何逃出囚笼？是因为世世代代探索者的不懈努力，并且他们发自内心地遵从这5条简单规则。质疑权威。不轻信人言。独立思考。自我质疑。不因自己想要相信，而相信任何事。相信不代表能成为现实。以依靠观察和实验得来的证据来检验想法。如果自己喜欢的想法没有通过全面的检验，它就是错的！ 乐观一点。遵循证据，无论它指向哪里。如果没有证据，不妄下结论。也许最重要的规则就是，要记住，你也会犯错。牛顿、爱因斯坦，还有历史上每一位伟大的科学家，他们都犯过错，这很正常，是人都会犯错。科学让我们不再欺骗别人和自己。科学家们有罪吗？有的。我们曾滥用科学就像手边的工具一样随意使用，因此我们不能把科学放在少数的掌权者手中。当科学更多的属于全人类时，它就越不会被乱用。科学的价值在于能阻止狂热和无知。 ——纪录片《宇宙时空之旅》2014-09-20Telling someone your goal makes it less likely to happen.告诉别人你的目标反而使目标不能实现。 ——网易公开课《不要公开宣布个人目标》2014-09-14每一个客户都是一群客户。2014-08-22快做眼前事，未来不可知。2014-08-13既然扎根于此，何不刻苦努力！2014-07-31这个世界很大，你总能找到你的伙伴。既然出生到这个世上，你绝不会总是孤身一人的。 ——《One Piece》2014-07-26There’s a time when a man needs to fight and a time when he needs to accept that his destiny’s lost. 人有必须奋战的时刻，也有必须接受现实的时刻。 ——《Big Fish》2014-07-23每个人的一生都是一部独有的长篇小说。2014-07-11就算你讨厌ta，也不要在背后议论ta的是非，毕竟议论是非之事必是是非之人。2014-06-29世事无常，计划赶不上变化，无须太过伤感。2014-06-27大 极，小 极，差，和，无大无小。2014-06-25荣耀只属于特定的时空。2014-06-161. 一个秘密有两个人知道，也便不是秘密。2. 没有做好准备就准备失败。3. 初学计算机语言，多敲代码。4. 不要太在乎别人对你的看法（不管是好是坏），不然你会活的很累。2014-06-11分数是老师给的，东西才是自己学的。2014-06-06参数——来自另一维度的手（上帝之手）（二维中的蚂蚁、三维中的蚂蚁、轻易逃脱囚笼）2014-05-301. 有些话（事）能说（做），有些话（事）不能说（做）。（要会判断）2. 不要在心情极端时做出让自己后悔的事。3. 相比于自律自觉能力，考上一个好大学显得并不是那么重要。4. 在这个人人都装逼的社会，对不对需要自己判断！2014-05-26“取法乎下，得乎下下；取法乎中，得乎其下；取法乎上，得乎其中；取法上上，得乎其上。” —— 《读大学怎么读》2014-05-211. 其实学校是第一个教会我们说谎的地方。2. 成绩只是老师给的，更重要地是在于你自己有没有学到东西，大学注重的不应是分数，而应是你真正学到的东西！2014-05-12每个人都是自己生活的主角。2014-04-211. 闲事为何事，何事为闲事！2. 距离！ 适度！3. 人生总有种种不如意之事，但也会有种种如意之事！4. 一般而言，抄不如乱写，乱写不如不写！2014-04-211. 世上的事很多，只是看你去不去做，所以何来无聊之说！2. 上大学易，读大学难，且读且珍惜！2014-04-19浑浑噩噩的一天，糊糊涂涂的人。2014-04-011. 不去争的话就什么都不会有！2. 因为在意，所以紧张！3. 人生就是一个奋斗的过程，人生也因奋斗而精彩！2014-04-011. 永远都不要以为你的时间很多！2. 深沉一点！3. 真搞不懂为什么这么多人喜欢听假话，假话比真话真的管用吗？也难怪现在有这么多假冒伪劣产品，连个话都是假的好。（※附：以 Shaun 2017-12-23的眼光来看在多数情况下假话确实比真话管用，说话也是一门学问啊）2014-04-011. 有些路还是自己走得好！2. 天下哪里有白吃的午餐，只有白痴的人。3. 做人可以懒，但不能傻！以上均为 Shaun 当时感想，也算是记录一下 Shaun 的心智成长过程吧，有不同意见请保持理智 (๑•̀ㅁ•́ฅ)。后记 哪来的后记，Shaun 的这一生还没过完呢 (╯°□°）╯︵ ┻━┻，（#-_-)┯━┯ 。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决写上篇文档“Hexo+GitHub搭建个人博客”遇到的问题]]></title>
    <url>posts/7d5bc07b.html</url>
    <content type="text"><![CDATA[超链接网址问题 问题描述：使用正常的 markdown 超链接格式[]()没问题，然而当直接将一个网址链接放入该文档时，它会将该链接后面的文字也当成是该链接的一部分，直接点击链接时，会将后面的文字也放入浏览器地址栏，从而出现网页 404 错误：404: Page could not be found。 解决办法：在网址链接后输入一个空格以隔开网址链接和后面的文字或用&lt;url&gt;将网址括起来。超链接样式问题 问题描述：Shaun 使用的 hexo 主题是基于 spfk 主题稍微修改过的，spfk 主题能自动修改超链接原有的样式，挺好看的 :D，但是当 Shaun 在 markdown 中数字编号列表，即有序列表中添加超链接时，其样式并没有修改，还是普通的超链接样式。 解决办法：没有解决。最后只是跳过了这个问题，就用中文的序号表示列表。文本段落问题 问题描述：为了使文本有段落感，一般都会在段落首字前空两格，但是在 markdown 中空两格，用 hexo 发布后并没有空两格，这使得文档没有段落感，阅读体验有点差。 解决办法：将中文输入法由半角切换至全角，在段落首字前输入两个空格即可。显示英文尖括号问题 问题描述：由于上篇文档需要在文档中显示&lt;youname&gt;，但由于 Hexo 可能将其当做一个 xml 标签处理了，所以发布之后的文档没有显示该文字。 解决办法：首先 Shaun 尝试了转义字符\，谁曾想它只出现了一个转义字符，该文字还是没显示，Shaun 差点又要跳过这个问题，将其用另一种表示法了。后来 Shaun 想到这最后不是会转为 html 吗，Shaun 就直接用 html 中尖括号的表示法不就行啦 :p，于是参考HTML语言中括号(尖括号)的字符编码，用&amp;lt;代替&lt;，用&amp;gt;代替&gt;，最后该文字终于出来了。给文字添加颜色问题 问题描述：Shaun 想给注意事项上的需要注意的问题添加醒目的颜色，但 markdown 本身不支持给文字添加颜色。 解决办法：由于 Hexo 最后会将 markdown 文档转换为 html 文档发布，所以直接将 html 标签写进 markdown 文档，最后自然会出现 html 样式，Shaun 这里参考CSDN-markdown编辑器语法——字体、字号与颜色，给想要变色的文字添加&lt;font color=#FA8072&gt;&lt;/font&gt;标签。参考资料[1] HTML语言中括号(尖括号)的字符编码（http://liuxufei.com/weblog/jishu）[2] CSDN-markdown编辑器语法——字体、字号与颜色（http://blog.csdn.net/testcs_dn）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>posts/d7965b48.html</url>
    <content type="text"><![CDATA[Shaun 的系统环境：Win10_x64。前言 本来是想在国内某网站上继续写的，毕竟完全不需要自己管理，只需要负责写好文档就可以了，但某一天，该网站由于响应国家的号召，要实名验证，本来实名验证也没什么，就输入手机号，并填写验证码即可，但该网站实名验证的方式给人的感觉特别不爽，于是就决定自己搭建博客，这样虽然有点麻烦，但由于完全是自己管理，自己完全拥有该文档的所有权，也不用担心哪天别的网站突然出现的各种破问题，相比这种完全自由支配、无比爽快的感觉，管理这种麻烦就是小事了。GitHub + Hexo 个人博客搭建准备篇在 GitHub 上搭建博客的要求： 1、要有 GitHub 账号。（没有怎么办，没有就去注册啊）使用 Hexo 框架的要求： 1、需要安装 node.js。（电脑上没有安装怎么办，没有安装就去下载（https://nodejs.org/en/download/）安装啊） 2、需要安装 git。（没有安装就去下载安装，附 git学习教程）GitHub 篇 满足上文的要求之后，就可以开始搭建了，首先在 GitHub 中新建一个仓库（ New repository ），在 Repository name 下填写 &lt;yourname&gt;.github.io ，其它可默认，点击 Create repository。 新建仓库完成后，点击 Create new file 新建一个 README.md 文件，随便写点什么，比如 “It's my blog website”。 点击上方横条选项中的 Settings ，查看 GitHub Pages 里的设置，上方应该有绿色框，框中“Your site is published at https://&lt;yourname&gt;.github.io”，该网址即为博客主页，Source 应该是 master branch，自此 GitHub 上的设置可以算是完成了，但为了方便和防止误删，一般把 Hexo 文件也放入 GitHub 中，为方便管理，可以新建另一分支专门放 Hexo 文件。 在仓库 code 界面中点击 Branch：master，在出现的框中输入 hexo 新建 hexo 分支，在 branches 中 Change default branch 设置 hexo 为默认分支。Hexo 篇 将刚才新建的仓库克隆到本地：git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git当前在 hexo 分支。在 &lt;yourname&gt;.github.io 文件夹下执行12345npm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --save 按这样一连串执行，如果没出问题的话就会在 &lt;yourname&gt;.github.io 文件夹里生成一个 blog 文件夹，该文件夹有一大堆 Hexo 有关的文件。配置 Hexo Hexo 的配置文件为 blog 文件夹中的 _config.yml 文件。 修改配置文件不要使用 windows 自带的记事本，Shaun 使用的 VS Code，或者 Notepad++ 和 Sublime Text 2 等编辑器都可以，以防文件编码改变，具体修改如下：123456789101112131415# Sitetitle: &lt;你的blog名&gt;author: &lt;作者名称&gt;language: zh-CN&lt;网站所用语言，中国大陆选择zh-CN即可&gt;# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://&lt;yourname&gt;.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git branch: master其它的默认即可，具体参数信息详见 Hexo官方文档。配置 git 用户信息12git config --global user.name "&lt;yourname&gt;"git config --global user.email "&lt;yourname&gt;@xxxxxx.com" 如果是个人电脑的话推荐加上 –global 全局参数，因为这样更加方便，如果不加的话，还要在 \&lt;yourname&gt;.github.io\.deploy_git\.git 中 config 里加入 git 用户信息，不然可能提交会出问题，稍显麻烦。部署 Hexo在 blog 文件夹下执行：123hexo g #generate 生成静态文件hexo d #deploy 部署网站.部署网站前,需要预先生成静态文件hexo s #server 启动服务器或者执行：1hexo g -d快速部署个人 blog。 在浏览器中输入http://localhost:4000/，将会出现 Hexo 的 Hello World 界面，更多 Hexo 命令详见 Hexo官方文档。最后将 Hexo 文件提交到 GitHub 远程仓库，具体提交命令为：123git add .git commitgit push origin hexo 在浏览器中输入https://&lt;yourname&gt;.github.io同样会出现 Hexo 的 Hello World 界面，自此整个个人 blog 的框架已经完全搭好了。其它篇主题选择 主题可以去官网上的主题界面去找，目前比较受欢迎主题有 next 和 yilia，去别人 GitHub 上的主题仓库上去下载或 clone 均可，Shaun 目前用的主题为black-blue，这个主题 Shaun 在用的时候还有些问题，或许会换，或许会自己魔改。最后由于术业有专攻，实在不知道该改哪里，所以决定换 black-blue 的原版主题 SPFK ，对照着 black-blue 对 spfk 进行修改。具体换主题的方法为： 先将下载好的主题整个放在 \blog\themes 文件夹中，再修改 blog 文件夹中的配置文件 _config.yml：12# theme: landscapetheme: black-blue black-blue 为打包主题文件并放入 \blog\themes 文件夹中的文件夹名，并不是原主题名，只是 Shaun 恰好将其重命名为主题名。文章发布发布文章需要在 blog 文件夹中执行：1hexo new "test" 将会在 _posts 文件夹中生成 test.md 文件，随后编辑 test.md 文件即可，Shaun 使用的 Markdown 编辑器为 Typora。至于给文章打标签和分类什么的，请参考 Hexo官方文档。写完文章之后推送到 GitHub 中，需要执行：123git add .git commit -m "add test.md"git push origin hexoHexo 文件配置同样需要同步一下：123hexo ghexo cleanhexo d插件添加以 RSS 订阅插件为例。首先安装 hexo-generator-feed，在 blog 文件夹下执行：12## rss插件npm install hexo-generator-feed --save安装成功后，修改 blog 文件夹中的配置文件 _config.yml：1234# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed #RSS订阅最后，修改当前主题文件夹中的配置文件 _config.yml，添加 RSS 订阅链接即可：12subnav: rss: "/atom.xml"修改完成后，执行123hexo cleanhexo ghexo d将会在页面中看到 RSS 图标。注意事项1、提交至远程仓库时可能会出现错误。 原因可能是因为没有将 SSH Key 添加到 GitHub 中。 查看当前用户主目录下的 .ssh 文件夹中（ windows 是 C:\Users\&lt;username&gt;\.ssh）是否有id_rsa（私钥）和id_rsa.pub（公钥）这两个文件，若没有，则执行1ssh-keygen -t rsa -C "youremail@example.com" 在 GitHub 中添加 SSH Key 的具体方法为：点击 GitHub 用户头像下的 Settings，选中 SSH and GPG keys，点击 New SSH key，将id_rsa.pub中的内容复制粘贴到 Key文本框中。2、Hexo 生成和部署命令都执行失败。 原因可能是修改配置文件 _config.yml 出错。 将修改的配置文件 _config.yml 复原试试。3、Hexo 部署之后网页没变化。可能需要执行1hexo clean 清除缓存文件 ( db.json ) 和已生成的静态文件 ( public )。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。后记 以后就在这上面写 blog 了，顺便把以前写的一些文档也放上来。参考资料[1] 利用github+hexo搭建自己的博客（http://blog.csdn.net/u012150360/article/category/6765461）[2] Hexo官方文档（https://hexo.io/zh-cn/）[3] GITHUB+HEXO博客轻松更换主题外观（http://www.jianshu.com/nb/10649566）[4] Hexo—正确添加RSS订阅（http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>posts/4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
