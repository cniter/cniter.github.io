<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Scala 学习小结]]></title>
    <url>posts/8d3d87a2.html</url>
    <content type="text"><![CDATA[前言 最近要改行做大数据相关的东西了，经调研大数据开发的语言还是用 Scala 好，当然 Java 也可以，毕竟都运行在 JVM 上，不过 Java 也有很长时间没用过了，所以对于 Shaun 来说用 Scala 和 Java 的代价是一样的，都需要学习一下，所以决定用对大数据更友好的 Scala。 以 Martin Odersky 14 年写的「Scala By Example」为参考，虽然是 14 年的，但 Scala 的基本语法还是没变的，就学习本身而言没问题，毕竟不兼容的只是更上层的 API，Shaun 学习用的 Scala 版本为 2.12.12。Alvin Alexander 的「Scala Cookbook, 2nd Edition」预计今年 8 月会出版，到时可能这本书用来入门更好，但 Shaun 不需要系统的学，就简单的能上手写出比较理想的 Scala 代码就行了。学习篇第一章：入门基础HelloWorld 由于「Scala By Example」第一章没啥内容，也为了在正式写 Scala 之前简单熟悉一下，这里先用「A Scala Tutorial for Java Programmers」简单上手一下，首先写个 HelloWorld，具体代码如下：12345object HelloWorld &#123; def main(args: Array[String]) &#123; println("Hello, world!") &#125;&#125; 和 C 语言类似，程序唯一入口函数都是 main 函数，但 Scala 的变量在前，声明的类型在后，相比常规的语言是有点奇怪了，但这种语法规则和 Typescript 一样，所以很容易接受，但其模板的表示就有点奇怪了，Array[String] 表示一个 String 类型的数组，即表示方法为 Array[T]，常规的模板方式为 Array&lt;T&gt; 或 T[]，def 关键字用来定义一个函数，object 用来表示一个单例类，即在定义类的同时，又创建了一个类的实例。Scala 中没有 static 关键字，需要用 static 修饰的都放在 object 中即可。调用 JavaScala 中默认已导入 java.lang 中的全部类，但其它类需要显式导入，以格式化输出本地日期为例：12345678910import java.util.&#123;Date, Locale&#125;import java.text.DateFormat._object LocalDate &#123; def main(args: Array[String]) &#123; val now = new Date val df = getDateInstance(LONG, Locale.CHINA) println(df format now) // df format(now) &#125;&#125; Scala 中的导入和 java 中 import 基本一样，但功能更强大，可以使用 {} 导入部分，也使用 _ 导入全部（java 导入全部为 *，这不一样），当一个函数只有一个参数，可以通过 空格+参数 的形式调用，而不需要使用 括号包裹 的形式。这里采用 val 关键字声明的是常量，而要声明变量需要用 var。对象Scala 中万物皆对象，一个数字也是一个对象，一个函数也是一个对象，具体如下图：enter image description here以简单计时器函数为例：12345678910111213141516171819object Timer &#123; def oncePerSecond(callback: () =&gt; Unit) &#123; while (true) &#123; callback(); Thread sleep 1000; &#125; &#125; def timeFiles() &#123; println("time files like an arrow..."); &#125; def main(args: Array[String]) &#123; // oncePerSecond(timeFiles); oncePerSecond(() =&gt; &#123; println("time files like an arrow..."); &#125;); &#125;&#125; 这个和 Typescript 函数式编程的用法基本差不多，唯一不同这里声明的函数返回的是 Unit ，这个 Unit 可认为是无返回的函数，大部分情况等同于 void，在 Scala 中真正的没有值指的是 Nothing。类Scala 中同样有类，具体代码示例如下：12345678910111213141516class Complex(real: Double, imaginary: Double) &#123; // def re() = real; // def im() = imaginary; def re = real; def im = imaginary; override def toString(): String = "" + re + (if (im &lt; 0) "" else "+") + im + "i";&#125;object ComplexNumbers &#123; def main(args: Array[String]) &#123; val c = new Complex(1.2, -3.4); // println("real part: " + c.re() + " imaginary part: " + c.im()); println(c.toString()); &#125;&#125; 在 Scala 中所有类都会继承某个父类，若没有显式声明父类，则默认继承 scala.AnyRef 类，如上面的 Complex 类，若需要覆盖父类的函数，则需要在函数声明前加上 override 关键字。当函数没有参数时，可以不用加括号，在调用时也不用加括号，如上面示例的注释和非注释的代码。模式匹配与条件类 接下来用 Scala 来写一个树结构表示表达式的示例代码，树的非叶节点表示操作符，叶子节点表示数值（这里为常量或变量），具体代码如下：1234567891011121314151617181920212223242526272829abstract class Treecase class Sum(l: Tree, r: Tree) extends Treecase class Var(n: String) extends Treecase class Const(v: Int) extends Treeobject Expression &#123; type Environment = String =&gt; Int def eval(t: Tree, env: Environment): Int = t match &#123; case Sum(l, r) =&gt; eval(l, env) + eval(r, env) case Var(n) =&gt; env(n) case Const(v) =&gt; v &#125; def derive(t: Tree, v: String): Tree = t match &#123; case Sum(l, r) =&gt; Sum(derive(l, v), derive(r, v)) case Var(n) if (v == n) =&gt; Const(1) case _ =&gt; Const(0) &#125; def main(args: Array[String]) &#123; val exp: Tree = Sum(Sum(Var("x"), Var("x")), Sum(Const(7), Var("y"))) val env: Environment = &#123;case "x" =&gt; 5 case "y" =&gt; 7&#125; println("Expression: " + exp) println("Evalution with x=5, y=7: " + eval(exp, env)) println("Derivative relative to x:\n" + derive(exp, "x")) println("Derivative relative to y:\n" + derive(exp, "y")) &#125;&#125; 该示例主要用来说明两种 case 关键字，分别为：case class 和 … match case …，前者可认为是一个结构体，实例化时可以省略 new 关键字，参数有默认的 getter 函数，整个 case class 有默认的 equals 和 hashCode 方法实现，通过这两个方式可实现根据值判断类的两个实例是否相等，而不是通过引用，条件类同样有默认的 toString 方法实现；后者可认为是一种特殊的 switch case ，只不过 case 的判定和执行是函数式的，case class 可直接参与 match case 的判定（判定是不是属于该类）。第 7 行中有个 type 关键字，可认为是定义了一种新的类型（不是数据类型），示例中是函数类型，通过这个 type ，可直接将字符串映射为整型，23 行中将这个 type 与 case 结合使用，定义多个字符串映射多个整型的变量。第 18 行中有个 _ ，这是 scala 中的通配符，不同的语义下表示的含义不同，这里的含义是指，当上面的模式都不匹配时，将执行这个，相当于 switch case 中的 default。Scala 中的 trait 简单理解就是 Java 中的 Interface（接口），Scala 中没有 interface 关键字，但是 trait 比 Interface 的功能更多，其中可直接定义属性和方法的实现，Scala 中可通过 trait 来实现多重继承。下面的示例用 trait 简单实现了一个比较接口：12345678910111213141516171819202122232425262728293031323334353637383940trait Ord &#123; def &lt;(that: Any): Boolean def &lt;=(that: Any): Boolean = (this &lt; that) || (this == that) def &gt;(that: Any): Boolean = !(this &lt;= that) def &gt;=(that: Any): Boolean = !(this &lt; that)&#125;class Date(y: Int, m: Int, d: Int) extends Ord &#123; def year = y def month = m def day = d override def toString(): String = year + "-" + month + "-" + day override def equals(that: Any): Boolean = &#123; that.isInstanceOf[Date] &amp;&amp; &#123; val o = that.asInstanceOf[Date] o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year &#125; &#125; def &lt;(that: Any): Boolean = &#123; if (!that.isInstanceOf[Date]) &#123; sys.error("cannot compare " + that + " and a Date") &#125; val o = that.asInstanceOf[Date] (year &lt; o.year) || (year == o.year &amp;&amp; (month &lt; o.month || (month == o.month &amp;&amp; day &lt; o.day))) &#125;&#125;object Comparable &#123; def main(args: Array[String]) &#123; val d1 = new Date(2021, 1, 3); val d2 = new Date(2021, 1, 3); println(d1 &lt; d2) println(d1 &lt;= d2) &#125;&#125; 比较关系一般只需要确定 小于 和 等于 关系即可，其它关系都可由这两关系推出来，由于等于方法默认存在于所有对象中，所以只需要重写小于即可， 其它的比较方法都可以在 trait 中定义好。在上面的示例中有两个函数 isInstanceOf 和 asInstanceOf，前者用来判断对象是否是指定类型，后者用来将对象转换为指定类型，一般用在将父类转为子类时，在使用 asInstanceOf 之前一般需要先使用 isInstanceOf。泛型 这东西没啥好说的，基本有编程经验的或见过或用过，只是 Scala 的泛型语法确实有点奇怪就是了，可能也是为了函数式那些乱七八糟的操作符，具体示例代码如下：123456789101112131415class Reference[T] &#123; private var contents: T = _ def set(value: T) &#123; contents = value &#125; def get: T = contents&#125;object IntegerReference &#123; def main(args: Array[String]) &#123; val cell = new Reference[Int] cell.set(13) println("Reference contains the half of " + (cell.get * 2)) &#125;&#125; 这里同样有个 _，这里表示的是默认值，对于数字类型来说是 0，对于 boolean 来说是 false，对于 Unit（函数签名）来说是()（无参数无返回），对于其他来说是 null。简单的了解 Scala 就到这里了。第二章：快排开场就是一个快排，示例代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344object QuickSort &#123; def qSort(xs: Array[Int]) &#123; def swap(i: Int, j: Int) &#123; val t = xs(i); xs(i) = xs(j); xs(j) = t; &#125; def sort(l: Int, r: Int) &#123; val pivot = xs(l); var i = l+1; var j = r; while (i &lt; j) &#123; while (i &lt;= r &amp;&amp; xs(i) &lt; pivot) i += 1; while (j &gt; l &amp;&amp; xs(j) &gt; pivot) j -= 1; if (i &lt; j) &#123; swap(i, j); i += 1; j -= 1; &#125; if (i &gt; j) &#123; i = j; &#125; &#125; while (i &gt; l &amp;&amp; xs(i) &gt; pivot) &#123; i -= 1; j -= 1; &#125; swap(i, l); if (l &lt; j-1) sort(l, j-1); if (j+1 &lt; r) sort(j+1, r); &#125; sort(0, xs.length-1); &#125; def main(args: Array[String]) &#123; // val xs = Array(4, 1, 2, 5, 6); // val xs = Array(1, 2, 4, 4, 55, 5, 6); // val xs = Array(55, 6, 6); val xs = Array(4, 1, 5, 7,7,7,7, 2, 6); qSort(xs); println(xs.mkString(" ")) &#125;&#125; 从这段快排代码可看出，Scala 支持函数嵌套和闭包，即在函数内部定义子函数，子函数可直接使用父函数的变量，同时，这里也简单说明一下 Scala 中数组的一些使用方法，用下标取数组元素时使用的是小括号 ()，而不是其它语言常见的中括号 []。当然 Scala 作为一种函数式语言，提供了非常多的函数式操作符，这篇也只会简单介绍。第三章：Actor Actor，Scala 中的多线程编程模型，下方的示例代码在 Scala 2.11 及之后的版本无法运行，因为 Actor 已从 Scala 库独立出来，见 object-actors-is-not-a-member-of-package-scala。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import scala.actors.Actorabstract class AuctionMessagecase class Offer(bin: Int, client: Actor) extends AuctionMessagecase class Inquire(client: Actor) extends AuctionMessageabstract class AuctionReplycase class Status(asked: Int, expire: Date) extends AuctionReplycase object BestOffer extends AuctionReplycase class BeatenOffer(maxBid: Int) extends AuctionReplycase class AuctionConCluded(seller: Actor, client: Actor) extends AuctionReplycase object AuctionFailed extends AuctionReplycase object AuctionOver extends AuctionReplyclass Auction(seller: Actor, minBid: Int, closing: Date) extends Actor &#123; val timeToShutdown = 36000000 // msec val bidIncrement = 10 def act() &#123; var maxBid = minBid - bidIncrement var maxBidder: Actor = null var running = true while (running) &#123; receiveWithin ((closing.getTime() - new Date().getTime())) &#123; case Offer(bid, client) =&gt; &#123; if (bid &gt;= maxBid + bidIncrement) &#123; if (maxBid &gt;= minBid) maxBidder ! BeatenOffer(bid) maxBid = bid; maxBidder = client; client ! BestOffer &#125; else &#123; client ! BeatenOffer(maxBid) &#125; &#125; case Inquire(client) =&gt; &#123; client ! BeatenOffer(maxBid) &#125; case TIMEOUT =&gt; &#123; if (maxBid &gt;= minBid) &#123; val reply = AuctionConCluded(seller, maxBidder) maxBidder ! reply; seller ! reply &#125; else &#123; seller ! AuctionFailed &#125; receiveWithin(timeToShutdown) &#123; case Offer(_, client) =&gt; client ! AuctionOver case TIMEOUT =&gt; running = false &#125; &#125; &#125; &#125; &#125;&#125;class HelloActor extends Actor &#123; def act() &#123; while (true) &#123; receive &#123; case name: String =&gt; println("Hello, " + name) &#125; &#125; &#125;&#125;object AuctionService &#123; def main(args: Array[String]) &#123; val seller: Actor = new HelloActor val client: Actor = new HelloActor val minBid = 10 val closing = new Date() val helloActor = new HelloActor helloActor.start() helloActor ! "leo" &#125;&#125; 通过重写 Actor 中的 act 方法即可简单的实现多线程编程，Actor 中有个特殊的标识符 !，该符号其实是是一种缩写，即可将 helloActor.!(&quot;leo&quot;) 缩写为 helloActor ! &quot;leo&quot;，代表将数据传递给 Actor，由 Actor 内部的 receive case 接受数据并处理，当然也可通过 receiveWithin 控制数据传递时间，若超时，则默认触发 TIMEOUT 处理模式。第四章：表达式与简单函数该章主要有两个例子：1、牛顿法求平方根；2、尾递归，具体如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647object Sqrt &#123; def sqrt(x: Double): Double = &#123; def sqrtIter(guess: Double, x: Double): Double = &#123; if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) &#125; def improve(guess: Double, x: Double) = &#123; (guess + x / guess) / 2 &#125; def isGoodEnough(guess: Double, x: Double) = (guess * guess - x).abs &lt; 0.001 // guess * guess == x sqrtIter(1.0, x) &#125;&#125;object TailRecursion &#123; def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) def facorial(n: Int): Int = if (n == 0) 1 else n * facorial(n-1) def facorialTail(n: Int): Int = &#123; def facorialIter(n: Int, res: Int): Int = &#123; if (n == 0) res else facorialIter(n-1, res * n) &#125; facorialIter(n, 1) &#125;&#125;object SimpleFunc &#123; def main(args: Array[String]) &#123; val sqrtValue = Sqrt.sqrt(0.01) println(sqrtValue) val gcdValue = TailRecursion.gcd(14,21) println(gcdValue) val facorialValue = TailRecursion.facorial(5) println(facorialValue) val facorialTailValue = TailRecursion.facorialTail(5) println(facorialTailValue) &#125;&#125; 由于并没有引入新的语法，就简单聊聊这两个例子吧。牛顿法求平方根主要在于构造一个特殊的二分函数 \(y_{i+1} = (y_i + x / y_i)/2, i=0,1,2,3,..., y_0=1\) ，如此迭代，直到 \(|y_i^2-x| &lt; \epsilon\) ，得到 \(y_i\) 即为 x 的平方根，更朴素一点的求多次方根就是利用二分法，分 [0, 1] 和 [1, +∞] 两个区间即可，对应从 [x, 1] 和 [1, x] 开始二分取值。至于尾递归，以前简单的写过一点，即最后递归调用原函数时，原函数不会再参与任何计算表达式。尾递归的好处在于当编译器或解释器支持尾递归时，将不会产生普通递归时的压栈操作，即不用担心递归层次太深，尾递归将类似循环迭代处理。第五章：高阶函数 高阶函数（First-Class Functions），支持以函数作为参数或返回值，也可将函数赋值给其它变量，由此也可引出闭包和柯里化，闭包是指将内嵌函数作为返回值，而柯里化是指将多个参数分解为独立参数传递给函数，如：\(f(args_1,args_2,...,args_n)=f(args_1)(args_2)(...)(args_n)\)。下面以求函数的不动点为例：12345678910111213141516171819object FirstClassFunctions &#123; val tolerance = 0.0001 def isCloseEnough(x: Double, y: Double) = ((x-y) / x).abs &lt; tolerance def fixedPoint(f: Double =&gt; Double)(firstGuess: Double) = &#123; def iterate(guess: Double): Double = &#123; val next = f(guess) if (isCloseEnough(guess, next)) next else iterate(next) &#125; iterate(firstGuess) &#125; def averageDamp(f: Double =&gt; Double)(x: Double) = (x + f(x)) / 2 def sqrt(x: Double) = fixedPoint(averageDamp(y =&gt; x/y))(1.0) def main(args: Array[String]) &#123; println(sqrt(0.01)); &#125;&#125; 该示例简单明了的展示了 Scala 中匿名函数，函数柯里化以及闭包。第六章：类和对象直接看下面的有理数示例吧，1234567891011121314151617181920212223242526272829303132333435// 主构造函数class Rational(n: Int, d: Int) extends AnyRef &#123; private def gcd(x: Int, y: Int): Int = &#123; if (x == 0) y else if (x &lt; 0) gcd(-x, y) else if (y &lt; 0) -gcd(x, -y) else gcd(y % x, x) &#125; private val g = gcd(n, d) // 构造函数重载（辅助构造函数） def this() &#123; this(0, 0) // 调用主构造函数 &#125; val number: Int = if (g != 0) n / g else 0 val denom: Int = if (g != 0) d / g else 0 def +(that: Rational) = new Rational(number * that.denom + that.number * denom, denom * that.denom) def -(that: Rational) = new Rational(number * that.denom - that.number * denom, denom * that.denom) def *(that: Rational) = new Rational(number * that.number, denom * that.denom) def /(that: Rational) = new Rational(number * that.denom, denom * that.number) def toNumber: Double = if (denom != 0) number.toDouble / denom else 0.0 override def toString = "" + number + "/" + denom&#125;object Rational &#123; def main(args: Array[String]) &#123; val rational = new Rational(2,1) / new Rational() println(rational.toNumber); println(rational.toString); &#125;&#125; 从有理数这个示例可以看出，Scala 的类支持操作符重载，也支持构造函数重载，同样支持继承，多继承也是支持的，每个父类用 with 关键字分隔就行。第七章：条件类和模式匹配大致和第一章内容差不多，就不重复写了。第八章：泛型 大致也和第一章内容差不多，值得一提的书中实现的泛型栈本质是一个链表，实现方法挺有意思的。通过 &lt;: 标识符可约束泛型的类型，如 [T &lt;: P[T]] 表明泛型 T 必须类型 P 的子类型。而标识符 &lt;% 比 &lt;: 约束性弱一点，只要 T 能够通过隐式类型变换为 P 即可。若想约束为父类型，则需使用 &gt;: 标识符。 Scala 中有一种特殊的泛型，就是变化型注解，trait List[+T] 代表协变，表示当 B 类型是 A 类型子类时，List[B] 也可认为是 List[A] 的子类；trait List[-T] 代表逆变，当 B 类型是 A 类型子类时，List[B] 可认为是 List[A] 的父类。 Scala 中同样有元组，使用时也很方便，简单使用直接用括号声明即可，如 def divmod(x: Int, y: Int): (Int, Int) = (x / y, x % y)，该函数即返回一个元组，也可声明一个元组 case class Tuple2[A, B](_1: A, _2: B)，若需要取元组的元素可通过 _i 的方式，如 val xy = divmod(3, 4); xy._1; xy._2;，也可通过 match-case 语句取，如 xy match { case (n, d) =&gt; println(&quot;quotient: &quot; + n + &quot;, rest: &quot; + d) }。第九章：List Scala 中的 List 其实是数组结构，并且是不可变的，可认为是 C++ 里的静态数组，不能往其中添加或删除元素，下面用数组排序示例下 List 的用法：123456789101112131415161718192021222324252627282930313233343536object Sort &#123; def insertSort(xsl: List[Int]): List[Int] = &#123; def insert(x: Int, xs: List[Int]): List[Int] = &#123; xs match &#123; // case Nil =&gt; List(x) case List() =&gt; List(x) case y :: ys =&gt; if (x &lt;= y) x :: xs else y :: insert(x, ys) &#125; &#125; if (xsl.isEmpty) Nil else insert(xsl.head, insertSort(xsl.tail)) &#125; def mergeSort[A](less: (A, A) =&gt; Boolean)(xs: List[A]): List[A] = &#123; def merge(xs1: List[A], xs2: List[A]): List[A] = &#123; if (xs1.isEmpty) xs2 else if (xs2.isEmpty) xs1 else if (less(xs1.head, xs2.head)) xs1.head :: merge(xs1.tail, xs2) else xs2.head :: merge(xs1, xs2.tail) &#125; val n = xs.length / 2 if (n == 0) xs else merge(mergeSort(less)(xs take n), mergeSort(less)(xs drop n)) &#125; def main(args: Array[String]) &#123; val xs = List(4, 1, 5, 7,7,7,7, 2, 6); // val xs = 3::2::1::1::Nil; println(xs(0), xs(1), xs(xs.length-1)) // (4,1,6) // val ys = insertSort(xs); val ys = mergeSort((x: Int, y: Int) =&gt; x &gt; y)(xs); println(ys.mkString(" ")) &#125;&#125; List 中有两个操作符非常类似，即 :: 和 :::， 前者用于 List 中的元素和 List 连接，即创建一个新 List，新 List 为原 List 头插入元素后的 List，后者用于连接两个 List，即创建一个新 List ，新 List 为将第二个 List 的元素全部放入第一个 List 尾部的 List。字符 Nil 代表空 List 和 List() 等效，head 方法返回 List 的第一个元素，tail 方法返回除第一个元素之外的其它所有元素，还是一个 List，isEmpty 方法当 List 为空时返回 true。List 的 case-match 方法中，case y :: ys 其中 y 代表 xs.head，ys 代表 xs.tail。(xs take n) 表示取 List 前 n 个元素，(xs drop n) 表示取 List 前 n 个元素之外的元素，即与 (xs take n) 取得元素正好互补，而 (xs split n) 返回一个元组，元组中第一个元素为 (xs take n)，第二个元素为 (xs drop n)。关于 List 还有些更高阶得方法：filter，map, flatMap, reduceRight, foldRight 等方法就不继续写了。至于动态 List 可用 ListBuffer 结构，当然 Scala 中直接用 Seq 作为返回值和参数一般会更好些。第十章：序列理解 Scala 中用来做序列理解的表达式是 For-Comprehensions，具体示例如下：for (p &lt;persons if p.age &gt; 20) yield p.name 相当于 persons filter (p =&gt; p.age &gt; 20) map (p =&gt; p.name)，可以简单认为 for-yield 方法是 filter 和 map 的集合体。下面具体用个 N-皇后（特例是 8 皇后）的示例来具体说明：1234567891011121314151617181920212223242526272829303132object NQueen &#123; def queens(n: Int): List[List[Int]] = &#123; def isSafe(col: Int, queenList: List[Int], delta: Int): Boolean = &#123; val curRow = queenList.length-1 + delta for (row &lt;- List.range(0, queenList.length)) &#123; val queenCol = queenList(row) val queenRow = queenList.length-1 - row if (queenCol == col) return false if (queenRow == curRow) return false if ((queenCol - col).abs == (queenRow - curRow).abs) return false &#125; true &#125; def placeQueens(k: Int): List[List[Int]] = &#123; if (k == 0) List(List()) else for &#123; queens &lt;- placeQueens(k-1); column &lt;- List.range(0, n); if isSafe(column, queens, 1) &#125; yield column :: queens &#125; placeQueens(n) &#125; def main(args: Array[String]) &#123; val queenList = queens(8); println("queenCount: " + queenList.length) // 92 &#125;&#125;for-yield 表达式中 for 中可以写多条语句，代表多重循环，第 5 行的 for 代表 for 循环，&lt;- 表示取 List 中的元素。 剩下的几章就没啥特别要写的，重点就两个特性，一个是 Stream ，一个 Lazy，Stream 和 List 有点类似，主要区别在于 Stream 是即时返回的，算一个返回一个，而 List 一般是全部计算完再返回一个 List；Lazy 一般用作常量的修饰符，主要作用是只用该常量被用到时才赋值，否则一直为空，有点类似常见的先判空再取值的封装。后记 曾看到过通过刷题去学习新语言的方式，一直都以为很粗暴，但这次照着「Scala By Example」敲下来，感觉还挺有效的，同时也巩固了一下基本的算法知识，后续再把 twitter 的 「Effective Scala」再看一下应该就差不多了。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020年小结]]></title>
    <url>posts/28416d7c.html</url>
    <content type="text"><![CDATA[社畜不易，行者多难，披荆斩棘，前路莫测，步履不停。前言 20 年，也算是正式步入社畜生活的第一年，新鲜感自然少不了，但也没持续很长时间。这一年中基本都在学习，工作中生活中都在熟悉新事物新模式。技术篇 开始独立负责项目，从无到有写完了一个产品，做了半个地图可视化项目，图形学相关知识从完全不会到熟练使用 Shader 做简单特效，学习新语言使用新工具，这就是 Shaun 过去一年在工作中的写照。 在产品中，Shaun 基本独立完成了调研设计编码的全过程，这款网页版的 OpenDrive 路网编辑器，让 Shaun 基本熟悉的前端开发的主流框架和打包流程，甚至基于这款编辑器继续引申出两个 SDK，虽然开发模式和真正的前端有所区别（Shaun 是把 Typescript 当 C# 用的，将网页程序当客户端程序开发），但感觉现在的浏览器完全能撑的住，完全可以将更多的计算和存储任务直接在前端全部做完，但同时也感到了纯前端的无力，没有后端，前端网页能呈现的数据和效果确实有限，网页的内存有限制，webgl 渲染的三角形也有限制，只能做些小东西，大场景就很难施展。路网编辑器中涉及的前端技术栈也有很多，主要是现在无论开发一个什么应用，都不可能从语言最底层的 api 写起，总会用到别人写好的库，熟悉，吸收，再修改，用着用着就需要自己写了，从用轮子到造轮子，从而产生更多的轮子，也算是一种良性循环。 半个地图可视化项目，主要用的 mapbox-gl + geoserver 显示地图，做完这个项目，同时也基本了解了国内的百度和高德两家的地图突然变好看了的原因，其背后的技术也同样源自于 mapbox，一家真正小而美的公司，定义了一套前端渲染地图的数据标准（Vector Tile），在非 3D 地图上，这套标准就是业内通用的标准了，如今的导航地图用的都是这套前端渲染技术，美观又高效。生活篇 整个 20 年出去玩的时间也不多，工作地所在能玩的地方基本也玩的差不多了，大部分时间都是宅在屋里看电影，学技术，感觉就非常平淡，也没啥特别好说的。20年，开始学习理财，锻炼买入卖出的感觉，由于整个 20 年股市一片良好，以至于 Shaun 这个新手也赚了些钱，但由于本钱不多，赚的也非常有限，赚大钱的机会，要么拿不住，要么下不去手，最终都失之交臂，这样一来，赚的就更少了，不过，股市中赚到的钱终究只是个数字，到手的才是赚到的，没到手是赚是亏还不好说，作为新手而言，Shaun 也就当玩玩而已，亏也不多，主要是锻炼自己的感觉或承受能力，反正理财是一辈子的事，不急于这一时。总结 生活一年如一日的平淡如水，依旧独自前行，由于疫情的原因，出去看看都嫌太麻烦，只能周边走走，着实无聊，好在工作上的东西对 Shaun 来说是新的知识，稍微有点挑战，每解决一个问题，总会带来一些成就感，冲淡些许无聊，可这成就感越来越少了，或许哪天成就感完全消失，就是 Shaun 换个新环境的时候。20 年获得技能：触类旁通20 年获得成就：独挡一面]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时空查询之ECQL]]></title>
    <url>posts/489fa7b3.html</url>
    <content type="text"><![CDATA[前言 ECQL 是 CQL 的扩展，CQL 是 OGC 标准查询语言，而 ECQL 是 GeoTools 为更好的方便查询，在编程实现时扩展了 CQL，主要扩展在于其移除了 CQL 的一些限制（属性必须在比较运算符的左边，不能创建 Id Filter 进行查询等限制），也和 SQL 更相似。所以可简单认为 CQL 是书面上的标准，而 ECQL 是事实上的标准。谓词篇时间查询主要有以下几个查询谓词：谓词作用T TEQUALS Time测试 T 和给定时间相等，相当于 T == Time。T BEFORE Time测试 T 在给定时间之前，相当于 T &lt; Time。T BEFORE OR DURING Time Period测试 T 在给定时间段之前或其中，相当于 T &lt;= TimePeriod[1]。T DURING Time Period测试 T 在给定时间段其中，相当于 TimePeriod[0] &lt;= T &lt;= TimePeriod[1]。T DURING OR AFTER Time Period测试 T 在给定时间段其中或之后，相当于 TimePeriod[0] &lt;= T。T AFTER Time测试 T 在给定时间之后，相当于 T &gt; Time。时间段以 / 分隔符区分前后两个时间，时间格式一般为 yyyy-MM-dd’T’HH:mm:ss.SSS’Z’。空间查询主要有以下几个查询谓词：谓词作用INTERSECTS(A: Geometry, B: Geometry)测试 A 与 B 相交，与 DISJOINT 相反。DISJOINT(A: Geometry, B: Geometry)测试 A 与 B 不相交，与 INTERSECTS 相反。CONTAINS(A: Geometry, B: Geometry)测试 A 包含 B，与 WITHIN 相反。WITHIN(A: Geometry, B: Geometry)测试 B 包含 A，即 A 在 B 中，与 CONTAINS 相反。TOUCHES(A: Geometry, B: Geometry)测试 A 的边界是否与 B 的边界接触，但内部不相交。CROSSES(A: Geometry, B: Geometry)测试 A 与 B 是否相交，但不存在包含关系。OVERLAPS(A: Geometry, B: Geometry)测试 A 与 B 是否重叠，需满足 A 与 B 是同一类型（如都是 POLYGON），并且相交区域同样是 A 和 B 的类型（只能是 POLYGON，不能是 POINT）。EQUALS(A: Geometry, B: Geometry)测试 A 与 B 完全相等。RELATE(A: Geometry, B: Geometry, nineIntersectionModel: String)测试 A 与 B 是否满足 DE-9IM 模型，该模型可模拟上述所有情况。DWITHIN(A: Geometry, B: Geometry, distance: double, units: String)测试 A 与 B 的最短距离是否不超过多少距离，单位有（feet, meters, statute miles, nautical miles, kilometers）。BEYOND(A: Geometry, B: Geometry, distance: Double, units: String)测试 A 与 B 的最短距离是否超过多少距离。BBOX(A: Geometry, leftBottomLng: Double, leftBottomLat: Double, rightTopLng: Double, rightTopLat: Double, crs=“EPSG:4326”)测试 A 是否与给定 box 相交。Geometry 是指 WKT 格式的数据，主要有以下几种：类型示例POINTPOINT(6 10)LINESTRINGLINESTRING(3 4,10 50,20 25)POLYGONPOLYGON((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2))MULTIPOINTMULTIPOINT(3.5 5.6, 4.8 10.5)MULTILINESTRINGMULTILINESTRING((3 4,10 50,20 25),(-5 -8,-10 -8,-15 -4))MULTIPOLYGONMULTIPOLYGON(((1 1,5 1,5 5,1 5,1 1),(2 2,2 3,3 3,3 2,2 2)),((6 3,9 2,9 4,6 3)))GEOMETRYCOLLECTIONGEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))※注： POLYGON 中的边界点必须闭合，即首尾点相同，若存在多个边界，则需要遵循 逆时针,顺时针,逆时针,顺时针… 的点排列顺序，逆时针封闭，顺时针开孔，以形成具有岛和洞的复杂多边形。 由于 WKT 标准只支持二维的坐标，为支持三维坐标以及齐次线性计算，所以在 PostGIS 中又有 EWKT 标准实现，EWKT 扩展了 WKT，带 Z 结尾用来支持三维坐标，带 M 结尾用来支持齐次线性计算，如 POINTZ(6 10 3)，POINTM(6 10 1)，POINTZM(6 10 3 1)，同时还支持坐标内嵌空间参考系，如 SRID=4326;LINESTRING(-134.921387 58.687767, -135.303391 59.092838)。GeoTools 19.0 之后也默认以 EWKT 进行解析和编码。查询篇属性字段查询12345678910111213141516171819202122// 查询属性 ATTR1 小于 7 的数据Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; (1 + ((3 / 2) * 4))&quot; );// 查询属性 ATTR1 小于属性 ATTR2 绝对值的数据Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; abs(ATTR2)&quot; );// 查询属性 ATTR1 为 test 字符串的数据Filter filter = ECQL.toFilter(&quot;ATTR1 == &apos;test&apos;&quot; );// 查询属性 ATTR1 在 10 和 20 之间的数据Filter filter = ECQL.toFilter( &quot;ATTR1 BETWEEN 10 AND 20&quot; );Filter filter = ECQL.toFilter( &quot;ATTR1 &gt;= 10 AND ATTR1 &lt;= 20&quot; );// 多条件查询Filter filter = ECQL.toFilter(&quot;ATTR1 &lt; 10 AND ATTR2 &lt; 2 OR ATTR3 &gt; 10&quot; );// 查询属性 ATTR1 为 silver 或 oil 或 gold 的数据Filter filter = ECQL.toFilter(&quot;ATTR1 IN (&apos;silver&apos;,&apos;oil&apos;, &apos;gold&apos; )&quot;);// 以 ID 主键进行查询Filter filter = ECQL.toFilter(&quot;IN (&apos;river.1&apos;, &apos;river.2&apos;)&quot;);Filter filter = ECQL.toFilter(&quot;IN (300, 301)&quot;);模糊查询1234567891011// 查询属性 ATTR1 包含 abc 字符串的数据Filter filter = ECQL.toFilter( &quot;ATTR1 LIKE &apos;%abc%&apos;&quot; );// 查询属性 ATTR1 开头不为 abc 字符串的数据Filter filter = ECQL.toFilter( &quot;ATTR1 NOT LIKE &apos;abc%&apos;&quot; );// 查询属性 cityName 开头为 new 的数据，忽略 new 的大小写Filter filter = ECQL.toFilter(&quot;cityName ILIKE &apos;new%&apos;&quot;);// 测试字符串是否包含Filter filter = ECQL.toFilter(&quot;&apos;aabbcc&apos; LIKE &apos;%bb%&apos;&quot;);空属性查询12345678// 查询有属性 ATTR1 存在的数据Filter filter = ECQL.toFilter( &quot;ATTR1 EXISTS&quot; );// 查询属性 ATTR1 不存在的数据Filter filter = ECQL.toFilter( &quot;ATTR1 DOES-NOT-EXIST&quot; );// 查询 Name 为 NULL 的数据Filter filter = ECQL.toFilter(&quot;Name IS NULL&quot;);时间查询1234567891011121314151617// 查询时间属性 dtg 等于的数据Filter filter = ECQL.toFilter( &quot;dtg TEQUALS 2006-11-30T01:30:00Z&quot; );// 查询时间属性 dtg 在之后的数据Filter filter = ECQL.toFilter(&quot;dtg AFTER 2006-11-30T01:30:00Z&quot;);// 查询时间属性 dtg 在之前的数据Filter filter = ECQL.toFilter(&quot;dtg BEFORE 2006-11-30T01:30:00Z&quot;);// 查询时间属性 dtg 在之间的数据，+3:00 代表 GMT 时间 +3 小时，以 Z 结尾的时间就是 GMT 时间Filter filter = ECQL.toFilter( &quot;dtg DURING 2006-11-30T00:30:00+03:00/2006-11-30T01:30:00+03:00 &quot;);// 查询时间属性 dtg 等于的数据Filter filter = ECQL.toFilter(&quot;dtg = 1981-06-20&quot;);// 查询时间属性 dtg 小于等于的数据Filter filter = ECQL.toFilter(&quot;dtg &lt;= 1981-06-20T12:30:01Z&quot;);空间查询1234567891011121314151617181920212223// 查询空间属性 geom 包含点的数据Filter filter = ECQL.toFilter( &quot;CONTAINS(geom, POINT(1 2))&quot; );// 查询空间属性 geom 与 box 相交的数据Filter filter = ECQL.toFilter( &quot;BBOX(geom, 10,20,30,40)&quot; );// 查询空间属性 geom 与点最短距离不超过 10 千米的数据Filter filter = ECQL.toFilter( &quot;DWITHIN(geom, POINT(1 2), 10, kilometers)&quot; );// 查询空间属性 geom 与线相交的数据（geom 也必须是线）Filter filter = ECQL.toFilter( &quot;CROSS(geom, LINESTRING(1 2, 10 15))&quot; );// 查询空间属性 geom 与 GEOMETRYCOLLECTION 相交的数据（geom 也必须是 GEOMETRYCOLLECTION）Filter filter = ECQL.toFilter( &quot;INTERSECT(geom, GEOMETRYCOLLECTION (POINT (10 10),POINT (30 30),LINESTRING (15 15, 20 20)) )&quot; );// 查询空间属性 geom 与线相交的数据Filter filter = ECQL.toFilter( &quot;CROSSES(geom, LINESTRING(1 2, 10 15))&quot; );// 查询空间属性 geom 与 GEOMETRYCOLLECTION 相交的数据Filter filter = ECQL.toFilter( &quot;INTERSECTS(geom, GEOMETRYCOLLECTION (POINT (10 10),POINT (30 30),LINESTRING (15 15, 20 20)) )&quot; );// 查询空间属性 geom 与包含线的数据Filter filter = ECQL.toFilter(&quot;RELATE(geom, LINESTRING (-134.921387 58.687767, -135.303391 59.092838), T*****FF*)&quot;); 在 GeoTools 中，可通过 FilterFactory 来构造 Filter，而不是直接写字符串，具体示例如下：12345678910111213FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();// 相当于 Filter filter1 = ECQL.toFilter("ATTR1 = 1 AND ATTR2 &lt; 4" );List&lt;Filter&gt; filterList = ECQL.toFilterList("ATTR1=1; ATTR2&lt;4");Filter filter1 = ff.and(filterList);// 相当于 Filter filter2 = ECQL.toFilter( "BBOX(geom, 10,20,30,40)" );Filter filter2 = ff.bbox("geom", 10, 20, 30, 40, "EPSG:4326");// 相当于 Filter filter3 = ECQL.toFilter( "dtg DURING 2006-11-29T00:30:00Z/2006-11-30T00:30:00Z");Date startTime = ZonedDateTime.of(2006, 11, 29, 0, 30, 0, 0, ZoneOffset.UTC);Date endTime = Date.from(startTime.plusDays(1).toInstant());Filter filter3 = ff.between(ff.property("dtg"), ff.literal(startTime), ff.literal(endTime));后记 基本可认为 CQL 和 SQL 中查询条件差不多，虽然不支持分组查询等复杂 SQL 特性，但对于一般的时空查询基本够用，CQL 中还有些空间操作函数就不继续写了，如取面积，取缓冲区，取交集，取长度等等，有需要的可自行查询 uDig Common Query Language。参考资料GeoTools CQLGeoTools ECQLGeoServer ECQL Reference / GeoServer 属性查询和空间查询支持 CQL / ECQL过滤器语言WKT解读GEOS库学习之三：空间关系、DE-9IM和谓词]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GeoMesa踩坑指北]]></title>
    <url>posts/9978824c.html</url>
    <content type="text"><![CDATA[前言 需要做个 GeoMesa 的微服务，简单熟悉一下 GeoMesa。基础篇 GeoMesa 可以说是大数据中的 PostGIS，主要用来在存储和处理 GIS 数据时提供相应的索引，从而加快处理速度。GeoMesa 基于 GeoTools，其中最重要的两个概念就是 SimpleFeatureType 和 SimpleFeature，SimpleFeatureType 对应的是关系型数据库中表的描述（表明，表的列字段属性信息等），而 SimpleFeature 对应的是表中每行数据。下面重点谈谈 GeoMesa 中的 SimpleFeatureType 以及其创建索引方式。 在 GeoMesa 中通常使用 SimpleFeatureTypes.createType 方法进行创建，该方法有两个重载，以没有 namespace 参数的方法为例：1234def createType(typeName: String, spec: String): SimpleFeatureType = &#123; val (namespace, name) = parseTypeName(typeName) createType(namespace, name, spec)&#125;先通过 parseTypeName 解析 typeName，以 : 作为分隔符，取最后一个有效（不为空）字符串作为表名（name），其余部分如有效则作为 namespace，否则 namespace 则为 null。spec 参数的通用形式有以下几种：1234567val spec = "name:String,dtg:Date,*geom:Point:srid=4326"val spec = "name:String,dtg:Date,*geom:Point:srid=4326;geomesa.indices.enabled='z2,id,z3'"val spec = "name:String:index=true,tags:String:json=true,dtg:Date:default=true,*geom:Point:srid=4326;geomesa.indices.enabled='z2,id,z3'"val spec = "userId:String,trackId:String,altitude:Double,dtg:Date,*geom:Point:srid=4326;geomesa.index.dtg='dtg',geomesa.table.sharing='true',geomesa.indices='z3:4:3,z2:3:3,id:2:3',geomesa.table.sharing.prefix='\\u0001'"先使用 ; 分隔符，再使用 , 分隔符，最后使用 : 分隔符。; 分隔符将 spec 分割为两个字符串：前者表示表中的全部列属性信息，列属性经过 , 分隔符分割为多列，列又经过 : 分隔符分割为 列名，列数据类型，列的一些属性（是否是索引，json 数据，默认索引等），而列名首字母 * 代表该字段是用于索引的 geometry 类型，一般采用 WKT 格式进行描述，当然存在数据库时会以字节码进行压缩；后者表示创建表时的 userData，同样经过 , 分隔符分割为多个 userData，userData 的一些默认属性可在 SimpleFeatureTypes.Configs 中看到，其它的可以用户自定义，这里重点说一下 geomesa.indices.enabled 属性，目前 GeoMesa 支持 8 种索引，分别为：12345678&quot;attr&quot;, // 属性索引&quot;id&quot;, // 主键索引&quot;s2&quot;, // Hilbert 曲线点空间索引&quot;s3&quot;, // Hilbert 曲线点时空索引&quot;z2&quot;, // Z 型曲线点空间索引&quot;xz2&quot;, // Z 型曲线线面空间索引&quot;z3&quot;, // Z 型曲线点时空索引&quot;xz3&quot; // Z 型曲线线面时空索引 由于 GeoMesa 中的索引一般存在多个版本，而 geomesa.indices.enabled 默认使用最新的版本，若需要指定版本，需要使用 geomesa.indices，该属性是 geomesa 内部属性，不对外开放，通用格式为：1s"$name:$version:$&#123;mode.flag&#125;:$&#123;attributes.mkString(":")&#125;"name 代表索引类别，version 代表索引版本，mode.flag 代表索引模式（是否支持读写，一般为3，支持读也支持写），attributes 代表是哪些字段需要建立该索引。spec 参数可以只有描述列属性的字段，即不带任何 useData 信息，GeoMesa 会默认添加索引信息，若存在空间和时间字段，则会默认建立 z3（空间字段为点 Point 类型） 或 xz3（空间字段为线面 非Point 类型） 索引，若有多个空间和时间字段，建立索引的字段为第一个空间和第一个时间字段；若只存在空间字段，则会建立 z2 或 xz2 索引；若只有时间字段，则默认建立时间属性索引。当然如没有在 spec 指明索引信息，可以在后续继续添加信息，如下：12345678910import org.locationtech.geomesa.utils.interop.SimpleFeatureTypes;String spec = "name:String,dtg:Date,*geom:Point:srid=4326";SimpleFeatureType sft = SimpleFeatureTypes.createType("mySft", spec);// enable a default z3 and a default attribute indexsft.getUserData().put("geomesa.indices.enabled", "z3,attr:name");// or, enable a default z3 and an attribute index with a Z2 secondary indexsft.getUserData().put("geomesa.indices.enabled", "z3,attr:name:geom");// or, enable a default z3 and an attribute index with a temporal secondary indexsft.getUserData().put("geomesa.indices.enabled", "z3,attr:name:dtg");坑篇导入 OSM 数据问题 在导入 osm 数据时，若使用 osm-ways 作为 SimpleFeatureType，则 geomesa 会使用数据库存储 node 临时使用，这时其默认使用 H2 Database，若想使用其它数据库，则需要在 lib 导入相应 jdbc 包，若使用 postgresql 数据库，则 geomesa 会触发一个 bug，因为 postgresql 没有 double 类型，只有 double precision 类型，这将导致建表出错。详情见 geomesa/geomesa-convert/geomesa-convert-osm/src/main/scala/org/locationtech/geomesa/convert/osm/OsmWaysConverter.scala 中1234private def createNodesTable(): Unit = &#123; val sql = "create table nodes(id BIGINT NOT NULL PRIMARY KEY, lon DOUBLE, lat DOUBLE);" WithClose(connection.prepareStatement(sql))(_.execute())&#125;所以若需要使用 geomesa-convert-osm 导入 osm 数据时，需要进入 geomesa/geomesa-convert/geomesa-convert-osm 文件夹中输入命令1mvn dependency:copy-dependencies -DoutputDirectory=./depLib导出 geomesa-convert-osm 依赖包，将其中的 h2，osm4j，dynsax，trove4j 等一系列库放入 $GEOMESA_HBASE_HOME/lib 中。s2 索引问题 s2 索引即 Google S2 Geometry 算法基于 Hilbert 曲线生成一种索引，GeoMesa 的 s2 索引是一个国人提交的，目前 3.2 版本只支持点的时空索引，不支持线面的时空索引，当然官方也在实现自己的 Hilbert 曲线，希望后续 GeoMesa 中会有 h2 索引。Shaun 在导入 osm 数据并启用 s2 索引时，报错，被提示不支持，对比 geomesa-index-api22Index.scala 和 geomesa-index-api22Index.scala 两文件的 defaults 函数可发现 S2Index 直接返回空，而在 geomesa-index-api.scala 中 fromName 函数需要调用 defaults 函数，从而导致 s2 索引不支持，修改 S2Index 的 defaults 函数即可（别忘了在 S2Index 类中首行加上 import org.locationtech.geomesa.utils.geotools.RichSimpleFeatureType.RichSimpleFeatureType）。后记 暂时就了解了这么多，等后续熟悉的更多再继续更吧 (ง •_•)ง。附录GeoMesa 命令行工具部分参数Geomesa 命令行参数：参数描述-c, –catalog *存放 schema 元数据的catalog 表（相当于数据库）-f, –feature-nameschema 名（相当于数据库中的表）-s, –spec要创建 SimpleFeatureType 的说明（即表中列的描述信息，表的 schema，如 &quot;name:String,age:Int,dtg:Date,*geom:Point:srid=4326&quot;）-C, –converter指定转换器，必须为一下之一：1、已经在classpath中的converter 名；2、converter 的配置（一个字符串）；3、包括converter的配置的名–converter-error-mode自定义的转换器的error mode-t, –threads指定并行度–input-format指定输入源格式（如csv, tsv, avro, shp, json,）–no-tracking指定提交的 ingest job何时终止（在脚本中常用）–run-mode指定运行模式，必须为：local（本地）、distributed （分布式）、distributedcombine（分布式组合）之一–split-max-size在分布式中，指定切片最大大小（字节）–src-list输入文件为文本文件，按行输入–force禁用任何的提示[files]…指定输入的文件参考资料：GeoMesa命令行工具—摄取命令]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>bigdata</tag>
        <tag>geomesa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA使用Docker环境开发调试]]></title>
    <url>posts/3692cd6.html</url>
    <content type="text"><![CDATA[前言 IDEA 以前基本没用过，只是简单用过 Android Studio，还基本都忘记了 ( ╯□╰ )，以后应该会用 Scala 做一些大数据方面的东西，而大数据的环境都是 Linux 下的，而 Shaun 日常都是在 Windows 下开发，所以需要用日前做的容器环境来测试调试运行程序，简单记录一下 IDEA 在这方面的使用方法。运行篇 右键项目名（HelloWorld），新建文件（New =》File），指定文件名为 Dockerfile 。写入内容示例如下：1234FROM stc:2.0COPY ./target/classes/ /tmpWORKDIR /tmpENTRYPOINT ["scala","HelloWorld"]点击左上角绿色双箭头，可编辑 Dockerfile（Edit ‘Dockerfile’） ，指定当前上下文目录（Context folder），Contaier name 等容器启动选项。直接运行 Dockerfile（Run ‘Dockerfile’），IDEA 即可自动创建容器，并在容器中运行程序，程序运行完则容器自动停止，若需要运行存在外部依赖的程序，则只能以 jar 包的方式运行。 设置 IDEA 生成 jar 包如下：在最上面的菜单栏中 File =》Project Structure =》Artifacts =》+ =》JAR =》From modules with dependencies，选择 Main Class，点击右边的文件夹图标即可选择相应类，由于存在外部依赖，所以不能直接用默认的 extract to the target JAR，而是应该选择下面的 copy to the output directory and link via manifest，点击 OK 后，自动或手动选择导出的依赖 jar 包，点击 OK。在最上面的菜单栏中 Build =》Build Artifacts…，可在 out/artifacts/HelloWorld_jar 文件夹中生成所有 jar 包。之后编辑 Dockerfile， 更改 Dockerfile 上下文目录为 out/artifacts/HelloWorld_jar ，指定容器名，在 Command 中输入 java -jar HelloWorld.jar 修改 Dockerfile 中第 2 行命令为 COPY . /tmp，修改第 4 行命令为 CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;HelloWorld.jar&quot;]。之后运行 Dockerfile 即可在下面 Services 栏对应 Docker 容器 Attached Console 中看到程序运行结果。调试篇 除了使用 IDEA 生成 jar 包外，还需要使用 IDEA 的远程调试功能，设置 IDEA 远程调试功能如下：在最上面的菜单栏中 Run =》Edit Configurations… =》+ =》Remote JVM Debug，上方的 Debugger mode 中使用默认的 Attach to remote JVM， 在下面的 Before launch 添加 Launch Docker before debug。在弹窗中选择相应 Dockerfile，在下方的 Custom command 中输入 java -agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005 -jar HelloWorld.jar， 完成后即可使用该配置在 IDEA 调试容器中运行的程序。后记 用这种方式使用 IDEA 确实达到了 Shaun 理想的结果，Windows 下开发，Docker 中调试和运行，应付简单的代码调试和运行确实是没问题，但是在复杂的分布式环境下总会碰到一些莫名奇妙的问题，这些问题就是纯粹的经验了。参考资料Run a Java application in a Docker containerDebug a Java application using a Dockerfile]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>devtool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据环境搭建笔记]]></title>
    <url>posts/af5e9ace.html</url>
    <content type="text"><![CDATA[前言 准备开始搞时空数据了，先简单搭一下环境。准备搭的环境为：jdk-1.8.0，hadoop-3.2.1，hbase-2.2.6，geomesa-hbase_2.11-3.1.0，spark-3.0.1-bin-hadoop3.2，geoserver-2.16.5-bin，geomesa-hbase_2.11-3.2.0-SNAPSHOT，所用的包都已下好并解压到 /home 目录下。※注： hbase-2.2.6 暂不支持最新的 hadoop-3.3.0，Hadoop 也最好使用 jdk-1.8.0，java-11 会有问题。Hadoop 环境 首先修改 /etc/hosts 文件中本机 ip 对应的名称为 master，若在容器中安装则需要在 run 开启容器就指定 --hostname master，否则改了也没用，下次启动容器时 hostname 又会回到初始状态，下面开启正式的配置。修改 /home/hadoop-3.2.1/etc/hadoop/hadoop-env.sh 文件，添加1export JAVA_HOME=$JAVA_HOME修改 /home/hadoop-3.2.1/etc/hadoop/core-site.xml 文件，添加12345678910111213141516171819&lt;configuration&gt; &lt;!-- master 前面配置的主机名称 --&gt; &lt;!-- &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; --&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/data/tmp&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;修改 /home/hadoop-3.2.1/etc/hadoop/hdfs-site.xml 文件，添加12345678910111213&lt;configuration&gt; &lt;property&gt; &lt;!--指定SecondaryNameNode位置--&gt; &lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt; &lt;value&gt;master:9001&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;修改 /home/hadoop-3.2.1/etc/hadoop/yarn-site.xml 文件，添加12345678910&lt;configuration&gt;&lt;!-- Site specific YARN configuration properties --&gt;&lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;修改 /home/hadoop-3.2.1/etc/hadoop/mapred-site.xml 文件，添加12345678&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;在 /home/hadoop-3.2.1/sbin/start-dfs.sh 和 /home/hadoop-3.2.1/sbin/stop-dfs.sh 文件头添加12345#!/usr/bin/env bashHDFS_DATANODE_USER=rootHDFS_DATANODE_SECURE_USER=hdfsHDFS_NAMENODE_USER=rootHDFS_SECONDARYNAMENODE_USER=root在 /home/hadoop-3.2.1/sbin/start-yarn.sh 和 /home/hadoop-3.2.1/sbin/stop-yarn.sh 文件头添加1234#!/usr/bin/env bashYARN_RESOURCEMANAGER_USER=rootHADOOP_SECURE_DN_USER=yarnYARN_NODEMANAGER_USER=root设置环境变量，在 /etc/profile 中添加12345#Hadoop Environment Settingexport HADOOP_HOME=/home/hadoop-3.2.1export JAVA_LIBRARY_PATH=$HADOOP_HOME/lib/nativeexport LD_LIBRARY_PATH=$JAVA_LIBRARY_PATHexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin由于容器中默认为 root 用户，所以在 /root/.bashrc 文件末尾添加 source /etc/profile，以开机启用设置的环境变量。在启动 Hadoop 之前需要执行 hdfs namenode -format 进行格式化，启动命令为 /home/hadoop-3.2.1/sbin/start-all.sh。后续若需要清空并重新设置 Hadoop 时，必须先删除 /home/hadoop/ 目录，再重新进行格式化。HBase 环境修改 /home/hbase-2.2.6/conf/hbase-env.sh 文件，添加123export JAVA_HOME=$JAVA_HOME# 使用自带的ZooKeeper管理export HBASE_MANAGES_ZK=true修改 /home/hbase-2.2.6/conf/hbase-site.xml 文件，添加123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.dynamic.jars.dir&lt;/name&gt; &lt;value&gt;hdfs://master:9000/hbase/lib&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.master.maxclockskew&lt;/name&gt; &lt;value&gt;180000&lt;/value&gt; &lt;description&gt;Time difference of regionserver from master&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;!-- 修改默认8080 端口--&gt; &lt;property&gt; &lt;name&gt;hbase.rest.port&lt;/name&gt; &lt;value&gt;8088&lt;/value&gt; &lt;/property&gt; &lt;!-- 2181 默认端口，尽量不要修改，geomesa-hbase 导入数据时默认连接端口为 2181--&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.clientPort&lt;/name&gt; &lt;value&gt;2181&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/home/hbase/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;!-- geomesa-hbase --&gt; &lt;property&gt; &lt;name&gt;hbase.coprocessor.user.region.classes&lt;/name&gt; &lt;value&gt;org.locationtech.geomesa.hbase.server.coprocessor.GeoMesaCoprocessor&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt;修改 /home/hbase-2.2.6/conf/regionservers 文件，修改为（原来为 localhost）1master设置环境变量，在 /etc/profile 中添加123#HBase Environment Settingexport HBASE_HOME=/home/hbase-2.2.6export PATH=$PATH:$HBASE_HOME/bin配置好之后，执行 start-hbase.sh 启动 HBase。Spark 环境修改 /home/spark-3.0.1-bin-hadoop3.2/conf/spark-env.sh 文件，在文件末尾添加1234567891011121314151617181920# 配置JAVA_HOME，一般来说，不配置也可以，但是可能会出现问题，还是配上吧export JAVA_HOME=$JAVA_HOME# 一般来说，spark任务有很大可能性需要去HDFS上读取文件，所以配置上# 如果说你的spark就读取本地文件，也不需要yarn管理，不用配export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop# 设置Master的主机名export SPARK_MASTER_HOST=master# 提交Application的端口，默认就是这个，万一要改呢，改这里export SPARK_MASTER_PORT=7077# 每一个Worker最多可以使用的cpu core的个数，我虚拟机就一个...# 真实服务器如果有32个，你可以设置为32个export SPARK_WORKER_CORES=1# 每一个Worker最多可以使用的内存，我的虚拟机就2g# 真实服务器如果有128G，你可以设置为100Gexport SPARK_WORKER_MEMORY=2g# master web UI端口默认8080export SPARK_MASTER_WEBUI_PORT=8090# worker web UI端口默认8081export SPARK_WORKER_WEBUI_PORT=8089复制 /home/spark-3.0.1-bin-hadoop3.2/conf/slaves.template 文件，并重命名为 slaves，将该文件尾修改为12# 里面的内容原来为localhost，改为master master设置环境变量，在 /etc/profile 中添加12export SPARK_HOME=/home/spark-3.0.1-bin-hadoop3.2export PATH=$PATH:$SPARK_HOME/bin:$SPARK_HOME/sbin将 /home/spark-3.0.1-bin-hadoop3.2/sbin/start-all.sh 重命名为 start-spark-all.sh，将 /home/spark-3.0.1-bin-hadoop3.2/sbin/stop-all.sh 重命名为 stop-spark-all.sh，执行 start-spark-all.sh 启动 Spark。geomesa-hbase 环境编译 geomesa克隆 LocationTech GeoMesa ，修改 pom.xml，即修改对应依赖的 hadoop 和 hbase 以及 spark 版本（spark 最新的3.0.1版本由 Scala-2.12 编译，而 Geomesa 编译目前采用 Scala-2.11， 所以 Spark 不能使用最新的版本，只能用 2.4.7）。进入 geomesa 根目录，使用命令1234mvn clean install -DskipTests# 或仅编译 geomesa-hbasemvn clean install -pl geomesa-hbase -am -DskipTests编译 geomesa，中间可能会失败很多次，包下不来，可能需要挂代理或换源，重复使用命令多次即可。配置 geomesa-hbase将 /home/geomesa/geomesa-hbase/geomesa-hbase-dist/target/geomesa-hbase_2.11-3.2.0-SNAPSHOT-bin.tar.gz 解压为 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT，将 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/dist/hbase/geomesa-hbase-distributed-runtime-hbase2_2.11-3.2.0-SNAPSHOT.jar 复制到 /home/hbase-2.2.6/lib/ 文件夹中，修改 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/conf/dependencies.sh 文件，设置正确的Hadoop 和 hbase 版本，依次执行 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-dependencies.sh 和 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-shapefile-support.sh。设置环境变量，在 /etc/profile 中添加12345export GEOMESA_HBASE_HOME=/home/geomesa-hbase_2.11-3.2.0-SNAPSHOTexport GEOMESA_LIB=$GEOMESA_HBASE_HOME/libexport GEOMESA_CONF_DIR=$&#123;GEOMESA_HBASE_HOME&#125;/confexport CLASSPATH=$CLASSPATH:$GEOMESA_LIB:$GEOMESA_CONF_DIRexport PATH=$PATH:$GEOMESA_HBASE_HOME/bin测试 geomesa-hbase启动 Hadoop 和 HBase 之后，可直接使用命令1geomesa-hbase ingest --catalog TestGeomesa --feature-name road --input-format shp "/home/shpdata/road.shp"导入 shp 数据，shp 不能有 id 字段，因为 Geomesa 在创建表时会默认生成一个 id 字段。也可克隆 geomesa-tutorials ，同样修改其中的 pom.xml 文件，进入 geomesa-tutorials 根目录，使用命令1mvn clean install -pl geomesa-tutorials-hbase/geomesa-tutorials-hbase-quickstart -am编译 geomesa-tutorials，编译完成后，使用命令1java -cp geomesa-tutorials-hbase/geomesa-tutorials-hbase-quickstart/target/geomesa-tutorials-hbase-quickstart-3.2.0-SNAPSHOT.jar org.geomesa.example.hbase.HBaseQuickStart --hbase.zookeepers localhost --hbase.catalog geomesaTest导入数据进 Hbase，导入成功后可通过 hbase shell 进入 hbase，在 hbase shell 中通过 list 查看 hbase 现有的表。整合 geoserver导入依赖插件1manage-geoserver-plugins.sh -l $&#123;GEOSERVER_HOME&#125;/webapps/geoserver/WEB-INF/lib/ -i修改 /home/geomesa-hbase_2.11-3.2.0-SNAPSHOT/bin/install-dependencies.sh 中第33行：12# install_dir="$&#123;GEOMESA_HBASE_HOME&#125;/lib"install_dir="$&#123;GEOSERVER_HOME&#125;/webapps/geoserver/WEB-INF/classes"执行 install-dependencies.sh 安装插件，安装完后将 classes 中的 lib 都移到 ${GEOSERVER_HOME}/webapps/geoserver/WEB-INF/lib中。后记 环境搞起来真麻烦，在编译和运行 Geomesa 时总能遇到一些莫名奇妙的问题，Java 系的这一套确实很麻烦，尤其是各种依赖关系，不过最后总算是搞好了，能直接在 geoserver 中看到 geomesa 存在 hbase 里的地图。参考资料Centos7系统 Hadoop+HBase+Spark环境搭建GeoMesa-HBase操作篇——安装centos7安装geomesa2.0.2_hbase_geoserver2.13.2的方法hadoop fs 命令使用GeoMesa HBase Quick StartInstalling GeoMesa HBaseSpark完全分布式集群搭建【Spark2.4.4+Hadoop3.2.1】附录最后附上一些常用的端口及说明：Hbase配置端口说明hbase.master.port16000HMaster绑定端口hbase.master.info.port16010HBase Master的Web UI端口hbase.regionserver.port16020HBase RegionServer绑定的端口hbase.regionserver.info.port16030HBase RegionServer的Web UI端口hbase.zookeeper.property.clientPort2181Zookeeper客户端连接端口hbase.zookeeper.peerport2888Zookeeper节点内部之间通信的端口hbase.zookeeper.leaderport3888Zookeeper用来选举主节点的端口hbase.rest.port8080HBase REST server的端口hbase.master.port60000HMaster的RPC端口hbase.master.info.port60010HMaster的http端口hbase.regionserver.port60020HRegionServer的RPC端口hbase.regionserver.info.port60030HRegionServer的http端口Hadoop配置端口说明fs.defaultFS9000hdfs访问端口dfs.namenode.rpc-address9001DataNode会连接这个端口dfs.datanode.address9866DataNode的数据传输端口dfs.namenode.http-address9870namenode的web UI 端口yarn.resourcemanager.webapp.address8088YARN的http端口Spark端口说明8080master的webUI，Tomcat的端口号（已修改为8090）8081worker的webUI的端口号（已修改为8089）18080historyServer的webUI的端口号需开放端口 22，2181，5432，8080，8088，8089，8090，9870，16010，16030。docker run -dit --privileged=true --name STC2 --hostname master -v E:/Docker/ShareFile:/mnt/sharefile -p 22:22 -p 80:80 -p 2181:2181 -p 5432:5432 -p 8080-8090:8080-8090 -p 9870:9870 -p 16010:16010 -p 16030:16030 stc:2.0 init]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>bigdata</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式浅谈]]></title>
    <url>posts/ae780057.html</url>
    <content type="text"><![CDATA[前言 进入职场一年半以来，Shaun 完全独立从 0 到 1 开发了 1.5 个项目（当然也有参与其它项目，但不是 Shaun 独立从 0 到 1 开发的，没多少控制权，就不谈了），一个网页版的高精地图编辑器，半个地图可视化系统，这里面 Shaun 用了不少设计模式，这篇就谈谈 Shaun 用过的和没用过的一些设计模式。 以「Head First 设计模式」为参考，Shaun 用 C++ 实现了一遍书中的例子（代理模式及其后面的模式除外），下面进入正文。模式篇策略模式 Shaun 个人认为最能体现面向对象编程思想（抽象封装继承多态）的一种模式，换句话说，只要真正理解和运用面向对象编程，一定会自然而然的用到策略模式。Shaun 在做高精地图编辑器时，需要设计一个渲染模块，渲染模块会包含高亮行为，高亮有两种，一种是直接改变颜色，一种是使用后期处理（OutlinePass 或 UnrealBloomPass 等）进行高亮，这时就需要在渲染类中组合高亮行为。 策略模式中涉及到的原则有：1、封装变化；2、多用组合，少用继承；3、针对接口编程，不针对实现编程。封装变化这点很考验程序员的经验水平，在写代码之初，往往预料不到变化，所以这一点一般是在编码过程中逐渐完善的，不断进行抽象，从而生成比较合理的基类；第二点一般也是对的，但有时在编码过程中难免会碰到到底是用继承还是组合的问题，这时候可以多想想，组合并不是万能的，有时继承更合适，这时可以请教身边更有经验的程序员，组合的优势在于当子类不想要这个对象时，可以随时丢弃，而继承的优势在于，当子类不想实现这个行为时，可以有默认的行为，而且有些时候只能用继承；针对接口编程没啥好说的，就是抽象。观察者模式 这个模式如果在分布式系统中又叫发布订阅模式，该模式常用于消息通知。前端有个 RxJS 的库将这一模式玩出花来了，Shaun 在高精地图编辑器的事件流管理中就使用了该库。在 threejs 中所有渲染对象的都有一个统一的基类 EventDispatcher，该类中就实现了一个简单的观察者模式，用来处理事件监听触发和通知，和真正的观察者相比，区别在于观察者只是一个函数，而不是一个类，其实浏览器的事件监听机制实现方式也和这个类差不多。 观察者模式中涉及到原则有：松耦合。这里的松耦合是指主题和观察者之间是隔离的，观察者可自行实现自己的更新行为，而主题同样可实现自己的通知机制，两者虽有关联但互不影响。松耦合原则说起来人人会说，但真正能实现松耦合的却不多，实现松耦合的关键在于怎样分离两个系统，两个系统的连接点在哪，这有时很难理清，从而造成逻辑混乱，bug 丛生。装饰者模式 利用该模式可以很方便的扩展一些方法和属性，尤其是遇到主体和配件这样的关系时，可以很轻松的添加配件到主体上。Shaun 没用过这个模式，本来在扩展 threejs 一个类时想用，但确实没找到非常明确的主体和配件这样的关系，最后还是简单的使用继承了。 装饰者模式涉及到的原则有：开放——封闭原则。设计一个类需要考虑对扩展开放，对修改关闭。修改和扩展看似矛盾，但实则可以独立存在，装饰者的配件可以无限加，这是扩展，是开放，而在加配件时无需修改现有代码，这是封闭。当然这一原则并不独属于装饰者模式，应该说是只要用到面向对象的思想开发程序，就一定会用到该原则，否则也就失去了面向对象的意义。但有时这个原则又没必要贯彻彻底，因为对于有些需求可能很难弄清修改和扩展的界限，这时就达到能尽量重用父类的方法就好。工厂模式 该模式在稍微大一点的系统中应该都会用到，根据不同的输入，生成不同的对象，这就是工厂模式的本质。至于工厂模式的实现方式一般会根据需求的复杂度来决定：1、只有一个工厂，一类产品，只是为了集中一层 if-else，可用简单工厂模式，甚至一个 builder 函数即可；2、有多个工厂，还是只有一类产品，用工厂模式，多个工厂继承一个工厂父类即可，相当于多个简单工厂组合；3、有多个工厂，多类产品，哪个工厂生产什么产品可能有变化，这时需要用到抽象工厂模式，除正常的继承之外，还需使用组合，组合组成产品的父类，相当于再组合一个工厂。Shaun 在高精地图编辑器中当然是大量使用的工厂模式和简单工厂模式，主要是为了集中 if-else 的处理，比如根据不同的数据类型创建不同的属性栏界面（枚举用下拉框，字符串用文本框，数字用数字栏等），根据不同的路网元素创建对应的渲染器对象以及对应的属性界面等。 工厂模式涉及到的原则有：依赖倒置原则。尽量依赖抽象，而不是具体类。这其实也是抽象一种作用或好处，即在使用过程中尽量使用最上层的父类，具体类只在创建实例时使用。单例模式 写程序的基本都会用到该模式，主要用来创建全局唯一对象，可用来存储和处理系统中常用的各个模块都会用到的一些数据。Shaun 在编辑器中单例模式用了好几个，比如全局唯一的 viewport，用力绘制 3d 图形；全局唯一的路网数据；当然系统中存在太多的单例模式也不好，最好是只有一个，如 Shaun 的编辑器中最好的模式就是创建一个单例的 Editor 类，需要做单例的对象都可以放在该类中，如此保证系统中只有一个单例类，以进行统一管理。 该模式与面向对象倒是没多大关系了，可以认为是全局变量的优化版，毕竟大的系统中全局变量基本不可避免，这时就可以使用单例模式。命令模式 该模式主要用来将函数方法封装成类，这样做的好处就是可以更灵活的执行该方法（将方法放进队列中依次执行，将方法持久化以便系统启动执行），同时也可以保存该方法的一些中间状态，以便撤销操作，回到系统执行该方法前的状态。Shaun 在编辑器中主要用命令模式做撤销重做功能，这基本也是编辑器的必备功能了，可以说没有撤销重做功能的编辑器是不完整的，要实现撤销重做功能除了基本的命令模式之外，还要提供撤销和重做两个栈以保存操作命令。 该模式与面向对象也没很大关系，只是提供了一个实现一些特殊功能的标准或通用方案。适配器模式 该模式正如其名，主要用来转换接口，将一个类的方法用其它类封装一下，以达到兼容其它类接口的目的，同时对外可接口保持不变，该模式通过对象组合实现。Shaun 没使用过该模式，就 Shaun 感觉这个模式应该可以用在维护了好几年的系统上，当新作的东西需要兼容老接口时，可以用适配器模式将新街口封装一下。 该模式同样只是提供了一种新接口兼容老接口的一种优良方案，当然实际使用过程中可能很难这么完美，但算是一种思路。外观模式 该模式算是封装的一种体现。当一个功能需要经过多次函数调用才能完成时，这时可以用另一个方法将这些函数都封装起来，从而简化调用方式。Shaun 用该模式处理整个渲染模块的初始化和资源释放，因为初始化时需要分配好很多东西（光照，viewport，固定图层，地面，天空盒等），而释放时同样需要释放这些东西。该模式同样只能算是提供了一种好的编程实践，实际使用过程可能每个函数都有很多参数，调用顺序可能有变，这时简化调用反而没有必要，让用户自己决定怎样调用更好。 外观模式涉及到的原则有：最少知识原则。该原则主要用来减少对象依赖，即尽量不将类中组合的对象直接暴露出去，而应该将组合对象的方法再简单封装一下，再将封装后的方法暴露出去，以减少另外的类又依赖类中组合对象的现象。该原则可以适当遵守，因为有时直接使用更方便一点，多次封装之后反而显得逻辑混乱，增加系统的复杂度。模板方法模式 该模式是抽象的一种体现。首先抽象出一套固定化的流程，流程中每个步骤的具体行为并一致，有些默认，有些可以重写，父类固定流程，子类负责重写流程中每个步骤，这就时模板方法模式。Shaun 没写过完全符合该模式的代码，只是写了个类似该模式的模块，该模块有三个功能（编辑道路节点，编辑车道节点，编辑车道线），做完前两个功能后，发现这里有一套逻辑是通用的，那就是滑过节点高亮，选择节点，出现 gizmo，拖动 gizmo，完成编辑（当然还有选择节点后不拖动 gizmo 等一套 if-else 中间处理状态），于是 Shaun 把这一套流程抽象出来，固化方法，这三个功能都继承该类，方法该重写的重写，不仅减少了代码量，同时整个流程也更清晰了，很快完成了第三个功能。 模板方法涉及到的原则有：好莱坞原则。即由父类负责函数调用，而子类负责重写被调用的函数，不用管父类的调用逻辑，也最好不要调用父类的函数。该原则用来理清流程很方便，只需要看父类即可，但实际编程过程中可能也会遇到子类不可避免的会调用父类的一些公共函数的情况，Shaun 觉得只要流程没问题的话，调用父类函数也能接受，并不需要严格遵守模式。迭代器模式 迭代器，即对遍历进行封装，一般只能顺序执行，提供 next() 方法获取下一个元素，集合容器的遍历方式一般都会用迭代器进行封装。Shaun 在这一个半项目里没写过迭代器，毕竟这是非常底层的一个模式，语言库本身有的数据结构大多自己实现了迭代器，除非需要设计一个新的集合或容器数据结构，才需要提供相应的迭代器。因为 js 没有 SortedMap 数据结构，为了高效分配路网元素 id，Shaun 利用 object 简单实现了一个，提供了相应的 forEach 方法。 迭代器模式涉及到的原则有：单一责任原则。即一类只做一件事，这个原则对于涉及最最底层的接口很实用，而大多具体类很难只做一件事。迭代器模式对于顺序访问来说还是非常有用的，毕竟使用迭代器的人不需要管底层到底用的什么数据结构，反正可以顺序遍历即可。组合模式 组合模式与其说是一种模式，更不如说就是一颗树，只是树的节点都是可供继承的类。在标准的组合模式中，父类中一定会有全部子类的全部函数，即所有子类的函数要么是继承自父类，要么是重写父类函数的，这其实是违背上面单一责任原则的，因为这必然会造成有些子类不需要这么多函数。而从组合模式会存储孩子节点这点来看，和装饰者模式有点类似，只不过装饰者只会存一个孩子，而组合模式可能会存多个，当然两者做的事是不一样，只是实现手法类似而已。Shaun 没写过标准的组合模式，如果只要符合树形模式都可认为是组合模式，那在高精地图编辑器中，所有路网元素都会继承一个父类，而道路中又包含车道簇，车道簇中包含车道，这也算组合模式。在 threejs 中有个 Object3D 的基类，所有渲染对象都会继承该类，该类中又包含若干孩子，threejs 计算 Model 矩阵时就是一层层孩子的 Model 矩阵乘下去，直到最后的孩子，结果就是最后 Shader 中的 Model 矩阵。状态模式 状态机的状态转移可以说是程序设计中最麻烦的部分之一了，这部分如果写不好的话，根本没法修改维护，同时会造成 bug 频发。在高精地图编辑器中鼠标操作有两类模式，一种是选择模式，另一种是编辑模式，选择模式又分为点选和框选，而编辑模式就非常多了，针对路网的不同元素，编辑模式的具体实现都不会一样，Shaun 首先使用 RxJS 封装了一个鼠标操作类（左键右键中键移动等），后续的鼠标操作都继承自该类，可以算是状态模式的父类，后续的鼠标操作就针对相应的需求实现相应的方法即可，当然其中鼠标操作自身也存在状态转移（左键到右键，左键到鼠标移动等），这些一般都是针对特定需求来的，所以这些小的状态转移一般在鼠标操作内部实现，但需要支持随时从编辑模式到选择模式，这意味着编辑模式编辑到一半的东西都需要支持随时释放，恢复编辑前的样子，这算是一个麻烦的地方，有时忘了释放就会出现问题。 状态模式算是为解决状态转移问题提供一种理想的方案，但其具体实现并不一定要和书上一样，Shaun 在用 C++ 实现时就采用另一套方案，状态类是独立的，控制状态转移的代码都在状态机内，而不是书中这种直接在状态类中控制状态机。好处坏处都有，看具体需求，Shaun 的方式就是状态类和状态机是分离的，状态类不需要管状态机怎么实现的，只需要管当前状态的情况，但需要在状态机中管理状态转移，而书中实现方式状态机的状态转移放到状态类中了，也因此状态类需要依赖状态机。剩下的模式，Shaun 就没直接写代码实践了，因为大多都需要跨模块实现，有的甚至就是个小项目了，所以就简要谈谈 Shaun 的个人理解。代理模式 主要可以用来做权限控制，在模块与模块之间的调用过程中，有时不想要一个模块可以访问另一个模块的全部内容，这时可以使用代理模式，创建一个中间模块，避免两个模块直接调用，同时进行访问控制。代理模式在如今的互联网时代不可避免的会用到，或直接或间接，往最小的说，对象组合也可用来实现代理模式。复合模式 将多种模式组合在一起使用，比如 MVC 模式，这种模式与其说是模式，更不如说就是一种架构，一种开发包含客户端系统的通用架构，当然每一层都会有很多模式进行组合，从而造成具体实现差异非常大。反模式 反模式指的是用“不好的解决方案”去解决一个问题，Shaun 主要想谈谈开发反模式，因为这非常常见。有时候一个解决方案好不好要从多个角度进行衡量，比如现有技术，长期短期，上手难度，开发效率，维护难度等角度，当出现一个新问题时，往往意味着就有解决方案有缺陷，这种缺陷可能很容易弥补，更可能很难，当很难解决时，往往要采用全新的解决方案，这时团队对新解决方案可能都不熟，也没有魄力去采用新解决方案，只能去老解决方案继续强行打补丁，直到最后没法维护，白白浪费了大量的人力和时间，这是非常典型的一种反模式。桥接模式 将抽象接口和实现分开，并独立派生，以支持抽象和实现的同时改变，并相互独立，可适用在需要跨平台跨不同设备的系统上。生成器模式 有点像是模板方法模式和工厂模式的结合版，使用多个步骤创建一个对象，但步骤没有固定顺序，可适用于流程复杂的规划系统中。责任链模式 可以认为是模板方法模式的进阶版，只是模板的步骤方法变成了一个个对象，并且支持步骤的增加和删除，以及更换顺序，一旦某个步骤成功执行，则整个链条终止，可适用于消除显式的 if-else，处理键盘或鼠标事件时，需要针对不同按键触发不同操作，这时可以采用该模式，缺点是链条很长时，要写很多类，导致执行啥很不直观。蝇量模式 这个模式算是一种优化内存占用的方案，通过牺牲类的独立性来减少内存，更彻底一点就是不创建类，直接用函数调用来处理就行。解释器模式 可用来实现简单语法规则语言的解释器或编译器，每个语法规则都由一个类进行解析，然后组合。中介者模式 可认为是状态模式和代理模式的结合版，不过各个状态可以是不同类，由中介者控制系统流转，集中控制逻辑，使被控制对象解耦，但可能会造成中介者本身非常复杂。备忘录模式 可用于系统（游戏）存档，存储系统中关键对象的运行状态，通常实现的方案一般是序列化/持久化，为了效率考虑，难的是有时需要增量存档。原型模式 js 的原型链应该是原型模式的典型，不仅实现了动态扩展实例，更实现了动态扩展对象，即继承。在高精地图编辑器中，由于需要做自动保存，所以在做序列化和反序列化的同时也简单实现了对象的 clone()，即从当前实例中创建一个完全一样的实例，可认为是 C++ 中的深拷贝。访问者模式 相当于加个中间层，从而以最小的代价修改现有系统（一般是增加一个方法），达到外部可以取得系统内部信息的目的。后记 曾看过这样一句话：抽象能力决定编程能力，Shaun 个人认为，所谓抽象即提炼事物的共同点，这也是设计模式中反复使用接口的原因，接口即一组具体类的共同点，接口中的函数和变量即为这些具体类共有的，虽然具体行为可以不一样，但行为本身总是存在的。而又有这样一句话：程序等于数据结构加算法，Shaun 的理解是，狭义上的程序确实是这样，一段代码解决一个问题，这是程序，多段代码解决一个问题，这也是程序，多段代码解决多个问题，这亦是程序，一个软件，一个系统，一个平台，都是程序，但显然这些程序不是简单的数据结构和算法就能概括的，其内部必然有一套合理的逻辑进行组织，这套逻辑可以称之为“设计模式”，但这个“设计模式”不仅仅是上面谈的这些模式概念。Shaun 认为好的数据结构和算法确实能使程序达到当前最优，但对于一个大型系统或平台来说，这种最优只能是一种局部最优，这对整个系统的全局最优来说可能是微不足道的，而“设计模式”要解决的是怎样使一个系统达到全局最优，怎么合理组织局部最优。面对现代的超大型系统或平台，传统意义上的设计模式也只能达到局部最优，全局最优基本很少有人能驾驭，都是针对特定的业务需要，不断的试错改进优化，逐渐趋于稳定，但这种稳定可能很难抽象，放进其它的业务中，又得花费大量的人力物力去修改。 Shaun 个人对现代大型系统架构的理解就是分层分模块，功能太多分模块，模块太多就分层，一层不够分两层，两层不够分三层，三层不够继续分，根据数据流的处理分层，根据功能的不同分模块，模块内部依靠设计模式进行组织，设计模式调度的就是数据结构与算法。Shaun 目前的设计原则就是：每层一个独立的服务控制模块，每个模块一个对外服务功能（或事件或 socket ），同层的各模块之间尽量保持独立，不相互依赖，若各模块存在共同点，则将共同点抽出来，将其作为公共模块或独立为小层，层与层之间通过服务控制模块进行数据流的传输，除服务控制模块之外，模块之间尽量避免相互通信，即每个模块的对外服务功能一般只对本层服务控制模块提供服务，最好是只负责接收数据。如果系统实在太大，就只能保持纵向分层，横向保证各模块间数据流依次传输，并在特定模块节点上进行上下层的数据传输。 数据结构与算法重不重要？当然重要，数据结构与算法不过关，面试都过不去 ( ╯□╰ )，工作都没有，还何谈什么设计模式，什么架构。设计模式重不重要？当然也重要，不会合理使用设计模式，写出一堆别人没法维护的垃圾代码（当然，这或许是好事 :p ），改个需求要半天，加个功能要半个月，效率太低，这样即使有好的数据结构与算法作用也不大。但是设计模式也不是万能的，针对不同的需求，同一种设计模式有不同的实现方式，所以书中的设计模式也仅供参考而已，与其说设计模式重要，还不如说书中那几个设计原则更重要些。同时一味的追求设计模式也不见得是件好事，设计模式可以参考，但不能生搬硬套，毕竟人是活的，需求也是活的，固定的模式也需要有所改变，总而言之，能以最小的代价解决问题完成需求的模式就是好模式。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[积分计算]]></title>
    <url>posts/eee1c041.html</url>
    <content type="text"><![CDATA[前言 最近需要计算一下曲线长度，无法直接得到被积函数的原函数，常规的积分解法牛顿莱布尼茨公式没法使用，所以只能使用数值积分计算积分。 下面主要介绍两种数值积分方法：龙贝格积分（Romberg Quadrature） 和 高斯-克朗罗德积分（Gauss-kronrod Quadrature）。 下面附带的代码只做简单测试，不保证正确性，语言使用 Typescript。Romberg 篇 计算积分最简单的当然是使用复化梯形公式，即 \(I=\int_a^b{f(x)dx}=\frac{b-a}{2n}[f(a)+f(b)+2\sum\limits_{i=1}^{n-1}f(x_i)]= T_n, x_i=a+i*h, h=(b-a)/n\) ，若将 n 段每段一分为 2，可得到 \(T_{2n}=T_n/2+\frac{b-a}{2n}\sum\limits_{i=0}^{n-1}f(x_{i+1/2})\) 。考虑数列 \(T=\{T_1,T_2,T_{2^2},...,T_{2^k}\}\)，显然该数列必收敛，最后收敛为对应积分，当 \(|T_{2^k}-T_{2^{k-1}}| &lt; ε\) （\(ε\) 为精度）时，可取 \(T_{2^k}\) 作为最后的积分结果。但是，直接利用梯形公司求解，收敛很慢，导致计算效率很差，所以需要使用理查德森（Richardson）外推法加速收敛，设 \(T_{2^k}^{(m)}\) 为 m 次加速值，当 m 为 0 时，表示没加速，为原梯形公司，则 \(T_{2^k}^{(m)} = \frac{4^m}{4^m-1}T_{2^{k+1}}^{(m-1)}-\frac{1}{4^m-1}T_{2^k}^{(m-1)}\)，当 \(|T_{2^{k+1}}^{(m)}-T_{2^k}^{(m)}| &lt; ε\) 时，则收敛，并取其中一值作为最终的积分值。未经修饰的代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function rombergIntegrator(f: (x: number) =&gt; number, a: number, b: number, tolerance = 1e-8) &#123; let h = b - a; let n = 1; let preTK = ((f(a) + f(b)) * h) / 2; let tkmArray = []; let m = 0; tkmArray[m] = preTK; while (true) &#123; m += 1; console.log(m, tkmArray[m - 1]); let tk = getTK(f, preTK, n, a, h); if (Math.abs(tk - preTK) &lt; tolerance) return tk; let preTKM = tkmArray[0]; let preTK1M = tk; tkmArray[0] = tk; for (let i = 1; i &lt;= m; i++) &#123; let newTKM = getTKM(preTK1M, preTKM, i); preTKM = tkmArray[i]; preTK1M = newTKM; tkmArray[i] = newTKM; if (preTKM !== undefined &amp;&amp; Math.abs(preTK1M - preTKM) &lt; tolerance) return preTK1M; &#125; preTK = tk; n *= 2; h /= 2; &#125; function getTK(f: (x: number) =&gt; number, preTK: number, n: number, a: number, h: number) &#123; let sum = 0; for (let i = 0; i &lt; n; i++) &#123; let x = a + (i + 0.5) * h; sum += f(x); &#125; return (preTK + h * sum) / 2; &#125; function getTKM(preTK1M: number, preTKM: number, m = 0) &#123; let m4 = 1 &lt;&lt; (2 * m); // 4 ** m; return (m4 * preTK1M - preTKM) / (m4 - 1); &#125;&#125; 由于采用闭型积分规则（积分上下限值参与积分计算），所以以上代码不适合计算两端点值被积函数值无限大的情况（如 1/4 圆弧积分等）。而且该方法不合适求取被积函数在积分区间内导数值变化较大（如被积函数在积分下限附近剧烈波动，在积分上限附近不变化等）的积分，因为该方法是均匀分段，这种情况将导致计算量剧增，这时就需要用到下面的自适应积分。自适应篇 自适应积分主要包括两类：全局自适应积分和局部自适应积分，通常情况下全局自适应积分的会比局部自适应积分的表现要好，全局自适应积分一般通过二分递归实现，当满足一定条件时，递归终止，即通过二分分别计算两边的积分，若一边满足一定条件，则不继续划分，从而减少计算量。全局自适应积分中比较经典的有基于辛普森（Simpson）公式的自适应算法，普通辛普森积分公式为：\(I=\int_a^b{f(x)dx}=\frac{b-a}{6}[f(a)+4f(m)+f(b)]= S(a,b), m=(a+b)/2\)，复化辛普森公式为 \(I=\int_a^b{f(x)dx}=\frac{h}{3}[f(a)+4\sum\limits_{i=1}^{n}f(x_{2i-1})+2\sum\limits_{i=1}^{n-1}f(x_{2i})+f(b)]= S(a,b)\)，其中 \(x_i=a+i*h (i=1,2,3,...,2n),h=\frac{b-a}{2n}\)，基于辛普森公式的自适应基本原理如下：令 \(S_2(a,b) = S(a,m)+S(m,b)\)，m 为 a,b 中值，若 \(|S(a,b) - S_2(a,b)| &lt; 15ε\)，则取 \(S_2(a,b)\) 或 \(S_2(a,b)+(S(a,b)-S_2(a,b))/15\) 作为该区间的积分值，否则，将区间二分递归，同时因为误差会累积，所以每次递归都需要将精度提高两倍，即 \(ε = ε/2\)，如此最后的精度才能达到最初的精度。具体 ts 代码如下：123456789101112131415161718192021222324252627282930313233function adaptiveSimpsonIntegrator(f: (x: number) =&gt; number, a: number, b: number, epsilon = 1e-8) &#123; let S = complexSimpson(f, a, b); return adsimp(f, a, b, epsilon, S); function adsimp(f: (x: number) =&gt; number, a: number, b: number, epsilon = 1e-8, S = 0): number &#123; let m = a + (b - a) / 2; let LS = complexSimpson(f, a, m); let RS = complexSimpson(f, m, b); const S2 = LS + RS; const tolerance = 15 * epsilon; let delta = S - S2; if (Math.abs(delta) &lt; tolerance) return S2 + delta / 15; else &#123; let doubleEPS = epsilon / 2; return adsimp(f, a, m, doubleEPS, LS) + adsimp(f, m, b, doubleEPS, RS); &#125; &#125; function complexSimpson(f: (x: number) =&gt; number, a: number, b: number, n = 1) &#123; const n2 = n * 2; const h = (b - a) / n2; let sum = f(a) + f(b); for (let i = 1; i &lt; n2; i += 2) &#123; sum += 4 * f(a + i * h); &#125; for (let i = 2; i &lt; n2 - 1; i += 2) &#123; sum += 2 * f(a + i * h); &#125; return (sum * h) / 3; &#125;&#125; 在 D.V. Fedorov 写的「Introduction to Numerical Methods with examples in Javascript」一书中介绍了一种全局自适应方法，即分别使用高阶和低阶的权值分别计算积分，两者之间的差值 \(E\) 作为误差估计，设绝对精度为 \(\delta\) ，相对精度为 \(\epsilon\) ，若 \(|E|&lt;\delta+\epsilon*Q\)，Q 为高阶权值计算的积分，则取 Q 作为积分值，否则将积分区间二分，同时使 \(\delta/\sqrt{2}\)，\(\epsilon\) 保持不变。具体 ts 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function recursiveAdaptiveIntegrator(f: (x: number) =&gt; number, a: number, b: number, accuracy = 1e-15) &#123; return recursiveAdaptiveIntegrate(f, a, b, accuracy); function recursiveAdaptiveIntegrate( f: (x: number) =&gt; number, a: number, b: number, accuracy = 1e-15, epsilon = Number.EPSILON, preFValue?: number[], ): number &#123; const abscissae = [1 / 6, 2 / 6, 4 / 6, 5 / 6]; const highOrderWeights = [2 / 6, 1 / 6, 1 / 6, 2 / 6]; const lowOrderWeights = [1 / 4, 1 / 4, 1 / 4, 1 / 4]; const isRecompute = [1, 0, 0, 1]; const h = b - a; const fValue: number[] = []; if (preFValue === undefined) &#123; abscissae.forEach((abscissa) =&gt; &#123; const x = a + abscissa * h; fValue.push(f(x)); &#125;); &#125; else &#123; for (let k = 0, i = 0; i &lt; abscissae.length; i++) &#123; if (isRecompute[i]) fValue.push(f(a + abscissae[i] * h)); else fValue.push(preFValue[k++]); &#125; &#125; let highResult = 0; let lowResult = 0; for (let i = 0; i &lt; highOrderWeights.length; i++) &#123; highResult += highOrderWeights[i] * fValue[i]; lowResult += lowOrderWeights[i] * fValue[i]; &#125; highResult *= h; lowResult *= h; const tolerance = accuracy + epsilon * Math.abs(highResult); let errorEstimate = Math.abs(highResult - lowResult) / 3; if (errorEstimate &lt; tolerance) &#123; return highResult; &#125; else &#123; accuracy /= Math.sqrt(2); let m = a + h / 2; let midIndex = Math.trunc(abscissae.length / 2); let leftFValue = fValue.slice(0, midIndex); let rightFValue = fValue.slice(midIndex); return ( recursiveAdaptiveIntegrate(f, a, m, accuracy, epsilon, leftFValue) + recursiveAdaptiveIntegrate(f, m, b, accuracy, epsilon, rightFValue) ); &#125; &#125;&#125; 该方法很巧妙的设计了一组插值点，使得当前计算的函数值正好可以被下次迭代所使用，从而提高性能，同时该方法可以得到 1/4 圆弧长，虽然精度只能到小数点后 8 位，至于 Shaun 写的其它测试函数，都能得到理想精度。Gauss 篇 高斯求积法是一种多项式插值积分法，同时由于不计算被积函数在区间两个端点处的值，所以高斯积分法采用的开型积分规则，高斯积分法的衍生方法有很多种，下面主要介绍高斯-勒让德（Gauss-Legendre Quadrature）以及其迭代改良的高斯-克朗罗德法。高斯-勒让德积分法的公式为积分的原始形态，即 \(\int_a^bf(x)dx=\sum\limits_{i=1}^{∞}w_if(x_{i})\approx\sum\limits_{i=1}^{n}w_if(x_{i})\) ，只不过 \(x_i \in [-1,1]\)，并且 \(x_i\) 和 \(w_i\) 都通过勒让德多项式求出，所以其原则上只能用在积分区间为 [-1, 1] 上的积分，但是可以将积分从任意区间通过简单的变形变换到 [-1, 1] 上，即 \(\int_a^b{f(x)dx} = \frac{b-a}{2}\int_{-1}^1{f(\frac{b-a}{2}t+\frac{b+a}{2})dt}\) ，从而可以将高斯-勒让德方法扩展到任意积分上。由于每个 n 对应的 \(x_i\) 和 \(w_i\) 都可以查表可得，所以具体代码方面就很简单了，以 n = 4，即插值点个数为 4 为例，ts 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function gaussLegendreIntegrate(f: (x: number) =&gt; number, a: number, b: number, n: 4 | 8 = 4) &#123; const weightsAndAbscissae = getWeightsAndAbscissae(n); const weights = weightsAndAbscissae.weights; const abscissae = weightsAndAbscissae.abscissae; const halfH = (b - a) / 2; let sum = 0; for (let i = 0; i &lt; abscissae.length; i++) &#123; let xi = halfH * abscissae[i] + a + halfH; sum += weights[i] * f(xi); &#125; return sum * halfH; function getWeightsAndAbscissae(n: 4 | 8 = 4) &#123; switch (n) &#123; case 8: return &#123; weights: [ 0.362683783378362, 0.362683783378362, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763, ], abscissae: [ -0.1834346424956498, 0.1834346424956498, -0.525532409916329, 0.525532409916329, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363, ], &#125;; break; case 4: default: return &#123; weights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538], abscissae: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526], &#125;; break; &#125; &#125;&#125; 若要提高高斯-勒让德积分法的精度，可通过增加插值点或分多个区间进行积分来实现，但是由于没有误差估计，所以还是没法精确控制精度，对与某些被积函数积分精度高，但对于其它被积函数，积分精度却有限，当然可以简单的引入一些常用的误差估计法，但一般需要重新计算积分，导致效率很低，而高斯-克朗罗德法为其引入了一种基于 Kronrod 点的误差估计法，可充分利用现有计算值，从而达到有效控制精度的同时，性能没有太大的损失。设 \(G(f,n)=\sum\limits_{i=1}^{n}w_if(x_{i})\) 为具有 n 个插值点的高斯-勒让德法计算结果，\(GK(f,n) = \sum\limits_{i=1}^{n}w&#39;_if(x_{i})+\sum\limits_{k=n+1}^{2n+1}w&#39;_kf(x_{k})\) 为高斯-克朗罗德法的计算结果，则 \(|GK(f,n)-G(f,n)|\) 可作为误差估计，有了误差估计，最后再使用全局自适应策略，即可得到精度可控的高斯积分结果。具体 ts 代码如下，以 n = 7 为例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576function gaussKronrodIntegrator(f: (x: number) =&gt; number, a: number, b: number, accuracy = 1e-15) &#123; return recursiveAdaptiveIntegrate(f, a, b, accuracy); function recursiveAdaptiveIntegrate(f: (x: number) =&gt; number, a: number, b: number, accuracy = 1e-12): number &#123; const gaussAbscissae = [ 0.0, -4.058451513773971669066064120769615e-1, 4.058451513773971669066064120769615e-1, -7.415311855993944398638647732807884e-1, 7.415311855993944398638647732807884e-1, -9.491079123427585245261896840478513e-1, 9.491079123427585245261896840478513e-1, ]; const gaussWeights = [ 4.179591836734693877551020408163265e-1, 3.818300505051189449503697754889751e-1, 3.818300505051189449503697754889751e-1, 2.797053914892766679014677714237796e-1, 2.797053914892766679014677714237796e-1, 1.29484966168869693270611432679082e-1, 1.29484966168869693270611432679082e-1, ]; const kronrodAbscissae = gaussAbscissae.concat([ -2.077849550078984676006894037732449e-1, 2.077849550078984676006894037732449e-1, -5.860872354676911302941448382587296e-1, 5.860872354676911302941448382587296e-1, -8.648644233597690727897127886409262e-1, 8.648644233597690727897127886409262e-1, -9.914553711208126392068546975263285e-1, 9.914553711208126392068546975263285e-1, ]); const kronrodWeights = [ 2.094821410847278280129991748917143e-1, 1.903505780647854099132564024210137e-1, 1.903505780647854099132564024210137e-1, 1.406532597155259187451895905102379e-1, 1.406532597155259187451895905102379e-1, 6.309209262997855329070066318920429e-2, 6.309209262997855329070066318920429e-2, 2.044329400752988924141619992346491e-1, 2.044329400752988924141619992346491e-1, 1.690047266392679028265834265985503e-1, 1.690047266392679028265834265985503e-1, 1.04790010322250183839876322541518e-1, 1.04790010322250183839876322541518e-1, 2.293532201052922496373200805896959e-2, 2.293532201052922496373200805896959e-2, ]; const halfH = (b - a) / 2; let guassResult = 0; let kronrodResult = 0; for (let i = 0; i &lt; gaussAbscissae.length; i++) &#123; let xi = halfH * gaussAbscissae[i] + a + halfH; let yi = f(xi); guassResult += gaussWeights[i] * yi; kronrodResult += kronrodWeights[i] * yi; &#125; for (let i = gaussAbscissae.length; i &lt; kronrodAbscissae.length; i++) &#123; let xi = halfH * kronrodAbscissae[i] + a + halfH; let yi = f(xi); kronrodResult += kronrodWeights[i] * yi; &#125; if (Math.abs(kronrodResult - guassResult) &lt; accuracy / halfH) return kronrodResult * halfH; else &#123; let m = a + (b - a) / 2; accuracy /= 2; return recursiveAdaptiveIntegrate(f, a, m, accuracy) + recursiveAdaptiveIntegrate(f, m, b, accuracy); &#125; &#125;&#125; 简单测试了一下，Shaun 这里写的 gaussKronrodIntegrator 方法最大精度只能到 1e-15，到 16 位就报错递归深度太大了，圆的 1/4 弧长也没法算出来，当然这些问题可通过设置最大递归深度以及处理异常值来解决，Shaun 这里就不继续写了。后记 数值积分策略非常多，尤其是针对一些特殊的函数，可能只能使用一些特殊的策略才能计算，Shaun 这里只是介绍了一些比较基础常用的积分方法，能解决大部分积分问题，唯一需要注意一点的就是如何追求性能与精度之间的平衡，因为积分常常涉及到迭代求值，通常而言精度越高，迭代越多，求积时，同时也需要注意被积函数的异常值（如无穷大等），这时可能需要拆分或变换积分区间，并且使用开型积分规则的积分方法进行重新计算。附录一些常见的积分变换\[ \int_a^bf(x) = \int_0^{b-a}f(a+t)dt \\ \int_a^b{f(x)dx} = \frac{b-a}{2}\int_{-1}^1{f(\frac{b-a}{2}t+\frac{b+a}{2})dt} \\ \int_{-∞}^{+∞}{f(x)dx} = \int_{-1}^1{f(\frac{t}{1-t^2})\frac{1+t^2}{(1-t^2)^2}dt} \\ \int_{a}^{+∞}{f(x)dx} = \int_{0}^1{f(a + \frac{t}{1-t})\frac{1}{(1-t)^2}dt} \\ \int_{-∞}^{a}{f(x)dx} = \int_{-1}^0{f(a + \frac{t}{1+t})\frac{-1}{(1+t)^2}dt} \]参考资料[1] 积分策略[2] Gaussian Quadrature Weights and Abscissae[3] Gauss-Kronrod Quadrature[4] Gauss-Kronrod Quadrature Nodes and Weights]]></content>
      <categories>
        <category>Mathematics</category>
      </categories>
      <tags>
        <tag>numerical</tag>
        <tag>integration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Geometry增量更新]]></title>
    <url>posts/a5661762.html</url>
    <content type="text"><![CDATA[前言 优化 DrawCall 是图形学性能优化中老生常谈的问题，而针对 DrawCall 优化有很多方案，大致可分为两种：简化（Simplification）和合并（Consolidation），简化是指减少三角形个数，即将精细的模型变为粗糙的模型以及各种三角形剔除方案（视锥体剔除（Frustum Culling），遮挡剔除（Occlusion Culling）等），而合并自然则是将同一中材质下的多个 geometry 合并成一个 geometry。需求篇 最近一段时间一直在做高精地图道路的编辑，道路的编辑涉及到很多东西，这篇仅简单谈谈编辑性能的问题。为了能更直白的显示高精地图，不能简单的只使用点和线，还需要使用面将路面和路面上的一些路面标识精确的还原出来。在可视化道路时，主要有两种方案：1、将每条道路作为一个单独的 Mesh，即单独控制每条道路的渲染，一条道路至少产生一次 DrawCall，这样可以更方便的对每条道路进行编辑，但在渲染时要求更高的性能，而且道路一多，将不可避免的引起卡顿；2、将所有道路作为一个 Mesh，即直接渲染出一整个路网，这样显著降低了 DrawCall 次数，使渲染更流畅，但问题在于每编辑一次道路时，都需要重新三角化（Tessellation）整个路网，而且在选中一条道路时，为可视化选中效果，同样需要重新三角化该道路，并生成相应的 Mesh，导致编辑卡顿，每编辑完一次都可能需要等待一会儿。所以为了平衡渲染性能和编辑效率，需要有一种折中的方案，即对整个路网的 Geometry 能做到快速的分离与合并，在编辑时将受影响的道路分离出来，而在编辑之后，又将全部道路合并一下，提高显示性能。下面就谈谈 Shaun 对这种方案的一些思考。编辑篇 Shaun 为平衡渲染性能和编辑效率，想出的一种方案是增量更新 Geometry，即只删除或增加局部的 Geometry，而其它不受影响的 Geometry 保持原样，如此即可达到快速的分离和合并 Geometry。具体做法如下：首先将所有道路的三角化结果合并成一个 Geometry，在合并的同时建立好每条道路的顶点索引以及面的索引（js 中可直接使用 object 进行存储）；在选择时，根据顶点索引和面索引重建一个 Geometry，再基于该 Geometry 构建一个新的 Mesh 以指示选择效果；当删除道路时，需要删除面索引对应的所有面，而顶点索引对应的顶点不需要删除，将顶点索引移到一个用来标识该部分顶点已废弃的容器 F 中；当新增道路时，需要先从容器 F 中查找是否有合适的地方放置该道路的顶点，若有，则放置在对应地方，并更新容器 F 中对应元素，若没有，则将该道路的顶点放置在 Geometry 顶点数组的最末尾，放置完顶点之后，同样需要建立该道路的顶点索引和面索引。※注：至于容器 F 使用怎样的数据结构以及其中的元素该怎样排列，针对不同的顶点索引可以有不同的选择；在新增道路时，同样可以不同的策略来决定放置顶点的位置（可参考操作系统内存分配的模式）。 由于新增道路时，可能会在容器 F 中产生一些永远无法删除的元素，导致顶点数组空闲碎片。 为抵抗顶点碎片以及减少顶点数目，需要对顶点数据进行压缩（Compaction），即移除没有使用的顶点，将后面的顶点前移，在前移顶点的同时，别忘了需要同时修改面中相应顶点的索引以及更新构建好的每条道路的顶点索引。后记 Shaun 这里只是提出了一种想法，最终实现起来发现效果也确实能达到基本需求（针对有很多条道路的大地图，显示性能从原来的十几二十帧到现在的 60 帧，同时选择和编辑也没受到影响），虽然在内存上比原来多增加了近 20%（还有优化的余地），但是为了渲染流畅以及编辑舒服，在如今这个内存越来越不值钱的年代，这种牺牲 Shaun 觉得是能接受的。当然或许有更好的方案，但限于 Shaun 目前的认知，只能暂时想到这一方案了，若有大佬有更好的方案，还望不吝赐教 🙏。]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mapbox显示GeoServer地图]]></title>
    <url>posts/e225d8fd.html</url>
    <content type="text"><![CDATA[前言 最近做项目需要用到 Mapbox 这个地图可视化框架，以前也没用过，甲方有自己的地图数据，所以得结合 GeoServer 发布一下，简单记录一下流程。发布篇环境准备 下载 GeoServer 以及同页面下的 Vector Tiles 插件，将插件中所有 jar 包都复制到 GeoServer 中webapps\geoserver\WEB-INF\lib目录下。在 bin 下执行 startup.bat 启动 geoserver，若需要修改端口，可修改 start.ini 文件中的jetty.port=8080，在浏览器中输入 http://localhost:8080/geoserver/web/，geoserver 中默认账号为admin，密码为geoserver，geoserver 中常用的两个坐标系为 EPSG:4326：wgs84坐标，Mercator 投影，EPSG:900913：wgs84 坐标，Web Mercator 投影，即保证投影为正方形，MapBox 中必须使用EPSG:900913坐标系统，900913 和 3857 是一样的坐标系统，在 PostGIS 中对应的 SRID 是 3857。设置 Tile Caching Tile Layers 中可进行图层和图层组的预览，以及切片，在 seed/truncate 中可以设置切片类型以及自动将切片保存到 \data_dir\gwc 目录中。 Caching Defaults 需要勾选 Enable TMS Service，以及在 Default Tile Image Formats for:中勾选 application/vnd.mapbox-vector-tile，其它默认即可。Gridsets 设置新的坐标系统。地图发布在 数据 栏下：点击工作区，添加新的工作区，命名以及填写 URI，勾选默认工作区。点击数据存储，添加新的数据存储，选择数据源，以 Directory of spatial files (shapefiles) 为例，在连接参数下点击 浏览，选择shape文件存放目录，DBF 文件字符集选择 UTF-8 或 GBK。注： shape 文件名中不能有中文。点击图层，添加新的资源，添加图层，选择上一步的添加的数据存储名称，点击发布或再次发布，进入发布配置界面，勾选 广告则会在 Layer Preview 中显示，一般不需要勾选，点击Compute from native bounds，GeoServer 会自动计算边框和经纬度信息，然后勾选Linear geometries can contain cicular arcs，使线性几何图形包含环形弧，然后保存。重复当前步骤，直到数据存储中所有图层都发布完毕。点击图层组，添加新的图层组，添加图层，然后点击 生成边界，保存，即完成整个地图的发布。在 Layer Preview 中点击 openLayers 进行地图预览，随意点击地图，若出现乱码，则需要在数据存储中修改 DBF 文件字符集。Mapbox 访问 GeoServer 地图 点击 Geoserver 的logo，然后点击 TMS 1.0.0协议，页面跳转后，查找需要访问的外部地址，即对应 TileMap 的 href 属性。MapBox 中访问发布好的切片服务需要在 http://localhost:8080/geoserver/gwc/service/tms/1.0.0/MapBoxTest:Test@EPSG:900913@pbf/{z}/{x}/{y}.pbf，即 href 属性值后面加上 /{z}/{x}/{y}.pbf ，同时注意 在 MapBox style 下 layers 中 source-layer 的值必须为图层名，这里为 &quot;Test&quot; （若使用图层组，则需要找到 Test 图层组下面的图层，使用对应图层名）。简单示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110const mapStyle: mapboxgl.Style = &#123; version: 8, sources: &#123; geoserverData: &#123; type: 'vector', scheme: 'tms', tiles: ["http://localhost:8080/geoserver/gwc/service/tms/1.0.0/MapBoxTest:Test@EPSG:900913@pbf/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.pbf"], &#125;, // 使用 OSM 数据源作为底图 // OsmTiles: &#123; // type: "raster", // tiles: ["http://a.tile.openstreetmap.org/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png"], // tileSize: 256, // &#125;, &#125;, layers: [ // 背景图层 &#123; id: 'background', type: 'background', paint: &#123; 'background-color': "rgb(0, 0, 0)", &#125;, // interactive: true, &#125;, // &#123; // id: "OsmTiles", // type: "raster", // source: "OsmTiles", // "source-layer": "osmtiles", // &#125;, // 道路 &#123; id: 'road', source: 'geoserverData', 'source-layer': 'Test', type: 'line', layout: &#123; 'line-cap': 'round', 'line-join': 'round', &#125;, paint: &#123; 'line-width': &#123; base: 1.5, stops: [ [5, 0.75], [18, 32], ], &#125;, 'line-color': 'rgb(255, 255, 255)', &#125;, interactive: true, &#125;, // 地图标注 &#123; id: 'label', source: 'geoserverData', 'source-layer': 'Test', type: 'symbol', layout: &#123; 'text-size': &#123; base: 1, stops: [ [9, 10], [20, 16], ], &#125;, 'text-max-angle': 30, 'symbol-spacing': 250, 'text-font': ['Microsoft YaHei'], // 标注使用字体 'symbol-placement': 'line', 'text-padding': 1, 'text-rotation-alignment': 'map', 'text-pitch-alignment': 'viewport', 'text-field': '&#123;name&#125;', // 标注显示属性名 'text-letter-spacing': 0.01, &#125;, paint: &#123; 'text-color': 'hsl(0, 0%, 0%)', 'text-halo-color': 'hsla(0, 0%, 100%, 0.75)', 'text-halo-width': 1, 'text-halo-blur': 1, &#125;, interactive: true, &#125;, ]&#125;;const map = new Map(&#123; container: "map-container", // html container id // style: "mapbox://styles/mapbox/outdoors-v11", //hosted style id style: mapStyle, center: [0, 0], // starting position [经度, 纬度] zoom: 1, // starting zoom antialias: true, // maxZoom: 24, // minZoom: 1, // pitch: 0, // maxPitch: 60, // // minPitch: 0, crossSourceCollisions: false,&#125;);GeoServer 跨域问题 将 lib 目录中的 jetty-servlets 和 jetty-util 两个 jar 包复制到\webapps\geoserver\WEB-INF\lib目录下，将\webapps\geoserver\WEB-INF\web.xml文件中两个 &lt;!-- Uncomment following filter to enable CORS 注释取消，重启 GeoSever。后记 Mapbox 显示的地图可以自定义样式，而且加载速度渲染性能方面也都还可以，最重要的是由于采用前端渲染矢量，所以没有传统瓦片那种缩放模糊的感觉，这点非常好，本来想总结一篇简单的 Mapbox 使用手册，但没时间整理了，还是算了 😅。参考资料基于geoserver+mapbox的定制化离线地图技术方案]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>mapbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用小结]]></title>
    <url>posts/3d8ab974.html</url>
    <content type="text"><![CDATA[前言 最近由于项目部署需要，简单学习了 docker 的使用和回顾下 CentOS 中的常用操作。Docker 篇 由于 Shaun 此次需要安装的环境有点偏门，没找到有完全符合要求的镜像，同时也趁着这次机会学一下 docker，所以就还是直接从最开始的装起了。 首先使用 docker pull centos:7 拉取 CentOS7 的系统镜像，使用 docker images 查看已有的本地镜像信息，使用 docker ps -a 查看当前已有的容器信息，去掉参数 a ，即显示正运行的容器，docker stop [container id | name] 可关闭指定容器，docker start [container id | name] 可打开指定容器，docker rm [container id | name] 可删除指定容器，docker rmi [image id | name] 可删除指定镜像，再删除镜像之前需要先删除依赖该镜像的所有容器。 使用 docker run -dit -p 80:80 -p 8080:8080 --name CentOS7 centos:7 bash 开启一个新的容器，其中参数的意义为： -i: 交互式操作；-t: 终端；-d: 后台启动；-p: 设置主机的端口映射到容器内的端口；-name: 指定容器名称；最后的 bash 代表使用 bash 终端。在 windows 中直接使用 docker run 运行镜像时会出现 the input device is not a TTY. If you are using mintty, try prefixing the command with ‘winpty’ 的错误，前面加上 winpty 即可，即 winpty docker run ...。当没有参数 d 时，则直接进入容器，而当存在参数 d 时，由于容器实在后台启动，进入容器时需要执行 docker exec -it [container id | name] bash 才能进入容器，而退出容器可以输入 exit 命令。 而为了在容器中可以开启后台服务，需要在开启容器时就进行提权，在 Windows 中提权命令为 docker run -dit --privileged=true --name CentOS7 centos:7 init；而在 Linux 中提权命令为 docker run -dit --privileged=true --name CentOS7 centos:7 /usr/sbin/init。 在新开启的容器中添加数据和相应的环境之后，即可使用 docker commit CentOS7 new_image:tag 生成一个新的镜像（生成镜像之前最好关闭容器），该镜像包含已经安装的环境和数据，再使用 docker save -o centos7.tar new_image:tag，可将生成的镜像导出成 tar 包，在其他机器中使用 docker load -i centos7.tar 即可导入该 tar 包，并生成相应的镜像， 从而简单便捷的完成环境和数据迁移部署任务。 容器有时需要和主机之间传输文件，有两种方案，一种是直接采用共享文件夹的方式，设置某个目录为两系统的共享目录，从而实现文件传输；另一种是使用 docker cp 命令，使用 docker cp src_path container:dst_path 将主机的文件拷贝到容器中；使用 docker cp container:src_path dst_path 将容器的文件拷贝到主机中。CentOS 篇安装PostgreSQL12CentOS安装PostgreSQL1234567891011121314151617181920212223242526# Install the repository RPM:yum install -y https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm# Install PostgreSQL:yum install -y postgresql12-server# Optionally initialize the database and enable automatic start:/usr/pgsql-12/bin/postgresql-12-setup initdbsystemctl enable postgresql-12systemctl start postgresql-12#开启远程访问修改/var/lib/pgsql/10/data/postgresql.conf文件，取消 listen_addresses 的注释，将参数值改为“*”修改/var/lib/pgsql/10/data/pg_hba.conf文件，增加下# IPv4 local connections:host all all 127.0.0.1/32 md5host all all 0.0.0.0/0 md5# 给数据库postgres用户分配密码 1psql -U postgresalter user postgres with encrypted password '1';# 重启服务systemctl restart postgresql-12由于需要切换账户，所以最好在第一步安装完之后就使用 passwd [username] XXXXXX 设置 root 和 postgres 两个账户的密码。安装postgis（https://yum.postgresql.org/12/redhat/rhel-7-x86_64/repoview/）1234567891011# 解决依赖yum install epel-release yum install -y https://yum.postgresql.org/12/redhat/rhel-7-x86_64/postgis30_12-3.0.2-2.rhel7.x86_64.rpm# 安装pgrouting yum install -y https://yum.postgresql.org/12/redhat/rhel-7-x86_64/pgrouting_12-3.0.2-1.rhel7.x86_64.rpm# 安装ogr_fdw yum search ogr_fdw # 查询yum install ogr_fdw # 安装postgres 移除扩展 drop extension postgis cascade;。安装Java（https://www.cnblogs.com/bcomll/p/12142747.html）123456789101112131415# 搜素javayum search java | grep -i --color JDK#安装yum install java-11-openjdk# 配置环境变量vi /etc/profile# 加入内容export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.8.10-0.el7_8.x86_64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/jre/lib/dt.jar:$JAVA_HOME/lib/tool.jarexport PATH=$PATH:$JAVA_HOME/bin# 重启环境source /etc/profile安装GeoServer（https://blog.csdn.net/weixin_34205076/article/details/88734828）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849mv /tmp/geoserver-2.13.2 /usr/share/geoserver### 添加环境变量vi /etc/profile# 追加export GEOSERVER_HOME=/usr/share/geoserver# 重新加载/etc/profile文件source /etc/profile# 授权chown -R root:root /usr/share/geoserver#### 改造启动脚本vim /usr/share/geoserver/bin/startup.sh # 在最上面引入环境变量source /etc/profile # 最后执行改为nohup，并将日志输入到 var/log/geoserver.lognohup "$_RUNJAVA" $JAVA_OPTS $MARLIN_ENABLER -DGEOSERVER_DATA_DIR="$GEOSERVER_DATA_DIR" -Djava.awt.headless=true -DSTOP.PORT=8079 -DSTOP.KEY=geoserver -jar start.jar 1&gt;/dev/null 2&gt;/var/log/geoserver.log &amp;#### 修改停止脚本vim /usr/share/geoserver/bin/shutdown.sh# 在最上面引入环境变量source /etc/profile#### 创建服务vim /lib/systemd/system/geoserver.service [Unit]Description=geoserver serviceAfter=network.target [Service]Type=forkingLimitNOFILE=65536ExecStart=/usr/share/geoserver/bin/startup.shExecReload=ExecStop=/usr/share/geoserver/bin/shutdown.shRestart=on-abort [Install]WantedBy=multi-user.target## 开机自启systemctl enable geoserver## 开启服务systemctl start geoserver安装 nginx123yum install nginx # 下载并安装nginxsystemctl start nginx # 启动nginx服务 在 /etc/nginx 下可修改 nginx.config 文件，监听端口默认是 80，直接输入本地地址可能并打不开网页，因为直接这样安装的 nginx 的可能“有毒”，在 /usr/share/nginx/html 目录中 index.html 可能并不是一个 html 文件，而只是快捷方式，需要从别的地方拷贝一个真正的 index.html 文件替换该文件才可正常打开网页。安装 nodejs（https://github.com/nodesource/distributions）123curl -sL https://rpm.nodesource.com/setup_10.x | bash -yum install -y nodejsVSCode 远程篇 需要安装 VSCode 远程开发插件 https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack，包括（Remote - WSL，Remote - Containers，Remote - SSH）。在远程资源资源管理器中 切换到 SSH Targes 标签，点击设置设置，在 C:/Users/用户名/.ssh/config 中输入123Host [随便写] HostName remote-ip 或 域名 User 远程服务器用户名 配置SSH，通过命令 ssh-keygen -t rsa -b 4096 生成密钥对（在 C:/Users/用户名/.ssh/ 目录中），将公钥内容拷贝到远程服务器/root/.ssh/authorized_keys 中，修改配置文件 /etc/ssh/sshd_config，取消 #PubkeyAuthentication yes 注释，允许使用基于密钥认证的方式登录。重启 sshd 服务 systemctl restart sshd。通过 VSCode ssh 远程连接在结束之后最好将终端全部删除，尤其是最开始的那个 install server 终端。 设置好SSH之后，通过在 VSCode 中设置 &quot;docker.host&quot;:&quot;ssh://your-remote-user@your-remote-machine-fqdn-or-ip-here&quot;，可以直接连接在远程服务器上的 docker。该设置最好用于 工作区设置，而不是 用户设置。 VSCode 远程连接 SSH 有时可能会出现无法连接，一直尝试连接的现象，这时需要粗暴的删除 ~/.vscode-server 目录，重新进行连接，不行的话就只能参考: https://stackoverflow.com/questions/56718453/using-remote-ssh-in-vscode-on-a-target-machine-that-only-allows-inbound-ssh-co，先关闭远程服务器上已存在的所有 vscode-server 进程，通过 https://update.code.visualstudio.com/commit:$COMMIT_ID/server-linux-x64/stable 下载 tar 包，使用 tar -xvzf vscode-server-linux-x64.tar.gz --strip-components 1 后再重新连接。后记 据查 docker 依然存在很多缺点，尤其是守护进程，Shaun 这两天在 Windows 中使用 Docker 也时不时的出现 docker 卡死的问题，需要重启 docker 服务， 以后有机会还是使用 Podman 吧。RedHat 系的 yum 也快退休了，以后再需要安装软件可能就直接上毒奶粉（bushi）dnf 了。VSCode 远程开发是真的舒服，文件无缝传输，任意修改，可以尽情享受现代编辑器的方便。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>unix-like</tag>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[空间中三角形与三角形相交]]></title>
    <url>posts/6694a214.html</url>
    <content type="text"><![CDATA[前言 一种快速判断空间中三角形与三角形相交的方法，出自论文：Tomas Moller. A Fast Triangle-Triangle Intersection Test. Journal of Graphics Tools, 1997, 2(2):25-30. ，与「快速判断三角形与长方体相交」中那篇论文的作者是同一个人。相交篇 该论文的理论基础部分来自分离轴理论，论文中三角形与三角形的相交测试主要可分为 3 类：1、沿三角形所在平面法线方向的相交测试；2、沿三角形所在两平面交线方向的相交测试；3、共面时的相交测试。下面来逐步分析这些相交测试。沿法线方向相交 沿法线相交很简单，直接使用分离轴理论分别判断两三角形在对应两条法线上的投影是否相交，若存在一条法线使投影不相交，则可直接判定两三角形不相交，若投影都相交，则存在两种情况，一种是两三角形共面，一种是两三角形相互跨立，判断这两种情况的依据为计算两段投影之间的距离，具体计算方法为：计算三角形 B 上三个点到三角形 A 所在平面的距离，距离计算的方法可参考「计算几何基础—点到平面的距离」，此距离同时需要保留方向，若三个点的距离都为 0，则两三角形共面；若三个距离都同号，则说明投影不相交，即两三角形不相交；若三个距离存在异号现象，则 B 跨立 A。沿交线方向相交 若两三角形相互跨立，则需要判断两三角形是否在两三角形所在平面交线上存在相交。由于两三角形相互跨立，则两三角形必然都与交线相交，则需要分别计算两三角形与交线的交点，根据交点判断两交线段是否相交，若相交，则可直接判定两三角形相交，若不相交，则同样可直接判定两三角形不相交。 问题的关键现在在于求取两交线段，比较粗暴的方式为：先求出两平面的交线，交线的方向向量为两三角形所在平面法向量的的叉积，交线上的一点通过联立两平面方程进行求取，由于是两个方程求 3 个未知数（x，y，z），所以理论上有无数个解，令交线方向向量绝对值最大的分量对应的未知数为 0，消除一个未知数，还剩两个，可得唯一解，即可求出交线上一点，亦可得到直线参数方程，求两交线段相当于求四个交点，根据直线与线段相交可得到交点，进而得到交线段。论文中的方法为：求出交线的方向向量 D 后，设 O 为交线上任意一点（不需要求），则交线方程为 \(L= O+tD\)，此时求交线段只需要求出 4 个 t。先求交线与三角形 A 的交线段，设三角形 A（V0，V1，V2）三个顶点到三角形 B 所在平面的距离分别为 \(d_0,d_1,d_2\)，设 \(d_1\) 与其它两个距离异号，则交线分别与 V0V1 和 V2V1 相交，先求与 V0V1 相交时的 t1，设三角形 B 所在的平面为平面 B，V0 和 V1 在平面 B 上的投影分别为为 K0 和 K1，V0 和 V1 在交线上的投影分别为为 P0 和 P1，交线与 V0V1 的交点为 C1，设 \(P0=O+p_0D,P1=O+p_1D,C1=O+t_1D\)，则 \(p_0=(V0-O)·D,p_1=(V1-O)·D\)，由论文中图二可知，有两组三角形相似，分别为 V0C1K0和V1C1K1 相似，以及 V0C1P0和V1C1P1 相似，所以 \[ \frac{V0K0}{V1K1} = \frac{V0C1}{V1C1} = \frac{C1P0}{C1P1} \Rightarrow \frac{d_0}{d_1} = \frac{p_0-t_1}{p1-t_1} \Rightarrow t_1 = \frac{d_0p_1-d_1p_0}{d_0-d_1} \] 若点 O 为原点在交线上的投影，则 \((V0-O)·D=V0·D=p_0, p_1=V1·D\)，若将交线投影到交线方向向量绝对值最大的分量对应的坐标轴上，在该投影交线上进行相交测试与在原交线上进行相交测试是等效的，所以此时 \(p_0,p_1\) 即为 V0 和 V1 上对应坐标轴的分量。同理可求出 t2，t3 ，t4，两交线段为 t1t2 和 t3t4。共面相交 判断共面相交，相当于判断 2 维中两三角形是否相交，先将三角形投影到 XOY，XOZ，YOZ 平面中投影面积最大的平面（为避免计算面积，可直接令三角形顶点坐标中对应法向向量中绝对值最大的分量为 0，即若法向向量中绝对值最大的分量为 y，则将三角形投影到 XOZ 平面），判断投影后的两三角形是否相交即可，因为此时的两三角形相交，当且仅当其投影三角形相交。2 维中两三角形是否相交，论文中方法是先判断两三角形的边是否相交，即相当于判断 9 组线段是否相交，若存在一组相交，则两三角形相交，若都不相交，则需要判断其中一个三角形是否被另一个三角形包含，具体判断方式取三角形 A 中一顶点，若该顶点在三角形 B 内（判断 2 维中点在多边形内的方法同样可参考「计算几何基础」），则说明三角形 A 在 B 内，同样也需要判断 B 是否在 A 内，若都不在，则两三角形不相交，否则两三角形相交。当然，也可以直接通过分离轴理论来判断两三角形是否相交，毕竟，这就是在 2 维中，而且三角形算是天然的凸多边形。后记 三角形是图形学中组成面的基本单元，图形学中面与面的碰撞检测都可以很粗暴的用三角形相交来实现，只不过直接一个个判断效率有点低就是了，所以一般会借助一些基于的树和包围盒空间加速结构，或者针对某种形状的特殊方法，这又是新的方法系列了。]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算几何基础]]></title>
    <url>posts/5315fcfd.html</url>
    <content type="text"><![CDATA[前言 由于本篇主要是谈谈基础，所以一些快速运算方法一般不在本篇探讨范围之内，一些特殊的快速手法等后续专门独立开篇再谈。基础篇解线性方程组：令 \(A\) 为 \(n×n\) 的矩阵，\(α\) 和 \(β\) 为 n 维的列向量，设 \(A = \begin{bmatrix} \alpha_1 &amp; \alpha_2 &amp; \alpha_3 &amp; ... &amp; \alpha_n \end{bmatrix}\)，对于线性方程组 \(Ax = β\)，初等数学中最常规的就是消元法了，但在线性代数中，有两种解法，一种是等式两边同乘 \(A\) 的逆阵，得到 \(x = A^{-1}β\)；另一种是克莱姆法则，可得 \(x_i = |A_i| / |A|\)，其中 \(|A|\) 为 矩阵 \(A\) 对应的行列式， \(|A_i|\) 为将矩阵 \(A\) 中第 \(i\) 列换成 \(β\) 后对应的行列式，如 \(x_3 = \left| \begin{array}{cccc} \alpha_1 &amp; \alpha_2 &amp; \beta &amp; ... &amp; \alpha_n \end{array} \right| / |A|\)。向量内积：又称向量点积，向量点乘。设 a，b 为空间中两个 n 维向量 \(a=(x_1,x_2,x_3,...,x_n)\)，\(b=(y_1,y_2,y_3,...,y_n)\)，则 \(a·b=|a|*|b|*cos(α)=\sum\limits_{i=1}^{n}x_iy_i\)，其中\(|a|= \sqrt{(x_1)^2+(x_2)^2+(x_3)^2+...+(x_n)^2},\alpha\) 为两向量之间夹角。向量内积一般用来计算投影（令 \(|b|=1\)，则 \(a \cdot b=|a|cos(α)\)，即为向量 a 在 b 上的投影），和两向量之间角度。向量外积：又称向量叉积，向量叉乘，\(|a×b|=||a|*|b|*sin(\alpha)|\)。向量外积一般只针对二维向量和三维向量，对于二维向量，\(a×b=a.x*b.y-b.x*a.y\)，可以认为是一个值（其实也是一个向量），对于三维向量 \(a×b=(a.y*b.z-b.y*a.z, a.x*b.z-b.x*a.z, a.x*b.y-b.x*a.y)\)，是一个向量，且该向量一定垂直于 a，b 两向量构成的平面，所以三维向量的外积一般可以用来计算平面的法向量。向量外积的几何意义为两向量构成平行四边形的面积，二维向量外积直接取绝对值即为面积，不取绝对值则可以用来判断两向量构成三角形的点是以顺时针排列（小于 0）的还是逆时针排列（大于 0）的，三维向量外积取所得向量的模即为面积。向量混合积： 设 \(a\)，\(b\)，\(c\) 为空间中三个向量，则其混合积 \((a,b,c)= (a×b)·c = -(c×b)·a = -(a×c)·b\)，\((a,b,c) = (b,c,a) = (c,a,b)\)。若 \(a\)，\(b\)，\(c\) 都为 3 维的向量，矩阵 \(A = [a, b, c]\)，则 \(|A| = (a, b, c)\) ，其中 \(a,b,c\) 是列向量或行向量都可以，因为 \(|A| = |A^T|\)，该混合积的几何意义为这三个向量组成的平行六面体的体积。直线参数方程：设 P 为直线上任意一点，若 P1 和 P2 为直线上已知两点，则 \(P=P1 + (P2-P1)*t, t\in[-∞,+∞]\)。当然直线的参数方程有很多种形式，之所以用两点式，是因为两点式除了能表示直线，同样能表示射线（\(t\ge 0\)），也能表示线段（\(0\le t\le 1\)）。平面方程：设 P 为平面上任意一点，O 为平面上已知一点，n 为平面法向量，则平面方程为：\((P-O)·n=0\) 。三角形内的点：设 P0，P1，P2 为三角形 3 个顶点，若 P 为三角形内一点，同时可认为 (P1-P0) 和 (P2-P0) 为一组基向量，则 P 满足 \(P=P0+u*(P1-P0)+v*(P2-P0),u \in [0,1],v \in [0,1],u+v\le 1\)。距离篇 一般的距离计算都是向量计算，要么点乘，要么叉乘。点到直线的距离 计算点到直线的距离通用的解法是使用向量叉乘，设 P 为直线外一点，Q1 和 Q2 为直线上两点，则可得到两向量 \(a=P-Q1, b=Q2-Q1\)，则 P 到直线的距离为 \(d=|a×b|/|b|\)，叉乘是面积，而面积又等于底乘高，\(|b|\) 为底，\(d\) 为高。当然点到直线的距离还有其他的一些方法，如 利用公式，利用点积再使用勾股定理，直接利用点积计算直线法向量上的投影等，这些方法都有一定的局限性。点到线段的距离 设 d 为点 P 到线段的距离，表示为点 P 到线段上最近点的距离，设 P1，P2 分别为线段两端点，计算 \(a=(P-P1)·(P2-P1) / |P2-P1|\)，若 \(0≤a≤1\)，则 d 为点 P 到线段所在直线的距离，若 \(a&lt;0\)，则 d 为点 P 到点 P1 的距离，若 \(a&gt;1\)，则 d 为点 P 到点 P2 的距离。三维中点到三角形的距离 先计算点 P 到三角形所在平面的投影点 \(P&#39;\)，若 \(P&#39;\) 在三角形内，则只需要求点 P 到三角形所在平面的距离，否则需要分别求点 P 到三角形三条边的距离（点到线段的距离），取三个距离中最小值即为点到三角形的距离。点到平面的距离 直接利用点乘计算，平面外一点与平面内一点构成的向量到平面法向量上的投影，即为点到平面的距离。设 P 为平面外一点，O 为平面内一点，n 为平面法向量，则点 P 到平面的距离为 \(d=(P-O) \cdot n\)。直线到直线的距离 设 P1 和 P2 为直线 1 上两点，Q1 和 Q2 为直线 2 上两点，则直线 1 与直线 2 之间的距离计算流程为：先判断两直线是否平行，即 \((P2-P1) = k*(Q2-Q1), k \neq 0\) 有解。若平行，则相当于计算点到直线的距离；若不平行，则进行下一步。再判断两直线是否共面，即 P1，P2，Q1，Q2 四点共面，先计算 \(n=(P2-P1)×(Q2-Q1)\)，再分别计算 \(n·(Q1-P1), n·(Q2-P1), n·(Q1-P2), n·(Q2-P2)\)，若这四个值都为 0 ，则两直线共面（之所以需要判断 4 个值，是为防出现 3 点共线情况，当然也可以先判断 3 点共线，再取不共线的一点构成向量与 n 做点积进行判断），若两直线共面，则两直线必然相交；若两直线不共面，则两直线间距离为 \(d=(Q1-P1) \cdot n\)。直线到平面的距离 设 P1 和 P2 为直线上两点，n 为平面法向量，则直线与平面之间的距离计算流程为：先判断直线与平面是否平行，即若 \((P2-P1) \cdot n = 0\) ，则直线与平面平行，则直线到平面的距离为 点 P1 到平面的距离；若直线与平面不平行，则直线与平面必相交。相交篇 一般的相交求交点都是联立方程组，但有些只需要做相交测试的，可以利用一些特殊方法快速求出来。有些相交直接求很麻烦或很难，可以反向求不相交的情况，而在实际编程中，一般都有很多条件语句，以便快速返回提高效率。直线与直线相交 设直线 1 方程为 \(P=P1 + (P2-P1)*t\)，直线 2 方程为 \(P=Q1 + (Q2-Q1)*u\)，联立两方程得 \(P1 + (P2-P1)*t = Q1 + (Q2-Q1)*u\)，即 \(P1-Q1 = (Q2-Q1)*u - (P2-P1)*t\)，设 \(v_0=Q2-Q1,v_1=P1-P2,v_2=P1-Q1\)，即 \(v_0*u+v_1*t=v_2\)，现在的问题就是解这个方程了，一种是直接把向量分解成单一维度，列方程组；一种是等式两边分别同时点乘 \(v_0\) 和 \(v_1\)，可得 \[ \begin{cases} (v_0 \cdot v_0)*u+(v1 \cdot v_0)*t=v_2 \cdot v_0 , \\ (v_0 \cdot v_1)*u+(v1 \cdot v_1)*t=v_2 \cdot v_1 \end{cases} \] 解得： \[ \begin{cases} u=((v1·v1)(v2·v0)-(v1·v0)(v2·v1)) / ((v0·v0)(v1·v1) - (v0·v1)(v1·v0)) , \\ t = ((v0·v0)(v2·v1)-(v0·v1)(v2·v0)) / ((v0·v0)(v1·v1) - (v0·v1)(v1·v0)) \end{cases} \] 若方程有解，则两直线相交，由于两点式方程可以很简单的转换为线段和射线，所以该方法同样可以判断两线段相交，两射线相交，射线与直线与线段相交等。针对二维直线，还有一种解法是将原方程写成矩阵形式，利用克莱姆法则进行求解，不过总的来说，最终的解都是一种形式。直线与平面相交 求直线与平面相交，直接联立直线方程和平面方程即可，得 \((P1-O+(P2-P1)*t)·n=0\) ，即 \(t=(P1-O)·n/((P1-P2)·n)\)。若 t 有解，则直线与平面相交。同样也可以用该方法判断线段或射线与平面相交。直线与三角形相交 二维中判断直线和三角形相交相当于判断直线和线段相交，而在三维中则同样需要联立直线和三角形方程，设直线方程为 \(P=P1+(P2-P1)*t\)，三角形方程为 \(P=Q1+(Q2-Q1)*u+(Q3-Q1)*v\)， 则联立后方程为 \(P1-Q1=(P1-P2)*t+(Q2-Q1)*u+(Q3-Q1)*v\)，令 \(V_0=P1-Q1,V_1=P1-P2,V_2=Q2-Q1,V_3=Q3-Q1\)，则 \(V_0=V_1*t+V_2*u+V_3*v\)，可以分解向量求解，也可以使用克莱姆法则得： \[ t = \frac{\begin{vmatrix} V_0 &amp; V_2 &amp; V_3 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}} \qquad u = \frac{\begin{vmatrix} V_1 &amp; V_0 &amp; V_3 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}} \qquad v = \frac{\begin{vmatrix} V_1 &amp; V_2 &amp; V_0 \end{vmatrix}}{\begin{vmatrix} V_1 &amp; V_2 &amp; V_3 \end{vmatrix}} \qquad \] 由于三阶行列式也可以用向量混合积来求值，所以 \[ t = \frac{-V_0 × V_3 · V_2 }{V_1 × V_2 · V_3} \qquad u = \frac{V_0 × V_3 · V_1 }{V_1 × V_2 · V_3} \qquad v = \frac{V_1 × V_2 · V_0 }{V_1 × V_2 · V_3} \qquad \] 若方程有解，且满足三角形条件，则相交。二维中凸多边形与凸多边形相交 曾在「快速判断三角形与长方体相交」中写过判断两凸多边形是否相交直接使用分离轴理论（separating axis theorem， AST）即可，简而言之就是，取两多边形任意一条边，计算两多边形在该边法向量上的投影是否相交，若存在一条边，使投影不相交，则两凸多边形不相交。二维中点在多边形内 判断点在多边形内有很多种方法，利用叉乘，面积等方法虽然思想简单粗暴但一般计算量较大，且有一定的局限性，仅限凸多边形，但有一种相对快速且能应对各种简单多边形的方法——射线法，射线法的本质是判断射线与线段相交，即从已知点处引一条沿 X 轴正向的射线，若射线与多边形边的相交条数为奇数，则该点在多边形内，该法的缺陷在于若点在边上则需要单独判断。判断该射线与多边形的边是否相交也比较简单，设射线起点为 P0，多边形边的两个端点分别为 P1 和 P2，则射线与边相交需满足的条件为：1、\(min(P1.y, P2.y)&lt;=P0.y&lt;=max(P1.y, P2.y)\)；2、\(P0.x &lt;= (P2.x-P1.x)*(P0.y-P1.y)/(P2.y-P1.y)+P1.x\)。圆与三角形相交 判断圆与三角形相交，即判断圆心到三角形各边的距离是否小于圆的半径，若存在一条边，使圆心到其的距离小于半径，则圆与三角形相交，该距离计算不是点到直线的距离，而是点到线段的距离。直线与长方体相交 判断直线与长方体相交，首先需要将坐标原点平移至长方体中心，再计算过原点且垂直于直线的法向量 n ，随后计算原点到直线的距离 d，若满足 \(|d| &lt;= h_x|n_x| + h_y|n_y| + h_z|n_z|\) ，则 直线与长方体相交。法向量 n 的求法为：设 P 为直线上一点，l 为直线方向向量，则 \(n=-(P·l)*l+P\)。球与 AABB 相交判断球与 AABB 相交，首先需要将坐标原点平移至球心，设平移后的 AABB 最小顶点为 V1，最大顶点为 V2，球半径为 r。最简单粗暴的当然是若原点不在 AABB 内，则直接求原点到 8 个面的距离，取最小值，若最小值比半径大，则不相交。另一种方法是将这个问题转化为求解不等式，若存在一点 \(P(x, y, z)\)，使 P 在球内，同时 P 在 AABB 中，即： \[ \begin{cases} x^2+y^2+z^2 ≤ r^2 , \\ V1.x ≤ x ≤ V2.x , \\ V1.y ≤ y ≤ V2.y , \\ V1.z ≤ z ≤ V2.z \end{cases} \] 若该不等式有解，则球与 AABB 相交，否则不相交。解该不等式也简单，由于是存在而不是任意，所以只需要求 \(min(x^2+y^2+z^2)≤r^2 \Rightarrow min(x^2) + min(y^2)+ min(z^2)≤r^2\)，则若 xyz 分量可以取 0，则对应分量取 0，否则取 \(x = min(|V1.x|, |V2.x|), y = min(|V1.y|, |V2.y|),z = min(|V1.z|, |V2.z|)\)，若满足不等式，则相交。该方法同样可用来求 OBB 与球相交，只需要先利用坐标系变换将 OBB 转成 AABB。反射篇 令入射向量为 \(I\)，法向量为 \(N\)，反射向量为 \(R\)，入射向量与反射向量构成的平面与镜面交线的方向向量为 \(T\)，这四个向量都为单位向量。首先以 \(I\) 和 \(R\) 组成一个菱形，则 \(N\) 和 \(T\) 则为该菱形对角线的方向向量，若已知 \(I\) 和 \(R\)，则 \(N = (R - I).normalize()\)，\(T = (I + R).normalize()\) ，\(normalize()\) 指向量归一化；若已知 \(I\) 和 \(N\)，则 \(R = I + 2*|I \cdot N|*N\)，\(2*|I \cdot N|*N\) 为菱形 \(N\) 方向的对角线向量。 镜面反射公式为 \((r&#39;,g&#39;,b&#39;) = (r,g,b) + (1-r,1-g,1-b)*t\)，当 \(t\) 越大则越接近白色，表现为越亮；漫反射公式为 \((r&#39;,g&#39;,b&#39;) = (r,g,b)*t\)，当 \(t\) 越小，则越接近黑色，表现为越暗。 其中 \(t\in[0,1]\)，\(t\) 为入射向量到平面法向量上的投影，即点积。后记 该篇不出意外的话也会是一个长期支持篇，等以后有碰到其他的一些计算几何知识再持续更新吧。]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenDrive解析小结]]></title>
    <url>posts/b7d79231.html</url>
    <content type="text"><![CDATA[前言 接触并使用高精地图和 OpenDRIVE 已有一年的时间，简要写写 Shaun 对 OpenDRIVE 的一些认知。基础篇OpenDRIVE 目前最新的版本的 1.6，下面主要结合 1.4，1.5 和1.6 版本一起看。 在 OpenDRIVE 中主要有两种坐标系统，一种是常见的 X/Y/Z 空间坐标系统，另一种是 S/T/H 坐标系统。其中 X/Y/Z 坐标系统常与地理信息的各种坐标系统一起使用，S/T/H 坐标系统是针对 OpenDRIVE 中道路参考线设定的一种局部坐标系统，在 OpenDRIVE 中称前者为 “inertial co-ordinates”，后者为 “track co-ordinates”（1.6 中直接为 Reference Line System）。除此之外，还有个局部坐标系 U/V/Z，该坐标系统系统是相对于 S/T/H 坐标系统平移旋转而来的。对于旋转，以逆时针为正，heading 是指绕 z/h 轴旋转，pitch 是指绕 y/t 轴旋转，roll 是指绕 x/s 轴旋转。对于曲率，逆时针延申的曲线曲率为正，顺时针延申的曲线曲率为负。在 OpenDRIVE 中对于道路和车道的描述，有以下几个重要的概念：Reference Line。用来指示一条道路的骨架，是 S/T/H 坐标系统的依据，道路中各车道线需要参考这条线。Lanes。用来描述各车道以及各车道所属 Lane Section。Lane Offset。其意义在 OpenDRIVE 标准看起来很清除，但实际用起来非常模糊，offset 到底是只能偏移一个车道，或半个车道或多个车道，所属哪个 Lane Section，其意义不明，故下文解析篇将直接忽略该属性。Lane Section。可以简单理解为子道路，一个 lane section 中包含多条车道，一条道路包含多个 lane section。一个 lane section 中车道数是一个常数，所以对于存在 m 变 n 车道的一条道路，至少要划分为两个 lane section。Superelevation、Crossfall 和 Shape。用来表示路面倾斜程度。Superelevation 是整个路面侧向太高，即路面倾斜程度，Crossfall 在 1.6 中已被废弃，原因为 1.6 完善了 Shape，可以完全取代 CrossFall，甚至能做的更好，Shape 主要用来描述路面两侧车道的倾斜程度，通过三次曲线和线性插值可以精确到车道各点倾斜程度。Road Linkage。道路之间的连接关系，通过前继（predecessor）和后继（successor）建立道路之间连接关系，若一条路存在多个前继或后继，则其对应前继或后继应该为 Junction ，即目前的标准中暂不支持道路多前后继，1.5 中只支持车道多前后继，道路多前后继依然不支持。Junction。交汇处，通俗意义上的路口，主要包含 incomingRoad 和 connectingRoad。Junction Group。可以简单理解为交通环岛。Neighbors。相邻关系，和 Road Linkage 类似，一个是前后连接关系，一个侧面相邻关系。Surface。车道或道路表面材质，有 OpenCRG 则优先使用，没有则由应用程序自定义字符串。……. 等等。还有一些冷门的元素暂时没用到，就不介绍了。下面就是真正的解析内容了。解析篇 一些简单的就不介绍了，就介绍解析时需要注意的一些重点元素。Road Geometry geometry 信息可以说是 OpenDRIVE 中最重要的信息，没有之一。OpenDRIVE 中最重要的元素为 Road，而 Road 中最重要的是 Reference Line，而 geometry 正是用来描述 Reference Line 几何线条形状的信息。 首先 geometry 标签中共有 5 个属性，分别为 s （该段 geometry 沿参考线起始位置），x（该段 geometry 在 inertial system 下起始横坐标），y（该段 geometry 在 inertial system 下起始纵坐标），hdg（该段 geometry 在 inertial system 下起始弧度），length（该段 geometry 长度）。其次，geometry 共有 5 种线型，分别为 straight lines（直线），spirals（螺线），arcs（圆弧线），cubic polynomials（三次曲线），parametric cubic polynomials（参数化三次曲线），这 5 种线型分别由 geometry 下 5 种标签控制。解析 geometry 的要点在于：先不用管 geometry 标签中的属性，直接解析对应线型标签，需要满足两点：1、起始点坐标一定为 (0, 0)；2、起始点斜率，即导数也一定为 0。依据这两点正确解析完线型之后，再根据 hdg 旋转线型，根据 (x, y) 将线型平移到正确位置。 下面就具体看看这 5 种线型：line，直线。没有任何属性，直接根据 geometry 中 (x, y) 和 hdg 就可得到直线方程。spiral，螺线。有两个属性 curvStart（起始曲率），curvEnd（结束曲率）。螺线解析的代码已经由 OpenDRIVE 官方直接给出了，里面涉及到的数值计算方法就不详解了，直接看官方提供 API 的输入输出，输入有两个：s（从原点开始，螺线延展的长度），cDot（螺线的曲率关于 s 的一阶导数）；输出有 3 个：x（横坐标），y（纵坐标），t（该点的切线弧度）。解析螺线最大的问题应该就是如何得到这两个输入参数，由螺线的性质可以得到，螺线的曲率一定随着螺线的长度均匀变化的，换句话说，对于一条已知螺线，cDot 一定是常数。则 \(cDot = (curvEnd - curvStart) / length\)，其中 length 为 geometry 中的长度属性，下一步需要求出 s，由于已知螺线在原点处的曲率一定为 0，则 (curv - 0) / (s - 0) = cDot，即 s = curv / cDot。由此可得到螺线的各点坐标和切向方向，但由于解析线型需要满足上面说的两点，所以需要将螺线坐标以起始点进行平移和旋转，以满足起始点为原点，起始点切线弧度为 0，最后再将完成平移和旋转后的点根据 geometry 的属性进行旋转和平移以得到真正的坐标点。arc，圆弧线。只有一个属性 curvature（曲率），可根据曲率直接得到圆的半径，在根据曲率的正负可得到该曲线是以顺时针延申还是逆时针延申，再根据解析线型需要满足的两点和 geometry 的属性可得到真正的 inertial system 中的点。poly3，三次曲线，在 1.6 中已被废弃。精度要求低一点可直接插值计算，要求高一点则需要利用 length ，数值计算和二分法直接求出最大的 u，然后插值。paramPoly3，参数化三次曲线。最有名的两个参数化三次曲线就是 Bezier 曲线和 Hermite 曲线，为满足解析线型需要满足的两点，一定有 \(a_u=0, a_v=0,b_v=0\)，需要注意的是一般参数化曲线的参数取值范围为 \([0,1]\)，即该标签最后一个属性 pRange=“normalized”，若碰到特殊情况 pRange=“arcLength”，则需要将 \(a_u,b_u,\dots\) 等属性转化为参数取值范围为 \([0,1]\) 时对应的属性。最重要的元素 Geometry 的解析就是这样了，下面谈谈 Shaun 对基于三次曲线的一些元素的理解。 比较重要的基于三次曲线的元素主要有 elevation（控制路面的高度），superelevation（道路侧面抬高弧度），crossfall（路面两侧弧度，已被废弃），shape（路面两侧形状，特殊，下文详细介绍），laneOffset（车道偏移量），border 和 width（特殊，下文详细介绍），这些元素所使用的三次曲线一般都基于道路参考线（特殊除外），即该三次曲线的横坐标一般为 s，纵坐标即三次曲线的值则为各元素的信息，这些三次曲线一般是分段描述的，即道路参考线上两个关键点的 s 之间必会生成对应的一段三次曲线，每一段三次曲线的横坐标取值范围都为 \([0,poly3Length]\)，其中 ploy3Length 为该段三次曲线的长度。这些三次曲线段全部合起来则构成沿道路参考线的一条三次曲线，根据 s 计算三次曲线的取值得到对应的信息。LaneOffset laneOffset 用来指示的是所有车道沿参考线法线方向的偏移量，所有车道包括中心车道（centerLane），由于中心车道没有宽度，所以也可以叫道路中心线，这和道路参考线是两个概念，若 laneOffset 都为 0，则道路中心线和道路参考线重合。Shape 路面两侧车道的高度，该元素虽然也是使用三次曲线进行描述的，但是该三次曲线的横坐标为 S/T/H 坐标中的 t，不是 s，不同的 t 得到不同的高度，该元素下可能存在多段三次曲线，这些三次曲线段是独立的，只是描述其属性 s 所在位置横截面的 shape，而没有完全指定 s 的横截面的 shape，则由两临近 s 的 三次曲线计算相同的 t 对应的高度然后线型插值得到（1.6 标准中插值的公式 Shaun 觉得有问题）。border 和 width 之所以把这个两个元素放在一起写，是因为这两个元素描述的本质上是一个东西，都是车道边界所在的位置。同时，Shaun 还是想吐槽一下，作为一个既定的标准，完全不应该把这两个元素同时放出来，只需要放出一个即可，既然为标准就应该做到完全统一，至于具体用哪个是应用程序的事，但是出来的东西必须得唯一。border 是指车道边界到道路中心线在道路参考线法线上的投影，有正负之分，一般左边车道为正，右边车道为负，而 width 是指车道的宽度，这两者完全可以相互转换。虽然描述这两者的三次曲线是基于道路参考线 s 的，但是这个 s 是相对于 laneSection 标签中 s 属性的，即其真正沿道路参考线的 s’ 应该为 s’ = s + laneSection.s。 至于Junction 的解析好像没什么需要注意的，就不写了，至于 1.5 中的 Virtual Junction，引入新的道路前后继描述方式，也新加了一个 virtual connection，解析时到也没有需要注意的，唯一需要注意是在应用程序中该如何利用这些信息。 对于 Signal 和 Object，Shaun 觉得标准中强制规定 s &gt; 0 同样是一件非常不合理的事情，既然能超出道路长度，只准正向超出，不能反向超出，这有点不讲道理。 Signal 和 Object 同样需要注意在应用程序中的用法，至于解析方面，需要注意的应该就是 Object 中 outline 下面的 cornerRoad 和 cornerLocal。cornerRoad 和 cornerLocal 这两个元素描述的本质上也是一个东西，都是面域对象多边形边界上的轮廓点，虽然 1.5 中引入了复杂多边形的概念，即有内轮廓和外轮廓，但 cornerRoad 和 cornerLocal 还是一样的解析。cornerRoad 是直接相对于道路参考线的坐标，即将 X/Y/Z 坐标直接转换为 S/T/H 坐标得到的，所以直接解析转换就可得到该点的真正坐标。而 cornerLocal 的解析则相对要麻烦些，首先根据 object 标签中 s 和 t 属性计算得到 Object 的位置，以道路参考线上 s 所在的位置建立 S/T/H 坐标系统，将该坐标系统平移到 Object 所在位置，即该 S/T/H 系统以Object 的位置为原点，将 cornerLocal 上 u,v,z 属性带入该坐标系统计算出真正的坐标。由于 Object 中的 roll,pitch,hdg 属性，所以还需要对坐标以 Object 的位置为中心进行相应旋转才能得到真正 X/Y/Z 坐标系统中坐标。好了，以上就是 Shaun 觉得在解析 OpenDRIVE 时需要注意的一些地方了。后记 整个地图行业本来就存在很强的壁垒，国内更是如此，而高精地图作为专为自动驾驶服务的地图，国内估计更是少有人接触过。 OpenDRIVE 虽作为一种高精地图标准，但离那种被广泛认可关注的标准还有很长一段距离，虽然它发展了十几年，但奈何整个行业才算是起步阶段，所以之前其一直发展的十分缓慢，之前用 OpenDRIVE 较多的应该是交通仿真领域，这个领域同样存在很强的壁垒，要在这种领域得到整个行业的认可是一件非常困难的事，因为其本来就存在一套自己的格式，而想要应用别人的标准，就势必需要逐渐抛弃自己的格式，这对企业来说需要下很大的决心。 就 Shaun 目前所知，行业内虽然有许多企业使用 OpenDRIVE 标准，但基本都是自己魔改后的标准，原因在于 OpenDRIVE 标准还没做到真正成为标准的地步，虽然其一些基本元素具备，但很有很多元素是完全缺失或不完善的，更重要的是，其可视化程序竟然不开源，在整个计算机领域内，还从没见过一种标准没有其开源实现的东西，没有相应的源码，只靠文字来理解难免会产生歧义，各大厂商自然就会选择实现自己的 OpenDRIVE，很难统一。历史上一些经典的论文和算法，都有其相应的开源实现，没有开源实现的论文和算法基本都淹没在了历史长河之中。所以没有开源实现，在计算机领域内很难真正推广开，就很难成为真正的标准。综上，OpenDRIVE 的发展任重而道远啊！希望现在在 ASAM 手中能发展的更快更完善些吧。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>opendrive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张纹理做天空盒]]></title>
    <url>posts/39a3c99e.html</url>
    <content type="text"><![CDATA[前言 前段时间做了一件很有意思的事，使用一张普通纹理图片做成了一个天空盒（SkyBox），其实是半个，因为最终形成的天空盒是上下对称的，看起来有天空之境的感觉。天空盒篇 常见的天空盒一般采用立方体包围盒做 geometry，再使用 CubeMap 将 6 张纹理图贴到立方体包围盒上，但是如果只用一张纹理图片，要映射到立方体包围盒上，无论怎么展 UV，都会造成部分棱和顶点 UV 聚集或突变，从而在这样的地方造成贴图扭曲或错位的不协调现象。 既然立方体包围盒不可行，就只有采用另一种 geometry —— 球 了，但是直接用球作为 geometry 会造成两种问题：1、球的极点处会有扭曲现象，因为球极点处的 UV 是聚集的，同一个位置，V 都为 1 或 0，而 U 则为 [0, 1] 都有，即在该位置处一个 V 对应多个 U，自然会造成扭曲；2、由于球是一个圆周，所以 U 为 0 的位置和 U 为 1 的位置是同一个，对于一张普通纹理图，这就会造成错位，能看到非常明显的接缝线。所以需要重新展开球面的 UV，而常见的展 UV 方法主要有以下几种：对于平面，uv 坐标自然通过线性归一化解决，取左下角坐标和右上角坐标，得到平面的宽度和长度，再用当前坐标减去左下角坐标，最后除以平面宽度和长度得到 uv 坐标。对于球面，自然是取水平方位角 \(θ, \theta \in [-\pi, \pi]\) 和 垂直仰角 \(φ, φ\in [0, \pi]\) 作为 uv 坐标。对于 threejs 而言，方位角在 XZ 平面上，可计算 \(\theta = Math.atan2(z, x)\)，仰角 \(φ = Math.acos(-y)\)，其中 \(x,y,z\) 为当前坐标归一化后的值，则 \(u = (θ +\pi)/(2*\pi)\)，\(v=φ/\pi\)。对于一般的曲面，可能会依据当前顶点的法线计算 uv 坐标。对法线向量 x,y,z 三个分量的值进行排序，取最小的两个作为 uv，或者将最小的两个除以最大的一个作为 uv（CubeMap 中通常用这种进行 6 个面的纹理映射，最大的那个决定映射 6 个面中的哪一面），或者取固定的两个分量作为 uv ，或者得到最小的两个分量索引取对应顶点坐标的分量值作为 uv 等等，若 uv 取值为 [-1,1]，则还需要做 \(uv = uv *0.5+0.5\) 。根据法线计算 uv 一般需要根据不同的使用情况选择不同的 uv 计算策略。 Shaun 很快的解决了第二个问题，想要将一张普通纹理图片贴在整个球面上而不留下接缝线是不现实的，而铺在半个球面上，另一半球面做对称，这个是可行的，而且看起来的效果也不错，计算 uv 就很简单了，原始的 v 不需要改变，只需要将 u 从 [0, 0.5] 映射为 [0, 1]，从 [0.5, 1] 映射为 [1, 0]，即 \[ f(u)=\begin{cases} 2*u, 0 \le u \le 0.5 \\ 2*(1-u), 0.5 \le u \le 1 \end{cases} \] ，接缝线问题使用对称性巧妙的解决了，但第一个问题，极点扭曲现象，还是没法解决，接下来才是真正的难点 ╯︿╰。 为了解决极点扭曲问题，首先需要知道极点扭曲的根本原因是同一个位置对应了多个 uv，所以要么将这些 uv 给散开，要么抛弃一部分 uv，散开 uv 的方式 Shaun 没想出来，抛弃一部分 uv 倒是有一种简单的方式，不过抛弃 uv 也意味着会损失一部分纹理，就这个天空盒而言，抛弃一部分 uv 是能接受的，不然平面到球面必然有形变。具体抛弃方法为，将球面铺平，变为一个大圆面，即忽略球面顶点坐标的 z 值，求出球的 AABB，将 AABB 铺平，即为大圆的外接正方形，用计算平面 uv 的方式重新球上各顶点的 uv 坐标，这种方式的确能解决极点扭曲的问题，但又带来了一个更为严重的问题。 这个问题就是，球面上半部分显示很正常，但是越靠近底部大圆的部分，纹理拉伸的越厉害，造成天空盒四周都出现很严重的纹理拉伸现象。出现纹理拉伸现象的原因也很好理解，那就是越靠近底部大圆的顶点，uv 坐标之间的间隔越小，即同样的 uv 间隔，顶点之间的距离变大了，在进行纹理插值时，自然会导致纹理拉伸现象。知道问题出现的原因了，那怎么解决了？这又是一个新问题 😔。 导致纹理拉伸现象的原因是线性映射，那能不能对计算好的 uv 进行非线性映射，从而抵消 OpenGL 线性纹理插值的影响，非线性映射最重要的是找到合适的非线性函数，常见非线性函数一般有幂函数（伽马变换就是一种幂函数变换，幂 &lt; 1 拉伸小值，幂 &gt; 1 拉伸大值），对数函数，指数等，对于 Shaun 这里的情况，常规的非线性函数肯定是不行的，只能自己想一个函数。 注意到，这是在球面上，要取一个非线性映射函数，自然需要从圆的弧长入手，先计算圆的弧长。计算弧长的本质是勾股定理 \(ds=\sqrt{(dx)^2 + (dy)^2} = \sqrt{1+(dy/dx)^2} * dx\)，对于圆 \(x^2 + y^2 = r^2, y \ge 0\)，即 \(y=\sqrt{r^2-x^2}\)，有 \(dy/dx = -x/ \sqrt{r^2-x^2}\)，则对于圆的弧长 \(L=\int \sqrt{1+x^2/(r^2-x^2)}dx = r \int 1/ \sqrt{1-(x/r)^2}d(x/r) = r*arcsin(x/r)|\)，即对于圆在第一象限的弧长可以为 \(L=r*arcsin(x/r), 0\le x \le r\) 。 由于 v 是均匀的，所以只需要对 u 进行拉伸即可，离圆心越近的点，则越接近 0.5， 离圆心越远的点则越偏离 0.5，非线性拉伸公式为 $ u = α * (u-0.5) + 0.5$，其中 \(α = L / (\pi*r/2), L中的x为点到圆心的距离\)，使用这种拉伸后，天空盒四周的纹理拉伸现象确实不见了，但是又引入了新的问题，天空盒顶部出现了局部拉伸现象，出现微弱的纹理模糊，虽然区域不大，依靠一些手段可以让用户看不到这块区域，但是不能自欺欺人，这一块存在总让 Shaun 觉得很不舒服，于是，就有了下面的终极解决方案。 Shaun 最终想出解决方案是：既然单纯的拉伸不能完美解决问题，那还是只能从问题根源入手，完全重新计算 uv 坐标，这次计算 uv 坐标，还是需要借助上文的 \(α\)。具体计算 uv 坐标的方式如下：先计算球面上顶点相对大圆圆心的角度，即 \(angle = Math.atan2(y - center.y, x - center.x)\)，其中 center 即为大圆圆心（0, 0）。根据顶点到圆心的距离得到 \(\alpha\)，计算 \(α_x = α * cos(angle)， α_y=α * sin(angle)\) 。计算 uv：\(u = α_x * 0.5 + 0.5， v=α_y*0.5+0.5\) 。 使用这个方式计算 uv，天空盒的全部问题都解决了，天空盒没有任何拉伸扭曲等令人看起来不协调的地方，至于对称也说的过去，Shaun 个人感觉挺漂亮的 (￣▽￣)&quot;。自此天空盒的事就算是告一段落了。后记 做这个天空盒，确实花费了 Shaun 了不少力气，在做的那两天，满脑子都是为什么会拉伸扭曲，以及如何解决拉伸扭曲，最终想出了这套方案，简单优雅，最后的效果也是完美达到了 Shaun 的预期。不过一般人应该也用不到 Shaun 这套方案，这只是 Shaun 自己想做做而已，搞不出来没关系，搞出来当然是好的。]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows Terminal 尝鲜小记]]></title>
    <url>posts/a250bb21.html</url>
    <content type="text"><![CDATA[前言 Windows Terminal 正式版在两个月之前终于发布了，正好最近找了点时间尝尝鲜，感觉确实可以，Cmder 可以退休了。尝鲜篇 直接在 Microsoft Store 安装，顺便安装好 Powerline，执行以下三个命令：123Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUserInstall-Module -Name PSReadLine -Scope CurrentUser -Force -SkipPublisherCheck // 使用 powershell core 则必选然后执行 notepad $PROFILE ，在弹出的记事本中添加：123Import-Module posh-gitImport-Module oh-my-poshSet-Theme Paradox重启 terminal，若出现 “无法加载文件 ***.ps1, 因为此系统上禁止运行脚本”，则需要执行 set-executionpolicy RemoteSigned，使powershell 能顺利执行该脚本。 由于目前 Windows Terminal 不会自动注册右键快捷菜单，所以需要手动修改注册表，执行 mkdir &quot;%USERPROFILE%\AppData\Local\terminal&quot; 后，在网上找一个终端图标，命名为 wt_32.ico，将该图标复制到 %USERPROFILE%\AppData\Local\terminal 目录中， 新建 wt.reg 文件后直接双击执行，该注册表文件的内容如下：12345678Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]@=&quot;Windows terminal here&quot;&quot;Icon&quot;=&quot;%USERPROFILE%\\AppData\\Local\\terminal\\wt_32.ico&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]@=&quot;C:\\Users\\[user_name]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;其中 [user_name] 是使用者电脑的用户名，wt_32.ico 可以是随便找的一张缩略图，也可以直接用 icons - yanglr 中的 wt_32.ico。 为了简单美化一下 Windows Terminal 界面，需要安装 Cascadia Code GitHub releases page 中 Cascadia Code PL 或 Cascadia Mono PL 字体，Shaun 因为只是尝鲜所以就简单配置了一下：12345678910111213141516171819202122232425262728293031323334353637&quot;theme&quot;: &quot;dark&quot;,&quot;profiles&quot;:&#123; &quot;defaults&quot;: &#123; // Put settings here that you want to apply to all profiles. &#125;, &quot;list&quot;: [ &#123; // Make changes here to the powershell.exe profile. &quot;guid&quot;: &quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;, &quot;name&quot;: &quot;Windows PowerShell&quot;, &quot;commandline&quot;: &quot;powershell.exe&quot;, &quot;hidden&quot;: false, &quot;startingDirectory&quot; : &quot;.&quot;, &quot;acrylicOpacity&quot; : 0.00000001, &quot;colorScheme&quot; : &quot;Campbell&quot;, &quot;cursorColor&quot; : &quot;#00CCFF&quot;, &quot;fontFace&quot; : &quot;Cascadia Mono PL&quot;, &quot;useAcrylic&quot; : true &#125;, &#123; // Make changes here to the cmd.exe profile. &quot;guid&quot;: &quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;, &quot;name&quot;: &quot;命令提示符&quot;, &quot;commandline&quot;: &quot;cmd.exe&quot;, &quot;hidden&quot;: false &#125;, &#123; &quot;guid&quot;: &quot;&#123;b453ae62-4e3d-5e58-b989-0a998ec441b8&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Azure Cloud Shell&quot;, &quot;source&quot;: &quot;Windows.Terminal.Azure&quot; &#125; ]&#125;, 为了在 VSCode 中使用 Windows Terminal ，需要简单设置一下默认终端，首先将设置默认终端 &quot;terminal.integrated.shell.windows&quot; 注释掉或者直接不设置，添加设置：12&quot;terminal.external.windowsExec&quot;: &quot;C:\\Users\\[user_name]\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;,&quot;terminal.integrated.fontFamily&quot;: &quot;Cascadia Mono PL&quot;,如此可在 VSCode 中集成 Windows Terminal，并将其作为默认终端。后记 在这两三天的使用过程中，发现 Windows Terminal 和 Cmder 之间还是存在差距的（如在输入命令过快的时候，tab 键补全跟不上等问题），暂时就两者先并行使用一段时间吧，等后续更新巨硬修复这些问题，相信 Windows Terminal 是能代替 Cmder 成为 Windows 首选终端的。参考资料[1] 【避坑】PowerShell：因为在此系统上禁止运行脚本 附原因和解决办法[2] 新发布的Windows Terminal如何添加到右键菜单？[3] Setting Windows Terminal as Default External Terminal in Visual Studio Code]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读大学]]></title>
    <url>posts/ae5f9dce.html</url>
    <content type="text"><![CDATA[前言知识的积累如同滚雪球一般，越滚越大，越滚越快。 人类简史中，人类花了几万年的时间完成采集文明到农耕文明的过度，花了几千年的时间从农耕文明到工业文明，而工业文明短短几百年就过渡到现代信息化文明。而如今的时代，短短几年就会产生一些新的行业，有些能产生巨大的社会价值，而有些则会被人所遗忘，亦或过些年又卷土重来，潮起潮落，社会总是以一种加速递增的趋势在发展。志愿篇 大学就是普通人进入社会的一块敲门砖，一块垫脚石，进入社会多年之后，这块敲门砖还有多大的重要性，这就看个人的际遇了，但总的来说，这块敲门砖越厚重，进入社会的机会和选择就越多，相对来说越容易成功。虽说取得一定的成就之后，也就可以不在使用这块敲门砖，但对于普通人来说，这块敲门砖还是挺重要的，毕竟这块敲门砖将会陪伴绝大多数的普通人一辈子。 对一般人来说，进入大学唯一的途径就是高考，而高考完之后需要走填志愿……录取等一系列流程才决定是否能进入大学。高考志愿最重要的一个指标即是所在省的排名，全国各个大学在每个省的指标基本是不变的，所以排名直接决定能上什么样的大学，当然，因为各种各样的原因，每年总会有一批人上不了自己该上的大学，甚至落榜，也有一批人上了自己本上不了的大学，但对于一般人，排名是绝对的指标，只看这一个就可以直接在这一档挑选自己能上的大学了，剩下的就是专业了，一个学校的王牌专业一般会远远高出录取线，所以这就需要选择，是去好一档学校的“差”专业，还是去差一档学校的“好”专业（这个差和好并不是绝对的，都是相对该校的王牌专业来说），Shaun 的看法是如果是同一个专业，当然是去好学校的差专业，不同的专业则仁者见仁智者见智，没有可比性。之所以这么选择，是根据 Shaun 这几年在社会上的摸爬滚打，好的学校还是要香一点，而专业这种东西反正都是靠自己学的，大学上课的那些东西一般都只是入门课程，有的甚至连入门都够不上。当然，专业选择这种东西还有个小技巧，就是可以选择类似的专业，当自己想上的专业是好专业，自己的分数够不上，这时可以采用这种技巧，捡漏，因为有些人对专业不是特别了解，只死盯着那个专业，但其实两者上的课程差不多，一般来说，同一个学院的专业会存在类似的情况，而一个大的专业，类似的专业就更多了，像计算机专业，无论是搞硬件的搞软件的搞自动化的都能搞计算机。 专业重不重要？对于 90% 以上的人来说，专业还是重要的，确实也有一小部分人也可以完全抛弃大学时的专业，照样也能混的风生水起，这样的人当然是极少的。但对于一般人来说，专业相当于 4 年的积累，为步入社会打下基础，多年后或许会完全抛弃自己的专业，但那也是在社会上有了一定的积累之后，刚开始就抛弃这份积累，从事一份完全无关的工作，对一般人来说何其艰难。 至于专业选择重不重要，这就看个人了，在 Shaun 眼中，专业选择同样重要，因为专业基本就确定了职业和所在的行业，而行业是有贵贱之分的，虽说三百六十行行行出状元，但有些行业的状元就是比另外行业的状元强，甚至踏上这个行业就比有些行业的状元还要强，而且就算出状元，也轮不到一般人头上。像老师和医生这样的职业，天然的就比别的职业社会地位要高，在这娱乐至死的时代，像电影游戏直播偶像行业，90% 以上的资源就掌握在 1% 的人手上，极度不平衡，成不了这 1% ，都是炮灰。 在特殊情况下，行业这东西又显得不是那么重要，而运气和眼光相对来说更重要些，有句话叫：站在风口上，猪都能飞起来。09 年，智能机开始兴起，12年，随着 3G 的普及，移动互联网时代开始逐步走向高潮，而三年后，4G 的到来，真正将移动互联网推向高潮，这股高潮一直持续到现在，当然，由于这块蛋糕基本被瓜分完了，现在进场也吃不到什么肉了，除非有新点子或市场。这十年间，有多少企业只靠一个 APP 就做大做强的，又有多少企业因为没搭上这趟车而逐渐走向衰落甚至倒闭的。当然，Shaun 是有点反感移动互联网的，但奈何市场喜欢，资本喜欢。移动互联网的本质在于各家的资源掌握在自己手里，绝不分享，这对于互联网的发展并不是一个好的现象，也就直接导致了如今的中文互联网像一滩狗屎。遥想 09 年之前，中文互联网是何等的辉煌，各种想要的资源应有尽有，高质量的内容产出也层出不穷，是真正的我为人人，人人为我。现如今内容资源都掌握在各家平台手上，还无法直接在浏览器上通过网页获取，必须使用各家的 APP，APP 就算是一滩屎，用户也只能跪舔，不过这各种流氓行为，说到底也都是用户自己惯的。现如今，中文互联网高质量的产出不多了，大多都存在于非常专业创立时间长且不太知名人数不多的社区和论坛中。不得不说，中文互联网变成如今这个样子，百度有很大一部分责任，贴吧可以说是一个跨时代的产品，被搞得乌烟瘴气，以前的百度空间确实也有些高质量的内容，直接关闭。 扯远了扯远了 (￣ε(#￣)。热门行业从来都不是一层不变的，大学的专业也是如此（Shaun 本科读的那个专业已经换了个名字），甚至大学本身也是如此，分拆合并，过去二三十年时有发生。时代在变化，行业在变化，大学也在变化，唯一不变的是变化本身，为适应变化，学习思维才是个人的立身之本。学习思维这种东西，确实无法明说，只能说是为自己量身定制的一种学习感觉（Shaun 刚入大学时，还停留在小初高的那种学习思维，认为多看书，多做题多想就能学好，这样的思维学习像高数这种基础课程，确实没问题，但像编程这样的专业课，这一套思维则完全走不通，Shaun 觉得编程更重要的是一种手感和思维方式，多抄多改，多模仿好代码，手感自然而来，不会的，网上也一般都有直接或近似的解决方案，拿过直接改改使用，在改的过程中就锻炼了编程手感和思维方式，这种方式虽然原始粗暴，但却是一种通用的编程学习方法，使用好这种方法，本科的专业课一般也比较轻松，甚至以后在工作中，就算网上没有任何解决方案，也能凭自己的感觉和思考将代码写好，至于代码的组织能力，就又需要另一种学习方法了，总之编程这门手艺，实践才是王道）。Shaun 觉得国内小初高的教育锻炼的是做题和狭小的思考能力，而大学的工科更注重的是动手和广泛的思考能力（当然基础课程还是小初高那一套），这两种学习思维是存在差异的，并且可以说差异很大。大学时期的建立的学习思维将直接影响个人的一生，拿大学的那套学习思维虽然不一定能在社会上混得开，但一定能让人把本职工作做好。大学篇 真正进入大学后，就有很多可以选择的事了，可以天天划水摸鱼，东游西逛，也可以比高三还要辛苦，这都是个人的选择，都看个人的追求，没有纯粹的对错。 Shaun 的四年本科一直很平庸，没干过什么大事，也没干过真正的蠢事，只是干过一些糗事（刚进大学的时候以为还要去某个教室集合，但其实只要在寝室等通知就好，军训是可以装病休息的，没人会在意，就大一上学期有过一些，后面摸清大学的套路就没了），也没伸手要过啥 🙃，虽被人有说愤青，但没真正做过网络喷子（在网络事件中，事和人需要分开讨论，事可能是好事，但人不一定是好人，同样，事是坏事，但人可能是好人，况且，网络上，事可能事假的，人可能也是假的，只要有自己的见解和判断，就不会人云亦云）。四年本科，唯一让 Shaun 觉得有价值的东西并不是学校提供的什么环境，也不是老师朋友的教导和帮助，而是这段时间逐渐形成在网络上求知的那种思维，这种思维在 Shaun 的读研和工作生涯中给予了极大的帮助。除真正的科研问题之外，工作中碰到的其他问题总能按部就班的解决，剩下的无非就是熟练度而已。 一般人在大学中待得最久的一个地方可能就是宿舍了，所以和室友之间的关系尽量不要搞得太僵，自身最应该做的就是不卑不亢，当然，每个学校总是会存在一部分蠢货的，运气不好，宿舍正好被分到，此时更加不能卑，只要有理就可以随便说放手做。后记 志愿篇是写给别人的，而大学篇是 Shaun 顺带回忆的，毕竟硕士的回忆篇早写了，大学篇也来凑个数吧，但正如『头脑特工队』中痛苦的记忆更容易被回忆起来，而平淡的记忆将逐渐灰飞烟灭，所以大学篇就只能简单写写了。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019，既是结束又是开始]]></title>
    <url>posts/cf97ba7c.html</url>
    <content type="text"><![CDATA[人生总算是告一段落了，虽然没取得好成绩，但总归要奔向新的起点，迎接新的挑战。前言 回首 2019，告别了学生身份，迎来的新的称号——社畜。普通人进入社会也只能是社畜，一批又一批的供养着食物链上层的生活，虽然有社畜能升级，但任务完成何其艰难，材料获取何其艰难。好了闲话也不多说了，开始进入正题吧。结束篇 19 年，终于迎来了学生生涯的最后阶段，依稀记得，从开学到毕业一直过的十分焦虑，虽说论文的思路早已想通，实验结果也有了，只剩对比试验还没做，但每周一次的例会着实让人头皮发麻。依旧每周一次的批斗大会，自己的想法，写的东西，说的东西，在导师面前都是屁，纯粹就是想把学生批的体无完肤，以体现自己导师的身份和那一份仅有的优越感。日子就这样一周周过去，从论文写完到查重，从答辩完到走完所有毕业流程，虽然心理上的压力不小，但总算还是顺利毕业了。不管怎么说，能够顺利毕业总比跳楼的要好太多了，如果说这小硕读的值不值，对于 Shaun 来说，还是值的，虽然承受了莫大的心理压力，但总归还算是承受住了，真鸡儿痛苦，完全不想承受第二次，估计也不会有第二次了，如果真有，Shaun 估计会选择尽快逃脱远离。 再回首 2019 年上半年，却发现从年初到脱离学生身份这一段时间发生的事已经渐渐模糊了，痛苦的事有时会被人选择性的忘记，最终回归平淡，或许这就是历史总会重演的原因。 好了，结束篇就这样结束吧，多的也不写了，该写的东西也早已写完。开始篇 刚步入社会就被上了一课，在培训时闹钟设错了，错设为工作日闹钟，而培训在周末仍在进行，而且当天开始的非常早，所以当然迟到了。事后反思这事最好自己闷在肚子里了，不要提任何理由，因为没人会同情你，甚至会嘲笑你，迟到就是迟到，过程就是个屁，结果才是王道，只能从中吸取经验，下次再有类似的事还是设一次性的临时闹钟比较好。本以为迟到这件事就会这样慢慢过去，但在新人见面会上（老板会和每一批新人见一下面），有人为了表现自己特意和老板强调了一下，也是有意思，非蠢即坏，不知是老板贵人多忘事还是情商高，这件事就这么过去了。这事算是 Shaun 真正步入社会后上的第一课，所以还是写下来了，以后估计还是会被上一些课，只是有些是大课有些是小课罢了，从课中吸取经验，或许就是成长吧。 初当社畜，干的当然都是一些打杂的活，还记得，正式干活的第一个任务就差点没完成，由于学生时代一直在搞图像，而第一个任务却是图形中的问题，那个问题是 “3维场景中选择物体不准确”。从来没接触过的 3维 的 Shaun 当时连相机模型都不了解，更何况是实际项目中的问题，就牵扯的更多了，于是花了几天时间熟悉项目中整个选择流程及 3维图形的一些基础知识，终于在一周后成功修复了这个 bug，刚开始还以为是相机模型的问题，重写了一下相机模型，中间确实发现了一个矩阵乘法的问题，修复了之后，这个 bug 还是存在，相机模型没有任何问题，最后选择输出全部点的坐标，发现有些点的 ndc 坐标有异常，排除这些点之后，选择终于正确了，社畜生涯中的第一个正式任务也算是圆满完成。 再之后就是一些大大小小的新功能添加以及 bug 修复。两个月后，来了一个项目，需要为这个项目单独开发一些功能在已有的产品上，鉴于组里其他人都有各自的任务，这个项目就落到 Shaun 头上了，还好经过两个月的熟悉，对已有产品基本熟悉了，开发相关的新功能难度也不大，唯独有一个要求导致已有的产品需要进行架构升级，不然就没法满足该需求，不知为啥，这架构升级的工作也落到了 Shaun 头上，没办法，只能硬着头皮上了，强行分离了一些文件出去，搞了一周多，虽然出现了一些 regression，但好歹也算是升级成功，满足了甲方的需求，以 Shaun 当前的眼光看，当时架构升级还是存在一些问题，有些文件不该抽离的，但碍于当时自身的能力以及对整个产品的理解程度，能升级成功也还可以了，这种经验算是比较难得的。 之后继续添加功能和修复 bug，就这样顺利过完了 19年，社畜的半年时间，虽然还不够真正入门，但好歹也摸到了门槛，开始接触了一些社畜的规则。总结 学生身份终于彻底结束，最后的学生阶段是 Shaun 整个学生生涯最难受的一段时间，说不好也可能是整个人生最难受的时光，不过总算是过去了。踏足当下，回首过去，展望未来，从这半年的社畜生活看，真的很不错，比读书爽太多了，也可能是最后的学生阶段压抑的太厉害了，总之感觉很爽，同事和上司都还可以，最重要的是没有了任人宰割的感觉，真的很舒服 😊。19 年获得技能：社畜新手19 年获得成就：顺利毕业]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速判断三角形与长方体相交]]></title>
    <url>posts/ff29de94.html</url>
    <content type="text"><![CDATA[前言 一种快速判断空间中三角形与 box 相交的方法，出自论文：Tomas Akenine-Moller. Fast 3D triangle-box overlap testing. A. K. Peters, Ltd. 2002.预备篇 该论文的理论基础来自分离轴理论（separating axis theorem， AST），AST 常用于检测两凸多边形是否相交。一句话描述 AST 即为：若两多边形能用一条直线分隔开，则两多边形不相交。如何判断该直线存在即为 AST 的关键。常用的判断方法为找出两多边形所有边向量（多边形相邻两点构成的向量，顺时针或逆时针都行）的法向量，使用向量点积分别计算两多边形在各法向量上的投影（一般以多边形上的点和原点构成一个向量与法向量做点积），从而得到两个投影集合，判断两集合是否相交（找出两个集合的最大值和最小值，若最小值大于最大值，则不相交），若不相交，则 AST 中的直线存在，即两多边形不相交，若相交，则继续判断在其它法向量上的投影，若所有法向量上的投影都相交，则两凸多边形相交。AST 常用于二维下判断两凸多边形的相交情况，三维下的情况比较复杂。正文篇 该论文给定 13 个向量，若 box 的边和三角形的边在这 13 个向量中的投影均相交，则认为 box 与三角形相交。为简化运算，box 直接假定为轴向包围盒（axis-aligned bounding box， AABB），坐标轴原点为 box 中心，由于可以将普通 box 通过旋转平移等一系列变换，变成以原点为中心的 AABB， 所以该假定是有效的。设三角形的顶点为 \(v_0, v_1, v_2\) ，box 的一半长宽高为 \(h_x, h_y, h_z\) ，则这 13 个向量分别为 \(e_0(1, 0, 0), e_1(0, 1, 0), e_2(0, 0, 1)\) ，三角形的法向量 \(n\) （通过三角形两边向量叉乘得到），剩下九个向量分别为 \(a_{ij} = e_i \times f_j , i,j \in \{0, 1, 2\}\) ，其中 \(f\) 为三角形的边向量 \(f_0 = v_1 - v_0, f_1 = v_2 - v_1, f_2 = v_0 - v_2\) ， \(\times\) 代表向量叉乘。若直接这样一个个的计算投影是否相交，虽然能达到目的，但快速就无法体现了，所以作者根据向量计算方法和一些策略将其中一些需要计算投影的地方极大的简化了，所以加快的计算速度。具体简化过程为：首先来看最后九个向量，\(a_{00} = e_0 \times f_0 = (0, -f_{0z}, f_{0y})\) ，三角形三个顶点在在该向量上的投影分别为：\(p_0 = a_{00} \cdot v_0 = (0, -f_{0z}, f_{0y}) \cdot v_0 = v_{0z}v_{1y} - v_{0y}v_{1z}\)\(p_1 = a_{00} \cdot v_1 = (0, -f_{0z}, f_{0y}) \cdot v_1 = v_{0z}v_{1y} - v_{0y}v_{1z} = p_0\)$p_2 = a_{00} v_2 = (0, -f_{0z}, f_{0y}) v_2 = (v_{1y} - v_{0y})v_{2z} - (v_{1z} - v_{0z})v_{2y} $由于 \(p_0 == p_1\)， 所以在求最大最小值时只需要做一次比较，接着求 box 在该向量上的投影，box 中心在原点，所以投影半径 \(r\) 可以以一种简单的方式求出：\(r = h_x|a_{00x}| + h_y|a_{00y}| + h_z|a_{00z}| = h_y|a_{00y}| + h_z|a_{00z}|\)计算投影是否重合也很简单：\(if(min(p_0, p_2) &gt; r \ || \ max(p_0, p_2) &lt; -r) \quad return \ false\) 否则两者投影相交，继续计算其它向量。三个轴向单位向量 e 中的投影是否重合就更好判断了，完全不需要计算投影，只需要计算三角形的最小 AABB，判断两个 AABB 是否相交即可（取两个 AABB 最小的顶点和最大的顶点，从三维上判断最小是否的大于最大的即可，若任意一个维度上最小的比最大的大，则两者不相交），至于判断最后一个向量——三角形的法向量上的投影是否重合，相当于判断三角形所在平面是否与 box 相交。判断 box 与平面相交有一种简单快速的方式，即通过公式 \(|d| &lt;= a_1 |n \cdot A^1| + a_2|n \cdot A^2| + a_3 |n \cdot A^3|\) ，其中 \(d\) 为 box 中心到平面的距离（中心点到平面上一点构成的向量与平面法向量做点积），\(n\) 为平面法向量，\(A^1\) 为 box 侧面法向量，对于 AABB 可为 \((1, 0, 0)\)，\(a_1\) 为 box 中心到侧面的距离，对于 AABB 可为 \(h_x\)，同理 \(A^2\) 为 box 顶面法向量，对于 AABB 可为 \((0, 1, 0)\)，\(a_2\) 为 box 中心到顶面距离，对于 AABB 可为 \(h_y\)，\(A^3\) 为 box 正面法向量，对于 AABB 可为 \((0, 0, 1)\)，\(a_3\) 为 box 中心到正面距离，对于 AABB 可为 \(h_z\)，即在 AABB 中，该公式可简化为 \(|d| &lt;= h_x|n_x| + h_y|n_y| + h_z|n_z|\) ，满足该公式，即可判定平面与 AABB 相交。 如此 13 个向量全部判断完毕，如全都相交，则可认定三角形与长方体相交，若其中一个不相交，则三角形与长方体不相交。三维的都能判断，二维的三角形与矩形相交判断就更简单了，分成两类法向量后，利用向量运算先简化运算量，再计算投影是否相交即可。附录 还有一种根据距离判断两个 AABB 是否相交的办法，即先取两个 AABB 的中心 \((x_1, y_1, z_1)\) 和 \((x_2, y_2, z_2)\)，然后计算两个中心点之间的三个维度的距离，将 x 维度的距离与两个AABB 的 \(h_x\) 之和比较，若中心点 x 维度的距离较大，则不相交。即：\(if (|x_1 - x_2| &gt; h_{x1} + h_{x2}) \quad return \ false\) ，否则比较 y 维度， z 维度，若所有都小，则两 AABB 相交。这种方式是 Shaun 在一次面试中被问到没答出后在网上找到的答案，其实感觉和比较最小最大顶点也差不多，都是从不相交出发，因为直接判断相交基本不可能，而不相交很容易判断，把所有的不相交情况判断完，那就只剩相交了，可惜面试官只想要这种方案 ╮(╯▽╰)╭。参考资料[1] Code by Tomas Akenine-Möller[2] Simple Intersection Tests For Games]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>geometry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页菜单纯 css 实现]]></title>
    <url>posts/70a807da.html</url>
    <content type="text"><![CDATA[前言 最近搞了些前端的工作，本来做菜单栏的时候想直接用 bootstrap 的，但是感觉 bootstrap 太大了，而且依赖有点多，在 webpack 中也不是很好打包（虽然可以绕过去），所以就索性自己在网上找了一些实现方式，改改感觉也还可以。这次主要实现了两种菜单栏，具体如下。鼠标悬停下拉菜单 鼠标悬停下拉菜单应该是最常见的一种菜单栏了，当鼠标悬停在菜单栏上时，子菜单缓缓下拉，看起来就很舒服，用 flex 布局结合列表也很好实现（不用像以前那种 float 了，舒服）。具体实现方式如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; .flex-body &#123; display: flex; flex-direction: column; &#125; header &#123; z-index: 1; &#125; ul, ul li &#123; list-style: none; margin: 0; padding: 0; &#125; .menu &#123; display: flex; justify-content: start; &#125; ul li &#123; width: 100px; height: 50px; line-height: 50px; &#125; .menu li .submenu &#123; /* display: none; */ background-color: aqua; &#125; .submenu li &#123; height: 0; line-height: 0; opacity: 0; visibility: hidden; &#125; .menu li:hover .submenu li &#123; /* display: block; */ height: 50px; line-height: 50px; opacity: 1; visibility: visible; transition: all 1s; &#125;&lt;/style&gt;&lt;div class="flex-body"&gt; &lt;header&gt; &lt;ul class="menu"&gt; &lt;li&gt; &lt;a&gt;menu1&lt;/a&gt; &lt;ul class="submenu"&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;menu2&lt;/a&gt; &lt;ul class="submenu"&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a&gt;menu3&lt;/a&gt; &lt;ul class="submenu"&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;submenu1&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;main&gt;mainmainmainmainmainmainmainmainmainmain&lt;/main&gt;&lt;/div&gt; ※注： 实现该菜单栏有两个需要注意的点：1、不能用 display: none 和 block 来使子菜单消失或出现，因为这样会造成缓缓下拉的动画失效，transition 并不支持 display，所以只能用 visibility 和 height 来共同实现，以达到下拉动画效果；2、因为使用了 flex 布局，所以 z-index 只对同级 flex-item 有效，所以为防止菜单栏下面的内容出现在子菜单之上，即将子菜单栏位于最上层，需要将整个页面的布局都设置为 flex，并使 header 的 z-index 最大，如此才能保证子菜单的菜单覆盖 main 中的内容，不然就会有重叠干扰现象。鼠标点击手风琴菜单 手风琴特效也算是非常常见的了，一般的手风琴是鼠标悬停展开，这种比较好实现，难的是如何保持这种展开状态，focus 可以短暂保持展开状态，但是不能点击其他地方，局限性太大。所以需要引入其它的东西来记录这种展开状态，可以用 checkbox 或 radio 的 checked 来记录这种状态，从而只用 css 即可实现该菜单，具体实现如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style&gt; input[data-prop="menu-recorder"] &#123; display: none; &#125; .menu-title &#123; display: block; width: 500px; height: 50px; line-height: 50px; border: 1px solid black; &#125; .menu-content &#123; width: 500px; max-height: 100px; overflow-y: auto; &#125; .menu-content&gt;li &#123; height: 0; line-height: 20px; overflow: auto; opacity: 0; visibility: hidden; transition: all 1s; &#125; input[data-prop="menu-recorder"]:checked+.menu-content&gt;li &#123; height: 20px; line-height: 20px; opacity: 1; visibility: visible; transition: all 1s; &#125;&lt;/style&gt;&lt;div class="accordion-menu"&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu1"&gt;menu1&lt;/label&gt; &lt;input id="menu1" type="checkbox" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu2"&gt;menu2&lt;/label&gt; &lt;input id="menu2" type="checkbox" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu3"&gt;menu3&lt;/label&gt; &lt;input id="menu3" type="checkbox" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu4"&gt;menu4&lt;/label&gt; &lt;input id="menu4" type="checkbox" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 这里需要注意一点的就是 height 从 0 到 100% 并不会触发 transition 渐变动画，而是需要确切的高度值变化才能触发，所以上文这里添加了个 &lt;li&gt; 标签，直接在该标签上添加动画，还有一种就是在 .menu-content 上设定确定的 max-height，也能触发动画，但是有个缺点就是前后 max-height 的差距太大时，动画效果就很不理想了，这时可能只能依靠 js 了。上文中 checkbox 也可用 radio 替换，效果略有差异，一个是能全部展开或收起，而另一个则是能且仅能展开一个。Tab 标签页切换菜单 这个菜单和上面那个菜单的实现非常相似，先上代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495&lt;style&gt; .tab-menu &#123; display: flex; position: relative; width: 500px; height: 300px; &#125; input[data-prop="menu-recorder"] &#123; display: none; &#125; .menu-title &#123; display: block; width: 100px; line-height: 50px; text-align: center; border: 1px solid black; border-right: 0; box-sizing: border-box; transition: all 1s; &#125; .tab-menu .menu-item:last-child .menu-title &#123; border-right: 1px solid black; &#125; .menu-content &#123; position: absolute; left: 0; top: 51px; height: calc(100% - 50px); overflow-y: auto; width: 100%; border: 1px solid #000; box-sizing: border-box; font-size: 24px; text-align: center; opacity: 0; visibility: hidden; transition: all 1s; &#125; input[data-prop="menu-recorder"]:checked+.menu-content &#123; opacity: 1; visibility: visible; transition: all 1s; &#125;&lt;/style&gt;&lt;div class="tab-menu"&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu1"&gt;menu1&lt;/label&gt; &lt;input id="menu1" type="radio" name="tab-control" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu2"&gt;menu2&lt;/label&gt; &lt;input id="menu2" type="radio" name="tab-control" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu3"&gt;menu3&lt;/label&gt; &lt;input id="menu3" type="radio" name="tab-control" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class="menu-item"&gt; &lt;label class="menu-title" for="menu4"&gt;menu4&lt;/label&gt; &lt;input id="menu4" type="radio" name="tab-control" data-prop="menu-recorder"&gt; &lt;div class="menu-content"&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;li&gt;test&lt;br&gt;&lt;/li&gt; &lt;/div&gt; &lt;/section&gt;&lt;/div&gt; 从代码上看关键点就是 .menu-content 的定位方式了，采用了绝对定位，并将整个菜单栏设置为相对定位，以保证所有 tab 标签页内容位置和大小保持一致。当然 tab 标签页肯定是唯一的，所以只能用 radio 记录显示标签页了。其中为了保证 .menu-title 和 .menu-content 的边框不重叠，所以在 .menu-title 中只设置 line-height，而 .menu-content 的 top 比其多一个像素。后记 这三种菜单应该是最常见也是用的最多的了，纯 css 实现的方式也比较类似，无非就是 flex 布局以及借助 css3 强大的选择器功能（父类选择器不知要到猴年马月了，比较遗憾 😥），就能相对简单的实现了，当然借助一些 js 库或框架可能会更简单一些 ，但能用 css 为何不用呢 😄。参考资料[1] 利用flex实现的二级导航栏[2] CSS3动画下拉菜单（当transition遇到display的坑）[3] CSS3手风琴下拉菜单[4] 教你两招用纯CSS写Tab切换]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人游记]]></title>
    <url>posts/abe58f8c.html</url>
    <content type="text"><![CDATA[简单的记录一下个人游记吧。张家界两日游前言 端午节前一个星期，正好也做完了人生中的一件大事，遂和小伙伴们来了场说走就就走的旅行，也是 Shaun 人生中第一次正式旅行吧，直接定好晚上的火车票，睡一觉，到张家界的时候正好是中午。旅程篇第一天下午 在火车站附近简单的吃了个三下锅，就 Shaun 感觉是个大杂烩，里面就是些很常见的菜混合在一起，当然也可能吃的不正宗，然后决定先去天门山，在美团上看票，发现需要提前一天，于是决定直接去售票处买票，去的过程中差点被无良司机坑了，就几百米的路还要收 10 块钱，幸好问了饭店老板，知道直接去索道公司买票就行，地图搜索，买票点离火车站就几百米，遂一行人步行过去，到索道公司的时候发现这里的票价和美团上的价格是一样的，不亏，于是选了A线：索道上山，大巴下山，由于时间关系，只走了天门山的 3/4 吧，基本算是匆忙转了一圈，顺便花 5 块钱走了下西边的玻璃栈道，说实话对玻璃栈道还是挺失望的，由于走的人太多了，玻璃表面都磨花了，下面的景色看不清楚，刺激感也少了许多，5 点半左右，快下山的时候，突然下起了大雨，此时走步行的天梯下天门有点危险，不得已只能每人花 30 块钱坐电梯（这是在天门山游玩花的最不值的一笔钱 (╯‵□′)╯︵┻━┻），因为在下山到天门的那一段路就是一段很长很长的山内电梯，这种感觉已经体验到了，到时步行下天梯的感觉想尝试一下，奈何天公不作美。等到完全走完电梯的时候，开始上巴士，天门山的雨又停了，也是醉了 😓。接下来，就是 Shaun 坐得最爽的一次巴士了，秋名山和天门山的天路简直不是一个档次的，五连发卡弯和天路相比也不算什么，这里的盘山公路从索道上看起来非常漂亮，但真正坐巴士在盘山公路上走的时候，就会发现，巴士司机才是真正的车神，这车坐的可以说是非常刺激了。第一天晚上 走了一下午路，人都疲了，就在市区吃了个自助餐，也不好吃，随后讨论了下第二天的行程，由于时间关系，张家界大峡谷（有玻璃桥的那个景区）和张家界的武陵源（最大最有名的景区） 只能选择去一个了，考虑到张家界大峡谷离市区太远而且没去武陵源何谈到张家界玩，所以最终选择了武陵源，武陵源的门票有 3 天的有效期（可以游玩三天，后面进景区发现，若真要慢慢游玩，3 天还不一定能玩完），因为这景区非常大，所以还有年票卖 😂（一年的有效期）。于是当晚吃完饭就联系了个武陵源景区附近的一个客栈，顺便让客栈的老板叫辆车接我们过去，到客栈的时候都已经11点了，客栈老板问了下我们的时间安排，于是给我们安排了下游玩路线，老板顺便做起了导游的生意，由于我们人多，老板就没另收导游费了，因为当地人买索道票价格是半价的，所以这足以让老板赚上一笔，谈好生意后，就洗澡睡觉了。第二天全天 因为和老板约好几点去买门票，所以就大早起床了，顺便买了些午餐，因为中午肯定还在山上，没记错的话，武陵源景区共有3个索道：黄石寨索道、杨家界索道和天子山索道。其中黄石寨索道可坐可不坐，如果准备一天的时间玩黄石寨可以不坐索道，徒步也行，但杨家界索道必须得坐，因为这是去杨家界的必经之路，徒步是到不了的，当然可以也可以在景区外包车去杨家界，因为徒步基本不可行，所以老板就推荐我们坐索道上去，然后包车下来，这样更划算一些（我们人多），车也是老板帮忙叫的，由于选择了包车下来，所以也就没坐天子山索道了，因为天子山索道比较特殊，它的索道下站是在景区外面，到时又要打车到客栈。老板让我们在景区门外一个地方买完门票之后（导游可以便宜几块购买门票），拿着门票就进进去了，第一个地方去的地方是黄石寨，由于赶时间所以买了双程票，索道上和索道下，大约玩了黄石寨 1/3 的地方，就下来了，又坐景区大巴赶往杨家界索道，坐索道去杨家界，主要看了个个天波府，然后坐景区大巴去袁家界，看了天下第一桥和阿凡达的取景地，最后坐大巴去了天子山，天子山上的天子阁我们刚到的时候正好关门 😔，没办法只好去贺龙公园下的观景台了，但是时机也不好，看不到云海，只能看看石柱山了，看完之后，天色也不晚了，老板也催着我们赶快坐车回去了，包车的那人在等了。虽然坐了索道，但还是走了一天，全员都乏了，不想去第三天的金鞭溪了，但是好不容易出来一趟，又硬着头皮上了。第三天上午 本来老板说好的提前两小时带我们进景区，游完金鞭溪还能去看看十里画廊，但因为一些小插曲，我们最后还是只能准点进景区，搞得我们在外面冻了半个多小时（那天早上很冷），我们徒步金鞭溪，以为会有景区大巴回到起点，但是没想到，我们走了一上午走完金鞭溪，发现前头确实有个景区车站，但是不能直接到我们来的那个起点，可能要绕很长一段距离，基于这些不确定性，最终还是决定原路返回，加快速度也要走近两小时，本来就已经很累了，这非常难受了，但没办法，定的火车票就在下午，周一还要赶回去上班 /(ㄒoㄒ)/~~。最后还是比较顺利的坐上了景区到火车站的中巴车，顺利的赶上了火车。感想篇 这次游玩张家界，感觉天门山虽小，但是比武陵源好玩多了，主要是武陵源的山千遍一律，黄石寨就围绕一座山有几十个景点，也是绝了 🙄。杨家界的天波府虽然难上，但上去还是很值得的，袁家界的猴子很多，运气好的话，能看到猴子在树上跳来跳去的，就像杂耍一样，袁家界比杨家界要更值得一去。天子山其实就一个观景台够看，但也要好时机，如果有云海的话相信是武陵源最漂亮的一个景点之一。在袁家界有个比较坑的产品，叫 把你的名字用一幅画写出来，那个人在我们外行人眼里看来还是很厉害的，边画的时候还会说很多吉祥话，这幅画只卖 5 块，怎么样，还是很值得吧 🙃，但是等画完之后，那人会叫你去后面胶缝，不然就花了嘛，胶缝 20 多块，但是不胶缝，5 块钱就白花了，这要明说还好，毕竟这手艺应该也值这价，但这样暗地里搞事就很没意思了。还有一种晶莹剔透的粉色水果，看起来非常漂亮，说是张家界的特产，但是很贵，Shaun 就只能远远的看着，后面查了下发现这就是传说中的金西梅 (¬◡¬)✧。后记 总而言之，张家界还是挺值得一去的，就是要规划好路线和时间，一天半的时间，武陵源景区大概只玩了 1/2 不到，还是算走的快的了 ( ╯□╰ )。其实原来不去黄石寨的话，直接去杨家界，然后坐天子山索道下来，再坐景区大巴到金鞭溪和十里画廊的交界处感觉会更好些。桂林两日游前言 人生终于告一段落了，要开始新的阶段了，于是决定趁着退休前的最后一次真正意义上自由自在的长假出去玩一下，虽然想玩的想法早就有了，但一直没想好去什么地方，邻近放假前两天才想好去桂林，于是匆忙查了下桂林的景点以及买了火车票，简单的规划了一下路线，就出发了，剩下的到了桂林再说。旅程篇第一天上午 前一天晚上在上火车的时候就决定先去阳朔玩玩，于是就在 X团 上买了桂林到阳朔的船票，晚上的时候，旅游公司打来电话确定明天的接送大巴地点和时间，正好是早上的时候到桂林，也能赶上接送大巴，所以就决定坐他们的大巴去码头坐船了，在等大巴的时候，顺便花 5 块钱吃了正宗的桂林米粉以及在虞山公园里转了一圈。等到坐上大巴的时候，导游开始推荐特色食物了，先是试吃环节，可是 Shaun 就一个人去玩，导游就直接把 Shaun 忽略了，独游没人权吗？连个试吃的机会都不给 😥。送到码头之后，导游帮我们把船票取了，上了船之后，这船坐起来还行，比 Shaun 以前在宜昌去三峡坐的船确实要好很多，在没坐船之前，导游一直在推销升舱，即从一楼升到二楼，到了船上之后，发现一楼和二楼没什么两样，无非就是二楼更高一点，但要看到好点的景色还是要到三楼甲板上，当然二楼甲板也能看，游客能随便选择去哪，所以升舱的意义确实不大。经过近四个小时，船终于到了阳朔，这中间主要是看了下漓江周围的山，最有名的应该就是 20 元人民币的背景和九马画山了，至于漓江的水，由于去的时机不对，没法看。第一天下午和晚上 本来第一天下午的行程没想好，后来坐大巴到码头的时候听到导游说，他们下午会去银子岩，于是 Shaun 也就到美团上买了阳朔到银子岩的票，于是下午中午到了阳朔时就坐大巴跟随另一个导游去银子岩，同样导游在车上也推荐了同样的食品，这次到没有忽略 Shaun，还是给试吃了下，味道也还行，就是太贵了，后来 Shaun 偷偷的在淘宝上搜了下，淘宝上的价格和导游给的价格一样。经过近一个小时到了银子岩，银子岩这个景点其实不归阳朔管，属于另一个县，本以为在山洞里会凉爽一些，但可能是由于人太多了，也可能是当天的天气原因，导致里面比外面还要闷热，幸好里面有很多台风扇，不然真有人可能会在里面中暑了，里面的景色确实还可以，灯光打的也不错 ๑乛◡乛๑。银子岩有着和张家界同样的套路：一样的金西梅，一样的名字作画，也是有意思。 从银子岩出来再坐原来的大巴到阳朔，在车上用飞猪定了个青年旅社，于是到阳朔的时候，就直奔那个青旅了，把背包放下，出去吃了个简单的晚餐，在回到青旅小睡了下，时间正好来到了晚上 8 点，可以去逛逛大名鼎鼎的阳朔西街了。来到西街，如果说白天的西街是死的，那么晚上的西街就是活的，这差距太大了，可能同样是时机不对，并没有出现人挤人的情况，但里面的人还是很多，歪果仁也不少，酒吧里的小姐姐也很可以。逛完阳朔西街给我留下最深印象的就是音乐喷泉的老板很有意思，很会招揽顾客，又不至于让顾客下不了台，就图个乐呵；比较后悔的就是没有拍一个陈文令的雕塑，主要原因是当时进西街的时候，就看到个小红人，以为就是个很普通的雕塑，根本没预料到这种雕塑遍布西街，是一个系列，所以就完全没有拍照的想法，又加上后面再看到的时候，感觉前面的都没拍，所以这个也就不拍了，导致一个都没拍，包括那些克苏鲁风格的也没拍。从西街回到青旅，已经快 11 点了，于是赶忙准备下明天的行程，在美团上看了下，就决定直接报个完整的跟团游，首先去十里画廊，再去遇龙河漂流，最后去世外桃源。下了单之后，就简单的洗了个澡睡觉了，毕竟逛了一天也累了。第二天白天 跟随这次旅途中的第三个也是最后一个导游，先坐大巴来到了十里画廊，导游在大巴上告诉我们，吃啤酒鱼就要去西街上装饰最好的地方去吃，那样才能彰显自己的壕气 ๑乛◡乛๑，导游还告诉我们今天到十里画廊的朋友坐了全世界最贵的一趟的大巴，仅 20 分钟的路程就要 60 块，因为十里画廊是不要门票的，就只要花 20 块钱买张公交通票就行，哭唧唧 (ノへ￣、)，到了十里画廊，导游帮我们买好通票之后就带另一批人去往银子岩了。Shaun 就坐着十里画廊景区内的公交到处逛了，十里画廊景区还是很大的，远不止十里，那天的天气去十里画廊正好，阴雨朦胧，景区内的月亮山雨雾缭绕，十里画廊周边的景区都是要另外算钱的，而且由于时间关系，所以 Shaun 就也就没进去了，简单的坐车逛了下十里画廊，回到和导游约定地点的时候，已经中午12点，于是导游把我们拉到了一个饭馆吃饭，导游先征求了下我们的意见是吃团餐还是独自解决，因为 Shaun 就一个人，所以还是想跟着大家吃团餐的，但是由于队伍里有一家人共十几个，他们一投票，自然是独自解决了，于是 Shaun 只能和别人搭伙了，于是就吃了顿又贵又难吃的午餐，搭伙的人点菜品味太差劲了，尤其是点了个什么野菜，那还真是野菜啊，就是一个像蒲公英一样的植物，那在 Shaun 老家可是真正的猪食 🤮。 吃完饭就去遇龙河了，但由于当时的天气，导游就预测今天应该是不能漂流了，因为头天晚上下了很大的雨，由于一些原因，导游也不确定是否能漂流，所以他还是带我们先去遇龙河看一下到底能不能漂流，等到了遇龙河，发现果然漂不了，于是导游带着我们徒步了遇龙桥，幸好漂不了，不然 Shaun 还得找人一起搭伙去漂流，因为如果没有两个人一起漂，就得还补一张票，80 块，这 tm 什么鬼，第一次听说有这种情况，来旅个游还必须偶数个人，要是游乐场敢这么搞，早关门倒闭了了，在张家界坐索道的时候也没听说过要把缆车里的人全部坐满，要不然要补票的，这遇龙河真 tm 坑，真的是幸好不能漂。听导游说好像是由于遇龙河以前出过一些事，后面就由上头接管了，所以情况就是这么个情况了。 既然没法漂流了，徒步过遇龙桥之后，导游就带我们去世外桃源了，据导游说世外桃源是当年一个台湾人在这边玩想方便却没有厕所，于是这人就在这里方便一下，方便完之后发现这里景色不错，于是为方便后来人，就在这修了个厕所，顺便圈了块地作为景点 。世外桃源主要是坐船玩，岸上确实没什么好玩的，在坐船的过程中，有一处确实有桃花源记描述的那样，还在出口处搞了些塑料桃花，船上的导游小姐姐说这是四季桃花 ๑乛◡乛๑ 。游玩世外桃源之后，就开始返程了，导游给了两个选择，一个是返回阳朔，另一个是直接返回桂林，Shaun 感觉在阳朔这边也玩够了，于是就回到了桂林，正好游游两江四湖的夜景。第二天晚上 回到桂林，大巴正好带我们到象山公园附近，本以为在外面也能看到象山，但是周围都被封的严严实实的，就算没有树遮住的地方也会被人工挡住，或许越没有料就越要遮严实点，象山公园的门票又是老贵了，就为了看个象山实在是不值得，而且那天漓江的水还是浑的，所以就只在远处远远的望了下象山。两江四湖最有名的景点当属日月双塔，而这个景点在晚上看更合适一点，又是免费的，所以 Shaun 在远望象山之后就直接去了日月双塔，在晚上灯光的照耀下，日月双塔确实非常漂亮。看完日月双塔，也算是满足了，就决定真正返程了，买好火车票之后，在火车站旁定了个旅馆，简单的洗洗睡了。感想篇 桂林总的来说要比张家界好玩一点，毕竟有水，而张家界只有山，但是由于 Shaun 去的时机不对，前几桂林正下大雨，漓江的水位上涨，又很浑浊，所以没看到好水还是有点遗憾的。至于景点，银子岩就真是景如其名，景区里面的东西就和银子有关，什么都能牵扯到钱，这也太俗了，Shaun 就想玩玩，谁管赚钱还是花钱（主要是 Shaun 没钱，看到这些虚假的钱就有点烦 ╮(╯▽╰)╭）。十里画廊是免费的，可以随便游玩，里面的景色其实还算可以了，不过周边单独的小景点都是要收费的，而且价格不菲，有些就是度假村一样的地方。至于西街，说实话如果没有那么多酒吧，那么西街应该就是条比较普通的小吃街了，和普通的小吃街一样，里面的东西一般很贵而且不一定好吃。遇龙河，应该最可惜的了，本来 Shaun 已经找到了搭伙人，但是不能漂也是没办法了，算是一个遗憾了，里面公厕据说是收费的，连导游都不放过。如果在世外桃源里不坐船的话那还不如不进去，感觉整个世外桃源的看点都在燕子湖上了。再谈谈桂林市区吧，整个桂林市区给 Shaun 留下的影响极差，Shaun 再桂林市走的时候刚好下过一场大雨，这时桂林市区遍布雷区，下面的铺的地砖基本都是坏的，如果不小心踩到一块中空的地砖，那么恭喜你，该洗鞋洗裤子了，地砖里藏得的脏水会全部溅到裤脚上，那脏水也有很多时米粉店里倒出来的水，又臭又油又脏，城市路面基建也太差劲了，作为一个旅游城市这太不应该了。象山公园的主要一个看点就是象山，但为了尽量不让外地人看到，就圈了超大一个地方作为象山景区，景区内除了象山感觉就没什么好看的了，不过也正好多收点费，一举两得啊，能想出这个点子的人真是个人才啊，希望桂林市多出点这样的人才，努力创收。在最后一个导游那里得知市区里面有个叫 小老弟 的面馆，那里面的米粉非常好吃，但只有早上有，下午就卖其它的小吃了，Shaun 就要走了，所以就没有这个口福了。后记 桂林还是很值得去的，主要是一定要选择个好季节和好天气，Shaun 去的时候天气非常热，完全不想出去的那种，所以就只玩了两天，天气不好，出去太累了。桂林的景点非常分散，小景点太贵且又不值得去，所以 Shaun 这次就尽量选择了报团，因为交通出行确实很是个问题，其实如果第一天下午不去银子岩，而是先去十里画廊的话应该就比较完美了，十里画廊和西街挨得很近。切记：如果要去遇龙河漂流的话最好选择偶数个人去桂林。南通一日游前言 堂哥在南通结婚，Shaun 这边离南通不远，所以去吃了酒席，第二天顺便在南通玩了一天。旅程篇 这一天主要在濠河风景区逛了一天，看了看南通的老建筑和濠河，一天的时间把整个濠河风景区逛个七七八八也没问题。感想篇 南通的人不多，也不算是个旅游城市，所以在濠河风景区瞎逛很悠闲，散心很舒服，濠河里的乌龟很多，巴西龟和草龟都有，白天会跑到岸边芦苇丛晒太阳，然后就被抓了。濠河风景区的历史街区比北京的八大胡同要有味很多，有兴趣的推荐尽早去看看，不然改造后可能就没味了。后记 南通人很少，只要不去市中心的商业街，主要专门来旅游的人不多，所以有想出去看看，散心的人可以去南通，沿着濠河走，会感觉很舒服。杭州两日游前言 Shaun 出去玩一般是心血来潮，临时起意，不会刻意做很多安排，清明时感觉闲着也是闲着，遂萌发出去杭州的想法，于是开始买票，没想到好几十躺车都卖完了，最后还好抢到了一发站票。旅程篇第一天下午 从火车站出来，直接坐地铁到凤起路，此时已经下午两点了，从凤起路出来沿着西湖边走到断桥，经过断桥沿着孤山路走，又返回西湖边去苏堤，走完苏堤全程，天已经快黑了，于是订了个青旅，直接订了两天，100 块一天，相对来说较贵，想着反正不急去青旅，就还是在西湖边继续逛了，雷峰塔夜晚的灯光也还不错，晚上的西湖也只能看灯光了。第二天 感觉好像今天就能回去，所以和青旅前台说要退一天，前台说要和 MT 联系（因为是在 MT 上订的），于是联系 MT 客服说要退一天，客服说要走下流程，四个小时内给回复，但后面四个小时过去了没有任何回复，查了查网上正好也有这样的事（MT 卡着不给处理，结果到下午 6 点，这一天不能退了，客服才回复），于是把网上别人的投诉信息直接发给了 MT 客服，客服这才开始处理，MT 真的垃圾，青旅都同意退了，结果卡在 MT 这里，以后应该都不会用 MT 订房间了。 由于住的青旅离钱塘江不远，于是决定沿着钱塘江走走，后发现一辆共享单车，遂骑着自行车一直到钱塘江大桥，沿着之江路到五云山，沿着进五云山这条路去龙井村，到九溪烟树就只能下车步行去龙井村，停车时需要注意，九溪路是禁停区（别问 Shaun 是怎么直到的，九溪烟树这个景点，在 Shaun 看来绝对是可以进西湖边全部景点前三的，从九溪烟树到龙井村就全是石子路了，这里的水非常清澈，人也不算是很多。之后从十里锒铛上山，看周围的茶园，爬天竺山，从十里锒铛去天竺山的路比较隐蔽，就是一条非常普通的山路，不是石板路，很难走，下山的时候也走了条户外拓展的路，非常陡，还摔了一跤，下来之后，腿都有点发抖，太久没爬山了。从山上下来，沿着天竺路一直走到三生石，原以为能直接上飞来峰，没想到路被封死了，查了下才直到需要门票，三生石那里有株藤曼很特殊，也很漂亮，乍一看还以为它身上的花是假的。从三生石出来后，已经是下午 3 点多了，想着西湖好像还有杨公堤，于是坐车去杨公堤，这段路如果能找到自行车，最好骑自行车过去，骑车绝对会比坐车快，这里的 1314 路车，绝对是 Shaun 坐过最挤的车，车内挤车外堵，这交通状况也是绝了。下车后沿着杨公堤两边走，走到尽头，这次的西湖之旅也到尽头了。于是把车票改签，坐公交去火车站，这又让 Shaun 见识到了杭州的整个公共交通运输系统有多烂，从西湖出来到火车站，最后预留地图软件上两倍的时间，不然很大概率会错过火车，最好是直接打车。感想篇 西湖的景色还是可以的，如果不考虑人那么多的情况，于 Shaun 而言，九溪烟树，龙井村十里锒铛都是远比西湖本身更值得玩的地方。西湖基本都是免费的，趁工作日的时候请假去散心算是个不错的选择，至于周末和节假日最好还是算了。最让 Shaun 觉得很不舒服的一点就是杭州的整个公共交通运输系统，可以说是稀烂也不为过，公交志愿者也是些垃圾，一座本身人口就上千万，又是个旅游城市，景区周围和市中心的交通系统在节假日和周末可以说是瘫痪的，在杭州有幸能见到比上海南京路步行街如外滩的人还挤的地方，近些年居然没出事也是奇怪，希望以后能针对性改善一下吧。Shaun 反正再也不会节假日去杭州了。后记 西湖还是比较值的去玩的，前提是工作日请假去，节假日和周末就最好不要去了，西湖周边两天差不多能逛完，Shaun 这次没去拱宸桥，不知道那边怎么样。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-chi主题更新小记]]></title>
    <url>posts/26d437be.html</url>
    <content type="text"><![CDATA[前言 Chi 主题的大体结构功能算是写完了，但是还有一些个性化的东西需要添加，所以以后有关于 Chi 主题更新的部分就都写在这里吧。但是由于是 Shaun 个性化定制的一些东西，所以如果不是大 Bug 或大优化的更新，一般就不进 Chi 主题仓库 中了。功能篇1. 脚注提示功能功能描述： 鼠标悬停在脚注上即可显示对应脚注内容。 Shaun 的脚注由于是采用 pandoc 渲染的，所以也是属于个性化定制，就不将这个功能放进 Chi 主题仓库中了。解决方案： 还是利用 Bootstrap 的 tooltip 提示插件，具体实现代码如下：1234567$('a.footnote-ref').each(function (index, elem) &#123; let post_id = $(this).parents('article').attr('id'); let fn_href = $(this).attr('href'); elem.setAttribute('data-toggle', 'tooltip'); elem.setAttribute('data-html', 'true'); elem.setAttribute('title', $("#" + post_id + " " + fn_href).html());&#125;);遍历脚注，先获取文章 id，再获取对应文章下的对应脚注内容，使用 tooltip 提示。Bug 篇1. 图片没居中问题描述： 上次那篇翻译的文章有几张图片，在放置的时候发现图片没有居中，查看代码后发现居中样式没写，但由于其图片标签 &lt;img&gt; 是放在一个 &lt;figure&gt; 标签中，由于不确定是不是 pandoc 渲染的问题，所以就没将这个修正放进 Chi 主题仓库中了。解决办法： 在 style.styl 文件中添加样式：123figure &#123; text-align: center;&#125;即可让图片居中。动画篇1. 鼠标跟随动画 其实一直都想把『奥日与黑暗森林』中的鼠标轨迹特效移植过来，但是苦于水平有限，一直没法做到，恰好 19 年 StackOverflow 的愚人节彩蛋中有个鼠标跟随动画很有意思，有好事者还专门将该彩蛋做了个脚本：Will there be an option to permanently keep this year’s April Fools design active? 。查看代码，知道实现原理后，发现用 jQuery 和 CSS3 实现一个类似的效果也不算很难，于是 Shaun 就尝试做了一下，并简单的美化了一下，感觉效果还行，就加到自己的个性化主题上了。至于在 Chrome 中的小尾巴和 Firefox 中的卡顿现象，是 Shaun 故意的，因为 Shaun 觉得这个小尾巴很有意思，从这个动画看，Chrome 确实比 Firefox 要流畅一点。最终实现代码如下：css 代码：123456789101112131415161718192021222324252627282930.cursor-trail--item &#123; display: inline-block; line-height: 1px; position: fixed; pointer-events: none; touch-action: none; z-index: 9999999; will-change: transform; font-size: 10px; color: rgba(186, 227, 240, 0.1); text-shadow: 0 0 2px #6CC2F8; -webkit-animation: cursorTrail 0.9s ease; animation: cursorTrail 0.9s ease;&#125;@keyframes cursorTrail &#123; 0% &#123; opacity: 1; &#125; 20% &#123; opacity: 0.5; transform: scale(5); &#125; 100% &#123; opacity: 0; transform: translate3D(0, -20px, 0) scale(1) rotate(90deg); &#125;&#125;js 代码如下：12345678910111213141516171819202122232425262728$(document).on('mousemove', function (e) &#123; e.preventDefault(); if (this.time &amp;&amp; (Date.now() - this.time) &lt; 16) return; this.time = Date.now(); let trail_character = '•'; let mouse_x = e.originalEvent.x || e.originalEvent.layerX || 0; let mouse_y = e.originalEvent.y || e.originalEvent.layerY || 0; mouse_x = mouse_x + 20; mouse_y = mouse_y + 26; $('#cursor-trail').append( '&lt;span class="cursor-trail--item" style="left:' + mouse_x + 'px;top:' + mouse_y + 'px;"&gt;' + trail_character + '&lt;/span&gt;' ); $('.cursor-trail--item').each(function () &#123; let item = $(this); setTimeout(function () &#123; $(item).remove(); &#125;, 900); &#125;);&#125;);若不要小尾巴，则只需要将移除元素的时间改快一点就行了，除开上面的代码，还需要在 html 页面中添加一个元素 &lt;span id=&quot;cursor-trail&quot;&gt;&lt;/span&gt; 。2. 点击波纹 一次偶然的机会，看到一篇这样的文章：还原一个 Windows 10 Metro 布局 。感觉其中的点击波纹动画很有意思，Shaun 决定把这个动画也放进自己的个性化主题中。至于代码就不贴了，毕竟就是上面文章提供的代码，只是用这个动画的时候发现了 Chrome 的一个问题，就是在进行模糊动画的时候会出现正方形的右边框和下边框，单个模糊不进行动画，不会有边框，进行动画但没模糊也不会有边框，两个同时一起就会出现问题，Firefox 没有这个问题，但 Firefox 存在另一个问题，就是鼠标快速连点的时候，鼠标跟随动画可能会出现问题。浏览器的问题 Shaun 暂时没法解决了，就先这样吧 ╮(╯▽╰)╭。虽然对 Chrome 为啥会出现这样的问题有些猜想，但还是不说出来丢人了，万一不是 Shaun 想的这样就尴尬了 ,,ԾㅂԾ,, 。后记有更新再继续更新吧。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[［译］为什么深度学习没有取代传统的计算机视觉]]></title>
    <url>posts/3578e309.html</url>
    <content type="text"><![CDATA[前言 这是一篇译文，译自：Why Deep Learning Has Not Superseded Traditional Computer Vision，原作者为：Zbigatron 。Shaun 水平有限，仅供参考学习，更多内容还请自行查看原文。至于为什么要翻译这篇文章，算是回答别人的一个问题吧。为什么深度学习还没有取代传统的计算机视觉？scale-cv-dl 编写这篇文章的原因是在论坛中经常有人问：深度学习是否取代了传统的计算机视觉？或者类似的问题：深度学习效果这么好，还有继续研究传统计算机视觉的必要？ 这是个好问题，深度学习（DL）确实彻底改变了计算机视觉（CV）和人工智能，许多曾经看起来不可能解决的问题都解决了，甚至达到了 机器的结果比人类更好 的程度，比如图像分类。正如 我之前讨论的，深度学习确实为计算机视觉做了很大的贡献。 但是深度学习只是计算机视觉的一个工具，并不是解决所有问题的万能药，所以，在这篇文章中，我想详细说明一下为什么传统的计算机视觉仍然非常有用，并且应该继续学习。这篇文章主要有一下几个观点：深度学习需要大量数据；深度学习有时大材小用了；传统的计算机视觉可以辅助深度学习。 但是在我开始讨论这些观点之前，需要先解释一下什么是传统的计算机视觉，什么是深度学习，以及深度学习为何这么 dio。背景知识 在深度学习之前，如果要实现图像分类这样的功能，需要首先进行 特征提取。特征即为图像中的信息块，能代表图像的部分信息，可以通过 边缘检测，角点检测，物体检测 等技术来提取特征。 在进行特征提取和图像分类之类的工作时，一个想法是从一类对象（例如椅子，马等）的图像中提取尽可能多的特征，并将这些特征视为对象的一种定义（比如 词袋模型），然后在其他图像中查找这些定义，若另一个图像中的特征和定义的特征很相似，则该图像可能包含该特定的对象（如椅子，马等）。 在图像分类中，这种特征提取的难点在于每个图像都必须选择哪些特征进行查找，当需要分类的类别开始增加时，比如 10 或 20 种类别，这种方式将变得很麻烦以至于不可能实现。当然也可以考虑角点、边缘和纹理信息，使用不同的特征可以更好的描述不同类别的对象，但是如果选择使用很多特征，则必须处理大量参数，所有这些参数都必须微调。 深度学习中有一个端到端学习的概念，其含义为告诉机器要针对每个特定类别对象学习需要查找的特征，它为每个对象设计了最具描述性和显著性的特征，换言之，告诉神经网络要发现图像中每个类别的基本模式。 因此，通过端到端学习，不需要再决定使用哪种传统的计算机视觉技术来描述特征，机器自动选择好了，Wired magazine 说过：如果想教一个神经网络识别一只猫，不需要让它寻找胡须、耳朵、皮毛和眼睛，只需要给它大量猫的图像，它就会自动识别猫，若它将狐狸错认成猫，不需要重写代码，只需要继续训练即可。下图表示了特征提取（使用传统计算机视觉）和端到端学习之间的差异：traditional-cv-and-dl 以上就是需要的背景知识，下面开始深入探讨为什么传统的计算机视觉仍然有存在的必要。深度学习需要大量数据 首先，深度学习需要大量的数据，那些著名的图像分类模型就是在海量数据集上训练的，训练数据集中最大的三个是：ImageNet – 150 万张图片，包含有 1000 个对象类别；Microsoft Common Objects in Context (COCO) – 250 万张图片，91 个对象类别；PASCAL VOC Dataset – 50 万张图片，20 个对象类别。 一般的图像分类任务不需要这么多图片，但仍然需要很多，如果没办法获得这么多图片怎么办？我们还是得训练我们所有的数据（有些方法可以增多我们的训练数据，但这些都是人工方法）。但是，没有足够的数据支持，训练出来的模型可能会在训练集之外表现不好，因为机器没有洞察能力，无法对没有的数据进行分类。而且无法直观查看训练好的模型并手动调整里面的数据，因为深度学习模型里面有数百万个参数，并且这些参数在训练时会自动微调，某种程度上，深度学习模型就是一个黑盒子。 传统的计算机视觉完全透明，可以很清楚的判断自己的解决方案在训练数据之外是否可行，而且可以深入了解算法中存在的问题。如果有没法解决的问题，也可以更容易的找出原因并调整。深度学习有时大材小用了 这可能是我支持传统计算机视觉技术研究的最佳理由。 训练深度神经网络需要很长时间，而且需要专门的硬件（高性能 GPU），如果想在普通的笔记本上训练最先进的图像分类模型，可以去外面玩一个星期，回来之后应该还没训练完 ：) 。而且，如果训练好的模型表现不好怎么办？必须调整训练参数并重新开始训练，这个过程有时会重复数百次。 但有时候使用深度学习是完全没有必要的，因为有时传统的计算机视觉技术可以比深度学习更有效的解决问题并且代码更少。比如，我曾经做过一个项目来检测传送带上每个罐头是否都有红色的勺子，解决这个问题可以训练深度神经网络来检测勺子，也可以针对红色编写一个简单的阈值分割算法（红色的某个范围内的像素点为白色，其它像素点为黑色），然后计算有多少个白色像素点，后者明显简单的多，一个小时就完成了。 了解传统的计算机视觉有时会节省大量时间和避免不必要的麻烦。传统计算机视觉提高改进深度学习技能 了解传统的计算机视觉可以帮助我们更好地进行深度学习。 例如，计算机视觉中使用的最常见的神经网络是卷积神经网络。但什么是卷积？它实际上是一种广泛使用的图像处理技术（例如 Sobel边缘检测）。了解这一点可以帮助我们了解神经网络正在做什么，并因此可以更好的设计和调整神经网络来解决问题。 深度学习中还可以对图像进行预处理，所谓的预处理是指对训练的数据进行一定的处理（Shaun 注：比如图像增强，图像去噪等），这些预处理操作一般由传统的计算机视觉技术完成，比如：当没有足够的训练数据时，可以使用一种叫数据增强的技术，使用数据增强让图像进行旋转，平移，裁剪等操作，从而增加“新”图像，通过执行这些操作，可以成倍的增加训练数据集。总结 在这篇文章中，我解释了为什么深度学习还没有取代传统的计算机视觉技术，因此还需要研究后者。首先我发现了深度学习要想表现的足够好需要大量数据的问题，有时候没法获得大量数据，这时只能用传统计算机视觉技术代替；其次，对于特定的任务，使用深度学习可能大材小用了，传统计算机视觉有时比深度学习更有效且代码量也更少；最后了解传统的计算机视觉可以更好的学习深度学习，因为这可以使我们更好的了解深度学习的内部机制，并且可以使用某些预处理操作来改善深度学习结果。 简而言之，深度学习只是计算机视觉的一个工具，不是万能药，不要只是因为它现在很流行所以使用它，传统的计算机视觉技术仍然十分有用，了解它可以节省时间和避免许多麻烦。后记 翻译这篇文章的原因在于，因为某些原因，Shaun 不得不回答一个 “为什么不用深度学习？” 的问题，虽然这里面有极大的因素是客观原因（设备不够 ╮(╯▽╰)╭），但 Shaun 不能明说，正好在网上看到这篇文章，加上也看到过一个问题（类似于 “既然已经能用深度学习做高层次的工作，为何还要用深度学习做底层的工作？”，比如深度学习能做全景分割（可以说是基本完成了图像理解），为何还要做目标检测，图像分割），预计以后有很大的概率也会被问到，所以就需要借用文中的一些观点来进行回答。至于为啥还要用深度学习做底层的工作，可以这样认为，如果用深度学习做底层工作效果不错的话，应该可以对上层工作进行一些辅助，并且可以为上层工作的做法提供一些新的思路。]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再也不见，18年]]></title>
    <url>posts/37b89a23.html</url>
    <content type="text"><![CDATA[转眼间，19 年也过去了两个月，迟来的 18 年小结还是得来。 18 年，感觉自己成长不大，该了解的在去年就了解的差不多，18 年了解的程度也并没有怎么加深，不了解的，18 年还是不了解。果然要想成长的更快些，了解的更多些，还是得去一个完全崭新的环境。 18 年，被老板派出去做事了，前前后后应该有三个多月，要说这三个多月完全没有成长，那也是不可能的，毕竟是一个完全崭新的环境，在那里面也做了一些粗浅的事（整整 Android，整整 C#， 整整 SQL Server 存储过程等等），也基本了解了一些在外面做事的一些规则，初步了解了全干工程师的痛苦，了解了被业务捆绑的码农的无奈，了解了有一个好领导是多么重要，……。 总之要说 Shaun 在 18 年哪段时间成长的最快，那无疑是这三个月了。在这三个月中，Shaun 从一个 Android 小白，成长为一个能解决 Android 各项问题的小白（好吧，还是小白 o(╯□╰)o，这里不得不插一句，Android 的各项兼容性真痛苦，简直比之 Web 前端兼容 IE 6 也不遑多让，同做 IOS 的那位童鞋就没这种烦恼了），从一个完全不会 C# 的到一个不怎么会 C# 的（好吧，确实在那里也没写过几行 C#，做最多的 C# 相关事情就是维护和重做几个零几年的水晶报表，照着前人写的代码实现并维护一些小功能），从一个完全不会存储过程的小白到熟练使用各种触发器各种游标各种联合查询语句的小白，……，鬼知道 Shaun 经历了什么 ⊙﹏⊙。 3 个多月的外包全栈（gan）工程师体验，总体来说还是学到了一些东西，见识到了外面的一些人，一些事，最深刻的体会就是大部分程序员的代码终究是为业务需求服务的，同时也体会到完全被业务捆绑的悲哀，业务需求是咋样的，代码就是咋样的，只不过不同的思维方式，会造成实现的方式的不同，而考虑不全面的代码，在后续使用中就极有可能会出现一些问题，最有可能的一个问题，就是 SQL 执行缓慢导致的一系列问题。还有一个问题就是，健全的文档很重要，别和 Shaun 扯什么「代码即文档」，当代码一团混乱，又没有文档，开发人员一波接一波的来来走走，会有人完全知道这个项目的具体实现方式也怕是有鬼了，这样的项目维护起来实在是太困难了。以后再有人和 Shaun 说「不懂的去看代码啊，代码里面什么都有」，怕不是要被 Shaun 打出屎来 (￣ε(#￣)☆╰╮(￣▽￣///)。Shaun 相信，真能写出代码即文档的人，在正规的开发流程下，也是会留下文档的。 18 年，收获最大的应该是提前了解了一些人性的恶，也真正见识到了「人前笑嘻嘻，背后捅刀子」的事。一个看起来还算和蔼的人，却是如此的小心眼，背地里一肚子坏水，就因为一些技术上的问题讨论，驳了 ta 的意思，就玩些不上台面的小把戏，呵，有意思的人啊。技术上的问题，就算从来一次，Shaun 还是要问个为什么，虽然 Shaun 碍于目前的眼界学识，对业务的了解程度，无法给出一些非常有用的建议，但是业务的实现，实现方式的好坏，Shaun 还是有基本的判断能力的，总不能说什么就做什么吧。 18 年初发生的一些事基本已经忘记了，年中的一些事也快忘了，有些事情不出意外还是会重复发生的，毕竟人类的本质就是复读机 ๑乛◡乛๑，太阳底下也很少有新鲜事，不过还好「暴走·大事件·第六季· 05 总结2018感谢有你陪伴，2019我们再出发！」这一期盘点了 18 年发生的一些事，虽然还有些事没有说，因为如果说了可能大概率已经被和谐了，毕竟有些事不存在了就可以当没发生过嘛 ╮(￣▽￣&quot;)╭ 。不过反正这些事总还是会以某种形式再次发生的，只是看什么时候发生，发生在谁身上而已，Shaun 能做的，就是尽量避免这些事发生在自己身上，反正 Shaun 个人也无法改变什么，普罗大众也乐得逍遥自在。 算了，就写到这里了，18 年确实没有什么值得称道的事 o(︶︿︶)o 。18 年获得技能：废人一个18 年获得成就：毫无成就]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-theme-chi主题开发小记]]></title>
    <url>posts/ac4679b5.html</url>
    <content type="text"><![CDATA[前言 2019 年 2 月 20 日，Shaun 的站点主题终于完成了，终于能用上自己的主题了，开心 ～(￣▽￣～)。 在网上看到的建议都是多写内容少整主题，但强迫症表示受不了，Shaun 就是想要一个自己的主题，自己怎么看着舒服就怎么来，即使没有一个访客，至少也要让自己看着舒服，自己想怎么设计就怎么设计，想用什么技术就用什么技术，想怎么排版就怎么排版，尽量少受写约束，总而言之，Shaun 喜欢自由。回顾篇 自己写主题的想法由来已久，应该是从 17 年 12 月份开始的吧，当时就感觉自己魔改的 spfk_x 主题只能勉强符合自己的需求，但是因为已经用的是别人已经完成的框架，大体框架也不好做太多修改（如果要改的话还不如自己重新写一个），而且里面由于经手太多人的修改，里面的代码结构在 Shaun 看起来有点混乱，而且有很多冗余的代码，有些代码甚至完全没有用上，导致修改起来有点麻烦。 至于为什么不在 17 年寒假期间就开始写，而要拖到 18 年 12 月份才开始动手，一部分原因是 Shaun 的拖延症，一部分原因是还没具体想好该怎么布局，该用什么技术，还有一部分就是外在客观原因了。 18 年 12 月份开始动手写，是因为这段时间稍显空闲，虽然白天还是一样的忙，但至少没那么多心里负担了，而且此时 Shaun 对于自己想要的大体布局已经十分清楚了（虽然一些具体细节还没不是那么清楚），所以就趁着晚上有时间写写，有时候晚上高兴或没事干就写写，有时候没想法或还没想好具体怎么实现就不写，就这样断断续续的写，总算在 19 年 2 月完成了。 本来想在 19 年之前完成的，可是由于本人的拖延症和一些客观原因，还是超期了很久，侯世达定律总是存在的（ sigh~😔），不过总的开发时间也差不多是一个月吧。感觉花费这一个月的晚上时间还是挺值得的，虽然从中学到的东西不多，但总算也有点自己的东西了。实现篇 既然要开始写主题了，首先当然要想一个主题名字，本来最初是直接取原来主题的首尾字母作为名字，但后面想了想感觉有点不对劲，有点骂人的意味在里面 (´ ; ω ; `)，后面又想了想，就用尾字母 X 算了，反正站点图标也是那个，后面感觉还是不好，单字母太单一了，后面突然想到希腊字母，就以希腊字母的英语命名了。 名字想好之后，就要决定用什么技术了，由于 Shaun 只是一个前端小白，无论用什么技术对 Shaun 来说难度都差不多，Shaun 理想的主题是能够支持响应式的，所以为了尽可能简单的支持响应式，CSS 方面的库就采用 Bootstrap4，CSS 预处理器当然是用 Stylus 了， JS 方面最令 Shaun 纠结，到底是采用现代的 Vue 还是传统的 jQuery，最终从相对熟悉程度和相关资料广度方面考虑，Shaun 最终选择了 jQuery3（以后有机会再尝试一下 Vue 吧），接下来要选择的是 Node.js 模板引擎，候选的主要有三个 EJS、Swig 和 Jade（现已更名Pug），Shaun 原来的主题是用 EJS 的，著名的 NexT 主题用的 Swig，而 Pug 的语法目前有点接受不能，所以直接放弃了，而 Swig 早已停止更新，所以也放弃了，所以最终选择的还是相对熟悉的 EJS（而 EJS 最近的一次提交时间为 2018 年 11 月 28 日，看来应该也是要停止更新了，以后有机会试试 Pug 吧）。 技术决定之后，就要开始写了，最开始写的时候，由于不清楚 hexo 的工作机制，导致完全无法显示页面，后面查阅了几篇关于如何写 hexo 主题的文章，加上自己的慢慢摸索，终于弄懂了，hexo 的最初页面需要有一个 index 文件，在 index 中写入的东西，将会显示在 http://localhost:4000/ 页面中，好了，终于能显示内容了，接下来要解决的是布局问题，hexo 的所有页面渲染都会通过一个叫 layout 的文件，layout 文件中必须存在一个 &lt;%- body %&gt; 语句，在渲染时，hexo 会用其它页面的内容替换 layout 中的 &lt;%- body %&gt; 语句，包括 index 中，所以在 layout 中写好 HTML 框架之后，其它页面只需要负责写内容就行。实现一个最简单的主题（只有纯文字版网页），只需要下面几步：在 index.ejs 文件中写入 &lt;%- include('_partial/archive', {item: page, is_index: true}) %&gt;；然后在 _partial 文件夹中 archive.ejs 文件中写入：12345678910&lt;% page.posts.each(function(item) &#123; %&gt; &lt;%- include(&apos;article&apos;, &#123;item: item, is_index: true&#125;) %&gt;&lt;% &#125;) %&gt;&lt;% if (page.total &gt; 1)&#123; %&gt; &lt;%- paginator(&#123; prev_text: &apos;&amp;laquo; Prev&apos;, next_text: &apos;Next &amp;raquo;&apos; &#125;) %&gt;&lt;% &#125; %&gt;在 _partial 文件夹中 article.ejs 文件中写入 &lt;div&gt;&lt;%- item.content %&gt;&lt;/div&gt;；最后在 layout.ejs 文件中写入：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;%- body %&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;即可将文章内容显示出来，前提是已有文章。当然也可把上面的1~3步合起来算作一步，直接在 index.ejs 文件中写入：12345678910&lt;% page.posts.each(function(post) &#123; %&gt; &lt;div&gt;&lt;%- post.content %&gt;&lt;/div&gt;&lt;% &#125;) %&gt;&lt;% if (page.total &gt; 1)&#123; %&gt; &lt;%- paginator(&#123; prev_text: &apos;&amp;laquo; Prev&apos;, next_text: &apos;Next &amp;raquo;&apos; &#125;) %&gt;&lt;% &#125; %&gt;这样就算是实现了一个最简单的主题，只是这个主题十分丑陋，文章也没有对应的标题。※注： 在写这几步的时候，Shaun 在这里发现 hexo-browsersync 插件和 hexo s 命令有冲突，会造成一个bug：hexo s 启动后，页面加载错误，大BUG，具体表现为：当直接使用 &lt;%- post.content %&gt; 在首页显示文章时，index.html 将会无法加载完全，后面的一部分会加载错误。解决办法为：卸载 hexo-browsersync 插件。 完成上面几步，就算是写主题已经入门了，万事开头难，入门之后就相对简单了，只要按部就班的一步步走下去就行了，接下来就是慢慢进行排版布局问题，就这样，Shaun 一边参考其它一些主题的排版和写法，一边查阅网上资料实现自己的想法，一步一步的解决问题，直到完成该主题。PS： 主题配置文件 _config.yml 中的配置变量的命名和其它编程语言一样，不能以数字作为第一个字符。文档篇 Chi 主题涉及到的技术主要为：Bootstrap4、jQuery3、Stylus、EJS、HTML5、CSS3、ES6 等；运行环境为：node-v8.11.1、Hexo-3（hexo-cli-1.1.0）等；测试浏览器为Firefox 60.5.0 esr 和 Chrome 72.0.3626.109，其它浏览器没测过，也不考虑测，有兴趣的童鞋可以自己测自己改。 Chi 主题的配色主要参考 Shaun 原来的主题 spfk_x，排版部分参考了 hexo-theme-freemind，部分代码也是来自这两个主题。Chi 主题的一些动画实现优先采用 CSS，除了那些无法用 CSS 实现或 Shaun 不知道如何用 CSS 实现的，所以 JS 代码部分不算很多，网页加载速度也勉强能够接受吧。 Chi 主题的代码高亮部分本来想参考 为hexo博客加入prettify高亮插件 使用prettify替换默认的代码高亮，但使用了之后发现效果不是很好，就还是使用默认的样式了。 Chi 主题的使用文档暂时就不写了，毕竟这个主题只是 Shaun 个人使用（应该也不会有其他人使用了，万一真有人要用却不太会用，欢迎提 issue，以后酌情考虑添加使用文档 🙃），由于 Shaun 只是前端小白，这个主题也只是当学习练手开发，里面肯定会有各种各样的问题，欢迎提 issue 或 fork 或 clone 后自行修改，提 issue 的话，Shaun 不保证一定能解决，毕竟水平有限，当然如果有代码优化想法还望不吝赐教 (｡･ω･｡)ﾉ♡ （至于 px 换 em 或 rem 就不用提了，没什么原因，主要是 Shaun 懒，更深层的原因在于 Shaun 手头上还没有更高分辨率的显示器，不知道显示差距有多大，不好进行测试 😓）。PS： Shaun 使用了 Hexo 博客美化代码块| 梦魇小栈 中的脚本对 Markdown 代码部分进行了美化渲染，但是该脚本有时候渲染会出现一些问题，无法进行美化，可能是代码语法格式有错误，这时需要自己手动调整一下 Markdown 代码格式。使用 Chi 主题推荐安装插件：hexo-renderer-pandoc # 使用pandoc渲染markdown，安装前需卸载默认渲染器hexo-renderer-markedhexo-generator-feed # RSS订阅hexo-generator-searchdb # 本地搜索hexo-abbrlink # 文章唯一永久链接hexo-all-minifier # 快速压缩优化代码好了，暂时就写到这里了。后记 当 Shaun 有一天使用其它 blog 框架时，这个主题可能就不再维护更新了，但其中的排版样式应该还会或保留或更新。下面要做的事就不立 Flag 了，因为立了多半会完不成，这就很尴尬了，但不立又没有动力，真是让人脑壳疼啊 (๑•ั็ω•็ั๑)，反正是一件长期要做的事了，长到可能接下来的业余时间可能都在做这件事，或开源或不开源，看以后的心情和完成程度了 （↖(^ ω ^)↗）。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab和OpenCV混合编程小结]]></title>
    <url>posts/64889158.html</url>
    <content type="text"><![CDATA[本文所用的 Matlab 版本为 Matlab R2017b，OpenCV 版本为 opencv-3.4.3，C++ IDE 为 Visual Studio 2017，系统环境为 Windows 10_x64。前言 秋招告一段落了，又要回到最初的起点，继续搞（qu）科（hua）研（shui）了，由于前人的代码主要是用 C++ 和 Matlab 混编实现的，而 Shaun 比较熟悉的是 C++ 和 OpenCV，而用 OpenCV 完全重写前人的代码工作量又太大了而且有些 API 不是很好互换，为了方便站在巨人的肩膀上继续前进，所以只能学习一下 OpenCV 和 Matlab 的混合编程了，这样在前人的基础上实现 Shaun 自己的想法相对来说更容易一些。准备篇 由于目前主要用 C++ 实现的是一些小功能，也不需要调试，所以就直接使用 VSCode 进行编程了（或许以后还是会用 VS 进行一些简单的调试），而在没有配置相关环境的前提下，VSCode 无法实现自动补全，所以需要在 VSCode 中配置相应环境。具体添加方法如下：在 VSCode 中点击菜单栏 “查看” ==》“命令面板…” ==》选择 “C/Cpp: Edit Configurations…”==》在出现的 c_cpp_properties.json 文件中 &quot;includePath&quot; 对应的值中添加 OpenCV 的 include 目录和 Matlab 的 include 目录，添加之后的 &quot;includePath&quot; 如下：1234567&#123;"includePath": [ "$&#123;workspaceFolder&#125;/**" , "D:/ProgramFiles/OpenCV/3.4.3/build/include/**" , "C:/Program Files/MATLAB/R2017b/extern/include/**"]&#125;如此就能在 VSCode 中写 OpenCV 和 Matlab 相关函数时实现自动补全了。Matlab 和 C++ 混编篇 由于 Shaun 使用的是 OpenCV 的 C++ 接口，所以需要先知道 Matlab 和 C++ 混合编程如何进行。以实现两个数的加法为例，首先创建一个 mexAdd.cpp 文件，其中 C++ 代码具体如下：1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;mex.h&gt; // 必须包含头文件 mex.h#include &lt;iostream&gt;// 检查输入是否合法void checkInputs(int nrhs, const mxArray *prhs[])&#123; if (nrhs != 2) &#123; mexErrMsgTxt("Incorrect number of inputs. Function expects 2 inputs."); &#125; if (!mxIsDouble(prhs[0])) &#123; mexErrMsgTxt("Input number must be double."); &#125;&#125;double add(double x, double y)&#123; return x + y;&#125;/** * nlhs：matlab 函数左边变量个数，即返回值参数个数 * plhs： matlab 函数左边变量，即返回值参数 * nrhs： matlab 右边变量个数，即函数输入参数个数 * prhs： matlab 函数右边变量，即函数输入参数 */void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])&#123; checkInputs(nrhs, prhs); // 输入参数可以不使用指针，但输出参数必须使用指针 double *a = nullptr; // 输出参数 double b = 0.0, c = 0.0; // 两个输入参数 plhs[0] = mxCreateDoubleMatrix(1, 1, mxREAL); // 创建1x1的实数矩阵用作输出第一个参数 a = mxGetPr(plhs[0]); // 用指针a指向第一个输出 b = *(mxGetPr(prhs[0])); // b作为第一个输入 c = *(mxGetPr(prhs[1])); // c作为第二个输入 *a = add(b, c); // 计算b、c之和得到a&#125; 若要使用 Matlab 混合编译 C++，必须要添加头文件 mex.h，使用 void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[]) 函数接收输入输出参数，如此编译完成之后，就和使用普通的 Matlab 函数一样了。具体编译调用方法如下，新建 addTest.m 文件，其中 Matlab 代码如下：123456789clc, clear, close all; % 清空变量和关闭所有打开窗口current_folder = pwd; % 获取当前文件路径addpath(genpath(current_folder)); % 添加matlab临时搜索路径，并包含子文件夹（matlab退出后该路径不存在）mex mexAdd.cpp; % 混合编译C++，得到matlab可识别的函数a = 3.1; b = 2.6;c = mexAdd(a, b);其中 mex mexAdd.cpp 可以直接在 Matlab 命令行窗口下预先执行编译动作，编译成功后会输出一个 mexAdd.mexw64 文件，若是 32 位系统则后缀为 mexw32，之后直接执行 ans = mexAdd(3.1, 2.6); 即可在 Matlab 中调用该函数。在 Matlab 首次执行 mex 命令时，Matlab 会自动选择 VS 编译器作为默认 C++ 编译器，也可以执行 mex -setup 初始化或更换默认编译器。BTW： 最好在安装 Matlab 之前安装 Visual Studio，否则使用 mex 编译时，可能会出现找不到编译器的情况。Matlab 和 OpenCV 混编篇 Matlab 和 OpenCV 混编大体上和 C++ 混编差不多，最大的区别在于如何利用 OpenCV 的 cv::Mat 对象和相关的库函数，Matlab 良心的提供了 OpenCV 接口以实现 mexArray 和 cv::Mat 格式之间的互相转化，使用这些接口需要包含头文件 opencvmex.hpp 。如果不使用 Matlab 提供的这些接口而是自己写转换过程的话有点麻烦，因为 Matlab 的数据是以列优先方式存储的，而 OpenCV 的数据是以行优先方式存储的。至于如何进行混编，主要有以下三种方式：第一种是自己写 make.m 文件，相当于 gcc 编译时需要的 Makefile 文件，需要手动拼接各种编译命令和添加相应的附加依赖库；第二种是通过 Matlab 官方提供的 Computer Vision System Toolbox OpenCV Interface 功能，Matlab 没有默认安装该功能，这个功能需要另外安装，具体安装方法为：在 Matlab 命令行窗口输入 visionSupportPackages，即可弹出“附加功能资源管理器”窗口选择对应附加功能安装即可，安装完之后可通过 mexOpenCV 命令对包含 OpenCV 库函数的 .cpp 文件进行编译，查看 mexOpenCV.m 的源码可知，mexOpenCV 其实是对 mex 命令进行了封装，其调用的 OpenCV 库也是其工具箱自带的 OpenCV，而且有些库还没有包含，有一定的局限性，不过该附加功能自带了些示例程序，可以参考学习一下；第三种是使用第三方的 mexopencv，不过需要安装与该工具对应的 OpenCV 版本，并需要进行一定的配置工作，略显麻烦。 Shaun 这里直接使用的是第一种方式，自己写 make.m 文件，比较灵活，想怎么配置就怎么配置。下面具体以 RGB 转 GRAY 为例，首先新建 mexRGB2GRAY.cpp，其中 C++ 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;opencvmex.hpp&gt;#define _DO_NOT_EXPORT#if defined(_DO_NOT_EXPORT)#define DllExport #else#define DllExport __declspec(dllexport)#endif/** * Usage: [img_matrix] = mexRGB2GRAY('img.jpg'); * Input: a image file; * Output: a matrix of image which can be read by Matlab**/// 检查输入是否合法void checkInputs(int nrhs, const mxArray *prhs[])&#123; if (nrhs != 1) &#123; mexErrMsgTxt("Incorrect number of inputs. Function expects 1 inputs."); &#125; if (mxGetNumberOfDimensions(prhs[0]) != 3) // 获取Matlab图像总的维度个数（灰度图为2维，RGB彩色图为3维） &#123; mexErrMsgTxt("Incorrect number of dimensions. First input must be a RGB image."); &#125; // 检查图像数据类型 if (!mxIsUint8(prhs[0])) &#123; mexErrMsgTxt("Template and image must be UINT8."); &#125;&#125;void exit_with_help()&#123; mexPrintf("Uasge: [image_matrix] = mexRGB2GRAY('image_file.jpg');\n");&#125;static void fakeAnswer(mxArray *plhs[])&#123; plhs[0] = mxCreateNumericMatrix(0, 0, mxDOUBLE_CLASS, mxREAL); // 创建一个0x0的空双精度matlab矩阵&#125;cv::Mat RGB2GRAY(const mxArray *prhs[])&#123; cv::Ptr&lt;cv::Mat&gt; img_cv = ocvMxArrayToMat_uint8(prhs[0], true); // 将unit8数据类型的matlab矩阵转换为OpenCV的mat对象智能指针 if (img_cv.empty()) &#123; return cv::Mat_&lt;double&gt;(0, 0); &#125; // 将RGB转化为GRAY图 cv::Mat gray((*img_cv).size(), CV_8UC1); if ((*img_cv).channels() == 3) &#123; cv::cvtColor(*img_cv, gray, CV_RGB2GRAY); &#125; else if((*img_cv).channels() == 4) &#123; cv::cvtColor(*img_cv, gray, CV_RGBA2GRAY); &#125; else &#123; (*img_cv).copyTo(gray); &#125; return gray;&#125;void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])&#123; checkInputs(nrhs, prhs); if (nrhs == 1) &#123; cv::Mat gray = RGB2GRAY(prhs); plhs[0] = ocvMxArrayFromMat_uint8(gray); // 将unit8数据类型的OpenCV的mat对象转换为matlab矩阵 &#125; else &#123; exit_with_help(); fakeAnswer(plhs); return ; &#125;&#125;然后新建 makefile.m 文件，自己配置相关编译环境， Shaun 这里具体如下：12345678910111213141516171819202122232425262728293031function makefile() % 选择相应计算机系统版本 is_64bit = strcmp(computer, 'MACI64') || strcmp(computer, 'GLNXA64') || strcmp(computer, 'PCWIN64'); % 配置OpenCV编译环境，如果系统是64位的，则OpenCV也需要是64位的 out_dir = '.'; % 输出目录,这里为当前目录 CPPFLAGS = ' -O -DNDEBUG -I./ -ID:/ProgramFiles/OpenCV/3.4.3/build/include'; % OpenCV “include” 目录 LDFLAGS = ' -LD:/ProgramFiles/OpenCV/3.4.3/build/x64/vc15/lib -LC:/PROGRA~1/MATLAB/R2017b/extern/lib/win64/microsoft'; % OpenCV “lib” 目录 和 MatLab 附加库目录 LIBS = ' -lopencv_world343 -lmwocvmex'; % 添加OpenCV相关库和Matlab libmwocvmex.lib库 if is_64bit CPPFLAGS = [CPPFLAGS ' -largeArrayDims']; end % 需要编译的 cpp 文件 compile_files = &#123; 'mexRGB2GRAY.cpp' 'mexAdd.cpp' &#125;; % 开始编译 for k = 1 : length(compile_files) str = compile_files&#123;k&#125;; fprintf('compilation of: %s\n', str); str = [str ' -outdir ' out_dir CPPFLAGS LDFLAGS LIBS]; args = regexp(str, '\s+', 'split'); mex(args&#123;:&#125;); end end其中 Matlab 配置路径中的 PROGRA~1 是指 Windows 下的 C 盘中的 Program Files 文件夹，为了使用 Matlab 提供的转换接口，libmwocvmex.lib 是必须要添加的一个库。最后具体使用示例 Matlab 代码如下：1234567891011clc, clear, close all; % 清空变量和关闭所有打开窗口current_folder = pwd; % 获取当前文件路径addpath(genpath(current_folder)); % 添加matlab临时搜索路径，并包含子文件夹（matlab退出后该路径不存在）makefile();image = imread('lena.jpg');I = mexRGB2GRAY(image);figure, imshow(I);也可以将 makefile(); 函数预先执行。※注： 这里如果出现编译报错 “缺少依赖共享库” 的情况可能还需要把 OpenCV 的 bin 目录加到系统环境变量 Path 中，Shaun 这里是路径 D:\ProgramFiles\OpenCV\3.4.3\build\x64\vc15\bin，然后重启 Matlab。调试篇 若要对写的 mexAdd.cpp 文件进行调试，则需要先使用 mex -g mexAdd.cpp 编译该文件，由于添加了 -g 参数，此时除了会生成 mexAdd.mexw64 文件之外，还会生成一个 mexAdd.mexw64.pdb 文件，该文件即包含调试信息；然后在相应 .m 文件中调用 mexAdd 函数的位置设置断点，运行该相关文件，matlab 程序会在调用 mexAdd 函数之前停下；此时使用 VS2017 打开 mexAdd.cpp 文件，在需要调试的地方设置好断点，选中菜单栏中的“调试” ==》“附加到进程”，或者直接点击菜单栏上的绿色三角 附加…，选中 MATLAB.exe ，点击附加，即可看到 VS2017 调试程序已启动；最后回到 matlab 中继续运行相关文件，即可看到程序跳转到 VS2017，并执行到设置断点的地方，此时即可在 VS2017 中按调试 C++ 程序一样对其进行调试。 完成调试并执行完 mexAdd.cpp 之后，程序将回到 matlab 界面继续执行，直到整个 matlab 程序执行完成。后记 这次主要是记录 Matlab 如何调用 C++ 编写的函数，其实还可以用 C++ 调用 Matlab 编写的函数，不过那是另一种混编方式了，以后有机会碰到的话再继续记录吧。参考资料[１] Matlab与C++混合编程（依赖OpenCV）[２] 更改默认编译器[３] OpenCV Interface Support[４] Matlab OpenCV混合编程[５] vc与matlab连接的实用函数简介]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android实践小结]]></title>
    <url>posts/be7949e4.html</url>
    <content type="text"><![CDATA[实践环境为：android-studio-bundle-162.4069837-windows（Android Studio 2.3.3 带 Android SDK 版）、该 Android Studio 自带的 JRE，系统环境为 Win10-1607。前言 由于上一届没有更新任何项目文档和学习文档，Shaun 只能自己去网上查找相关的资料，从零开始学习，顺便留下一些文档，正所谓：「代码未动，文档先行」，也算是实践出真知吧。PS： 本次实践的项目主要来自 12.1Android 实战 ：DrySister看妹子应用(第一版) — 项目搭建与简单实现（http://www.runoob.com/w3cnote_genre/android） 以及目前手头上正在维护的项目。布局篇 首先打开 Android Studio ，新建项目，一路默认下去即可，等待片刻，“MainActivity.java” 文件的错误提示就会自然消失，将左侧栏上方的 “Android” 切换为 “Project”，打开 app -&gt; src -&gt; main -&gt; res -&gt; layout -&gt; activity_main.xml，由于其默认是以 “Text” 的模式打开（Android Studio 右侧有个 “Preview” 标签可以进行当前布局预览），这对于小白来说不大好控制布局，所以需要在该文件底部将 “Text” 切换为 “Design”，如此可以进行拖拽式布局，以下正式开始进入 Android UI 的布局。至于具体如何进行布局设置，可以参考 Android ConstraintLayout 使用指南 和 Android实现拖拽式布局开发—-约束性布局 以下两篇资料。 而若要使控件大小根据屏幕大小自适应，一般可使用相对布局，但如今的 Android Studio 默认新建的页面就是一种类似于相对布局的页面，所以直接在控件中设置 android:layout_width=&quot;match_parent&quot; 以及 android:layout_height=&quot;match_parent&quot; 属性即可，再设置 layout_margin 属性进行调整即可，而若要让控件大小随控件内的内容自适应，则只需要将 match_parent 更改为 wrap_content 即可。编码篇 首先新建自己的业务逻辑 java 代码，具体新建方法可参考 Android studio怎么创建一个Java类文件 ，在 MainActivity.java 文件所在目录上鼠标右键 New -&gt; Java Class，新建完成之后即可编写自己的业务逻辑。若要新建文件夹，则在目录上鼠标右键 New -&gt; Package 。若要使级联目录展开，例如 com.example.admin.myapplicationtest，则需要在该目录的父级目录新建一个 com.example.admin.test Package 即可将com.example.admin 目录展开。页面跳转 首先新建一个页面 jump_test_activity，在 \MyApplicationTest\app\src\main\res\layout，即 layout 文件夹上鼠标右键，“New” ==》“Activity” ==》“Empty Activity” （有多种 Activity 样式可供选择，Shaun 这里就以 Empty Activity为例了），随后弹出窗口，在 Activity Name 栏填写页面逻辑控制代码文件名 JumpTestActivity，在 Layout Name 栏填写页面 UI 设计代码文件名 jump_test_activity，在 Package name 以及页面逻辑控制代码文件所在在包名 com.example.admin.myapplicationtest.ui.activity，其它设置为默认即可，这样新建的页面的有个问题就是会有一个丑陋的标题栏，所以还需要去掉该标题栏，具体方法为：在 MyApplicationTest\app\src\main\res\values\styles.xml 文件中添加：1234&lt;style name="AppTheme.NoActionBar"&gt; &lt;item name="windowActionBar"&gt;false&lt;/item&gt; &lt;item name="windowNoTitle"&gt;true&lt;/item&gt;&lt;/style&gt;将 MyApplicationTest\app\src\main\AndroidManifest.xml 中的 &lt;activity android:name=&quot;.ui.activity.JumpTestActivity&quot;&gt;&lt;/activity&gt; 更改为 &lt;activity android:name=&quot;.ui.activity.JumpTestActivity&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt; ，再次编译运行即可看到标题栏已消失。好了，准备阶段已经搞完，接下来就是正式的页面跳转了，一般页面跳转是用户点击事件发生的，所以需要添加一个具有点击事件的控件，一般而言就是 Button 了，这里设该 button 的 id 为 page_jump_btn；该 button 所在页面为 MyApplicationTest\app\src\main\res\layout\activity_main.xml，则在对应的逻辑控制文件MyApplicationTest\app\src\main\java\com\example\admin\myapplicationtest\ui\activity\MainActivity.java 中的页面跳转代码为：12345678page_jump_btn = (Button) findViewById(R.id.page_jump_btn);page_jump_btn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(MainActivity.this, JumpTestActivity.class); MainActivity.this.startActivity(intent); &#125;&#125;);如此，在主界面中点击跳转按钮，即可跳转到新建页面。URL 中的坑 在学 12.2 的时候，由于请求的URL地址中有中文“福利”，所以其返回的字符串为：1234&#123;"error": false,"results": []&#125;可以看到 “results” 的值为空，这显然是错的，后面调试发现需要对 URL 地址转义（这都 8102 年了，为什么 URL 地址中还要有中文，或者说为什么 URL 地址还不支持解析中文 ╮(╯▽╰)╭），具体转义代码如下：123fetch_url = Uri.encode(fetch_url); // 将URL地址转义fetch_url = fetch_url.replace("%3A", ":"); // 将%3A替换为:fetch_url = fetch_url.replace("%2F", "/"); // 将%2F替换为/主要参考资料为：Android url中文乱码问题及解决办法 和 Android URL encode 空格处理 。SQL 语句中的坑 在使用字符串拼写 SQL 语句时，一定要注意 SQL 语句中的空格，要不然拼起来的 SQL 语句可能语法不通而导致 APP 崩溃。如在使用创建表的 SQL 语句时，可能的错误写法（不注意空格）如下：123456789101112String create_table_sql = "CREATE TABLE IF NOT EXISTS" + TableDefine.TABLE_FULI + "(" + TableDefine.COLUMN_ID + "INTEGER PRIMARY KEY AUTOINCREMENT," + TableDefine.COLUMN_FULI_ID + "TEXT," + TableDefine.COLUMN_FULI_CREATEAT + "TEXT," + TableDefine.COLUMN_FULI_DESC + "TEXT," + TableDefine.COLUMN_FULI_PUBLISHEDAT + "TEXT," + TableDefine.COLUMN_FULI_SOURCE + "TEXT," + TableDefine.COLUMN_FULI_TYPE + "TEXT," + TableDefine.COLUMN_FULI_URL + "TEXT," + TableDefine.COLUMN_FULI_USED + "BOOLEAN," + TableDefine.COLUMN_FULI_WHO + "TEXT" + ")";以上写法无法正确建表，甚至会因为错误 SQL 语句而导致 APP 闪退，正确的写法如下：123456789101112String create_table_sql = "CREATE TABLE IF NOT EXISTS " + TableDefine.TABLE_FULI + " (" + TableDefine.COLUMN_ID + " INTEGER PRIMARY KEY AUTOINCREMENT, " + TableDefine.COLUMN_FULI_ID + " TEXT, " + TableDefine.COLUMN_FULI_CREATEAT + " TEXT, " + TableDefine.COLUMN_FULI_DESC + " TEXT, " + TableDefine.COLUMN_FULI_PUBLISHEDAT + " TEXT, " + TableDefine.COLUMN_FULI_SOURCE + " TEXT, " + TableDefine.COLUMN_FULI_TYPE + " TEXT, " + TableDefine.COLUMN_FULI_URL + " TEXT, " + TableDefine.COLUMN_FULI_USED + " BOOLEAN, " + TableDefine.COLUMN_FULI_WHO + " TEXT" + ")";调试篇 编码完成之后，一般而言需要进行调试，Android Studio 的调试可参考 【Android 开发入门】android studio 控制台打印输出日志 ，进入调试模式具体方法为：点击上方工具栏中的 Debug ‘app’ 图标，而不是直接 Run ‘app’，进入调试模式之后，点击下方的 “Android Monitor”，切换到 “logcat” 标签，即可查看调试信息。 华为手机打印调试信息可参考 华为手机logcat不出日志解决方案。这里由于 Shaun 还没有对 AndroidManifest.xml 进行修改，所以该 APP 在点击 Button 的时候会直接闪退，调试窗口出现 java.lang.SecurityException: Permission denied (missing INTERNET permission?) 错误信息，参考 android菜瓜笔记之missing INTERNET permission 和 SecurityException: Permission denied (missing INTERNET permission?) 可知，该 APP 没有网络权限，所以需要在 AndroidManifest.xml 中添加网络权限，具体在 manifest 标签中添加语句 &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;，如此该 APP 就能正常执行了。PS： 如果是对应用发生闪退或崩溃的原因进行调试，建议直接在 logcat 中搜索 fatal 关键字。附录更换马甲重新发布为另一个 app 即一样的代码却编译出另一个相同的 app，在某些特殊的需求（使两个功能大致一样的 app 共存在一台手机上）上可能需要这个技巧，具体步骤如下（以 MyApplicationTest 更名为 MyApplication 为例）：首先将 MyApplicationTest 文件夹（即 APP 根目录）更名为 MyApplication；（这一步不是刚需）将 MyApplicationTest\app\src\main\res\values\strings.xml 文件中 &lt;string name=&quot;app_name&quot;&gt;MyApplicationTest&lt;/string&gt; 更改为 &lt;string name=&quot;app_name&quot;&gt;MyApplication&lt;/string&gt;；将 MyApplicationTest\app\build.gradle 文件中 applicationId &quot;com.example.admin.myapplicationtest&quot; 更改为 applicationId &quot;com.example.admin.myapplication&quot; 。（这一步是刚需）如此，即可另外安装一个全新 APP，同时保留原有 APP，至于 applicationId 的更多作用和用法可参考 设置应用 ID 。更换 APP 图标只需在 app 文件上鼠标右键， “New” ==》“Image Asset” ，即可弹出设置 app 图标窗口，或者直接更改 AndroidMainfest.xml 文件中的 android:icon 也可。后记 排版可能有点乱，毕竟是随便写的，碰到问题就简单的记录一下，Shaun 这次的实践过程可在 AndroidLearning 中查看，页面跳转的方法来自手头上正在开发维护的一个项目，附录中第一个问题的来源是对方提出的一个特殊需求。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++数组中的坑]]></title>
    <url>posts/fc1165b7.html</url>
    <content type="text"><![CDATA[前言 在写快排的时候偶然发现了 C++ 数组中的一个坑，具体表现为：对数组元素进行无临时变量的自交换时竟然会将数组该元素置为 0，这应该是 C++ 的一个 BUG Shaun 脑子抽了。交换函数篇 据参考资料 [1] 中， C++ 的交换函数可以有如下三种写法：12345678910111213141516171819202122// 第一种：使用模板，创建临时变量template &lt;class T&gt; void swap(T &amp;a, T &amp;b)&#123; T temp(a); a = b; b = temp;&#125;// 第二种：无临时变量，针对int,double等内建数值类型的基本运算（以double为例）void swap(double &amp;a, double &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125;// 第三种：无临时变量，针对int的异或运算void swap(int &amp;a, int &amp;b)&#123; // a ^= b ^= a ^= b; a = a ^ b; b = b ^ a; a = a ^ b;&#125; 其中，第一种是通用的交换方法，无论做什么交换都能用第一种，但需要创建一个临时对象；而第二种不需要创建一个临时对象，只能用在 int，double 等内建数值类型上，且存在溢出的风险；第三种同样不需要创建临时对象，只能用在 int 类型上，由于采用位运算，所以不存在溢出的风险，且效率最高。BUG 复现篇 bug 复现代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;template &lt;class T&gt; void swap_1(T &amp;a, T &amp;b)&#123; T temp(a); a = b; b = temp;&#125;void swap_2(int &amp;a, int &amp;b)&#123; a = a + b; b = a - b; a = a - b;&#125;void swap_3(int &amp;a, int &amp;b)&#123; a ^= b ^= a ^= b;&#125;int main(int argc, char *argv[])&#123; int data[] = &#123; 0, 3, 8, 2, 9, 4, 6, 1, 7, 5 &#125;; int a = 1, b = 2, c = 3; swap_1&lt;int&gt;(data[a], data[b]); printf("%d\t%d\n", data[a], data[b]); // 输出 8 3 swap_1&lt;int&gt;(data[a], data[a]); printf("%d\t%d\n", data[a], data[a]); // 输出 8 8 swap_2(data[a], data[b]); printf("%d\t%d\n", data[a], data[b]); // 输出 3 8 swap_2(data[a], data[a]); printf("%d\t%d\n", data[a], data[a]); // ***输出 0 0*** swap_3(data[b], data[c]); printf("%d\t%d\n", data[b], data[c]); // 输出 2 8 swap_3(data[b], data[b]); printf("%d\t%d\n", data[b], data[b]); // ***输出 0 0*** std::swap(data[4], data[5]); printf("%d\t%d\n", data[4], data[5]); // 输出 4 9 std::swap(data[4], data[4]); printf("%d\t%d\n", data[4], data[4]); // 输出 4 4 return 0;&#125; 目前没有找到什么好的解决方案，只能老老实实的用第一种创建一个临时变量的交换方法，或者在交换之前先判断一下是不是同一个元素，若不为同一个元素，才进行交换，否则不交换，即避免自交换。后记 刚开始出现这个问题的时候，Shaun 还纳闷了，怎么写个快排把数组元素都改变了，刚开始根本没想到这茬，还以为是 Shaun 代码的问题，倒着检查了好几遍，换第一种交换方式以及换个冒泡排序用一样的交换方式进行排序输出结果都没问题，后面使出终极调试法，一个个的输出看看才知道原来是自交换的锅。 如果有大佬知道为什么会出现这个问题还望不吝赐教 ◔ ‸◔?。经 @ Magnesium12 大佬提醒，这个问题由于引用引起的，采用第二种方法进行交换时如果两个数是完全一样的（地址也一样），则在进行两数相减时，由于是引用，所以这两个数完全一样，则最后会导致这两个完全一样的数，即自交换的该数置为 0 。参考资料[1] 谈谈C++中的swap函数]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发环境配置]]></title>
    <url>posts/cafdd60d.html</url>
    <content type="text"><![CDATA[由于一些历史原因，本篇配置的 Android 开发环境所需的软件对应版本号为：jdk-7u80-windows-x64、android-studio-bundle-162.4069837-windows（Android Studio 2.3.3 带 Android SDK 版），系统环境为 Win10-1607。前言 没想到，时隔两年之后又要重新捡起 Java，还要学基本没怎么做过的 Android，而且还是在这节骨眼上，真是造化弄人 _(´ཀ`」 ∠)_。Java 环境篇 先在 Oracle Java Archive 下载对应的 Java 版本，下载完成后去 这里 校验对应的 Hash 值（若是其它 JDK 版本，则只需将 url 末尾的 7u80 改成相应的版本号即可），并安装，安装时需要注意，在安装完 JDK 之后，该安装器还会继续弹出让安装 JRE 的窗口，此时直接点取消即可，因为 JDK 中已包含 JRE ，所以没必要也不需要再继续安装，安装了之后，就相当于有两个 JRE ，还可能会为以后的工作造成一些麻烦。具体系统环境变量配置如下（若没有相应的变量名则新建）：变量名变量值JAVA_HOMEC:\Program Files\Java\jdk1.7.0_80 （PS：此为JDK安装目录，后面不能加分隔符分号）CLASSPATH.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; （PS：最前面的 .; 必须要有）Path%JAVA_HOME%\bin;%JAVA_HOME%\jre;配置完之后，键入 Win+R ==》cmd ==》 Enter，在终端输入 “java -version”，“java”，“javac” ，这几个命令，若有正确的响应，则表示配置成功。Android 篇※注： 在安装和配置 Android Studio 时最好先自行找好梯子，这其中有一些步骤可能需要连接外网。 自然还是先在这里（http://www.android-studio.org/）下载安装 Android Studio ，为避免再下载安装配置 SDK 的麻烦，推荐直接下载带 SDK 版本的 Android Studio 。直接默认安装，其中安装 SDK 的时间略长。安装完成之后，推荐把 SDK 目录下的 tools 和 platform-tools 子目录也添加到系统的 PATH 环境变量中。 在第一次打开 Android Studio 的时候，可能需要连接外网以更新 SDK ，所以需要自行设置好代理，更新又要花一段时间 ╮(╯▽╰)╭，当然也可以选择不更新，不更新的办法为：在AS启动前，打开安装目录，请先将bin目录的idea.properties文件中增加一行：disable.android.first.run=true就行了，避免第一次打开AS时自动重新下载SDK。 第一次运行时，首先需要配置 SDK 路径和 JDK 路径，配置 SDK 路径方法为：“Configure” —&gt; “SDK Manager”，编辑 “Android SDK location” ，其会自动找到安装的 SDK 路径；配置 JDK 路径方法为：“Configure” —&gt; “Project Defaults” —&gt; “Project Structure”，编辑 “JDK location”（这里它有个默认内置的 jre，但推荐还是使用自己的 JDK）。 Android Studio 默认的编辑器方案无法更改字体（若真想在默认的方案上更改字体，可以先将其另存为一个新方案），而且个人认为其默认的主题（配色，字体等）不好看，所以推荐自行去 Color Themes 选择合适的主题。最终 Shaun 选择 Wombat 主题。至于导入主题的方法为：“Configure” —&gt; “Import Settings”，将下载好的 jar 包导入即可。 为了测试方便，就直接装了个 网易MuMu模拟器 ，用起来感觉还可以，至于 Android Studio 连接 MuMu 模拟器的方法为：先打开 MuMu 模拟器，在 Android Studio 底下的 Terminal（终端） 中输入命令：adb connect 127.0.0.1:7555 ，响应 connected to 127.0.0.1:7555 则说明连接成功，这时就能愉快的使用 MuMu 模拟器调试 Android app 了。后记 以后有碰到什么坑再继续记录吧 ╮(╯▽╰)╭。参考资料[1] Android Studio安装配置、环境搭建详细步骤及基本使用[2] 第一次使用Android Studio时你应该知道的一切配置（http://www.cnblogs.com/smyhvae/category/587732.html）[3] Android Studio连接不到MuMu模拟器]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows实用技巧]]></title>
    <url>posts/27a4c8b6.html</url>
    <content type="text"><![CDATA[前言 本篇主要用来记录在 Windows 下使用命令行能做到的一些特殊技巧。Windows 粉碎文件技巧 有时候 Windows 下会莫名出现文件无法删除的现象，即使通过 Shift+Delete 组合键也还是无法删除，这时可能需要通过一种 “文件粉碎机” 的工具才能删除，但是为了偶尔出现的这种现象而安装一个这样的工具又略显麻烦，这时只需要新建一个 Windows 批处理文件，即新建一个 txt 文本文件，并将后缀改为 .bat 即可，文件内容输入：12DEL /F /A /Q \\?\%1RD /S /Q \\?\%1其中DEL 表示删除文件，命令参数为： del /?/F：表示强制刪除/A：选择文件的属性/Q：静默模式，在删除时不会弹出提示信息RD 表示刪除目录，命令参数为： rd /?/S：连带删除子目录下的文件/Q：静默模式，在删除时不会弹出提示信息 具体用法为将待删除的文件拖拽到该 .bat 文件图标上，用该 .bat 文件打开待删除的文件即可。 但有时候即使使用上面的方法，也无法删除文件，同时还会弹出“无法删除文件，文件或目录损坏且无法读取”这样的提示，这可能是文件存储时发生错误造成的，此时需要在 Windows 命令提示符界面中输入命令 CHKDSK 盘符:/F，盘符为需要删除的文件所在的磁盘或 U 盘，比如在 D 盘，则输入命令 CHKDSK D:/F，如出现无法锁定的提示信息，则输入 Y 强制卸载该卷，等待一段时间，等磁盘扫描和修复完成后即可删除待删除的文件。Windows 校验文件技巧 为确保从网络上下载的文件为原文件，一般需要对其进行 hash 校验（如 SHA1、SHA256、SHA384、SHA512、MACTripleDES、MD5、RIPEMD160 值等），一般随原文件一起释放的比较常见的 hash 值有 SHA1、SHA256 或 MD5 等，但是为了校验下载文件的 hash 值可能需要专门的第三方工具，但其实 Windows 、Linux 和 macOS 都自带了校验 hash 值的命令，通过这些命令可以直接对文件的 hash 值进行校验，而不需要使用额外的第三方工具，这里只介绍 Windows 的哈希值校验命令，其命令为 Get-FileHash，具体使用方法如下：12# []内为待校验的文件 和 所用的hash算法Get-FileHash [文件路径及名称] -Algorithm [校验的Hash值类型]| Format-List 如果觉得每次这样输入比较麻烦，可以使用参考资料[2]提供的注册表文件（.reg 后缀），双击运行，即可在鼠标右键菜单添加「文件哈希校验」，如此可以通过鼠标右键直接对文件进行 hash 校验。附其中代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\文件哈希校验]&quot;SubCommands&quot;=&quot;MACTripleDES;MD5;RIPEMD160;SHA1;SHA256;SHA384;SHA512&quot;&quot;MUIVerb&quot;=&quot;文件哈希校验&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MACTripleDES]@=&quot;MACTripleDES&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MACTripleDES\command]@=&quot;PowerShell Get-FileHash -Algorithm MACTripleDES \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MD5]@=&quot;MD5&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\MD5\command]@=&quot;PowerShell Get-FileHash -Algorithm MD5 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\RIPEMD160]@=&quot;RIPEMD160&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\RIPEMD160\command]@=&quot;PowerShell Get-FileHash -Algorithm RIPEMD160 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA1]@=&quot;SHA1&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA1\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA1 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA256]@=&quot;SHA256&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA256\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA256 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA384]@=&quot;SHA384&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA384\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA384 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA512]@=&quot;SHA512&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\SHA512\command]@=&quot;PowerShell Get-FileHash -Algorithm SHA512 \\\&quot;%1\\\&quot; | format-list;“按任意键退出...”;[Console]::Readkey() | Out-Null;exit&quot;Windows 隐写文件技巧 在 Windows 下可以通过 copy 命令实现简单的文件合并，即隐写，例如：将压缩文件隐写入 jpg 文件中，将 txt 文件隐写入 jpg 文件中。这样在没改后缀名的情况下，该文件是以图片形式存在，若要恢复原有隐写文件信息，则只需要将 jpg 后缀名更改为相应文件后缀名，例如：若隐写的是 rar 文件，则只需将后缀名 .jpg 改为 .rar ，再用解压缩软件打开即可，也可以直接用解压缩软件打开相应 jpg 文件；若隐写的是 txt 文件，则需要用记事本打开该文件，通过 ctrl+end 组合键让光标定位到文件最末尾，即可看到隐写的 txt 文件内容。具体命令如下：1234567891011# 将 b.txt 隐写进 a.jpg 中，并输出为 c.jpgcopy/b a.jpg+b.txt c.jpg# 将当前目录下 2.rar 隐写进 1.jpg 中，并输出为 3.jpgcopy /b ./1.jpg + ./2.rar ./3.jpg# 将 b.txt 隐写进 a.jpg 中，并输出为 c.jpgcopy a.jpg /b + b.txt /a c.jpg# 将 b.rar 隐写进 a.jpg 中，并输出为 c.jpgcopy a.jpg /b + b.rar c.jpg※注：图片文件要放在前面，需要隐写的信息放在后面，不然输出的图片无法正常查看和显示。 其中参数 /b 表示以二进制格式复制、合并文件，在合成图片和压缩文件等二进制文件时必须使用该参数，不然会丢失信息，从而造成合成失败，当然合成 txt 文本文件时也可以使用该参数；参数 /a 表示以 ASCII 码格式复制、合并文件，参数 /a 只适用于 txt 文本文件合并。 至于其它需要注意的就是：1、要合成的两个文件最好放在同一目录下，不然输入路径有点麻烦； 2、txt 文本文件前面最好空三行，这样它头部的内容就不会丢失。 输出的图片 c.jpg 和原图片 a.jpg 显示是一样的，看起来就是同一张图片，因此达到隐写的目的。Win10 开启休眠方法 不知道巨硬是怎么肥事，居然 Win10 中默认电源选项中没有「休眠」选项，需要手动开启。虽然睡眠和休眠有重叠的地方，但是休眠是完全关机，再次开机时会恢复原有工作状态，更多的情况是必须要关机（因为需要考虑电量情况），相反如果有充足电力的情况下，还不如使用锁定代替睡眠，从这里的需求看还不如在默认电源选项中去掉「睡眠」选项。好了，抱怨吐槽的话就说这么多了，具体开启「休眠」的方法为：只需要在命令行（需要以管理员身份打开「命令提示符」）中输入一下命令：1powercfg /H on回车 执行即可在电源选项中发现「休眠」选项。Windows 新建用户命令 前一段时间电脑系统升级之后崩了，资源管理器损坏，没有任务栏，没有桌面，Win 键都无法使用，还好可以使用任务管理器，通过任务管理器调出 cmd，输入以下命令新建一个用户：12345# 添加用户tmp、密码123 net user tmp 123 /add # 设置tmp为管理员 net localgroup administrators tmp /add 通过 tmp 用户可以正常使用电脑，因此猜测应该是原来的用户系统配置文件（例如注册表文件，系统设置文件等等）损坏。系统损坏之后捣鼓了两天，这没办法修复了，即使新建用户也还是有些软件没法使用，还不如直接重装系统（系统出现问题果然重装系统才是最快的解决方案），还好可以新建用户以备份原有系统盘文件，不然就是真 gg 了。既然新建命令记录了，也顺便记录一下删除命令吧，删除用户 tmp 命令为：net user tmp /del 。Windows 解除 U盘或移动移动硬盘被占用技巧 Windows 在弹出 U盘或移动硬盘时，有时会出现 “该设置正在使用中，请关闭可能使用该设备的所有程序或窗口，然后重试。” 的提示，导致 弹出 USB 大容量存储设备时出现问题，无法弹出。解决该问题需要知道是那个或哪些程序占用该存储设备，然后结束该进程即可。查看存储设备占用程序 Shaun 知道的有两种方法：通过 “Windows 日志”。Windows 每次弹窗提示都会有相应的日志，右键计算机 ==》管理 ==》事件查看器 ==》Windows日志 ==》系统，然后在窗口左侧查找其中有黄色警告的日志信息，找到来源为 Kernel-PnP 的日志，双击该日志即可看到 “进程 ID 为 XXX 的应用程序 XXX 已停止删除或弹出设备 XXX。” 之类的信息，从而知道是哪个进程占用该存储设备，停止该进程即可正常弹出。停止进程一般通过 任务管理器 ==》详细信息，找到对应的 名称 和 PID，右键 ==》结束任务即可。通过 “资源监视器”。右键计算机 ==》管理 ==》性能，打开资源监视器。然后在 “CPU” 栏中找到 “关联的句柄”，在后面的搜索栏中输入存储设备的盘符（D: 、E: 或 F: 等 ），即可显示占用程序的 名称 和 PID，随后在任务管理器中停止该进程即可。 ※注： 有时只有 System 进程阻止存储设备弹出，这时可以直接关机了 :），因为 System 进程是系统核心进程，不能结束，结束之后系统会崩溃，并自动关机。当然，如果是其他进程阻止，可以用上述方法正常弹出，一般阻止存储设备弹出的都是 explorer.exe，在停止该进程后，Windows 的任务栏将会消失，所以需要在任务管理器中重新运行该任务（任务管理器 ==》文件 ==》运行新任务， 输入 “explorer” 即可）。后记 如果以后碰到更多有意思的小技巧再继续和大家分享吧 ↖(^ω^)↗。参考资料[1] windows文件夹删不掉怎么办[2] 巧在Win10右键菜单添加校验文件Hash值命令（MD5、SHA1/256等）[3] 【命令行copy命令】将txt文档与jpg图片合并[4] 升級Win10後，為何筆電專有的休眠選項消失了[5] CMD命令（添加删除管理员账户）]]></content>
      <categories>
        <category>Share</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FFmpeg提取与合并命令使用小结]]></title>
    <url>posts/6315717b.html</url>
    <content type="text"><![CDATA[前言 前面有一段时间需要对视频做一些简单的处理，所以就去查了一下一些常用的视频处理工具，因为不想再另外装个什么软件，所以就决定直接采用 FFmpeg 了，毕竟其它的一些视频处理软件也极有可能只是对 FFmpeg 进行一些图形化界面的封装而已。 而在查找 FFmpeg 相关资料的时候，也同时发现了 Libav ， 对于 FFmpeg 和 Libav Shaun 只想说，开源界的战争总是这么莫名其妙，有各种各种一些奇怪的原因（或许大佬们都是各有各的脾性吧 ╮(╯▽╰)╭），像两个小飞机的战争也是如此，不过神仙打架，凡人享福也好 ~\(≧▽≦)/~。神仙们的想法我等凡人是无法揣测了，不过这种事还是少出点为好，不然下次变为小鬼遭殃就不好了。 使用 FFmpeg 而不是 Libav 是因为 FFmpeg 的相关资料相对来说要多很多；而且Libav 更新的特性，FFmpeg 全都支持；更重要的是 FFmpeg 是更新特别频繁，差不多是日更了，几乎每天都会发布一个稳定版；而且从两者的下载页面来看， FFmpeg 好像更会照顾跨平台用户一点。下文主要是对 FFmpeg 的部分命令进行记录总结。Shaun 的系统环境为 Win10 1607，测试的 FFmpeg 版本为 ffmpeg-20180429-19c3df0-win64-static。 在 Win10 下使用 FFmpeg 前首先需要配置系统环境变量，Windows 下 FFmpeg 的安装是下载完 Windows 版编译好的 FFmpeg 压缩包后直接解压即可，将解压后的 FFmpeg 文件夹中的 bin 目录添加到系统环境变量 Path 中，不然系统会无法找到 ffmpeg 命令。提取命令 FFmpeg 的提取命令的参数很多，因此可以使用不同参数排列组合达到不同的提取效果，具体如下：1234567891011121314151617# （1）快速提取video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将提取结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -to 00:02:00 -c copy cut.mp4# （2）快速提取video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将提取结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -t 00:02:00 -c copy cut.mp4# （3）快速提取video.mp4从第一分钟开始到第二分钟的视频，并将提取结果输出为cut.mp4ffmpeg -ss 00:01:00 -i video.mp4 -to 00:02:00 -c copy -copyts cut.mp4# （4）精确提取video.mp4从第一分钟开始到第二分钟的视频，并将提取结果输出为cut.mp4ffmpeg -i video.mp4 -ss 00:01:00 -to 00:02:00 -c copy cut.mp4# （5）精确提取video.mp4从第一分钟开始持续两分钟的视频，即到第三分钟，并将提取结果输出为cut.mp4ffmpeg -i video.mp4 -ss 00:01:00 -t 00:02:00 -acodec copy -vcodec copy cut.mp4# （6）快速提取video.mp4从第三分钟开始持续60秒的视频，即到第四分钟，并将提取结果输出为cut.mp4ffmpeg -ss 00:03:00 -i video.mp4 -t 60 -c copy -avoid_negative_ts 1 cut.mp4以下为各参数的含义：-i：用法为 -i INPUT_VIDEO，代表输入的视频，该视频应为 MPEG 编码（h.264, MPEG4/divx/xvid, MPEG2; MP2, MP3, AAC） ；-ss：用法为 -ss START_TIME，代表提取的开始时间，时间格式有两种写法：1、纯数字格式，以秒为单位（eg: -ss 90，代表从第90秒开始提取）；2、时:分:秒 格式（eg: -ss 00:01:30，代表从 0 时 1 分 30 秒开始提取）；-to：用法为 -to STOP_TIME，代表提取的结束时间，时间格式同样有两种写法：1、纯数字格式，以秒为单位（eg: -to 180，代表第180秒结束提取）；2、时:分:秒 格式（eg: -to 00:03:00，代表 0 时 3 分 00 秒结束提取）；-t：用法为 -t DURATION_TIME，代表提取的持续时间，时间格式同样有两种写法：1、纯数字格式，以秒为单位（eg: -to 180，代表提取持续180秒）；2、时:分:秒 格式（eg: -to 00:03:00，代表提取持续 0 时 3 分 00 秒）；-c：用法为 -c CODEC，代表音视频编码格式（若 CODEC 为 copy 则代表输出视频的音视频编码格式与原视频一样），其实 -c 是 -codec 的缩写，其中包含音频编码参数 -acodec 和 视频编码参数 -vcodec ；-copyts：保持原有时间戳，即使当 -ss 在 -i 之前时，仍使 -t 和 -to 保持原有效果，不会被同化；-avoid_negative_ts：当开启该参数时，提取视频会找到首尾的相邻关键帧（这样会造成提取时间不精确），补全视频，当 -ss 在 -i 之前时该参数默认开启；-accurate_seek：使提取时间更精确，在转码时该参数默认启用。更多参数可参考：Format-Options 。※注： 1、-t 和 -to 不能同时使用，若同时使用，将以 -t 为准； 2、当 -ss 在 -i 之前时，可以实现快速提取，但提取的时间点不精确，此时-to 和 -t 的效果一样，都表现为 -t ，此时可以加上 -copyts 参数使两者效果不一样； 3、当 -ss 在 -i 之后时，提取的时间点比较精确，但提取速度比较慢。 以上命令（1）、（2）是一样的提取结果，命令（3）的 -t 和 -to 会产生不一样的结果，（6）的 -t 和 -to 会产生一样的结果。因此若只考虑速度，可以使用命令（3），若需使提取时间精确，则需使用命令（4）和（5）。PS：当然还有一种更精确的方式，通过命令 ffmpeg -i input.mp4 -strict -2 -qscale 0 -intra output.mp4 将输入视频由原来的帧间编码转换为帧内编码，使每一帧都成为关键帧，如此转换之后再进行提取，可使提取时间十分精确，但该转换方式会造成视频文件空间成倍增大。合并命令 FFmpeg 的合并命令大概有 4 种，可参考： FFMpeg无损合并视频的多种方法 。这里主要介绍两种：方法一：使用 FFmpeg concat 分离器（推荐） 该方法使用命令为：ffmpeg -f concat -i filelist.txt -c copy output.mp4，其中 filelist.txt 文件最好和待合并的视频在同一个文件夹中，文件中内容就是待合并的视频的描述，具体内容如下：12file &apos;input1.mp4&apos;file &apos;input2.mp4&apos;或12file ./input1.mp4file ./input2.mp4※注： 待合并的视频文件名最好由英文、数字、连接符（-）或下划线（_）组成，且中间最好不要有空格，不然可能会因为文件名而在合并时出现一些奇怪的错误。方法二：利用中间格式合并 所谓利用中间格式进行合并是因为可能有些待合并的视频编码不一致，这时采用方法一可能无法进行合并，这时需要对待合并的视频的进行统一转码，都转成同一个编码格式。若要采用这种方法，建议都转成 mpg 格式，因为 mpg 格式可以直接 cat 命令进行合并，具体如下：12345678# 将input1.avi转成intermediate1.mpg,输出视频质量为1ffmpeg -i input1.avi -qscale:v 1 intermediate1.mpg# 将input2.mp4转成intermediate2.mpg,输出视频质量为1ffmpeg -i input2.mp4 -qscale:v 1 intermediate2.mpg# 合并intermediate1.mpg和intermediate2.mpg，输出合并结果intermediate_all.mpgcat intermediate1.mpg intermediate2.mpg &gt; intermediate_all.mpg# 将intermediate_all.mpg转成output.avi,输出视频质量为2ffmpeg -i intermediate_all.mpg -qscale:v 2 output.avi 其中参数 -qscale 是指使用固定的视频量化标度 ，取值范围为 0.01 ~ 255 ，越小代表质量越好，一般推荐取值为 2 ~ 5，实际使用不能超过 50， -qscale:v 代表设置视频输出质量。PS： 方法一为无损合并，方法二为有损合并。后记 以后有用到新的命令再继续记录吧 ↖(^ω^)↗ 。参考资料[1] ffmpeg Documentation（https://ffmpeg.org/documentation.html）[2] FFmpeg wiki: Seeking（http://trac.ffmpeg.org/wiki）[3] FFmpeg：视频转码、剪切、合并、播放速调整[4] 通过 ffmpeg 无损剪切/拼接视频[5] 使用ffmpeg合并视频文件的三种方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决VSCode使用Cmder作为默认终端问题]]></title>
    <url>posts/fd823bf9.html</url>
    <content type="text"><![CDATA[前言 Shaun 最近想换换新口味，想尝试用 Cmder 作为 VSCode 下的默认终端，不想再继续使用 git-bash 了，因为 git-bash 有时会出现一些乱码问题。但是在用 VSCode 集成 Cmder 时出现了几个问题。问题篇 如果在 VSCode 用户设置文件中直接添加 Cmder.exe 及其路径，那么在使用 VSCode 终端时会重新打开一个 Cmder 窗口，而不是直接显示在 VSCode 的「终端」里。Shaun 想要的是 Cmder 就是 VSCode 的终端，就在 VSCode 里，就和原有cmd 终端一样，在 VSCode 下的终端可以直接输入相关命令，而不是另外弹出一个命令行窗口。解决方案篇方法一将 Cmder 放进一个文件夹中，文件夹名不带空格，比如 Shaun 所有的绿色软件全部放在 D:\ProgramFiles 下，在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k D:\\ProgramFiles\\Cmder\\vendor\\init.bat"],方法二一部分用户可能有点强迫症 ๑乛◡乛๑，硬是要把绿色软件还放入系统盘中的 Program Files 文件夹里，这样在 VSCode 里配置 Cmder 作为默认终端时就会出现问题。主要是因为 Program Files 文件夹名中有空格（这里吐槽一下带空格的文件名真鸡儿坑爹，命令行中根本无法访问，这应该是巨硬的历史遗留问题了， 特立独行的支持带空格的路径名，想显摆一下自己，但以目前的情况看，这种支持简直无力吐槽，造成了一堆问题，和 Windows 路径名中的 \ 有的一拼，都是逼死现代程序员的设计 _(´ཀ`」 ∠)_）。好了，吐槽的话也就说到这里了，如果配置路径里无法避免 Program Files 文件夹，这里有三种解决方案：Windows 在支持带空格的长文件名的同时，也会分配一个短名称，可以称为该文件夹的别名，通过这个别名就可以在命令行中访问该文件夹，获取这个别名的方法有：在命令行中输入 dir /X ，即可在文件夹名之前的一列的看到该别名，若没有别名则为空白，若要添加别名则需要加入 /N 参数。Shaun 这里显示别名如下：123456789101112$ dir /X 驱动器 C 中的卷是 System 卷的序列号是 XXXX-XXXX C:\ 的目录.........2018/05/16 19:21 &lt;DIR&gt; PROGRA~1 Program Files2018/05/17 15:14 &lt;DIR&gt; PROGRA~2 Program Files (x86)..........由上面可知 Program Files 文件夹的别名为 PROGRA~1，而 Program Files (x86) 文件夹的别名为 PROGRA~2，在配置路径时只需要用别名替换相应的文件夹名即可，如下：123456&#123; "terminal.integrated.shell.windows": "C:\\Windows\\Sysnative\\cmd.exe", "terminal.integrated.shellArgs.windows": [ "/k C:\\PROGRA~1\\Cmder\\vendor\\init.bat" ]&#125;通过转义符添加 &quot; &quot; 使 Program Files 作为一个整体，如下：12"terminal.integrated.shell.windows": "cmd.exe","terminal.integrated.shellArgs.windows": ["/k", "C:\\\"Program Files\"\\Cmder\\vendor\\init.bat"],直接在系统环境变量中新建一个变量，将 Cmder 的根目录加进去，如下：变量名变量值CMDER_ROOTC:\Program Files再在 VSCode 用户设置文件中添加：1234"terminal.integrated.shell.windows": "C:\\Windows\\system32\\cmd.exe","terminal.integrated.shellArgs.windows": [ "/k %CMDER_ROOT%\\vendor\\init.bat"]通过以上几种方法（推荐直接使用方法一），就能成功在 VSCode 中集成 Cmder，可以直接在 VSCode 的终端里享受 Cmder 了。后记 没有什么好说的了，该吐槽也已经吐槽完了。方法二 Shaun 没试过，只是感觉应该可行，有问题的小伙伴可以在下方留言（这是不可能的，这辈子都不会有人留言的，反正也没人会看到的 ╮(╯▽╰)╭）。以上解决方案全部来自网络，Shaun 只是做个总结记录，万一以后碰到类似问题至少有多种方案可以尝试。参考资料[1] How to use Cmder in Visual Studio Code?[2] Setting Cmder.exe as integrated shell still opens in separate window[3] IntelliJ idea webstrom Visual Studio Code vscode 设置cmder为默认终端 Terminal]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图割算法之NCuts浅见]]></title>
    <url>posts/fddd1e17.html</url>
    <content type="text"><![CDATA[前言 图割算法主要有两个发展方向，一个是 Shaun 上次写过的 Graph Cuts ，通过边界项和区域项（有的可能还会添加一个约束项，或者叫标签项）之和建立能量方程，并利用一定程度的交互式构建一个 S/T 图，最后采用最大流/最小割（Max-flow/Min-cut ）算法寻找 S/T 图的最小“割”，从而对图像进行分割；而另一个方向就是 NCuts（Normalized Cuts），中文一般叫规范割、标准割等等，该方法主要出自：Shi J, Malik J. Normalized cuts and image segmentation[J]. IEEE Transactions on pattern analysis and machine intelligence, 2000, 22(8): 888-905. 。提到 NCuts，就不得不提「谱聚类」，因为 NCuts 可以说是谱聚类的一个应用。谱聚类篇谱聚类（Spectral Clustering， SC）是一种基于图论的聚类方法——将无向带权图划分为两个或两个以上的最优子图(sub-Graph)，使子图内部尽量相似，而子图间距离尽量远，以达到常见的聚类的目的。在了解谱聚类之前需要先了解两个概念：拉普拉斯矩阵（Laplace Matrix）和瑞利熵（Rayleigh quotient）。拉普拉斯矩阵拉普拉斯矩阵的定义如下：设 \(W\) 为无向带权图 \(G=(V,E)\) 的邻接矩阵，\(D\) 为无向带权图 \(G\) 的度矩阵，（所谓的度矩阵即为图中各顶点邻接的所有边权值之和构成的矩阵，是一个对角矩阵，若设顶点 \(i\) 和顶点 \(j\) 之间的权值为 \(w(i,j)\)，则度矩阵对角线上的元素 \(d_{i,i}=\sum \limits_{j=1}^n w(i,j)\) ），则拉普拉斯矩阵 \(L=D-W\)。如下图：若图的邻接矩阵：\(\mathbf{W}=\begin{pmatrix} 0 &amp; 0.1 &amp; 0 &amp; 0 &amp; 0.2 &amp; 0 \\ 0.1 &amp; 0 &amp; 0 &amp; 0.5 &amp; 0.1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 &amp; 0.4 \\ 0 &amp; 0.5 &amp; 0.3 &amp; 0 &amp; 0 &amp; 0.1 \\ 0.2 &amp; 0.1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.4 &amp; 0.1 &amp; 0 &amp; 0 \end{pmatrix}\) ，其中图中不连通的顶点之间的权值为 0；则对应的度矩阵为：\(\mathbf{Ｄ}=\begin{pmatrix} 0.3 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0.7 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.7 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0.9 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0.5 \end{pmatrix}\)则拉普拉斯矩阵 \(L\) 为：\(\mathbf{L}=\mathbf{D}-\mathbf{W}=\begin{pmatrix} 0.3 &amp; -0.1 &amp; 0 &amp; 0 &amp; -0.2 &amp; 0 \\ -0.1 &amp; 0.7 &amp; 0 &amp; -0.5 &amp; -0.1 &amp; 0 \\ 0 &amp; 0 &amp; 0.7 &amp; -0.3 &amp; 0 &amp; -0.4 \\ 0 &amp; -0.5 &amp; -0.3 &amp; 0.9 &amp; 0 &amp; -0.1 \\ -0.2 &amp; -0.1 &amp; 0 &amp; 0 &amp; 0.3 &amp; 0 \\ 0 &amp; 0 &amp; -0.4 &amp; -0.1 &amp; 0 &amp; 0.5 \end{pmatrix}\)以上三个矩阵都为实对称矩阵。对于拉普拉斯矩阵，由 $L* [1,1,1,1,1,1]^T =0* [1,1,1,1,1,1]^T= $ 可知其一定存在一个特征值为 0，对应的特征向量为 \([1,1,1,1,1,1]^T\) 。拉普拉斯矩阵是半正定的，且对应的 n 个实数特征值都大于等于 0，即 \(0=λ_1≤λ_2≤\cdots≤λ_n\)， 且最小的特征值为 0 。至于拉普拉斯矩阵的更多性质，可参考：Laplacian matrix 。瑞利熵 瑞利熵的公式形如：\(R(M,x)=\frac{x^*Mx}{x^*x}\) ，其中 M 是厄米特矩阵（Hermitian matrix），满足 \(M=M^H\) ，即矩阵 \(M\) 与其共轭转置矩阵相等，\(x\) 为非 0 向量，\(x^*\) 是指 \(x\) 向量的共轭转置向量。对于实数而言，厄米特矩阵就是对称阵 \(M=M^T\)，\(x^*\) 就是 \(x\) 向量的转置向量 \(x&#39;\) 或 \(x^T\)。 若设 \(x^*x=c\)，其中 \(c\) 为一个常数，则 \(R(M,x)=\frac{x^*Mx}{c}\) ，则其极值问题可转化为：\(\min R(M,x) = \min x^*Mx \qquad s.t.\ x^*x=c\) ，可利用拉格朗日乘数法求取 \(x^*Mx\) 的极值。 具体求法如下： \[ \mathcal{L}(x) = x^T M x -\lambda \left (x^Tx - c \right) \\ \begin{align} &amp;\frac{d\mathcal{L}(x)}{dx} = 0 \\ &amp;\Rightarrow x^TM - \lambda x^T = 0 \\ &amp;\Rightarrow Mx - \lambda x = 0 \\ &amp;\Rightarrow M x = \lambda x \end{align} \\ \therefore R(M,x) = \frac{x^T M x}{x^T x} = \lambda \frac{x^Tx}{x^T x} = \lambda. \]瑞利熵有如下几个性质：R 的最大值就是 M 最大特征值，R 的最小值就是 M 最小特征值 ；x 的解，就是 M 对应的特征向量。至于瑞利熵的更多性质，可参考：Rayleigh quotient 。 以上只是一般意义上的普通瑞利熵，还有一个广义瑞利熵（generalized Rayleigh quotient ），其定义为：\(R(M,D;x)=\frac{x^*Mx}{x^*Dx}\) ，即在分母上添加一个 D 矩阵相乘，其中 D 为 Hermite 正定矩阵 ，满足 \(D=D^*\)，普通瑞利熵是广义瑞利熵中 D 矩阵为单位矩阵时的情况。广义瑞利熵可以通过以下变换转换为普通瑞利熵： \[ \begin{equation} \begin{aligned} R(M,D;x) &amp;= \frac{x^*Mx}{x^*Dx} \xlongequal{x=D^{-\frac{1}{2}}y} \frac{(D^{-\frac{1}{2}}y)^*M(D^{-\frac{1}{2}}y)}{(D^{-\frac{1}{2}}y)^*D(D^{-\frac{1}{2}}y)} \\ &amp;= \frac{y^*(D^{-\frac{1}{2}})^*M(D^{-\frac{1}{2}}y)}{y^*(D^{-\frac{1}{2}})^*D(D^{-\frac{1}{2}}y)}=\frac{y^*D^{-\frac{1}{2}}MD^{-\frac{1}{2}}y}{y^*D^{-\frac{1}{2}}DD^{-\frac{1}{2}}y} \\ &amp;= \frac{y^*(D^{-\frac{1}{2}}MD^{-\frac{1}{2}})y}{y^*y} \end{aligned} \end{equation} \]只需要求出矩阵 \(D^{-\frac{1}{2}}MD^{-\frac{1}{2}}\) 的特征值和特征向量即可。好了，这两个概念介绍完了，就可以真正介绍谱聚类了。 上面说了，谱聚类是一种基于图论的聚类方法，既然有图，则必有相应的邻接矩阵。设图 G 的顶点被聚类成两类，即将图 G 分割为子图 A 和 B，则所要断开的边的权值之和为代价函数（也叫损失函数），类似于“Graph Cuts”中的能量方程。割边 Cut(A,B) 的具体表示为：\(Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j)\) 。 设图 \(G\) 中共有 \(n\) 个顶点，则需要构建一个 \(n \times n\) 的邻接矩阵 \(W\)，其相应的度矩阵为 \(D\)，对应的拉普拉斯矩阵为 \(L=D-W\)，令 \(p_i = \begin{cases} l_1 &amp; i \in A \\ l_2 &amp; i \in B\end{cases}\) ，则 \[ Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j) = \frac{\sum \limits_{i=1}^n \sum \limits_{j=i}^n w(i,j) (p_i-p_j)^2}{(l_1-l_2)^2}= \frac{\sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i-p_j)^2}{2(l_1-l_2)^2} \]当且仅当 \(i\) 和 \(j\) 不属于同一子图时，\((p_i-p_j)^2/(l_1-l_2)^2=1\)，否则 \((p_i-p_j)^2/(l_1-l_2)^2=0\)，（为什么采取这种计算方式，是因为在无法直接确定割边时，用这种计算方式能确保全部割边且只有割边会被加入权重之和），至于为什么等式最后还要除以 2 ，是因为等式最后的那种写法每条边会被遍历两次，每条割边权值会被计入两次，所以还要除以2。而： \[ \begin{equation} \begin{aligned} &amp; \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i-p_j)^2 = \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i^2-2p_ip_j+p_j^2) \\ &amp;= \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_i^2) + \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (p_j^2) - \sum \limits_{i=1}^n \sum \limits_{j=1}^n w(i,j) (2p_ip_j) \\ &amp;= \sum \limits_{i=1}^n p_i^2 (\sum \limits_{j=1}^n w(i,j)) + \sum \limits_{j=1}^n p_j^2 (\sum \limits_{i=1}^n w(i,j)) - 2\sum \limits_{i=1}^n \sum \limits_{j=1}^n p_iw(i,j) p_j \\ &amp;= p^TDp+p^TDp-2p^TWp = 2p^T(D-W)p = 2p^TLp \end{aligned} \end{equation} \]则：\(Cut(A,B)=\frac{p^TLp}{(l_1-l_2)^2}\) ，当 \(l_1=1,l_2=-1\) 时， \(\min Cut(A,B) = \min p^TLp \qquad s.t.\ p^Tp=n\) ，n 为图的顶点个数。由上可知，该最小割问题即是一个瑞利熵问题，只需求取 \(L\) 的特征值和特征向量。 对 \(L\) 的特征值进行从小到大排列（即取最小 k 个特征向量），若要分成 k 类，则需要取前 k 个特征值（除 0 以外）对应的特征向量，并归一化，将每一个特征向量按列排列构成一个 \(n \times k\) 的特征矩阵，对特征矩阵的行向量使用 k-means 或其它聚类算法，将 n 个行向量聚成 k 类，每一行都属于某一类，根据聚类结果为每个顶点分配相应的类标签，从而完成谱聚类。所以利用谱聚类求的解相当于是一个近似解，它将连续的 n 维问题离散化为 k 维问题，p 是一个 n 维的标签向量，标签值为 \(\{1,2,\cdots,k\}\) ，而 \(L\) 的特征向量中的元素并不是离散化的 \(\{1,2,\cdots,k\}\) ，无法直接用 \(L\) 的特征向量作为标签向量，所以需要将其离散化，对特征矩阵的行向量进行聚类，从而近似的生成标签向量；由于只取前 k 个特征向量，所以在对特征矩阵进行聚类时被聚类的 n 条数据只有 k 维，而本来 \(L\) 的特征向量至少有 n 个，即被聚类的 n 条数据至少有 n 维，所以从某种程度上，谱聚类同时也对数据进行了降维处理。※注： 推荐使用 SVD 代替特征值和特征向量的求取。至于谱聚类的更多性质，可参考：Spectral clustering。 因为有时候简单的全局最小割，可能并不是最优割，所以需要对割做一个归一化，即 Normalized Cuts ，简称 NCuts。图篇 同样，Shaun 还从图的构造开始，NCuts 所需要构造的图就是最普通的无向带权图，图的顶点由图像中像素点构成，相邻的像素点之间互相连接构成图的边。边的权值计算公式为： \[ w(i,j) = e^{\dfrac{-\|\mathbf{F}(i)-\mathbf{F}(j)\|_2^2}{\sigma_I}} * \begin{cases} e^{\dfrac{-\|\mathbf{X}(i)-\mathbf{X}(j)\|_2^2}{\sigma_X}} &amp; \text{if } \|\mathbf{X}(i)-\mathbf{X}(j)\|_2 &lt; r \\ 0 &amp; \text{otherwise}. \end{cases} \] 其中 \(\mathbf{X}(·)\) 是指该顶点的空间位置向量，即图像中像素点的坐标； \(\mathbf{F}(·)\) 可指像素点的强度（灰度）值，颜色向量或纹理值；\(\|\mathbf{X}(i)-\mathbf{X}(j)\|_2\) 表示向量的「2-范数」，即欧氏距离。当 \(\mathbf{F}(·)\) 表示强度（灰度）值时，NCuts 分割的是灰度图；当 \(\mathbf{F}(·)\) 表示颜色向量（一般在 HSV 颜色空间，有 \((h,s,v)\) 三个颜色分量）时，NCuts 分割的是彩色图。对于这个权值的计算说人话就是：当两个像素点之间的距离大于一个人为指定的 \(r\) 时（其实也就用这个 \(r\) 判断到底是连接 4 邻域还是连接 8 邻域，一般不会连接 8 邻域之外的像素点），就不连接，此时权值设为 0 ；否则，则计算两像素点颜色向量的 RBF 核的值和两像素点坐标向量的 RBF 核的值，并取其乘积作为权值。好了，Ncuts 的图的构成大致就是这样。接下来就是它的割法了。割篇 NCuts 中定义割 \(Cut(A,B)=\sum \limits_{i \in A,j \in B} w(i,j)\) ，定义 \(assoc(A,V)=\sum\limits_{i \in A,t \in V}w(i,t)\) 为子图 A 内所有像素点连接的所有边权重之和，最终的 NCuts 目标函数如下： \[ Ncut(A,B)= \frac{cut(A,B)}{assoc(A,V)}+\frac{cut(A,B)}{assoc(B,V)} \] 即通过除以两个子图内所有像素点连接的所有边权值之和对割做了个归一化处理。 令 \(\mathbf{W}\) 为图的邻接矩阵， \(\mathbf{D}\) 为其对应的度矩阵，\(L=D-W\) 为其对应的拉普拉斯矩阵，令 \(S_1 = assoc(A,V) = \sum\limits_{i \in A}D_{ii}\)，\(S_2 = assoc(B,V) = \sum\limits_{i \in B}D_{ii}\)，则 \(S = S_1+S_2=\sum\limits_{i \in A}D_{ii}+\sum\limits_{i \in B}D_{ii}=\sum D_{ii}= \sum \limits_{i=1}^n\sum \limits_{j=1}^n w(i,j)\) ，则：\(NCut(A,B)=\frac{p^TLp}{(l_1-l_2)^2}*(\frac{1}{S_1}+\frac{1}{S_2})\) ，其中向量 \(p\) 为 \(N=|V|\) 维的标签向量， \(p_i = \begin{cases} l_1 &amp; i \in A \\ l_2 &amp; i \in B\end{cases}\) ，令 \(l_1 = \sqrt{\frac{S_2}{S_1S}},l_2=-\sqrt{\frac{S_1}{S_2S}}\) ，则 \(NCut(A,B)=p^TLp\) ，此时 \(p^TDp=\sum p_i^2D_{ii}=\sum\limits_{i \in A}l_1^2D_{ii}+\sum\limits_{i \in B}l_2^2D_{ii}=l_1^2S_1+l_2^2S_2=1\) ，则可化为 \(NCut(A,B)=\frac{p^TLp}{p^TDp}\) ，即 \(\min NCut(A,B) = \min p^TLp \qquad s.t.\ p^TDp=1\) ，该式即为一个广义瑞利熵，只需要求出矩阵 \(D^{-\frac{1}{2}}LD^{-\frac{1}{2}}\) 的特征值和特征向量，按照谱聚类最后的聚类方式将顶点（像素点）聚成 k 类，从而完成图像的分割。而 NCuts 有个特殊的变换，具体如下： \[ \begin{equation} \begin{aligned} NCut(A,B) &amp;=\frac{p^TLp}{p^TDp}\xlongequal{p=D^{-\frac{1}{2}}x} \frac{x^T(D^{-\frac{1}{2}}LD^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= \frac{x^T(D^{-\frac{1}{2}}(D-W)D^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= \frac{x^T(D^{-\frac{1}{2}}DD^{-\frac{1}{2}})x}{x^Tx} - \frac{x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x}{x^Tx} \\ &amp;= I - \frac{x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x}{x^Tx} \end{aligned} \end{equation} \] 使用该变换可得出：\(\min NCut(A,B) = \max x^T(D^{-\frac{1}{2}}WD^{-\frac{1}{2}})x \qquad s.t.\ x^Tx=1\) ，这样可不求出拉普拉斯矩阵，直接求出 \(D^{-\frac{1}{2}}WD^{-\frac{1}{2}}\) 的特征值和特征矩阵即可，而此时在谱聚类最后聚类的时候要将其特征值从大到小排列（即取最大 k 个特征向量），取前 k 个特征值对应的特征向量构造特征矩阵进行聚类。附录 Ratio Cuts（RCuts） 和 NCuts 的目标函数差不多，两者间的差异就是：RCuts 是除以子图内顶点的个数；NCuts 是除以子图内所有顶点的边权值之和；最后变换完之后 RCuts 是个普通瑞利熵，而 NCuts 是个广义瑞利熵。具体的 RCuts 割法等以后有机会用到再写吧，毕竟子图顶点个数多不代表所占权重就大，而且在割时一般是基于权重的，所以一般而言 NCuts 的结果要比 RCuts 的结果要好。总结 由上文中应该可以看出 NCuts 与 Graph Cuts 需要构造的图是不一样，所使用的能量方程从形式上看也是完全不一样的（虽然本质上都是求“最小割”），其构成的图主要差别在于 Graph Cuts 多了 S 和 T 两个顶点，而这两个顶点由交互式获取，NCuts 不需要交互式，因此也没有这两个顶点，Ncuts 构造的图就相当于只由 Graph Cuts 的普通顶点和边界项 n-links 构成图，因此 Ncuts 没有 Graph Cuts 所谓的区域项 t-links ，也不需要求区域项 t-links 的权值。而这两种方法边界项 n-links 的权值求法都是差不多的，都是用 （高斯）RBF 核函数进行相似性度量，即 \(w_{\{i,j\}} \propto exp\left(-\frac{(I_i-I_j)^2}{2\sigma^2}\right)\) 。后记 后面查阅资料发现图割其实还有好几个方向（井底之蛙了o(╯□╰)o），等有机会把用图割做超像素分割的那篇论文看一下吧 😜 。 5 月份的时候自己抽空实现了一下该算法，发现效果很糟糕，分割效果很不理想，当然不排除 Shaun 代码有 BUG 的原因，或者是还有一些步骤或 trick 漏掉了 ╮(╯▽╰)╭。而且不管是用 svds 还是 eigs 其分割结果都是随机的，只能保证邻域内像素点大概在一起，但具体谁和谁在一起这就是随机的了，这导致每次运行程序都可能有不同的分割结果 _(´ཀ`」 ∠)_ ，后面发现分割结果随机应该是 k-means 的锅（与 svd 和 eig 无关），原因是因为 k-means 每次初始化 k 个种子点时都是随机的，这自然会导致每次分割结果不完全一致 o(╯□╰)o。参考资料[1] 【聚类算法】谱聚类(Spectral Clustering)[2] 谱聚类算法(Spectral Clustering)[3] 拉普拉斯矩阵（Laplace Matrix）与瑞利熵（Rayleigh quotient）（http://www.cnblogs.com/xingshansi/category/958994.html）[4] Normalized cuts and image segmentation 简单实现[5] 谱聚类（spectral clustering）原理总结 （http://www.cnblogs.com/pinard/category/894692.html）]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>segmentation</tag>
        <tag>clustering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图割算法之Graph Cuts浅见]]></title>
    <url>posts/c42ff8d4.html</url>
    <content type="text"><![CDATA[前言 以后可能需要用图割算法做一些事情，所以就简单阅读了一下图割算法中最基础的一篇论文，Boykov Y Y, Jolly M P. Interactive graph cuts for optimal boundary &amp; region segmentation of objects in ND images. Computer Vision, 2001. ICCV 2001. Proceedings. Eighth IEEE International Conference on. IEEE, 2001, 1: 105-112. 。图篇 图割算法（Graph Cuts），顾名思义，是基于图的一种图像分割方法，这里的图既是指数据结构中的图结构也是指数学中的图论，毕竟数据结构中的图结构也来自于数学中图论。既然是图，必然离不开图的构建，论文中图的构建如下，可以简称为 S/T 图：论文中图结构和普通的无向图 \(G=(V,E)\) 一样，该图也是由顶点集合 \(V\) 和边集合 \(E\) 构成，不一样的是，该图有两种顶点和两种边：第一种顶点是普通顶点。由图像中各像素点组成，每个顶点对应于图像中每个像素点。每两个邻域顶点，对应于图像中每相邻两个像素点（对2维图像来说，是8邻域；对3维图像来说，是26邻域），的连接就是一条边，这种边叫做 n-links (neighborhood links)。第二种顶点是两个终端顶点，代表目标（object）的 source terminal（简称 S）和代表背景（background）的 sink terminal（简称 T），每个终端顶点都与所有普通顶点相连，这种相连构成的边叫做 t-links (terminal links)。 设图像 \(P\) 中每个像素点为 \(p\)，则 \(p \in P\)，目标终端顶点 \(S\)，背景终端顶点 \(T\) ，则构建的图 \(G\) 中顶点集合可表示为：\(V = P \cup \{S,T\}\) ；每个 \(p\) 都有两种 t-links 边，分别为 \(\{p,S\}\) 和 \(\{p,T\}\) ，每个 \(p\) 与其邻域内像素 \(q\) 构成的 n-links 边为 \(\{p,q\}\) ，设 \(N\) 代表 n-links 边集合，即邻域边集合，则 \(\{p,q\} \in N\) ，则构建的图 \(G\) 中边集合可表示为：\(E = N \bigcup\limits_{p \in P} \{\{p,S\},\{p,T\}\}\) 。因为这构建的是一个无向带权图，所以还需要设定边的权值，论文中边的权值设定如下：边权值（代价，能量）区域\(\{p,q\}\)\(B_{\{p,q\}}\)\(\{p,q\} \in N\)\(\{p,S\}\)\(\lambda \cdot R_p(&quot;bkg&quot;)\)\(p \in P, p \notin O \cup B\)\(\{p,S\}\)\(K\)\(p \in O\)\(\{p,S\}\)0\(p \in B\)\(\{p,T\}\)\(\lambda \cdot R_p(&quot;obj&quot;)\)\(p \in P, p \notin O \cup B\)\(\{p,T\}\)0\(p \in O\)\(\{p,T\}\)\(K\)\(p \in B\)其中集合 \(O\) 代表确定为目标的像素点的集合，即在交互时手动标注为目标的像素点；集合 \(B\) 代表确定为背景的像素点的集合，即在交互时手动标注为背景的像素点；\(B_{\{p,q\}}\) 可以表示 {p,q} 不连续的惩罚因子，其正比于一个指数函数，具体为：\(B_{\{p,q\}} \propto exp\left(-\frac{(I_p-I_q)^2}{2\sigma^2}\right) \cdot \frac{1}{dist(p,q)}\) ，其中 \(I_p\) 和 \(I_q\) 代表像素 \(p\) 和像素 \(q\) 的像素值，\(dist(p,q)\) 代表其两像素点之间的距离。从 \(B_{\{p,q\}}\) 对应的函数中可以看出当两像素点之间的差异越大时，其权值越小；两像素点之间距离越大时，权值越小（这里对于二维图像来说，一般只考虑周围 8 邻域内像素点，因此可以简单认为相邻两像素点之间距离为 1）。\(R_p(&quot;bkg&quot;)\) 和 \(R_p(&quot;obj&quot;)\) 分别是指像素 p 分配给背景和前景目标的惩罚因子，该惩罚因子与像素 p 属于前景目标的概率 \(Pr(I|O)\) 和背景的概率 \(Pr(I|B)\) 有关，一般取概率的负对数值，具体如下：\(R_p(“obj”) = −lnPr(I_p|O)\) 和 \(R_p(“bkg”) = −lnPr(I_p|B)\) 。至于概率的计算方法可以用简单的直方图概率模型，因为 \(O\) 和 \(B\) 为手动标注的确定的前景目标和背景的像素点集合，因此可以分别统计其灰度直方图，再对直方图频数进行归一化得到分布概率直方图，将像素 p 与 背景分布概率直方图和前景目标概率分布直方图进行对比，即可得到其属于背景的概率和属于前景目标的概率（当然更好的一种计算前景和背景概率的方法是用高斯混合模型）。\(K\) 表示整个无向带权图中最大的权值，具体计算方法如下：\(K=1+\max\limits_{p \in P} \sum \limits_{q:\{p,q\} \in N} B_{\{p,q\}}\) ，即取图像中像素点邻域边权值之和的最大值再加 1 （对于二维图像而言，邻域边权值之和是指 8 邻域边权值之和，图像中每个像素点都有其邻域边权值之和，取所有像素点中的最大值），至于为什么要令 K 为整个无向带权图中权值最大值？请详见下文。至于其中的参数 \(\lambda\) 和 \(\sigma\) 论文中没有明确指定，在初始计算时可以将其置为 1，随后再慢慢调整。至此，整个 Graph Cuts 算法中关于图的构建已经完全确定，接下来就是割（cut）的算法了。割篇 割（cut）是构建的无向带权图中边集合 \(E\) 的一个子集 \(C\)，即割 \(C \subset E\) ，该 cut 的 代价（cost）可表示为：\(|C|=\sum \limits_{e \in C} W_e\)，即该割边集合的所有边权值之和。如果一个割，其包含的所有边的权值之和最小，那么这个割就称为最小割，也就是图割的结果。在图分割里，是要求两个终端顶点被分离开的，即最小割把图的顶点划分为两个不相交的子集 \(S\) 和 \(T\) ，其中 \(s∈S\)，\(t∈T\)，\(T=V/S\)。事实上，这两个子集对应于图像的前景像素集和背景像素集，也就相当于完成了图像分割。 割相关的算法有很多，eg：Max-flow/Min-cut、GrabCut、One cut、 Normalized cut、Ratio cut 等等，但是其最关键的地方在于能量方程（或称 代价函数，损失函数）的优化，能量优化的目的在于最小化能量函数，而最小化能量函数时取得割就是最小割，即图割的结果。论文中能量方程的定义如下： \[ E(A)= \lambda \cdot R(A)+B(A) \] 其中： \[ R(A)= \sum_{p \in P} R_p(A_p) \\ B(A)= \sum_{\{p,q\} \in N} B_{\{p,q\}} \cdot \delta(A_p,A_q) \\ 其中 \delta(A_p,A_q) = \begin{cases} 1 &amp; \text{if } A_p \neq A_q \\ 0 &amp; \text{otherwise}. \end{cases} \]其中令 \(A=(A_1,\cdots,A_p,\cdots,A_{|P|})\) 为二值向量，每个 \(A_p\) 可赋值为 “obj”（可用 1 表示前景） 或 “bkg”（可用 0 表示背景）；\(R(A)\) 表示区域项，即上文中的两种 t-links 边相连的图像像素点权值，代表像素点分配给 “obj” 或 “bkg” 的惩罚项，对应于 \(R_p(&quot;obj&quot;)\) 和 \(R_p(&quot;bkg&quot;)\) ，求和后即可得到 \(R(A)\) 。当像素点 p 属于前景目标的概率 \(Pr(I|O)\) 大于背景的概率 \(Pr(I|B)\) 时，由上文 \(R_p(A_p) = −lnPr(I_p|A_p)\) 可知，此时 \(R_p(&quot;obj&quot;)\) 小于 \(R_p(&quot;bkg&quot;)\) ，即当像素 p 更有可能属于目标时，将 p 归类为目标就会使能量 \(R(A)\) 小，也因此要取概率的负对数值，由此，如果所有像素点都能正确划分为前景和背景，则总能量会达到最小。当像素点 p 已经人为手动标注为确定的前景目标时，这时其与顶点 \(S\) 相连的边的权值为 K，为整个无向带权图中最大的权值，即能量也最大，此时就不可能被分割，这就是为什么要令 K 为整个无向带权图中权值最大值，而其与顶点 \(T\) 相连的权值为 0 ，能量也为 0，此时一定会被分割。\(B(A)\) 表示边界项，即上文中 n-links 边的权值，代表邻域像素点 \({p,q}\) 不连续的惩罚，当其差异越大时， \(B(A)\) 越趋近于 0，即当邻域像素点差异越大时，由上文 \(B_{\{p,q\}} \propto exp\left(-\frac{(I_p-I_q)^2}{2\sigma^2}\right) \cdot \frac{1}{dist(p,q)}\) 可知其权值越小，能量 \(B(A)\) 也越小，则越应该被分割。参数 \(\lambda\) 用来表示区域项和边界项的重要性，初始计算时同样可以将其置为 1。至于 \(\delta(A_p,A_q)\) 的个人理解为：当邻域像素点 \(p,q\) 被分配的二值变量不同时，即一个是前景另一个是背景，这时在进行能量计算时需要考虑连接亮点的边 \(\{p,q\}\) 的权值，否则可以不考虑其权值。最后，本文割的具体实施是采用基于「最大流/最小割」算法进行的，而「最大流/最小割」算法针对的是有向图，所以需要把本文 S/T 图的每条无向边都转化为一去一回的两条有向边。附录 该论文还有一个有意思的地方就是其证明了能量函数 E(A) 的值只与割 \(C\) 有关，最小割与最小化能量函数对应。证明过程如下：由上文可知，对于图像中每个像素点，割 \(C\) 切断且仅切断一条 t-links 边，即要么切断 \(\{p,S\}\) 边，要么切断 \(\{p,T\}\) 边，毕竟一个像素点不可能同时属于前景和背景，也不可能既不属于前景也不属于背景；不属于同一终端顶点相连的 n-links 边也会被割 \(C\) 切断，因为如果不断开，则整个图还是相连的，而如果属于同一终端顶点相连的 n-links 边不应该被割 \(C\) 切断，否则，该割就不是最小割。对于任意割 \(C\) ，可定义其对应的图像分割结果向量 \(A(C)\) ，如下： \[ A_p(C) = \begin{cases} &quot;obj&quot; &amp; \text{if } \{p,T\} \in C \\ &quot;bkg&quot; &amp; \text{if } \{p,S\} \in C \end{cases} \] 因此当 C 确定之后，分割结果 A 也就确定了。利用上文给出的边的权值计算方法结合定义的 A 可得出割的代价（cost）： \[ \begin{align} |C| &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) + \sum_{p \in O} \lambda \cdot R_p(A_p(C)) + \sum_{p \in B} \lambda \cdot R_p(A_p(C)) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \\ &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) +0 + 0 + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \end{align} \] 这里是因为 \(O \cap B = \emptyset\) ，而且如果确定像素点 p 属于前景或背景，则其割边的权值必为 0，相应的代价也为 0，eg：设 p 确定为前景，则必定断开 {p,T} 边，而 {p,T} 边的权值为 0。又因为：\(E(A) = \lambda \cdot R(A) + B(A)\) ，则： \[ \begin{align} E(A(C)) &amp;= \lambda \cdot R(A(C)) + B(A(C)) \\ &amp;= \sum_{p \in P} \lambda \cdot R_p(A_p(C)) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \\ &amp;= \sum_{p \notin O \cup B} \lambda \cdot R_p(A_p(C)) + \sum_{p \in O} \lambda \cdot R_p(&quot;obj&quot;) + \sum_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;) + \sum_{\{p.q\} \in N} B_{\{p,q\}} \cdot \delta((A_p(C)),A_q(C))) \end{align} \] 所以：\(|C| = E(A(C)) - \sum \limits_{p \in O} \lambda \cdot R_p(&quot;obj&quot;) - \sum \limits_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;)\)又因为对于标注确定的前景和背景，任意割 C 的 \(\sum \limits_{p \in O} \lambda \cdot R_p(&quot;obj&quot;)\) 和 \(\sum \limits_{p \in B} \lambda \cdot R_p(&quot;bkg&quot;)\) 都是完全确定不变的，可以令其为 const，则 \(E(A) = |C| + const\) ，当 \(C\) 取最小时，对应的 \(E(A)\) 也最小，即当割最小时，能量函数也最小。后记 虽说关于 Graph Cuts 网上已经有了无数篇博客对其进行描述，但其中或多或少感觉还是有些令人困惑的地方，于是写下本文将那些个人感觉有些困惑的地方重新梳理一下，再改变一下原论文的行文思路，个人感觉更好理解一点，不然一上来就是神马能量方程，简直一脸懵逼 (･ัω･ั) 。参考资料[1] Interactive Graph Cuts for Optimal Boundary and Region Segmentation of Objects in N-D ImageS[2] Graph Cuts[3] 图像分割之（二）Graph Cut（图割）[4] 图像分割算法——Graph Cuts[5] Interactive Graph Cuts for Optimal Boundary &amp; Region Segmentation of Objects in N-D Images 阅读笔记]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>segmentation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中static用法小结]]></title>
    <url>posts/b93d943b.html</url>
    <content type="text"><![CDATA[前言 static 是 C++ 中很常用的一个关键字，它的用法也很多，时常会将其弄混，索性做个小结，以免以后忘记了或者继续弄混 (｡･ω･｡)。预备篇 首先要了解程序中数据的存储形式，一般而言数据的存储形式有三种：栈区（stack）—— 由编译器自动分配释放，一般用来存放函数的参数值，局部变量的值等；堆区（heap）—— 由程序员分配释放，对应于对象的 new 或 malloc 和 delete 或 free，若程序员忘记释放，则在程序完全退出之后由操作系统回收；静态存储区（static）—— 在编译时由编译器分配，在程序完全退出时由操作系统回收，一般用来存放全局变量和 static 变量。 一般1声明的变量默认（如果变量类型，eg: int, double, … 等，前不加 static 或其它关键字）都是 auto 2的，其一般存放在栈区，生存周期就只在包围其的 { } 内，在包围其的 { } 外就无法使用该变量。而 static 存放在静态存储区，其生存周期是全局的，它要等整个程序完全退出时才会销毁，在程序运行过程中，每次调用 static 变量都保持上一次调用结束后的值。类中篇静态成员变量 类中的静态成员变量被该类的所有实例共享，也可以不通过类的实例使用，在使用时首先需要对其初始化，也必须对其进行初始化，因为类中的静态成员变量只是声明，而且，类中的静态成员变量和普通静态变量一样是在程序初始化的时候分配的，在程序完全退出时由操作系统回收。具体用法如下：12345678class Test&#123;private: static int s_value; // 注意，这里不能初始化！因为其不属于类对象，只属于类作用域，独立于该类的任何实例&#125;;// 在cpp中或类定义体外必须对它进行定义和初始化，因为在程序编译时首先执行的就是对其初始化并分配内存：int Test::s_value = 0; // 注意，这里没有static的修饰！总而言之就是：类中的静态成员变量可以简单理解为一个名为 Test::s_value 的全局变量，被所有该类的实例共用，但独立于该类的任何实例，只属于该类作用域，在类的定义中能且只能被声明，不能在类定义体中进行初始化，必须要在类定义体外被定义和初始化。静态成员函数 类中的静态成员函数和类中的静态成员变量有点类似，其在实现时不需要再加 static 修饰，同样能被该类的所有实例复用，同样只属于类作用域中的全局函数，同样不需要类的实例即可调用。类中的静态成员函数不能访问类的普通成员变量，只能访问类的静态成员变量（可以参考 C++静态成员函数访问非静态成员的几种方法 中的小 trick 访问普通成员变量，但非特殊情况不建议这么做）。具体用法如下：12345678910111213141516class Test&#123; private: static void func(int i); // 静态成员函数调用非静态成员变量方法 static void staticTest(Test *t) &#123; t-&gt;value += 1; &#125;private: int value;&#125;;// 在cpp中可以不通过类的实例进行调用：void Test::func(int);总而言之就是：类中的静态成员函数可以简单理解为一个名为 Test::func(int) 的全局函数，能被该类的所有实例复用，但独立于该类的任何实例，只属于该类作用域，可以不通过类的实例进行调用，也可以像普通成员函数一样通过类的实例进行调用。特定范围篇 为了使全局变量或函数只在特定 cpp 文件中起作用，需要在 cpp 文件中相应变量或函数前添加static 修饰，如下表：类型.h 文件中.cpp 文件中全局变量不使用 static 修饰，使用 extern 修饰使用 static 修饰全局函数不使用 static 修饰使用 static 修饰如果在头文件中声明 static 全局变量，则在包含该头文件的每个 .cpp 文件中都会生成一个独立的同名变量，而这种写法没有任何意义；如果在 .cpp 文件中不使用 static 声明全局变量，则该全局变量可能会被其它 .cpp 文件共享，也可能不会，造成该变量的不确定性；所以如果该全局变量要被所有 .cpp 文件共享，则需要在头文件中声明 extern 全局变量（eg：extern int g_value; // 注意，不要初始化值！），再在某个 .cpp 文件中单独进行定义和初始化（仅一次）（eg：int g_value = 0; // 不要extern修饰！），如此即可在每个 .cpp 文件中共享该全局变量；而若只想在单个 .cpp 文件中使用全局变量，则需要在该 .cpp 文件中全局范围类声明和定义 static int g_value = 0;，如此可保证该变量能且只能被该 .cpp 文件使用。如果在 .cpp 文件中不使用 static 声明全局函数，则该全局函数可能会被其它 .cpp 文件共享，也可能不会，这样在别的 .cpp 文件调用同名函数时可能会出现问题；而在头文件中使用 static 声明全局函数同样没有任何意义；所以如果要被多个 .cpp 文件复用，就将其声明移到头文件中，且不需要 static 修饰，而若只想在特定 .cpp 文件中使用该全局函数，则需要在声明时添加 static 修饰。最后，若是在 .hpp 文件中，则需要去除全局对象，将全局函数封装为类的静态方法。 PS：若在函数中使用 static 修饰变量，则该函数无法做到线程安全，在程序运行过程中，每次调用该函数，函数内的 static 变量都将保持上一次调用结束后的值，所以在函数中慎用 static 变量，除非需要这个特性。后记 写这篇文章的初衷在于时常需要 static 时老是忘记或弄混它的用法，不得不去网上查找，虽说网上的相关资料也有很多，但在找的时候还是有点麻烦，毕竟有很多不是自己需要的，而且自己总结一下对其理解又更深一些，下次要用时也能马上找到自己所需。参考资料[1] c/c++ static 用法总结（三版本合一）[2] C++中static的用法总结[3] C++ 类中的static成员的初始化和特点[4] C++静态成员函数访问非静态成员的几种方法这里的一般是指局部变量，若为全局变量则默认为 extern ，局部变量没有默认初值，其初值不确定，一般需要人为明确的赋初值，而全局变量默认初值为 0 ，一个比较好的编程习惯是声明一个变量就对其进行初始化（赋初值），尽量少用全局变量，全局变量显示声明 extern。↩※注：这里的 auto 与 C++11 中的意义不同，这里的 auto 指的是变量的存储形式，而不是 C++11 那种可以当做任意的变量类型，eg: int, double, std::vector&lt;std::vector&lt;double&gt;&gt;, …… ，与其对应的还有 extern 和 register 关键字，其中 register 关键字基本不用 。↩]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契数列的三种写法]]></title>
    <url>posts/8fb9f004.html</url>
    <content type="text"><![CDATA[前言 本文预示着 Shaun 开始着手准备找工作的事了，初步计划是先把『剑指Offer』上的题先做一遍，对照着 牛客网 上的题进行测试，尽量争取先把书上的题都能 AC 。一般定义的斐波那契数列数列为：0,1,1,2,3,5,8……（对应 \(F(0)=0, F(1)=1, F(2)=1, \cdots \cdots\)），用数学公式表示即为：\(F(n)=F(n-1)+F(n-2)\)。以下代码均用 C++ 实现，且均通过牛客的测试。循环写法1234567891011int fibonacci_loop(const unsigned int &amp;n)&#123; int fn = 0, f1 = 0, f2 = 1; for (int i = 0; i &lt; n; i++) &#123; fn = f1 + f2; f2 = f1; f1 = fn; &#125; return fn;&#125;递归写法123456789101112131415int fibonacci_recursive(const unsigned int &amp;n)&#123; if (n == 0) &#123; return 0; &#125; else if (n == 1 || n == 2) &#123; return 1; &#125; else &#123; return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2); &#125;&#125; ※注：这里 Shaun 在牛客上进行测试的时候，如果把 || n == 2 去掉的话，就没法通过，可见多递归一次花费的时间并不是线性增长的。尾递归写法 说来惭愧，这个概念还是在一个小学弟那里得知的，后面才逐渐了解并学会使用。 尾递归，简而言之就是最后会且仅会调用函数本身，递归调用函数之后没有其它的语句需要执行。就像上面的递归，它在递归调用之后还会执行加法运算，而尾递归在执行递归调用之后就没有其它的运算了。1234567891011int fibonacci_tailRecursive(unsigned int n, unsigned int f1 = 1, unsigned int fn = 0)&#123; if (n == 0) &#123; return fn; &#125; else &#123; return fibonacci_tailRecursive(n - 1, fn, fn + f1); &#125;&#125;总结 循环和尾递归花费的时间和空间都差不多，都要比普通的递归要小，普通的递归优势在于便于理解，代码好写，在不强调性能的前提下，用递归写法的代码可读性可能要好些。参考资料[1] 递归与尾递归总结（http://www.cnblogs.com/Anker/category/436371.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>posts/982ff584.html</url>
    <content type="text"><![CDATA[前言 Shaun 一直以为自己的搜索能力还可以，基本上自己想要的东西都能搜到，但是自从接触到这个世界，才知道自己大概只是个入门的水平（或者说连入门都说不上 /つ∇T)），和网上的一些大神相比还有比较大的差距，此文只是网上一些资料的整理，方便 Shaun 熟练使用，提高驾驶技巧，毕竟信息检索能力还是很重要的。搜索篇Google 可以通过添加一些字符优化搜索结果，如：搜索需求对应字符搜索社交媒体在用于搜索社交媒体的字词前加上 @。例如：@twitter。从搜索结果中排除特定字词在您要排除的字词前加上 -。例如：jaguar speed -car搜索完全匹配的结果为字词或短语加上引号。例如：&quot;tallest building&quot;。搜索通配符或未知字词在字词或短语中您要放置占位符的地方加上 *。例如：&quot;largest * in the world&quot;。在某个数字范围内执行搜索在两个数字之间加上 ..。例如：camera $50..$100组合搜索在各个搜索查询之间加上“OR”。例如：marathon OR race搜索特定网站在相应网站或域名前加上“site:”。例如：site:youtube.com或 site:.gov搜索相关网站在已知网址前加上“related:”。例如：related:time.com查找链接到某个特定网页的网页在已知网址前加上“link:”。例如：link:chongbuluo.com，就能查到哪些网页中包含链接chongbuluo.com查找在URL地址里有搜索关键词的页面在已知网址前加上“inurl:”。例如：inurl:chongbuluo，就能查到哪些网页 url 中包含链接chongbuluo查找在网页标题里有搜索关键词的页面在已知网址前加上“intitle:”。例如：intitle:chongbuluo，就能查到哪些网页标题中包含链接chongbuluo查找在网页正文里有搜索关键词的页面在已知网址前加上“intext:”。例如：intext:chongbuluo，就能查到哪些网页正文中包含链接chongbuluo查找pdf,xml,xls,txt,doc,csv等特定格式的结果在特定文件格式前加上filetype:。例如 filetype:pdf查找关键词的定义在关键词前加上define:。例如 define:搜索 经 Shaun 实测，以上大部分字符对百度搜索引擎同样适用。当然，最好的搜索方式是使用高级搜索，高级搜索可以进行一系列设置，比如时间范围，从而使搜索结果更精确，更容易得到想要的结果，不过在不十分确定的时候，不要做太多限制，不然可能会过滤掉关键信息。 Google 和百度对英文字符大小写都不敏感，搜索 QQ 与 qq 所得到的结果是一样的。搜索是否成功最关键的地方还是在于关键词的选取，关键词的选取这没什么好说的，只能提高搜索熟练度及对问题的把握程度了。 哦，还有一点忘记说了，就是在 Google 中如果要搜索那个的话，必须要在搜索设置里面关闭安全搜索功能，如果简体中文不能关闭安全搜索功能的话，就在搜索设置里将语言更换到繁体中文或英语应该就能关闭安全搜索功能。技巧篇 有时候第一个页面没有想要的结果，于是需要看第二个、第三个页面的结果，是不是觉得翻页很麻烦？（如果不觉得麻烦可以直接跳过🙄），但是设置增加搜索结果条目又会提高显示延迟，这时可以使用 Super_preloaderPlus_one 脚本（Chrome 中可以使用 AutoPagerize 插件），只需鼠标继续往下滚轮就会自动加载下页搜索结果，无需点击翻页。 当点击网页链接却出现404错误或无法显示页面的错误时，这个时候可以使用搜索引擎的「网页快照」功能，Google的这个功能点击搜索结果页面标题下的 绿色小三角 即可看到，百度的这个叫 百度快照，在搜索结果 url 地址的末端，即结果最后面。快照功能最强大的是 互联网档案馆（Internet Archive），又叫『网站时光倒流机器』（Wayback Machine），在知道链接的情况下，将链接输入到 Internet Archive 点击搜索就能查看历史快照了。 如果要查找某个网页出现的关键词，可以利用 Chrome 和 Firefox 的网页搜索功能，一般可以通过 Ctrl + F 去检索。也可以通过 F12 或「鼠标右键」（Firefox 点击「查看元素」，Chrome 点击「检查」，都是右键弹框最后一个选项）进入浏览器控制台开发工具，Chrome 中还要通过 Ctrl + F 才能检索元素，而 Firefox 可以直接搜索 HTML，输入要查找的关键词，回车即可。专项篇 图像搜索：这个一般用 Google 和百度的以图搜图就可以了，不过也有些特殊的图像搜索引擎，如 TinEye 等，当然，图像搜索最好还是安装相应的插件，在 Chrome 中可以安装一个叫 二箱 的插件，在 Firefox 中可以安装一个叫 Search by Image 的插件。 音乐搜索：这个如果能听出歌词的话就直接去搜索引擎上搜听到的歌词，如果无法听出歌词的话，可以尝试各大音乐软件的「听歌识曲」功能。 当然更精确的专项搜索一般只存在于特定的网站，这就要看对整个互联网的了解程度了，这里强推「虫部落-快搜」，不管是日常搜索需求还是特殊搜索需求基本都能满足。后记 尽量优先使用 Google，百度或许能找到自己想要的，但太浪费时间了，浪费时间就是浪费生命，不过能看到本文的看官，应该也是能熟练使用 Google 的了。参考资料[1] 如何在 Google 中进行搜索(https://support.google.com/websearch/#topic=3081620)[2] 优化网页搜索[3] 提高搜索能力的关键技巧（如何查找可靠出处）[4] 谷歌搜索技巧：搜索语法+隐藏彩蛋+高级设置]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17年走了，18年来了]]></title>
    <url>posts/7cebf0ee.html</url>
    <content type="text"><![CDATA[17 年走了，18 年也过了一个月，从这一个月看，18 年好像并没有对那个傻逼好一点。 17 年，也算是 Shaun 人生的一个转折点吧，既然是转折点，况且人也这么大了，不能像以前那样浑浑噩噩的过了，所以总要留下点什么东西吧。 17 年，从本科升入研究生，学校变了，所在城市却没变，所接触到的人好像变了，也好像没变，人还是那样的人。虽然早知读研是个坑，但还是转身继续扎入象牙塔中，但此时的象牙塔已不再是四年前的象牙塔，如果说四年前的象牙塔是白色的，那现在的就是黑色的，虽然是黑色的，但总比外面无尽的黑暗要好一点吧（或许有一点光明），至少是个塔，至少还稍微有点保护作用（心里安慰罢了）。黑色象牙塔和白色象牙塔最大的区别在于黑色象牙塔里有 boss，更NB的是 boss 拥有生杀予夺的权利，而且这种权利没人监管，也无法申述（或许是 Shaun 不知道？），除非有玉石俱焚的决心，否则很难反抗 。进入这黑色的象牙塔是为了逃避黑暗还是大势所趋， Shaun 认为自己或许两者皆有，在这黑色的象牙塔待两年，一来能在将来真正进入黑暗之前稍微接触一点黑暗，做好心理准备，起到一个缓冲的作用；二来能趁这两年提升一下自己，为自己在将来在黑暗中寻找那 些微光明 提供一点帮助，而且外界的黑暗也对黑色象牙塔中走出来的人好像更重视，这样不管是硬实力，还是软实力都能得到提升，这在黑暗中行走就更有的底气了，而且也更会有后劲，这样的话走进光明是不是更容易些？ 17 年，不管是求知方面还是视界方面都得到了一定程度的提升和扩大，或许在外面那无尽的黑暗中能提升的更快，扩大的更多也说不好。要说 Shaun 真正进入计算机的世界，应该是在大三上的时候吧，那时候才算是真正入门了，以前只能说是上过计算机的基础课，有什么问题还是没办法解决，还处在混沌阶段，没有方向，只能瞎摸。入门了之后感觉学计算机相关的东西就轻松多了，大多数问题都能找准方向，并一步一步的解决，当然最快的解决方案还是在 Google 上。大四做毕设的时候，从没接触过 OpenCV 的 Shaun ，借助网上的资料和书本，花了两个月的时间，还是勉强做了简单的手势识别系统，等以后时间把这个系统还是记录一下吧，好歹这其中基本上把经典计算机视觉中数字图像处理和传统机器学习结合的流程走了一遍，做完这个系统，Shaun 的计算机视觉也算是正式入门了。至于目前火热的深度学习，因为设备的原因，暂时还无法实践，不得不说这是一大憾事。 17年，人或许没接触到更多，但事倒是见得更多了。主要是因为接触到了一些更有趣的世界，或者说圈子，这其中强推 「Solidot」 ，该站点的资讯确实更新的很及时，科技界的一些大事都能及时公布出来，还有一个就是 「虫部落」，其快搜资源的聚合简直无敌了。网络如此之大，不知道还有多少有趣的事物等着 Shaun 去发现，每发现这些有趣的东西，就像是找到一个宝藏一样，想想就觉得很开心呢 🙃。 17 年，以一种看客的心态看了很多场戏。番茄界的用户资源之争，人肉的厉害之处，本是同根生，相煎何太急，最后有一人只能黯然退出，不知道是好是坏，毕竟 Shaun 也没用过那个工具及其提供的相关服务（或许以后会用到吧），但一家独大总归不是什么好事。在网上看到这样一句话：「鲁迅已逝，阿Q 重生」，『暴走大事件』对时事的调侃虽然很尖锐，但三观基本很正，坚持这样不容易啊，望其能唤醒一些 阿Q 吧。『新浪微博』，可以说是当前中国最大的信息聚合平台了，什么样的东西总能在微博上找到，国内大部分的戏也能在微博上看到，尤其是评论区更是有趣，但其信息和用户太杂了，良莠不齐，信息的价值密度比较低，总而言之，微博这种东西是需要带着脑子去逛的，微博上有些东西，Shaun 无法辨别，但借用鲁迅先生的一句话，「我向来是不惮以最坏的恶意来揣测中国人」。至于『知乎』，『V2EX』等，仁者见仁智者见智吧。 17 年，在网上看到这样一句话：“你可以不关心政治，但政治会来关心你”。政治上的事，无非是民主自由，但出于某些不可描述的原因就不谈了，无知是福 （๑乛◡乛๑）。但知道一些人和政策总是有好处的，虽然暗地里可能会违背，但估计没人敢明目张胆的违背吧，通过知道这些事，总能做点趋利避害的事吧。 17 年，已在实验室待了半年，还好有音乐这种东西可以麻痹一下，不然这两年就难熬喽。17 年，总归还是或知道或学会了很多有趣的东西。世界总的来说还是美好的，但这些美好的东西又有多少人能亲身经历，亲身享受。Shaun 能做的只有向这些美好的东西前进，接近，享受，顺便看看路上的风景，不管是好的还是坏的。17 年获得技能：视界开拓17 年获得成就：打开新世界的大门]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵的应用之图像仿射变换]]></title>
    <url>posts/e124baa1.html</url>
    <content type="text"><![CDATA[前言 好像很久没写新的东西了，主要是最近期末有一大堆事情要做，忙着写各种结课论文和复习数学，又加上最近忙着把《奥日与黑暗森林：终极版》剧情通关，这游戏不管是画面还是音乐都特别棒，但是对键盘用户太不友好了，不能改键位，需要一只手控制键盘，一只手控制鼠标，如果只是普通的键位就算了，它还要万恶的 shift 键配合，手残党完全吃不消 (´･ω･`)。最终死亡 658 次好歹剧情通关了，最后悔的是没把三段跳点出来 /つ∇T)。这些事情一搞完，Shaun 这不就又开始写了嘛（ 说什么也摆脱不了你拖延症晚期的事实 (￣ε(#￣)☆╰╮(￣▽￣///) ）。 选修的《数字图像处理》是也早结课了，虽然教的东西大都事前已经了解了，但是好像还没写过图像处理相关的 blog，所以谨以此篇最基础的 blog 来表示一下。预备篇 首先需要了解的是图像中坐标系和数学课本中常用的坐标系略有不同，图像中坐标系是以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴；而数学课本中常见的坐标系是以图像中心为原点，水平向右为 X 轴，垂直向上为 Y 轴。所以由图像中坐标 \((x,y)\) 转数学课本中常见的坐标 \((x&#39;,y&#39;)\) 的公式为 $x’ = x - C/2; y’ = -y + R/2; $ 其中 \(C\) 表示原图像总列数，即原图像宽度，\(R\) 表示原图像总行数，即原图像高度。X 轴Y 轴X 轴Y 轴数学坐标系图像坐标系 ※注：值得注意的是因为 MATLAB 和 OpenCV 的像素索引坐标形式为 (行坐标，列坐标) ，所以若以本文这样定的图像坐标，则图像中坐标 \((x,y)\) 对应的像素值为 \(f(y,x)\)。变换篇据 OpenCV 文档所说：一个任意的仿射变换都能表示为 乘以一个矩阵 (线性变换) 接着再 加上一个向量 (平移).综上所述, 我们能够用仿射变换来表示:旋转 (线性变换)平移 (向量加)缩放操作 (线性变换)你现在可以知道, 事实上, 仿射变换代表的是两幅图之间的 关系 .我们通常使用 矩阵来表示仿射变换. 考虑到我们要使用矩阵 和 对二维向量 做变换, 所以也能表示为下列形式: or 而在冈萨雷斯的《数字图像处理_第三版》里有：最常用的空间坐标变换之一是仿射变换，其一般形式如下： \[ \begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \textbf{T} = \begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix} \begin{bmatrix} t_{11} &amp; t_{12} &amp; 0 \\ t_{21} &amp; t_{22} &amp; 0 \\ t_{31} &amp; t_{32} &amp; 1 \end{bmatrix} \] 其中 \((v,w)\) 为原坐标，\((x,y)\) 为变换后的坐标，可根据变换矩阵 \(\textbf{T}\) 中的元素选择的值，对一组坐标点做尺度、旋转、平移或偏移变换。一些常见的变换矩阵及作用如下表：变换名称仿射变换矩阵\(\textbf{T}\)坐标公式恒等变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=w \end{cases}\)尺度变换\(\begin{bmatrix} c_x &amp; 0 &amp; 0 \\ 0 &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vc_x , \\ y=wc_y \end{cases}\)旋转变换（以逆时针为正）\(\begin{bmatrix} cos(\theta) &amp; sin(\theta) &amp; 0 \\ -sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)-wsin(\theta) , \\ y=vsin(\theta)+wcos(\theta) \end{cases}\)旋转变换（以顺时针为正）\(\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=vcos(\theta)+wsin(\theta) , \\ y=-vsin(\theta)+wcos(\theta) \end{cases}\)平移变换\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 \\ t_x &amp; t_y &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+t_x , \\ y=w+t_y \end{cases}\)偏移变换（水平）\(\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ s_h &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v+ws_h , \\ y=w \end{cases}\)偏移变换（垂直）\(\begin{bmatrix} 1 &amp; s_v &amp; 0 \\\ 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix}\)\(\begin{cases} x=v , \\ y=vs_v+w \end{cases}\)仿射变换的实现由两种方式：一种是 前向映射（Forward Mapping）：直接采用利用原图像坐标 \((v,w)\) 通过 \(\begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}\) 得到变换后的坐标 \((x,y)\)，使用前向映射会导致一些问题：可能会有多个像素坐标映射到输出图像的同一位置，也可能输出图像的某些位置完全没有相应的输入图像像素与它匹配，也就是没有被映射到，造成有规律的空洞（黑色的花纹状）；更好的一种方式是采用 反向映射（Inverse Mapping）：扫描输出图像的位置 \((x,y)\)，通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\)（其中 \(\textbf{T}^{-1}\) 为 \(\textbf{T}\) 的逆矩阵）计算输入图像对应的位置 \((v,w)\)，通过插值方法决定输出图像该位置的灰度值。 本文这里采取冈萨雷斯的《数字图像处理_第三版》的变换矩阵方式，毕竟所学的矩阵论也是将变换矩阵放在后面作为第二个因子。虽然仿射变换都有现成的 API 可以调用，而且速度一般要比自己写的要快，但是知其然终究也要知其所以然。 下面就以旋转变换为例了，因为尺度变换和平移变换只需要相应的缩放图像即可，而旋转变换不仅需要更改图像大小，还要确定旋转中心，而旋转中心一般以图像中心为标准。旋转变换 旋转变换首先需要确定旋转中心，若以图像左上角为旋转中心，则只需要像做尺度变换和平移变换那样通过 \(\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix}= \begin{bmatrix} x &amp; y &amp; 1\end{bmatrix}\textbf{T}^{-1}\) 做普通的变换即可。而以图像中心为旋转中心，首先需要做坐标变换，将以左上角为原点，水平向右为 X 轴，垂直向下为 Y 轴的图像坐标系转换为以图像中心为原点，水平向右为 X 轴，垂直向下为 Y 轴的数学坐标系；再做正常的旋转变换；随后再将数学坐标系转换为图像坐标系，所以图像中心为旋转中心的旋转变换总共需要做三次变换。这里就以图像中心为旋转中心为例，由于有三次变换，所以应该有三个变换矩阵相乘，设 图像坐标系==》数学坐标系的变换矩阵为 T1，旋转变换矩阵为 T2，数学坐标系==》图像坐标系的变换矩阵为 T3，设顺时针旋转角度为 \(\theta\) ，原图像宽度为 \(C\)，高度为 \(R\)，旋转后图像宽度为 \(W\)，高度为 \(H\)，则： \[ T1=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ -0.5C &amp; 0.5R &amp; 1 \end{bmatrix} T2=\begin{bmatrix} cos(\theta) &amp; -sin(\theta) &amp; 0 \\ sin(\theta) &amp; cos(\theta) &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{bmatrix} T3=\begin{bmatrix} 1 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 \\ 0.5W &amp; 0.5H &amp; 1 \end{bmatrix} \] 则旋转变换最终形式为：\(\begin{bmatrix} x &amp; y &amp; 1 \end{bmatrix}=\begin{bmatrix} v &amp; w &amp; 1\end{bmatrix} \textbf{T}=\begin{bmatrix} v &amp; w &amp; 1 \end{bmatrix}T1*T2*T3\)。※BTW：旋转变换中，旋转后图像宽度 \(W\)，高度 \(H\) 与 原图像宽度 \(C\)，高度 \(R\) 的关系为： \[ \begin{cases} H = |R*cos(\theta)| + |C*sin(\theta)| , \\ W = |C*cos(\theta)| + |R*sin(\theta)| \end{cases} \]插值篇 因为经过采用反向映射1方式的仿射变换之后，得到的原图像坐标 \((v,w)\) 往往不是整数值，所以无法知道其对应的像素值 \(f(w,v)\)，这时需要采取插值的方式近似估计该坐标位置的像素值。 常用的插值方法有最近邻插值（nearest neighbor interpolation）、双线性插值（bilinear interpolation）和双三次插值（bicubic interpolation），其中双三次插值在保持图像细节方面最好，但花费时间也最多，PS 中的消除锯齿和羽化效果好像就采用了双三次插值。 最近邻插值只考虑相邻最近的像素，双线性插值考虑相邻的 4 个像素点，双三次插值则考虑相邻的 16 个像素点。最近邻插值 最近邻插值最简单，将变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，直接对 \((v,w)\) 进行四舍五入得到相应的整数坐标 \((⌊v+0.5⌋,⌊w+0.5⌋)\)2，用该整数坐标的像素值近似估计 \((v,w)\) 的像素值，令 \(f(y,x)=f(⌊w+0.5⌋,⌊v+0.5⌋)\) ，从而得到变换后图像每个像素点的像素值。双线性插值 双线性插值是线性插值方法的一种扩展，它是 X 和 Y 两个方向上线性插值的组合。X 轴Y 轴P1P2P3P4Z1Z2P(v,w)如上图，设变换后图像的坐标 \((x,y)\) 通过反向映射得到原图像坐标 \((v,w)\) ，即点 \(P\) 正好处于四个像素点 \(P1(v_0, w_0)\)、\(P2(v_0+1, w_0)\)、\(P3(v_0+1, w_0+1)\)、\(P4(v_0, w_0+1)\) 的中间，其中 \(v_0=⌊v⌋\)，\(w_0=⌊w⌋\) ，点 \(P\) 对应的像素值为 \(f(P)\) 因为双线性插值即在 \(X\) 和 \(Y\) 两个方向进行线性插值，首先计算 \(X\) 方向的插值： \[ \begin{cases} \frac{f(P2)-f(P1)}{P2.x-P1.x}=\frac{f(Z1)-f(P1)}{Z1.x-P1.x} , \\ \frac{f(P3)-f(P4)}{P3.x-P4.x}=\frac{f(Z2)-f(P4)}{Z2.x-P4.x} \end{cases} \] 即： \[ \begin{cases} f(Z1)=\frac{Z1.x-P1.x}{P2.x-P1.x}f(P2)+\frac{P2.x-Z1.x}{P2.x-P1.x}f(P1) =(v-v_0)f(P2)+(v_0+1-v)f(P1), \\ f(Z2)=\frac{Z2.x-P4.x}{P3.x-P4.x}f(P3)+\frac{P3.x-Z2.x}{P3.x-P4.x}f(P4) =(v-v_0)f(P3)+(v_0+1-v)f(P4) \end{cases}\tag{1} \] 然后计算 \(Y\) 方向的插值： \[ \begin{equation} \frac{f(Z2)-f(Z1)}{Z2.y-Z1.y}=\frac{f(P)-f(Z1)}{P.y-Z1.y} \end{equation} \] 即： \[ \begin{equation} f(P)=\frac{P.y-Z1.y}{Z2.y-Z1.y}f(Z2)+\frac{Z2.y-P.y}{Z2.y-Z1.y}f(Z1) =(w-w_0)f(Z2)+(w_0+1-w)f(Z1) \end{equation}\tag{2} \] 结合式（1）和式（2）可得： \[ \begin{equation} f(P)=(v_0+1-v)(w_0+1-w)f(P1)+(v-v_0)(w_0+1-w)f(P2)+(v-v_0)(w-w_0)f(P3)+(v_0+1-v)(w-w_0)f(P4) \end{equation} \] 用矩阵形式可表示为： \[ f(P)=\begin{bmatrix} v_0+1-v &amp; v-v_0 \end{bmatrix} \begin{bmatrix} f(P1) &amp; f(P4) \\ f(P2) &amp; f(P3) \end{bmatrix} \begin{bmatrix} (w_0+1-w) \\ (w-w_0) \end{bmatrix} \] 即： \[ f(y,x)=f(w,v)=\begin{bmatrix} ⌊v⌋+1-v &amp; v-⌊v⌋ \end{bmatrix} \begin{bmatrix} f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) \\ f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) \end{bmatrix} \begin{bmatrix} (⌊w⌋+1-w) \\ (w-⌊w⌋) \end{bmatrix} \]双三次插值X 轴Y 轴P11P(v,w) 如上图，双三次插值需要考虑相邻16个像素（4×4），用双三次插值重采样的图像更平滑并且更能保留图像细节，在这三种插值算法中，双三次插值效果最好，但处理速度最慢。同样设变换后图像的坐标 \((x,y)​\) 通过反向映射得到原图像坐标 \((v,w)​\) ，与其左上角相邻最近的 点P11 坐标则为 \((⌊v⌋,⌊w⌋)​\) ，该插值方法需要选取一个合适的插值基函数，参照维基百科 Bicubic interpolation 的一般为： \[ W(x) = \begin{cases} (a+2)|x|^3-(a+3)|x|^2+1 &amp; \text{for } |x| \leq 1, \\ a|x|^3-5a|x|^2+8a|x|-4a &amp; \text{for } 1 &lt; |x| &lt; 2, \\ 0 &amp; \text{otherwise}, \end{cases} \] 其中 \(a\) 一般取 -0.5 、-0.75 或 -1；则：\(f(y,x)=f(w,v)=A*B*C\) ，其中： \[ A=\begin{bmatrix} W( v-(⌊v⌋-1) ) &amp; W(v-⌊v⌋) &amp; W( (⌊v⌋+1)-v ) &amp; W( (⌊v⌋+2)-v ) \end{bmatrix} \\ B=\begin{bmatrix} f(⌊w⌋-1,⌊v⌋-1) &amp; f(⌊w⌋,⌊v⌋-1) &amp; f(⌊w⌋+1,⌊v⌋-1) &amp; f(⌊w⌋+2,⌊v⌋-1) \\ f(⌊w⌋-1,⌊v⌋) &amp; f(⌊w⌋,⌊v⌋) &amp; f(⌊w⌋+1,⌊v⌋) &amp; f(⌊w⌋+2,⌊v⌋) \\ f(⌊w⌋-1,⌊v⌋+1) &amp; f(⌊w⌋,⌊v⌋+1) &amp; f(⌊w⌋+1,⌊v⌋+1) &amp; f(⌊w⌋+2,⌊v⌋+1) \\ f(⌊w⌋-1,⌊v⌋+2) &amp; f(⌊w⌋,⌊v⌋+2) &amp; f(⌊w⌋+1,⌊v⌋+2) &amp; f(⌊w⌋+2,⌊v⌋+2) \end{bmatrix} \\ C=\begin{bmatrix} W( w-(⌊w⌋-1) ) \\ W(w-⌊w⌋) \\ W( (⌊w⌋+1)-w ) \\ W( (⌊w⌋+2)-w ) \end{bmatrix} \]即： \[ f(y,x)=f(w,v)= \sum\limits_{row=-1}^2\sum\limits_{col=-1}^2f(⌊w⌋+row,⌊v⌋+col)W(row-(w-⌊w⌋))W(col-(v-⌊v⌋)) \] 另附：网上也有人中间那个矩阵 \(B\) 是本文中间矩阵 \(B\) 的转置，经过下文实践，感觉效果差不多，但从理论上来说，应该本文这样写才是对的吧🤔。Lanczos 插值 Lanczos 插值和双三次插值本质上差不多，不同的是插值权重基函数不一样，Lanczos 插值算法的基函数为： \[ L(x) = \begin{cases} 1 &amp; \text{for } x = 0, \\ a*sin(\pi x)sin(\pi x/a)/(\pi x)^2 &amp; \text{for } 0 &lt; |x| \leq a, \\ 0 &amp; \text{otherwise}, \end{cases} \] 其中 a 代表插值窗口半径，若 a = 2，则代表取周围 4×4 邻域像素点进行插值，和双三次插值除权重不一样外其它都一样，此时适用于对图像下采样（缩小），若 a = 3，则代表取周围 9×9 邻域像素点进行插值，此时适用于对图像上采样（放大），OpenCV 的 INTER_LANCZOS4 插值参数就代表取周围 8×8 邻域的像素点进行插值。实践篇 本次实践采用 Matlab R2016b，具体 matlab 实现代码为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849clc;clear;close all;img = imread('lena_gray.jpg'); % 读取图像[R, C] = size(img); % 获取图像大小theta = 45 * pi / 180.0; % 旋转角度H = ceil(abs(R*cos(theta)) + abs(C*sin(theta))); % 变换后图像的高度W = ceil(abs(C*cos(theta)) + abs(R*sin(theta))); % 变换后图像的宽度res = zeros(H, W); % 构造结果矩阵。每个像素点默认初始化为0（黑色）T1 = [1 0 0; 0 -1 0; -0.5*C 0.5*R 1]; % 将原图像坐标映射到数学笛卡尔坐标T2 = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; 0 0 1]; % 数学笛卡尔坐标下顺时针旋转的变换矩阵T3 = [1 0 0; 0 -1 0; 0.5*W 0.5*H 1]; % 将数学笛卡尔坐标映射到旋转后的图像坐标T = T1*T2*T3;inv_T = inv(T); % 求逆矩阵% inv_T = [cos(theta) -sin(theta) 0; sin(theta) cos(theta) 0; -0.5*W*cos(theta)-0.5*H*sin(theta)+0.5*C 0.5*W*sin(theta)-0.5*H*cos(theta)+0.5*R 1];for y = 1 : H % 变换后图像的纵坐标，行，高 for x = 1 : W % 变换后图像的横坐标，列，宽 original_coordinate = [x y 1] * inv_T; % 矩阵乘法 v = original_coordinate(1); % 原图像的横坐标，列，宽 w = original_coordinate(2); % 原图像的纵坐标，行，高 % 变换后的位置判断是否越界 if v&gt;=1 &amp;&amp; w&gt;=1 &amp;&amp; v&lt;=C &amp;&amp; w&lt;=R res(y, x) = img(round(w), round(v)); % 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） % ------------- 双线性插值（bilinear interpolation）----------------- left = floor(v); right = ceil(v); top = floor(w); bottom = ceil(w); dC = v-left; % 列偏差 dR = w-top; % 行偏差 res(y, x) = (1-dC)*(1-dR)*img(top, left) + dC*(1-dR)*img(top,right) + (1-dC)*dR*img(bottom, left) + dC*dR*img(bottom, right); % ------------- 双三次插值（bicubic interpolation） ------------------------- if left&gt;=2 &amp;&amp; top&gt;=2 &amp;&amp; left&lt;=(C-2) &amp;&amp; top&lt;=(R-2) img = double(img); MA = [bicubic(1+dC) bicubic(dC) bicubic(1-dC) bicubic(2-dC)]; MB = [img(top-1,left-1) img(top,left-1) img(top+1,left-1) img(top+2,left-1); img(top-1,left) img(top,left) img(top+1,left) img(top+2,left); img(top-1,left+1) img(top,left+1) img(top+1,left+1) img(top+2,left+1); img(top-1,left+2) img(top,left+2) img(top+1,left+2) img(top+2,left+2)]; % MB = MB'; % 求转置矩阵 MC = [bicubic(1+dR); bicubic(dR); bicubic(1-dR); bicubic(2-dR)]; res(y, x) = MA*MB*MC; end end endend;figure, imshow(uint8(res)); % 显示图像BiCubic 基函数 Matlab 代码为：1234567891011121314function W = bicubic(x)%bicubic 双三次插值基函数a = -1; % 默认取a为-1x1 = abs(x);x2 = x1*x1;x3 = x1*x2; if x1 &lt;= 1 W = 1 - (a+3)*x2 + (a+2)*x3;elseif x1&gt;1 &amp;&amp; x1&lt;=2 W = -4*a + 8*a*x1 - 5*a*x2 + a*x3;else W = 0;end 旋转变换中感觉插值的作用没体现出来，以肉眼来看感觉三种插值方法的效果差不多，可能是 Shaun 选取的示例不好，为了体现插值效果，应该采用尺度变换（缩放变换）的。以上代码改为尺度变换也简单，自定义图像缩放后的宽高，以两倍为例，H = R * 2; W = C * 2;，再将旋转变换矩阵改为尺度变换矩阵，尺度变换矩阵中 \(c_x=W/C；c_y=H/R\)。为了便于理解，Shaun 对代码就不进行优化了（其实是你懒吧 _(:з」∠)_）。后记 本文算是数字图像处理中最基础的知识了，但 Shaun 在写时还是查阅了大量相关的资料，有些地方理解的还不是很透彻，行文思路有点混乱 ╮(╯▽╰)╭。本来是不想使用图片的，但本文不用图片很难理解清楚，又为了不使用外部图，最后只得参考 SVG 教程 和 如何创建SVG箭头和polymarker——marker元素 采用 SVG 绘制相应图片了。等有时间再把用 OpenCV 实现的 C++ 代码也贴上吧。最后再感叹一下 Matlab 确实是做科研的好工具（°Д°）Ъ，吐槽一下 MathJax 排版好痛苦啊，太多需要转义符\的地方了吧。，搞错了 Σ(ﾟдﾟ;)，这主要和 markdown 渲染有关，hexo 默认的 markdown 渲染插件 hexo-renderer-marked 太普通了，有些东西根本没办法渲染或者渲染有问题 （╯‵□′）╯︵┴─┴，Shaun 最后决定使用 hexo-renderer-pandoc 插件渲染 markdown，这样就完美了 (๑•̀ㅂ•́)و✧ 。 至于具体怎么使用 hexo-renderer-pandoc 替换默认的渲染器可参考：如何禁止 hexo 在 html 代码里插入&lt;br&gt;标签?。具体如下：12345# 1、安装 Pandoc，可以不顺带安装 MiKTex# 2、卸载默认渲染器npm uninstall hexo-renderer-marked --save# 3、安装 hexo-renderer-pandocnpm install hexo-renderer-pandoc --save附录 挖的坑总是要填的，呐，这就是用 OpenCV 实现的旋转变换，实现语言为 C++ ：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;opencv2/opencv.hpp&gt;#define M_PI 3.14159265358979323846double bicubic(double x)&#123; // bicubic 双三次插值基函数 int a = -1; // 默认取a为 - 1 double x1 = fabs(x); double x2 = x1*x1; double x3 = x1*x2; if (x1 &lt;= 1) &#123; return 1 - (a + 3)*x2 + (a + 2)*x3; &#125; else if (x1 &gt; 1 &amp;&amp; x1 &lt;= 2) &#123; return -4 * a + 8 * a*x1 - 5 * a*x2 + a*x3; &#125; else &#123; return 0; &#125;&#125;int main(int argc, char *argv[])&#123; cv::Mat img = cv::imread("../Data/lena_gray.jpg", 0); // 以灰度模式读取图片 int R = img.rows; // 获取原图像高度 int C = img.cols; // 获取原图像宽度 double theta = 45 * M_PI / 180.0; // 旋转角度 int H = ceil(fabs(R*cos(theta)) + fabs(C*sin(theta))); // 变换后图像的高度 int W = ceil(fabs(C*cos(theta)) + fabs(R*sin(theta))); // 变换后图像的宽度 cv::Mat res = cv::Mat::zeros(H, W, CV_8UC1); // 构造结果矩阵。每个像素点默认初始化为0（黑色） cv::Mat T1 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; 1, 0, 0, 0, -1, 0, -0.5*C, 0.5*R, 1); // 将原图像坐标映射到数学笛卡尔坐标 cv::Mat T2 = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, 0, 0, 1); // 数学笛卡尔坐标下顺时针旋转的变换矩阵 double t3[3][3] = &#123; &#123; 1, 0, 0 &#125;, &#123; 0, -1, 0 &#125;, &#123; 0.5*W, 0.5*H, 1 &#125; &#125;; // 将数学笛卡尔坐标映射到旋转后的图像坐标 cv::Mat T3 = cv::Mat(3, 3, CV_64FC1, t3); cv::Mat T = T1*T2*T3; cv::Mat inv_T = T.inv(); // 求逆矩阵 //cv::Mat inv_T = (cv::Mat_&lt;double&gt;(3, 3) &lt;&lt; cos(theta), -sin(theta), 0, sin(theta), cos(theta), 0, -0.5*W*cos(theta) - 0.5*H*sin(theta) + 0.5*C, 0.5*W*sin(theta) - 0.5*H*cos(theta) + 0.5*R, 1); for (int y = 0; y &lt; H; y++) &#123; for (int x = 0; x &lt; W; x++) &#123; cv::Mat point = (cv::Mat_&lt;double&gt;(1, 3) &lt;&lt; x, y, 1); cv::Mat original_coordinate = point * inv_T; // 矩阵乘法 double v = original_coordinate.at&lt;double&gt;(0, 0); // 原图像的横坐标，列，宽 double w = original_coordinate.at&lt;double&gt;(0, 1); // 原图像的纵坐标，行，高 // 变换后的位置判断是否越界 if (v &gt;= 0 &amp;&amp; w &gt;= 0 &amp;&amp; v &lt;= C - 1 &amp;&amp; w &lt;= R - 1) &#123; res.at&lt;uchar&gt;(y, x) = img.at&lt;uchar&gt;(round(w), round(v)); // 用原图像对应坐标的像素值填充变换后的图像（最邻近插值） // ------------ - 双线性插值（bilinear interpolation）---------------- - int left = floor(v), right = ceil(v), top = floor(w), bottom = ceil(w); double dC = v - left; // 列偏差 double dR = w - top; // 行偏差 res.at&lt;uchar&gt;(y, x) = (1 - dC)*(1 - dR)*img.at&lt;uchar&gt;(top, left) + dC*(1 - dR)*img.at&lt;uchar&gt;(top, right) + (1 - dC)*dR*img.at&lt;uchar&gt;(bottom, left) + dC*dR*img.at&lt;uchar&gt;(bottom, right); // ------------ - 双三次插值（bicubic interpolation）------------------------ - if (left &gt;= 1 &amp;&amp; top &gt;= 1 &amp;&amp; left &lt;= (C - 3) &amp;&amp; top &lt;= (R - 3)) &#123; cv::Mat MA = (cv::Mat_&lt;double&gt;(1, 4) &lt;&lt; bicubic(1 + dC), bicubic(dC), bicubic(1 - dC), bicubic(2 - dC)); cv::Mat MB = img(cv::Rect(left - 1, top - 1, 4, 4)); // 提取当前相邻区域16个像素点做插值 MB.convertTo(MB, CV_64FC1); // 变换为浮点型数据 MB = MB.t(); // 求转置矩阵 cv::Mat MC = (cv::Mat_&lt;double&gt;(4, 1) &lt;&lt; bicubic(1 + dR), bicubic(dR), bicubic(1 - dR), bicubic(2 - dR)); cv::Mat result = MA*MB*MC; res.at&lt;uchar&gt;(y, x) = static_cast&lt;uchar&gt;(result.at&lt;double&gt;(0, 0)); &#125; &#125; &#125; &#125; cv::imshow("result", res); // 显示变换后图像 cv::waitKey(0); return 0;&#125; 以上 C++ 代码在 VS2013 下能完美运行，不管是用 OpenCV-2.4.11 还是 OpenCV-3.2.0。其实完全理解的话，不管用什么工具都能实现，只是看哪个工具方便一点而已，就这个而言，感觉 Matlab 要方便很多，Shaun 就不继续挖 Python 的坑了，毕竟如果要用 Python 实现其实还是用 OpenCV，只是用 OpenCV Python 版的接口而已。参考资料[１] 第4章 图像几何变换[２] 图像旋转原理及实现[３] 仿射变换（http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/tutorials.html）[４] 图像处理常用插值方法总结[５] Wikipedia Bilinear interpolation[６] 双线性插值算法的详细总结[７] Wikipedia Bicubic interpolation[８] 双三次插值(bicubic interpolation)原理及MATLAB源码实现[９] 图像缩放】双立方（三次）卷积插值（https://dailc.github.io/blog/tags.html#%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95）为啥不说前向映射呢？这是因为若原图像坐标 \((v,w)\) 通过前向映射方式得到变换后图像的坐标 \((x,y)\) ，而且这个坐标为小数的话，一般采用四舍五入的方式得到变换后图像对应的整数坐标 \((⌊x+0.5⌋,⌊y+0.5⌋)\)，令 \(f(⌊y+0.5⌋,⌊x+0.5⌋)=f(w,v)\) 。↩\(⌊x⌋\) 表示向下取整，称为 Floor，指的是小于或等于 \(x\) 的最大整数；\(⌈x⌉\) 表示向上取整，称为 Ceil，指的是大于或等于 \(x\) 的最小整数，\(eg：⌊5.6⌋ = 5，⌊-5.6⌋ = -6；⌈5.6⌉ = 6，⌈-5.6⌉ = -5。\)↩]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>opencv</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本人常用小工具安利]]></title>
    <url>posts/aef52be2.html</url>
    <content type="text"><![CDATA[前言 由于 Shaun 目前使用最多的是 Windows 系统，所以以下推荐的软件基本都是 Windows 下的软件，全凭 Shaun 主观感觉推荐，也算是个人备份吧。 首先推荐的自然是装机软件 ULTRAISO，下个绿色版就好，只有 1M 多一点 或者 Rufus 好像也不错。下载 Windows 镜像的地方推荐为：MSDN，I Tell You。接下来就是正式的软件推荐篇了：大众篇 首先推荐浏览器：首选的自然是 Chrome 和 Firefox，还有一个比较偏门的是 Tor Browser（如果在一些特殊时段，各种番（fang）茄（qiang）工具都失效的情况下，这个可以临时用用）。推荐完浏览器，自然也要玩浏览器，这里极为推荐的是脚本管理插件：Tampermonkey（支持多种浏览器），有 Tampermonkey 和没 Tampermonkey 是两种浏览体验，会用 Tampermonkey 和没用 Tampermonkey 的是两个世界的人（ᖗ乛◡乛ᖘ），Tampermonkey 是通过 Javascript 改变浏览器的，顺便推荐几个常用的脚本：1、护眼脚本；2、Super_preloaderPlus_one；3、解除百度云大文件下载限制（这个配合 IDM 食用效果最佳）；4、贴吧全能助手；5、破解VIP会员视频集合；6、Cat Mouse Translation；7、解除B站区域限制；8、bye-flash-hello-html5 | 再见flash 你好html5；９、网页限制解除(改)。再顺便说一下这两个浏览器中一些比较好用的插件和好看的主题吧。Firefox 最新版的插件 Shaun 目前还没发现几个好用的，但是 Adblock Plus 绝对是必须要装的，Firefox 的主题 Shaun 目前在用为 Blue space 2 ；而 Chrome 中好用的插件就有很多了，首先自然也是 Adblock Plus，有一个 AutoPagerize 插件可以替代 Super_preloaderPlus_one 脚本，还有一个 划词翻译 可以替换 Cat Mouse Translation 脚本，由于 Chrome 没有撤销关闭的标签按钮，只能通过快捷键 Crtl+Shift+T 操作，对于 Shaun 这种习惯用 Firefox 恢复按钮的人来说这很不人性化，所以只能使用 SimpleUndoClose 插件来代替了，当然番茄之所以推荐使用 Chrome 有很大一部分原因在于 Chrome 中有一代理神器 Proxy SwitchyOmega，好像也正在开发 Firefox 版的 Proxy SwitchyOmega，已经在 Firefox 测试版上使用了，Chrome 的主题 Shaun 目前在用的为 Blue Space Sunset Chrome Theme ，浏览器相关的东西就推荐到这里了，接下来推荐下载工具吧。附浏览器使用小技巧，有时点击链接不会新建标签页，只是在原标签页刷新，这不符合国人的使用习惯，这时可按住 Crtl 键再点击链接，这时会强制使用新标签页打开链接。 下载工具首推的自然是 IDM，全称是：Internet Download Manager；种子和磁力链接的下载工具推荐 μtorrent 或者 BitTorrent，好像还有一个 qBittorrent ；至于迅雷，勉强推荐个极速版吧，最后一版为 ThunderSpeed1.0.35.366。还有一款免费的下载工具 Free Download Manager 也还不错，可以一定程度上替代 IDM。 解压缩工具首推的是 Bandizip（ta家的图片浏览器 Honeyview 也还不错），其次 7-Zip，最后是 WinRAR（主要是最近版本的广告太恼火，好像 5.2 版本没广告），BTW：IDM 下载百度云的大文件可能会造成部分文件损坏，这时可能需要 WinRAR 的修复工具去修复受损的压缩文件（具体操作为用 WinRAR 打开损坏的压缩文件，选中菜单栏的“工具”==》“修复压缩文件”），才能解压出正常文件。※附：其实 WinRAR 官方也有无广告版的，只是下载链接被隐藏，这位大佬：武文隹山发现了，具体可参考：WinRAR官方不带弹窗广告的简体中文版，其隐藏的链接为：WinRAR5.4官方无广告简体中文版64位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x64-540sc.exeWinRAR5.4官方无广告简体中文版32位 下载链接：http://www.win-rar.com/fileadmin/winrar-versions/sc20160819/wrr/winrar-x32-540sc.exeWinRAR5.5官方不带弹窗广告的简体中文版，具体链接为：WinRAR v5.50 简体中文官方版（试用版，注册后没有广告弹窗！）32位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/wrar550sc.exe64位：http://www.win-rar.com/fileadmin/winrar-versions/sc20170830/wrr/winrar-x64-550sc.exe列位看官应该从下载链接中发现了其中的规律（๑乛◡乛๑）。 拼音输入法，Shaun 使用的是 搜狗拼音智慧版，搜狗拼音的皮肤 Shaun 选择 雨后莲色，不过有人说 Win10 自带的微软拼音也还行。 至于清理垃圾的可以用 Advanced SystemCare（ASC），也可以用 CCleaner ，至于 Win10 不需要装杀毒软件，国内的的什么 360 全家桶、百度全家桶、腾讯全家桶（诶，好像就差阿里全家桶了，什么时候阿里再来一个，就装个 BAT 全家桶 （๑乛◡乛๑））可以丢了 （(╯°□°）╯︵ ┻━┻）。 QQ 还是用 TIM 版吧。 播放器推荐的是 Potplayer。不过有一款解码工具叫 终极解码，可以充当播放器（很多人确实把它当播放器用，比如 Shaun （๑乛◡乛๑））。 音乐软件 Shaun 用 网易云音乐（等升到 10 级就把它卸了，只听本地音乐）。 PDF 阅读器还是推荐 Adobe Acrobat_DC，毕竟能和 Office 联合使用，有时 Word 转 PDF 需要加密就靠它了。 截图工具推荐 FastStone Capture（FSCapture），国人的 Snipaste 也非常不错。小众篇 远程控制工具当然推荐 TeamViewer。 文件管理相关强推 搜索工具 Everything 和文件资源管理器（即 Windows 快捷键「Win+E」打开的「我的电脑」）增强工具 Listary （有个开源实现的同类产品 Wox ，还有国产的 火萤酱 也很不错，而且功能更全且附带一些实用小工具），这两个工具有重叠的地方，如果硬要只装一个的话推荐后者。还有一个文件管理器增强工具 QTTabBar ，可以为文件管理器增加标签页，类似于浏览器标签页那种，当然还有其它一些功能。当然 Windows 下最强的文件管理器当属 Total Commander，只是学习成本略高。 快捷键程序快速启动工具 RunAny ，修改配置文件可以通过快捷键快速启动任意程序，以任意程序打开文件，该工具集成 Everything 和支持 AutoHotkey 热键格式。 Office Tabs 给 Microsoft Office 添加标签页界面，类似于浏览器标签页那种，以实现文档快速切换。再推荐一些程序员的工具吧。 首先当然是编辑器（可别和编译器搞混了），Shaun 就不加入 Vim 和 Emacs 的党争了，就直接推荐 VS Code吧（巨硬出品，必属精品（^_^））。 Windows 下的命令行没一个好用的，要真矮子里面挑高个的话，只能推荐 Git Bash 了，其实以前有个 Babun 也挺好用的，可惜早已停止更新。但是 Git Bash 有时输出中文会乱码，Windows 下真正的命令行神器是 Cmder，完整包直接集成 Git for Windows，也就是包含 Git Bash，mini 包只包含基本命令行工具，关于 Cmder 的一些设置和用法可参考 Win下必备神器之Cmder，解压之后为了方便通过右键菜单使用 Cmder，需要在配置好之后以管理员方式执行 Cmder.exe /REGISTER ALL 命令。 Markdown 编辑器推荐的是 Typora，不过现在还是 Beta 版，也还能使用，期待正式版，希望到时即使收费的话也能继续推出一个免费版。（推出正式版看看效果怎么样吧，如果真的很不错就去支持一下，如果改进不大的话我还是老老实实继续用 beta 版吧）。 在 VS 下写 C++ 自然少不了 Visual Assist X 这款插件，用 OpenCV 的自然少不了 ImageWatch（ VS2017版ImageWatch ）这款神器。 编程的字体 Shaun 目前在用是 Arial monospaced for SAP(优化版)（http://www.vimer.cn/archives/396.html/comment-page-1），背景颜色使用护眼色：R: 204，G: 232，B: 207。 代理工具：Shaun 使用的是 XX-Net 和 Lantern，非特殊情况还是很好用的，还有比较推荐的是 赛风。偏门篇 鼠标手势软件 WGestures，可以利用鼠标手势做一些前进后退，复制粘贴搜索等简单操作。 Tickeys，让打字发出音效。 Windows 系统优（mei）化工具 Dism++ ，桌面美化工具可以用雨滴桌面 Rainmeter，或软媒魔方绿色版（※注：软媒魔方一定要是绿色版），桌面美化工具需要占用一定的配置，配置不高的老电脑还是别用比较好。后记如果以后碰到更多有意思的小东西再和大家分享吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决无法打开某个网页问题]]></title>
    <url>posts/376168c6.html</url>
    <content type="text"><![CDATA[前言 Shaun 最近在某台 Win10 的电脑中打开网页 https://www.typora.io/ 时出现了问题，一直出现无法连接现象。问题篇Chrome 中出现：未连接到互联网请试试以下办法：检查网线、调制解调器和路由器重新连接到 Wi-Fi 网络运行 Windows 网络诊断DNS_PROBE_FINISHED_NO_INTERNETFirefox 中出现：我们无法连接至 www.typora.io 的服务器。 如果确定此网址正确，您可以尝试：过会儿再重试。检查您的网络连接是否正常。如果您部署有网络防火墙，请检查 Firefox 是否已被授权访问网络。手机和其它设备在同一网络下能正常连接，打开 host 文件也没发现域名被劫持的情况，挂代理也能连接上。解决方案篇Shaun 尝试过的方法：刷新 DNS 缓存：在命令行界面中输入 ipconfig /flushdns，无效；改 DNS 服务器：把电脑的 dns 修改为首选 8.8.8.8，备用 114.114.114.114，和将首选改成 8.8.4.4 均无效；Disable Path MTU discovery，具体操作方法为：单击“开始”，单击“运行”，键入 regedit，然后单击“确定”。在注册表中找到下面的项： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters找到EnablePMTUDiscovery，将其值改为 0，如果没找到，则在“编辑”菜单上，指向“新建”，然后单击“DWORD 值”，键入 EnablePMTUDiscovery，然后按 Enter，在“编辑”菜单上，单击“修改”，在“数值数据”框中，键入 0，然后单击“确定”。退出注册表编辑器，然后重新启动计算机。设置 MTU 值，将其调小，完美解决。具体操作方法为：以管理员身份运行命令提示符，在命令行界面输入 netsh interface ipv4 show subinterfaces，查看传入字节和传出字节的接口，修改对应接口的 MTU 的值，具体命令为：netsh interface ipv4 set subinterface &quot;对应接口名&quot; mtu=值 store=persistent，其中 对应接口名 和 值 需要替换成相应修改的东西。后记 将 MTU 值调小，可能会造成网速变慢，但 Shaun 又无法去改变其它的东西，既然不能改变其它，只能改变自己喽 ╮(╯﹏╰)╭。但 Shaun 这里觉得奇怪的是：别人的电脑设置默认 MTU 的值为 1500 也能访问啊，无奈 （╯‵□′）╯︵┴─┴。参考资料[1] 电脑上部分网页打不开，但是手机可以，如何解决？[2] mtu值怎样设置才网速最快]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyQt5使用小结]]></title>
    <url>posts/5f54aa2c.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，PyQt5 版本为 pyqt5-5.9.1，OpenCV 版本为 opencv-python-3.3.0.10 和 opencv-contrib-python-3.3.0.10，TensorFlow 版本为 tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 本文是上一篇（TensorFlow Object Detection API使用小结）的后续，因为那个 project 还需要一个界面，所以 Shaun 使用 PyQt 做了这么个界面，其中借用 OpenCV 的图像数据显示。准备篇 首先使用 pip 安装所需库，由于上一篇已经安装了 tensorflow，所以本文其实只需要安装 pyqt5 和 opencv-python 就可以了，安装 pyqt5 指令为：pip install pyqt5，相关依赖关系解决办法在上一篇中已提到，这里不再赘述，然后再使用指令 pip install opencv-python 安装 opencv，这里 Shaun 发现在 python 中配置 OpenCV 简直不要太轻爽 O(∩_∩)O~~，就一个 pip 就解决了，哪有 C++ 那么麻烦，以后可能还会继续使用 python 版的 opencv，所以就顺便把它 python 版的扩展包也顺便一起装上，安装指令为：pip install opencv-contrib-python。至此所需环境库安装完毕。 ※注：相对于上文中使用 pip 在线安装的方式，还有另一种使用 pip 进行离线安装的方式，在 Unofficial Windows Binaries for Python Extension Packages上下载离线包，即 XXXXXX.whl 文件，文件名一般包含库名称和对应版本、python 版本以及是 64 位还是 32 位的等信息，这里以离线包 numpy-1.13+mkl 为例，首先下载适合自己的库版本，适合 Shaun 的当然是 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl（这适合 64 位的 python3.6 安装），将命令行目录切换至 numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 文件所在目录，输入指令 pip install numpy-1.13.3+mkl-cp36-cp36m-win_amd64.whl 即可离线安装 numpy-1.13+mkl 库。相比在线安装，这种离线安装更加灵活，而且能够安装一些在线安装无法安装的库，像上文中的 numpy-1.13+mkl 库只能采取离线安装的方式，在线安装只能安装不带 mkl 的 numpy 库。采用离线安装方式也可以直接安装带扩展包的 opencv-python库：opencv_python‑3.3.1+contrib‑cp36‑cp36m‑win_amd64.whl ，不需要像在线安装那样装两个库。实践篇 以前有用过 Qt 的基础，所以这次使用 PyQt5 感觉上手很快，毕竟这里面的语法有很多是相通的，再加上网上的资料也有很多，所以很快就做了个简陋的界面。不过直接用代码控制界面的布局确实很麻烦，每改下布局都要重新运行一下看看，而且启动时间还有点长 ╮(╯﹏╰）╭。网上有种说法是：可以先通过QtDesigner设计UI，然后通过Qt提供的命令行工具pyuic5将.ui文件转换成python代码，具体用法是：若ui文件名称为firstPyQt5.ui，则在命令行界面中输入指令：pyuic5 -o firstPyQt5.py firstPyQt5.ui，即可将firstPyQt5.ui文件转换成python代码文件firstPyQt5.py不过 Shaun 这里由于界面比较简陋，没有几个控件，所以就直接将其用 python 代码控制了，没去尝试这个命令行工具 pyuic5 了，下次有机会再尝试吧 ↖(^ω^)↗。 Shaun 做的这个小界面实现的功能是：1、可以选择已经训练好的模型来检测选定图片中的目标；2、可以播放选定的视频；3、还有打开摄像头，显示摄像头拍摄的视频。其中由于 Shaun 电脑无法实时检测目标，所以在视频和摄像头拍摄中就没有添加检测的代码，只有选择图片时才会执行检测功能，有需要的童靴可以自行添加(•̀ᴗ•́)。附完整代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import osimport sys from PyQt5.QtCore import * from PyQt5.QtWidgets import *from PyQt5.QtGui import * import numpy as npimport cv2import tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = './model/hand_model_faster_rcnn_resnet101.pb' # 选择模型文件 self.PATH_TO_LABELS = r'./model/hands_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() # 加载模型 self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) return imageclass DetectUI(QWidget): def __init__(self): super().__init__() self.initUI() self.detector = Detector() self.cap = cv2.VideoCapture() def initUI(self): self.timer = QTimer(self) # 初始化一个定时器 self.timer.timeout.connect(self.showFrame) # 计时结束调用showFrame()方法 self.show_pic_label = QLabel(self) self.show_pic_label.resize(640, 480) self.show_pic_label.move(10, 10) self.show_pic_label.setStyleSheet("border-width: 1px; border-style: solid; border-color: rgb(255, 170, 0);") self.show_filename_lineEdit = QLineEdit(self) self.show_filename_lineEdit.resize(200, 22) self.show_filename_lineEdit.move(10, 500) self.select_img_btn = QPushButton('Select File', self) self.select_img_btn.clicked.connect(self.selectImg) self.select_img_btn.resize(self.select_img_btn.sizeHint()) self.select_img_btn.move(218, 500) self.open_camera_btn = QPushButton('Open Camera', self) self.open_camera_btn.clicked.connect(self.openCamera) self.open_camera_btn.resize(self.open_camera_btn.sizeHint()) self.open_camera_btn.move(292, 500) self.select_model_btn = QPushButton('Select Model', self) self.select_model_btn.clicked.connect(self.selectModel) self.select_model_btn.resize(self.select_model_btn.sizeHint()) self.select_model_btn.move(366, 500) self.show_modelname_lineEdit = QLineEdit(self) self.show_modelname_lineEdit.setText('hand_model_faster_rcnn_resnet101.pb') self.show_modelname_lineEdit.resize(200, 22) self.show_modelname_lineEdit.move(450, 500) self.setGeometry(200, 100, 660, 530) self.setWindowTitle('Hand Detector') self.show() def showImg(self, src_img, qlabel): src_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2RGB) # src_img = self.detector.detect(src_img) # 检测目标 height, width, bytesPerComponent = src_img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(src_img.data, width, height, bytesPerLine, QImage.Format_RGB888) qlabel.setPixmap(QPixmap.fromImage(q_image).scaled(qlabel.width(), qlabel.height())) def showFrame(self): if(self.cap.isOpened()): ret, frame = self.cap.read() if ret: self.showImg(frame, self.show_pic_label) else: self.cap.release() self.timer.stop() # 停止计时器 def selectImg(self): if self.cap.isOpened(): self.cap.release() file_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "Image Files (*.jpg *.png *.bmp *.tif);;Video Files (*.avi *.mp4)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 # print(file_name,file_type) if file_type.find("Image") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) img = cv2.imread(file_name, cv2.IMREAD_COLOR) cv2.cvtColor(img, cv2.COLOR_BGR2RGB, img) img = self.detector.detect(img) # 检测目标 height, width, bytesPerComponent = img.shape bytesPerLine = bytesPerComponent * width # 转为QImage对象 q_image = QImage(img.data, width, height, bytesPerLine, QImage.Format_RGB888) self.show_pic_label.setPixmap(QPixmap.fromImage(q_image).scaled(self.show_pic_label.width(), self.show_pic_label.height())) if file_type.find("Video") &gt;= 0: if file_name: self.show_filename_lineEdit.setText(os.path.split(file_name)[1]) self.cap.open(file_name) self.timer.start(30) # 设置时间隔30ms并启动 def openCamera(self): self.cap.open(0) # 默认打开0号摄像头 self.timer.start(30) # 设置时间隔30ms并启动 def selectModel(self): model_name, file_type = QFileDialog.getOpenFileName(self, "选取文件", "./", "model Files (*.pb);;All Files (*)") #设置文件扩展名过滤,注意用双分号间隔过滤，用空格分隔多个文件 if model_name: self.show_modelname_lineEdit.setText(os.path.split(model_name)[1]) self.detector.PATH_TO_CKPT = model_name self.detector.detection_graph = self.detector._load_model() # 重新加载模型 if __name__ == '__main__': app = QApplication(sys.argv) dtcui = DetectUI() sys.exit(app.exec_())后记 初次使用 Python 做一个小东西，其语法确实简洁，不过对于 Shaun 这种习惯用 C++ 的人来说确实还有点不太习惯 (˘•ω•˘)。参考资料[1] 用PyQt5+Caffe+Opencv搭建一个人脸识别登录界面[2] PyQt5学习笔记09—-标准文件打开保存框QFileDialog[3] PyQt5教程——第一个程序（2）（http://www.cnblogs.com/archisama/tag/PyQt5/）[4] PyQt5应用与实践[5] PyQt5系列教程(二)利用QtDesigner设计UI界面（http://www.cnblogs.com/tkinter/tag/pyqt5/）[6] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Images[7] OpenCV 3.2.0/OpenCV-Python Tutorials/Gui Features in OpenCV/Getting Started with Videos[8] python3.3 分割路径与文件名 小例]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>qt</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TensorFlow Object Detection API使用小结]]></title>
    <url>posts/82d3b275.html</url>
    <content type="text"><![CDATA[本文所用的 Python 版本为 python-3.6.2，TensorFlow 版本为tensorflow-1.4.0，编程语言为 python3，系统环境为 Windows 10。前言 很久没写过东西了，主要原因是最近研究生课程开始陆续结课，Shaun 也要忙于应付各种结课时的考试、论文、project 等一堆麻烦事。这不深度学习结课时需要做个 project，Shaun 也顺便将做这个 project 的过程记录下来。准备篇 该 project 主要利用 TensorFlow 中的 Object Detection API 进行训练和检测。在开始使用该 API 之前需要安装配置 Python 环境。 既然是 Python 首先需要 下载安装Python，安装完之后，为了顺利使用 pip 需要配置环境变量，在 Windows 系统环境变量中 Path 末尾添加：变量名变量值Path;C:\Users\admin\AppData\Local\Programs\Python\Python36\; C:\Users\admin\AppData\Local\Programs\Python\Python36\Scripts\其中 C:\Users\admin\AppData\Local\Programs\Python\Python36 为 python-3.6.2 默认安装目录。 然后为了方便使用命令行工具，下载安装git，安装方式一路默认即可。 接下来利用 pip 安装 TensorFlow，鼠标右键桌面空白处，点击“Git Bash Here”，打开 bash 命令行，输入 pip install tensorflow，其中一些依赖关系可能需要手动解决，手动解决的办法就是用 pip install 相关依赖库，这是 CPU 版的 TensorFlow，若要使用 GPU，则需要安装 GPU 版的 TensorFlow，安装命令为：pip install tensorflow-gpu，以同样方式解决依赖关系。由于 Shaun 电脑没 N 卡，所以没安装 GPU 版的 TensorFlow，所以如果想使用 GPU 版的 TensorFlow 请另行尝试。 然后安装 TensorFlow Object Detection API 依赖库，在命令行中输入：1234pip install pillowpip install lxmlpip install jupyterpip install matplotlib 因为 tensorflow 并没有默认自带 Object Detection API，所以该 API 需要自行下载，下载地址为：https://github.com/tensorflow/models ，下载之后解压，Shaun 解压目录为：D:\ProgramFiles\PythonLibs\tensorflow，解压完之后需要配置环境目录，在系统环境目录中添加：变量名变量值PYTHONPATHD:\ProgramFiles\PythonLibs\tensorflow\models; D:\ProgramFiles\PythonLibs\tensorflow\models\research; D:\ProgramFiles\PythonLibs\tensorflow\models\research\slim; 下载配置 Object Detection API 完之后需要安装 Protoc，进入 Protoc下载页，下载 protoc-3.4.0-win32.zip，解压之后将 bin 文件夹内的 protoc.exe 拷贝到 C:\windows\system32 目录下（用于将 protoc.exe 所在的目录配置到环境变量当中）,当然也可以在系统环境变量 Path 中添加该 bin 文件夹路径。 最后在命令行中切换目录至：D:\ProgramFiles\PythonLibs\tensorflow\models\research 文件夹，即 object_detection 文件夹所在目录，在命令行中输入：1protoc object_detection/protos/*.proto --python_out=.编译 object_detection/protos 文件夹下的 proto 文件，生成对应的 python 文件。 至此，Windows 下 TensorFlow中 的 Object Detection API 的使用配置全部完成，至于 Ubuntu 下的配置可参考其官方文档。 至于如何验证，可以在命令行中切换目录至 object_detection，输入：jupyter notebook，稍等一会，浏览器将自动打开 http://localhost:8888/tree jupyter 界面，点击 object_detection_tutorial.ipynb 文件，进入打开的新标签，点击“Cell”中的“Run All”，耐心等待几 ~ 十几分钟（因为它需要下载相应的模型），将会在浏览器下方显示检测结果。 截止本文完成前，该API公开的有以下几个模型：Model nameSpeed (ms)COCO mAP1Outputsssd_mobilenet_v1_coco3021Boxesssd_inception_v2_coco4224Boxesfaster_rcnn_inception_v2_coco5828Boxesfaster_rcnn_resnet50_coco8930Boxesfaster_rcnn_resnet50_lowproposals_coco64Boxesrfcn_resnet101_coco9230Boxesfaster_rcnn_resnet101_coco10632Boxesfaster_rcnn_resnet101_lowproposals_coco82Boxesfaster_rcnn_inception_resnet_v2_atrous_coco62037Boxesfaster_rcnn_inception_resnet_v2_atrous_lowproposals_coco241Boxesfaster_rcnn_nas183343Boxesfaster_rcnn_nas_lowproposals_coco540Boxes 根据上述模型可推知，利用该 API 可能只能训练 Faster-RCNN、R-FCN 和 SSD 三种算法的模型。接下来介绍如何使用该 API 来训练自己的模型进行物体检测。实践篇数据准备篇 既然要训练自己的模型，当然要准备相应的数据，而 TensorFlow 有其独特的输入数据格式 TFRecord，所以通常还要将自己的数据转换成 TFRecord 格式以输入 TensorFlow 中进行训练。以 datitran/raccoon_dataset 数据集为例，该作者在 Google image 上收集了 200 张 Raccoon 图片，用 LabelImg 对这些图片进行标记，并将标记以 PASCAL VOC 格式保存为 xml 文件。作者在文中也提到了另一个图片标记工具 FIAT (Fast Image Data Annotation Tool) 。保存为 PASCAL VOC 格式的 xml 文件之后，可以使用 object_detection 文件夹中的 create_pascal_tf_record.py 文件将数据转化为 TFRecord 格式，用法为：123./create_pascal_tf_record --data_dir=/home/user/VOCdevkit \ --year=VOC2012 \ --output_path=/home/user/pascal.record当然也可以使用 datitran 作者提供的 xml_to_csv.py 文件将 xml 文件先转化为 csv 文件，再利用 generate_tfrecord.py 文件将 csv 文件转化成 TFRecord 格式文件。 注意，使用 xml_to_csv.py 和 generate_tfrecord.py 其文件结构应该是这样的：.├── annotations├── generate_tfrecord.py├── images└── xml_to_csv.py2 directories, 2 files其中 images 文件夹存的是 jpg 图片，annotations 文件夹存的是 xml 标签文件。generate_tfrecord.py 文件中的：12345def class_text_to_int(row_label): if row_label == 'raccoon': return 1 else:None其中的 raccoon 注意要改成自己的类别标签。如此，数据的问题就解决了。训练篇 然后就是正式开始训练了，以 Faster-RCNN 算法为例。首先准备相应的数据，Shaun 准备的数据文件结构如下：TensorFlowObjectDetectionAPITest├── data│ ├── model.ckpt.data-00000-of-00001│ ├── model.ckpt.index│ ├── model.ckpt.meta│ ├── object_label_map.pbtxt│ ├── test.record│ └── train.record├── eval├── eval.py├── export_inference_graph.py├── faster_rcnn_resnet101_coco.config├── model├── train└── train.py4 directories, 10 files其中，TensorFlowObjectDetectionAPITest 为项目文件夹，该 project 在此文件夹下运行；data 文件夹中三个 model.ckpt 文件：model.ckpt.data-00000-of-00001、model.ckpt.index 和 model.ckpt.meta 来自 faster_rcnn_resnet101_coco 模型，用来初始化网络参数；object_label_map.pbtxt 文件内容如下：item { ​ id: 1 ​ name: ‘raccoon’ }将其中的 raccoon 改成自己的类别标签，如果有多个类别标签则可以参考 object_detection\data 文件夹中的 pascal_label_map.pbtxt 文件格式；test.record 和 train.record 是生成的 TFRecord 数据，分别为待输入的测试数据和训练数据；eval 文件夹为空文件夹用来输出测试结果；train 文件夹为空文件夹用来输出训练结果（包括checkpoint文件和最终的模型文件）；faster_rcnn_resnet101_coco.config 为配置文件，包括各种参数和输入输出数据的配置，其来自 object_detection\samples\configs 文件夹中 faster_rcnn_resnet101_coco.config 文件，在使用时需对其做如下修改：首先是 num_classes，这是待检测的类别数目，如果只要检测一种，则将其值改为 1；fine_tune_checkpoint: &quot;PATH_TO_BE_CONFIGURED/model.ckpt&quot;，将 PATH_TO_BE_CONFIGURED 改为 ./data；123456train_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_train.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot;&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_train.record 改为 ./data/train.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；123456789eval_input_reader: &#123; tf_record_input_reader &#123; input_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_val.record&quot; &#125; label_map_path: &quot;PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt&quot; shuffle: false num_readers: 1 num_epochs: 1&#125;将其中的的 PATH_TO_BE_CONFIGURED/mscoco_val.record 改为 ./data/test.record，将其中的 PATH_TO_BE_CONFIGURED/mscoco_label_map.pbtxt 改为 ./data/object_label_map.pbtxt；至于其它的参数可以选择默认，不对其进行修改；train.py 为训练代码，其来自 object_detection/ 文件夹中的 train.py，直接复制出来使用即可，具体用法为：1python train.py --logtostderr --train_dir=./train --pipeline_config_path=faster_rcnn_resnet101_coco.config其在运行过程中会在 train 文件夹生成一系列训练过程文件，比如 checkpoint、model.ckpt-{num}（{num} 代表训练过程保存的第几个网络模型，一般从 0 开始，包括 .index、.meta和 .data 三个文件）等文件。eval.py 为评估代码，其来自 object_detection/ 文件夹中的 eval.py，直接复制出来使用即可，具体用法为：1python eval.py --logtostderr --checkpoint_dir=./train --eval_dir=./eval --pipeline_config_path=./faster_rcnn_resnet101_coco.config其在运行过程中会在 eval 文件夹生成一系列评估文件，每个文件对应一个测试 image。export_inference_graph.py 为导出 pb 模型代码，其来自 object_detection/ 文件夹中的 export_inference_graph.py，直接复制出来使用即可，具体用法为：1python export_inference_graph.py --input_type image_tensor --pipeline_config_path ./faster_rcnn_resnet101_coco.config --trained_checkpoint_prefix ./train/model.ckpt-18298 --output_directory ./model其中 model.ckpt-18298 表示使用第 18298 次保存的网络模型导出 pb 模型文件，导出的模型文件保存在 model 文件夹，主要有一下几个文件：- graph.pbtxt- model.ckpt.data-00000-of-00001- model.ckpt.info- model.ckpt.meta- frozen_inference_graph.pb其中 frozen_inference_graph.pb 就是训练成功用来检测目标的模型。 TensorFlow 训练时可以随时查看训练过程，如损失函数的值下降曲线等，所用命令为：在命令行中切换目录至 project 运行目录，即 train.py 所在文件夹，Shaun 这里即 TensorFlowObjectDetectionAPITest 文件夹，输入：tensorboard --logdir=./，等待片刻，在浏览器地址栏输入：http://localhost:6006/，即可看到训练过程曲线。检测篇 检测结果使用 opencv 窗口显示（至于 python 中 opencv 的使用详见下一篇（PyQt5使用小结）），具体调用自己训练的模型进行检测的 Python 代码（该代码为 eli 大佬参考 object_detection 文件夹中的 object_detection_tutorial.ipynb（该文件可在 jupyter 中查看）改的）为：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import cv2import numpy as npimport tensorflow as tffrom object_detection.utils import label_map_utilfrom object_detection.utils import visualization_utils as vis_utilclass Detector(object): def __init__(self): self.PATH_TO_CKPT = r'./model/frozen_inference_graph.pb' # 选择模型 self.PATH_TO_LABELS = r'./data/object_label_map.pbtxt' # 选择类别标签文件 self.NUM_CLASSES = 1 self.detection_graph = self._load_model() self.category_index = self._load_label_map() def _load_model(self): detection_graph = tf.Graph() with detection_graph.as_default(): od_graph_def = tf.GraphDef() with tf.gfile.GFile(self.PATH_TO_CKPT, 'rb') as fid: serialized_graph = fid.read() od_graph_def.ParseFromString(serialized_graph) tf.import_graph_def(od_graph_def, name='') return detection_graph def _load_label_map(self): label_map = label_map_util.load_labelmap(self.PATH_TO_LABELS) categories = label_map_util.convert_label_map_to_categories(label_map, max_num_classes=self.NUM_CLASSES, use_display_name=True) category_index = label_map_util.create_category_index(categories) return category_index def detect(self, image): with self.detection_graph.as_default(): with tf.Session(graph=self.detection_graph) as sess: # Expand dimensions since the model expects images to have shape: [1, None, None, 3] image_np_expanded = np.expand_dims(image, axis=0) image_tensor = self.detection_graph.get_tensor_by_name('image_tensor:0') boxes = self.detection_graph.get_tensor_by_name('detection_boxes:0') scores = self.detection_graph.get_tensor_by_name('detection_scores:0') classes = self.detection_graph.get_tensor_by_name('detection_classes:0') num_detections = self.detection_graph.get_tensor_by_name('num_detections:0') # Actual detection. (boxes, scores, classes, num_detections) = sess.run( [boxes, scores, classes, num_detections], feed_dict=&#123;image_tensor: image_np_expanded&#125;) # Visualization of the results of a detection. vis_util.visualize_boxes_and_labels_on_image_array( image, np.squeeze(boxes), np.squeeze(classes).astype(np.int32), np.squeeze(scores), self.category_index, use_normalized_coordinates=True, line_thickness=8) cv2.namedWindow("detection", cv2.WINDOW_NORMAL) cv2.imshow("detection", image) cv2.waitKey(0)if __name__ == '__main__': image = cv2.imread('./test_img.jpg') # 选择待检测的图片 detector = Detector() detector.detect(image)后记 经过这次 TensorFlow 训练，感觉深度学习 真tm 吃硬件，费时间，也难怪神经网络理论出来几十年之后才火，当年的硬件根本无法支持这么大的计算量。附录最后附上 datitran 作者提供的 xml_to_csv.py 文件源码和 generate_tfrecord.py 文件源码：xml_to_csv.py 源码如下：1234567891011121314151617181920212223242526272829303132333435import osimport globimport pandas as pdimport xml.etree.ElementTree as ETdef xml_to_csv(path): xml_list = [] for xml_file in glob.glob(path + '/*.xml'): tree = ET.parse(xml_file) root = tree.getroot() for member in root.findall('object'): value = (root.find('filename').text, int(root.find('size')[0].text), int(root.find('size')[1].text), member[0].text, int(member[4][0].text), int(member[4][1].text), int(member[4][2].text), int(member[4][3].text) ) xml_list.append(value) column_name = ['filename', 'width', 'height', 'class', 'xmin', 'ymin', 'xmax', 'ymax'] xml_df = pd.DataFrame(xml_list, columns=column_name) return xml_dfdef main(): image_path = os.path.join(os.getcwd(), 'annotations') xml_df = xml_to_csv(image_path) xml_df.to_csv('raccoon_labels.csv', index=None) print('Successfully converted xml to csv.')main()generate_tfrecord.py 文件源码 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798"""Usage: # From tensorflow/models/ # Create train data: python generate_tfrecord.py --csv_input=data/train_labels.csv --output_path=train.record # Create test data: python generate_tfrecord.py --csv_input=data/test_labels.csv --output_path=test.record"""from __future__ import divisionfrom __future__ import print_functionfrom __future__ import absolute_importimport osimport ioimport pandas as pdimport tensorflow as tffrom PIL import Imagefrom object_detection.utils import dataset_utilfrom collections import namedtuple, OrderedDictflags = tf.app.flagsflags.DEFINE_string('csv_input', '', 'Path to the CSV input')flags.DEFINE_string('output_path', '', 'Path to output TFRecord')FLAGS = flags.FLAGS# TO-DO replace this with label mapdef class_text_to_int(row_label): if row_label == 'raccoon': return 1 else: Nonedef split(df, group): data = namedtuple('data', ['filename', 'object']) gb = df.groupby(group) return [data(filename, gb.get_group(x)) for filename, x in zip(gb.groups.keys(), gb.groups)]def create_tf_example(group, path): with tf.gfile.GFile(os.path.join(path, '&#123;&#125;'.format(group.filename)), 'rb') as fid: encoded_jpg = fid.read() encoded_jpg_io = io.BytesIO(encoded_jpg) image = Image.open(encoded_jpg_io) width, height = image.size filename = group.filename.encode('utf8') image_format = b'jpg' xmins = [] xmaxs = [] ymins = [] ymaxs = [] classes_text = [] classes = [] for index, row in group.object.iterrows(): xmins.append(row['xmin'] / width) xmaxs.append(row['xmax'] / width) ymins.append(row['ymin'] / height) ymaxs.append(row['ymax'] / height) classes_text.append(row['class'].encode('utf8')) classes.append(class_text_to_int(row['class'])) tf_example = tf.train.Example(features=tf.train.Features(feature=&#123; 'image/height': dataset_util.int64_feature(height), 'image/width': dataset_util.int64_feature(width), 'image/filename': dataset_util.bytes_feature(filename), 'image/source_id': dataset_util.bytes_feature(filename), 'image/encoded': dataset_util.bytes_feature(encoded_jpg), 'image/format': dataset_util.bytes_feature(image_format), 'image/object/bbox/xmin': dataset_util.float_list_feature(xmins), 'image/object/bbox/xmax': dataset_util.float_list_feature(xmaxs), 'image/object/bbox/ymin': dataset_util.float_list_feature(ymins), 'image/object/bbox/ymax': dataset_util.float_list_feature(ymaxs), 'image/object/class/text': dataset_util.bytes_list_feature(classes_text), 'image/object/class/label': dataset_util.int64_list_feature(classes), &#125;)) return tf_exampledef main(_): writer = tf.python_io.TFRecordWriter(FLAGS.output_path) path = os.path.join(os.getcwd(), 'images') examples = pd.read_csv(FLAGS.csv_input) grouped = split(examples, 'filename') for group in grouped: tf_example = create_tf_example(group, path) writer.write(tf_example.SerializeToString()) writer.close() output_path = os.path.join(os.getcwd(), FLAGS.output_path) print('Successfully created the TFRecords: &#123;&#125;'.format(output_path))if __name__ == '__main__': tf.app.run()参考资料[1] 对于谷歌开源的TensorFlow Object Detection API视频物体识别系统实现教程[2] TensorFlow学习——Tensorflow Object Detection API（win10，CPU）[3] How to train your own Object Detector with TensorFlow’s Object Detector API[4] TensorFlow 之 物体检测（http://rensanning.iteye.com/category/374992）See MSCOCO evaluation protocol.↩]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>cv</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言中整型提升问题]]></title>
    <url>posts/2a3d46b0.html</url>
    <content type="text"><![CDATA[前言 今天有人问了 Shaun 一个移位的问题，就是下面这段 C 语言代码：12unsigned short a = 0xffff;printf("%#hx\n", a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4);你认为会输出什么结果？ ੧ಡ ⌣ ಡ੭解答篇 正确答案是：0xfff0。恐怕有一部分会像 Shaun 一样觉得答案就是 0xff0 才对，还像模像样的给出对应的说法：看 a 首先向左移四位，即去掉最左边的 f，右边补 4 个 0 变成这样 0xfff0；然后再向右移 8 位，a 将会变成这样 0x00ff；最后向左移四位，得到 0x0ff0，所以应该输出 0xff0。但是，正确答案终究是正确答案。之所以会输出正确答案，是因为这里面还有一个整型提升。所谓的整型提升就是：在一个表达式中，如果int能够表示原始类型中的所有数值，那么这个数值就被转成int型，否则，它被转成unsigned int型。这种规则被称为整型提升。所有其它类型都不会被整型提升改变。 所以在 a &lt;&lt; 4 &gt;&gt; 8 &lt;&lt; 4 中，会先将 a 提升为 int 型，即 a 会变成 0x0000ffff，接着向左移四位，a 变成 0x000ffff0，再向右移 8 位，变成 0x00000fff，最后向左移 4 位，变成 0x0000fff0，最后为了输出，再做一个隐式的类型转换（由 int 转 unsigned short），得到 0xfff0，所以最后输出 0xfff0。后记 这个问题是一个刚入大学的童靴问 Shaun 的，刚问 Shaun 时 Shaun 还没反应过来，后来才想起有整型提升这么回事 o(╯□╰)o。btw，这位童靴主要是想去掉高 4 位和低 4 位只取中间 8 位的值，其实最简单的办法就是直接 a &amp; 0x0ff0，这样管它有没有整型提升，肯定能得到中间 8 位的值 (╯▽╰)。参考资料[1] C语言进阶：整型提升（http://blog.csdn.net/mishifangxiangdefeng/article/category/1058873）[2] 对 unsigned char 先左移 后右移 可以出现两种结果]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TXT数据转OpenCV中的Mat数据]]></title>
    <url>posts/dece8eba.html</url>
    <content type="text"><![CDATA[前言 本文是以前做的一个小东西的处理前奏，当时也记录过，现在把它翻出来重新看看。那个东西需要利用深度图，Shaun 当时还没拿到 Kinect，就在网上下了一些数据（http://eeeweba.ntu.edu.sg/computervision/people/home/renzhou/HandGesture.htm），该数据集包含了彩色图及对应的深度图，但是该数据集没有以图像形式存储深度值，而是用 txt 文本以行列形式存储真正的深度值（单位为 mm），所以并不能直观的看到深度图像，Shaun 需要把这些深度值从 txt 文本提取出来并把它以图像的形式呈现出来，由于需求比较特殊，网上没看到现成的解决的方案，所以 Shaun 只有用现成的轮子自己做一个了。思路篇 程序的基本思路是：先找到目录及子目录下的所有 txt 文件路径；再根据路径分别读取 txt 文件，按行读取之后再进行字符串分割提取其中的深度值；为了便于以图像形式显示，将深度值归一化至 0~255 存入 8 位单通道的 Mat 类型数据中，最后以 png 图像形式保存至各个目录。实现篇 因为当时还在用 opencv-2.4.11，所以本文所实现的代码是基于 opencv-2.4.11，不过应该只要在 opencv-2.0 版本及以上只要有 Mat 数据结构的都能用，毕竟 Shaun 只用到了 OpenCV 中的 Mat 数据结构。Talk is cheap, show you the code（代码很乱，估计也只用这么一次，所以就没怎么注意了 :-P）。具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;#include &lt;io.h&gt; #include &lt;direct.h&gt; #include &lt;fstream&gt;#include &lt;iostream&gt;using namespace cv;using namespace std;// ******************************************************************// @refer to [C++文件读写操作（二）逐字符读取文本和逐行读取文本](http://blog.csdn.net/wangshihui512/article/details/8921924)// [字符串分割(C++)](http://www.cnblogs.com/MikeZhang/archive/2012/03/24/MySplitFunCPP.html)// [C++读取文件夹中所有的文件或者是特定后缀的文件](http://blog.csdn.net/adong76/article/details/39432467)// [C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用](http://blog.csdn.net/u012005313/article/details/50688257)// [Split a string in C++?](http://stackoverflow.com/questions/236129/split-a-string-in-c)// [Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取](http://blog.csdn.net/zouxy09/article/details/8151044)// [Depth Map Tutorial](http://www.pages.drexel.edu/~nk752/depthMapTut.html)// ******************************************************************// ----- 逐个字符读取文件 --------void testByChar() &#123; fstream testByCharFile; char c; testByCharFile.open("./test.txt",ios::in); while(!testByCharFile.eof()) &#123; testByCharFile&gt;&gt;c; cout&lt;&lt;c; &#125; testByCharFile.close(); &#125; // -------- 逐行读取文件 -------------------void testByLine() &#123; char buffer[256]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 256, '\n');//getline(char *,int,char) 表示该行字符达到256个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; &#125; outFile.close(); &#125; // ------- 分割字符串 --------------void splitString() &#123; char buffer[1280]; fstream outFile; outFile.open("./test.txt",ios::in); while(!outFile.eof()) &#123; outFile.getline(buffer, 1280, '\n');//getline(char *,int,char) 表示该行字符达到1280个或遇到换行就结束 cout&lt;&lt;buffer&lt;&lt;endl; const char *d = " ,*"; char *p; p = strtok(buffer, d); while(p) &#123; printf("%s\n", p); p=strtok(NULL, d); &#125; &#125; outFile.close(); &#125; // 获取文件夹下指定格式所有文件名void getAllFormatFiles( string path, string format, vector&lt;string&gt;&amp; files ) &#123; //文件句柄 long hFile = 0; //文件信息 struct _finddata_t fileinfo; string pathName; if((hFile = _findfirst(pathName.assign(path).append("/*." + format).c_str(),&amp;fileinfo)) != -1) &#123; do &#123; //如果是目录,迭代之 //如果不是,加入列表 if((fileinfo.attrib &amp; _A_SUBDIR)) &#123; if(strcmp(fileinfo.name,".") != 0 &amp;&amp; strcmp(fileinfo.name,"..") != 0) &#123; //files.push_back(p.assign(path).append("/").append(fileinfo.name) ); getAllFormatFiles( pathName.assign(path).append("/").append(fileinfo.name), format, files); &#125; &#125; else &#123; files.push_back(pathName.assign(path).append("/").append(fileinfo.name) ); &#125; &#125;while(_findnext(hFile, &amp;fileinfo) == 0); _findclose(hFile); &#125; &#125; // http://stackoverflow.com/questions/236129/split-a-string-in-c// ---- stackoverflow上大神的C++版本分割字符串 --------------------std::vector&lt;std::string&gt; split(const std::string&amp; text, const std::string&amp; delims)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = text.find_first_not_of(delims), end = 0; while((end = text.find_first_of(delims, start)) != std::string::npos) &#123; tokens.push_back(text.substr(start, end - start)); start = text.find_first_not_of(delims, end); &#125; if(start != std::string::npos) tokens.push_back(text.substr(start)); return tokens;&#125;// 创建文件夹及子文件夹void makeDir(const string &amp;path)&#123; std::vector&lt;std::string&gt; tokens; std::size_t start = 0, end = 0; while ((end = path.find('/', start)) != std::string::npos) &#123; if (end != start) &#123; tokens.push_back(path.substr(0, end)); &#125; start = end + 1; &#125; if (end != start) &#123; tokens.push_back(path); &#125; vector&lt;string&gt;::const_iterator itp = tokens.begin(); while (itp != tokens.end()) &#123; if (access(itp-&gt;c_str(), 0) == -1) // 判断文件夹是否存在 &#123; cout&lt;&lt;*itp&lt;&lt;" is not existing"&lt;&lt;endl; cout&lt;&lt;"now make it"&lt;&lt;endl; if (mkdir(itp-&gt;c_str()) == 0) // 不存在则创建，只能一级一级的创建 &#123; cout&lt;&lt;"make successfully"&lt;&lt;endl; &#125; &#125; cout &lt;&lt; *itp++ &lt;&lt;endl; &#125;&#125;// Txt文件转opencv Mat（txt文件中存的是以行列形式的深度值）cv::Mat Txt2DepthMat(const string &amp;txtname)&#123; cv::Mat result(480, 640, CV_8UC1, cv::Scalar(0)); char buffer[12800]; // 按行读取文件 fstream outFile; const char *d = ","; // 以,为分割点 char *p; // 分割出的子串 outFile.open(txtname, ios::in); for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) &#123; p = strtok(buffer, d); for (int j = 0; p &amp;&amp; j &lt; result.cols; j++) &#123; int realDepth = (atoi(p) &amp; 0xfff8) &gt;&gt; 3; //提取距离信息，高13位 int depth = (int)(256 * realDepth / 0x0fff); //因为提取的信息是距离信息，为了便于显示，这里归一化为0-255 result.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(depth); p = strtok(NULL, d); &#125; &#125; outFile.close(); return result;&#125;// 以颜色表示深度信息，越暖（红色）越近，越冷（蓝色）越远cv::Mat Depth2Color(const cv::Mat &amp;depth)&#123; cv::Mat result(depth.size(), CV_8UC3, cv::Scalar::all(0)); int tempDepth, depthRed, depthGreen, depthBlue; for (int i = 0; i &lt; result.rows; i++) &#123; for (int j = 0; j &lt; result.cols; j++) &#123; tempDepth = 255 - depth.at&lt;uchar&gt;(i, j); if(tempDepth &lt; 43) &#123; depthRed = tempDepth * 6; depthGreen = 0; depthBlue = tempDepth * 6; &#125; if(tempDepth &gt; 42 &amp;&amp; tempDepth &lt; 85) &#123; depthRed = 255 - (tempDepth - 43) * 6; depthGreen = 0; depthBlue = 255; &#125; if(tempDepth &gt; 84 &amp;&amp; tempDepth &lt; 128) &#123; depthRed = 0; depthGreen = (tempDepth - 85) * 6; depthBlue = 255; &#125; if(tempDepth &gt; 127 &amp;&amp; tempDepth &lt; 169) &#123; depthRed = 0; depthGreen = 255; depthBlue = 255 - (tempDepth - 128) * 6; &#125; if(tempDepth &gt; 168 &amp;&amp; tempDepth &lt; 212) &#123; depthRed = (tempDepth - 169) * 6; depthGreen = 255; depthBlue = 0; &#125; if(tempDepth &gt; 211 &amp;&amp; tempDepth &lt; 254) &#123; depthRed = 255; depthGreen = 255 - (tempDepth - 212) * 6; depthBlue = 0; &#125; if(tempDepth &gt; 253) &#123; depthRed = 255; depthGreen = 0; depthBlue = 0; &#125; if (tempDepth == 255) &#123; depthRed = 0; depthGreen = 0; depthBlue = 0; &#125; result.at&lt;Vec3b&gt;(i, j)[0] = depthBlue; result.at&lt;Vec3b&gt;(i, j)[1] = depthGreen; result.at&lt;Vec3b&gt;(i, j)[2] = depthRed; &#125; &#125; return result;&#125;int main(int argc, char *argv[])&#123; string filePath = "C:/Users/XXXXXX/Downloads/NTU-Microsoft-Kinect-HandGesture Dataset/Depth"; vector&lt;string&gt; files; //读取所有文件 string format = "*"; // 不知道为什么在我电脑读不了特定文件？ getAllFormatFiles(filePath, format, files); for (int i = 0; i &lt; files.size(); i++) &#123; cv::Mat tempMat = Txt2DepthMat(files[i]); files[i].replace(0, 66, "../data"); files[i].replace(files[i].find(".txt"), files[i].length() - 1, ".png"); cout&lt;&lt; files[i] &lt;&lt; endl; string tempString = files[i].substr(0, files[i].find_last_of("/")); makeDir(tempString); cv::imwrite(files[i], tempMat); &#125; cout &lt;&lt; "File Size: " &lt;&lt; files.size() &lt;&lt; endl; //cv::imshow("test", Depth2Color(Txt2DepthMat("./1.txt"))); cv::waitKey(0); return 0;&#125;2018-01-01 BTW：以上代码在 VS2010+Win7 下编译运行通过，在 VS2013+Win10 下 for (int i = 0; outFile.getline(buffer, 12800, '\n') != NULL &amp;&amp; i &lt; result.rows; i++) 会报错，可能需要改成 for (int i = 0; outFile.getline(buffer, 12800, '\n') &amp;&amp; i &lt; result.rows; i++) ，即去掉后面的 != NULL。后记 正如前言所说，本文是以前记录过的，一些细节也快忘记，这次重写算是回顾一下吧，这段程序可能也确实只用这么一次，但其中用到了不少 C++ 处理字符串和读写文件等相关知识，而这些知识，在以后有极大的可能会再次用到，因此记录 ↖(^ω^)↗。参考资料[1] C++文件读写操作（二）逐字符读取文本和逐行读取文本（http://blog.csdn.net/shihui512/article/category/1397194）[2] 字符串分割(C++)（http://www.cnblogs.com/MikeZhang/category/345894.html）[3] C++读取文件夹中所有的文件或者是特定后缀的文件（http://blog.csdn.net/adong76/article/category/1632029）[4] C/C++ 判断文件夹是否存在以及创建、删除文件夹 windows以及linux通用（http://blog.csdn.net/u012005313/article/category/5586103）[5] Split a string in C++?（http://stackoverflow.com/questions/236129/split-a-string-in-c）[6] Kinect开发学习笔记之（六）带游戏者ID的深度数据的提取（http://blog.csdn.net/zouxy09/article/category/1273380）[7] Depth Map Tutorial（http://www.pages.drexel.edu/~nk752/depthMapTut.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中滑动条和鼠标事件响应操作的使用小结]]></title>
    <url>posts/e8b35736.html</url>
    <content type="text"><![CDATA[前言 既然在上一篇中提到了回调函数，Shaun 就干脆把 OpenCV 中较常使用的两个使用回调函数的函数使用方法也一并记录下来吧。说明篇OpenCV 中使用回调函数的两个函数为：鼠标事件响应操作函数：void cv::setMouseCallback(const string&amp; winname, MouseCallback onMouse, void* userdata = 0);参数浅解：const string&amp; winname：窗口名称，对名为winname的窗口执行鼠标事件响应操作；MouseCallback onMouse：鼠标响应事件回调函数，监听鼠标的点击，移动，松开，判断鼠标的操作类型并做出相应处理；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);参数浅解：int event：鼠标滑动（CV_EVENT_MOUSEMOVE）、左键单击（CV_EVENT_LBUTTONDOWN）、右键单击（CV_EVENT_RBUTTONDOWN ）等10种鼠标点击事件的int型代号；int x, int y：鼠标位于窗口的（x，y）坐标位置，窗口左上角默认为原点，向右为x正轴，向下为y正轴；int flags：鼠标左键拖拽（CV_EVENT_FLAG_LBUTTON）、右键拖拽（CV_EVENT_FLAG_RBUTTON）等6种鼠标拖拽事件的int型代号；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。创建滑动条函数：int cv::createTrackbar(const string&amp; trackbarname, const string&amp; winname, int* value, int count, TrackbarCallback onChange=0, void* userdata=0);参数浅解：const string&amp; trackbarname：创建的滑动条名称；const string&amp; winname：所在窗口名称，对名为winname的窗口添加滑动条；int* value：滑块的位置，其初始值对应滑块的初始位置；int count：滑块可达到的最大位置的值，滑块最小位置的值总为0；TrackbarCallback onChange：滑动条事件回调函数，当滑动条上位置改变的时，则执行该回调函数；void* userdata：对应回调函数的可选参数，若使用全局变量可以忽略该参数。对应的回调函数声明为：typedef void (CV_CDECL *TrackbarCallback)(int pos, void* userdata);参数浅解：int pos：滑动条的位置对应的值；void* userdata：回调函数的参数，若使用全局变量可以忽略该参数。※注：本文的函数说明采用的是 opencv-2.4.11 的函数声明，与 opencv-3.2.0 的函数声明区别在于 string 类型，opencv-3.2.0 采用的是其自己实现的一个 String 类。实例篇Show u the code，具体 C++ 实现代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include &lt;opencv2/opencv.hpp&gt; #include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;// ---------------- 鼠标事件回调函数 ---------------------------------static cv::Mat src_img; // 原始图像全局变量static void mouseCallback(int event, int x, int y, int flags, void *)&#123; bool selected = false; static cv::Point left_top_vertex, right_down_vertex; // 左上角顶点和右下角顶点 // When the left mouse button is pressed, record its position and save it in corner1 if (event == CV_EVENT_LBUTTONDOWN) // 左键按下 &#123; left_top_vertex.x = x; left_top_vertex.y = y; std::cout &lt;&lt; "Corner 1 recorded at " &lt;&lt; left_top_vertex &lt;&lt; std::endl; &#125; // When the left mouse button is released, record its position and save it in corner2 if (event == cv::EVENT_LBUTTONUP) // 左键弹起 &#123; // Also check if user selection is bigger than 20 pixels (jut for fun!) if (abs(x - left_top_vertex.x) &gt; 10 &amp;&amp; abs(y - left_top_vertex.y) &gt; 10) &#123; right_down_vertex.x = x; right_down_vertex.y = y; std::cout &lt;&lt; "Corner 2 recorded at " &lt;&lt; right_down_vertex &lt;&lt; std::endl &lt;&lt; std::endl; selected = true; &#125; else &#123; std::cout &lt;&lt; "Please select a bigger region" &lt;&lt; std::endl; &#125; &#125; // Update the box showing the selected region as the user drags the mouse if (flags == CV_EVENT_FLAG_LBUTTON) // 左键拖拽 &#123; cv::Point pt; pt.x = x; pt.y = y; cv::Mat local_img = src_img.clone(); rectangle(local_img, left_top_vertex, pt, cv::Scalar(0, 0, 255)); imshow("Cropping app", local_img); &#125; // Define ROI and crop it out when both corners have been selected if (selected) &#123; cv::Rect box; box.width = abs(left_top_vertex.x - right_down_vertex.x); box.height = abs(left_top_vertex.y - right_down_vertex.y); box.x = cv::min(left_top_vertex.x, right_down_vertex.x); box.y = cv::min(left_top_vertex.y, right_down_vertex.y); // Make an image out of just the selected ROI and display it in a new window cv::Mat crop(src_img, box); cv::namedWindow("Crop"); imshow("Crop", crop); &#125;&#125;// ---------- 响应鼠标事件 ------------------------------------void setMouseCallbackTest()&#123; src_img = cv::imread("../data/lena.jpg", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("Cropping app"); imshow("Cropping app", src_img); // Set the mouse event callback function cv::setMouseCallback("Cropping app", mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// -------------- 滑动条回调函数 ------------------------static void thresholdCallback(int slider_value, void* gray)&#123; //static_cast&lt;&gt;用于安全转换指针 cv::Mat *tmp_gray = static_cast&lt;cv::Mat *&gt;(gray); cv::Mat tmp = *tmp_gray; cv::Mat dst; threshold(tmp, dst, slider_value, 255, CV_THRESH_BINARY); //显示效果图 cv::imshow("Trackbar Demo", dst);&#125;// ------------ 创建滑动条 ----------------------------------void createTrackbarTest()&#123; cv::Mat src_gray = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Trackbar Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_gray); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_gray); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;// ------- 将两个函数在同一个窗口执行 ------------void callbackTest()&#123; src_img = cv::imread("../data/lena.jpg", 0); const int max_value = 255; //滑动条的最大值 int slider_value = 0; // 滑动条的初始值 char *window_name = "Callback Demo"; char *trackbar_name = "Value:"; // 创建一个窗口显示图片 cv::namedWindow(window_name, CV_WINDOW_AUTOSIZE); imshow(window_name, src_img); // 创建滑动条来控制阈值 createTrackbar(trackbar_name, window_name, &amp;slider_value, max_value, thresholdCallback, &amp;src_img); // 鼠标事件响应 cv::setMouseCallback(window_name, mouseCallback); while (char(cv::waitKey(30)) != 'q') &#123;&#125;&#125;int main(int argc, char *argv[])&#123; //setMouseCallbackTest(); //createTrackbarTest(); callbackTest(); while (char(cv::waitKey(30)) != 'q') &#123;&#125; return 0;&#125; 经 Shaun 测试，上面示例程序在 Win10 的 VS2013 中 opencv-2.4.11 和 opencv-3.2.0 下都能完美运行。后记 本来这两个函数都已经写（chao）好了，但为了更好的体现示例程序，又稍作了修改：添加鼠标左键拖拽事件及不使用全局变量等。参考资料[1] opencv2 使用鼠标绘制矩形并截取和保存矩形区域图像（http://www.cnblogs.com/lidabo/category/516776.html）[2] Opencv中添加进度条及回调函数（http://blog.csdn.net/weixin_35738542/article/category/6337413）[3] OpenCV2中滑动条（Trackbar）回调函数的小发现（http://blog.csdn.net/u014291399/article/category/3097955）[4] OpenCV GUI基本操作，回调函数，进度条，裁剪图像等（http://blog.csdn.net/wangyaninglm/article/category/1653815）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用回调函数计算函数运行时间]]></title>
    <url>posts/b6fb6109.html</url>
    <content type="text"><![CDATA[前言 曾有一段时间在写一个小程序，由于其对运行时间有要求，所以每写一段代码就要测试一下运行时间，如果超出就需要优化一下代码或换一种方法和算法。但是每次都需要插在某两个位置插两段代码感觉有点烦，也有点浪费时间，毕竟浪费时间就是浪费生命，本着保尔柯察金关于生命的言论，Shaun 不愿虚度年华，所以只得寻找一个方便简洁的方法计算运行时间（说了这么多，说到底其实就是懒吧 */ω\*）。后面就想到了回调函数，将想要计算运行时间的代码段放入一个函数中，并将其作为回调函数，用事先写好的计算时间函数调用它，从而方便计算该代码段的运行时间。正文Show u the code，具体 C++ 实现代码为：12345678910111213141516171819202122232425262728#include &lt;ctime&gt;#include &lt;cstdio&gt;#define _CALLED_ printf("The function %s", __FUNCTION__);// 使用回调函数计算一段代码执行时间void computeTotalTime(void(*processingCallback)() = 0)&#123; clock_t start_time = clock(); processingCallback(); clock_t end_time = clock(); printf(" takes: %fs.\n", (double)(end_time - start_time) / CLOCKS_PER_SEC);&#125;void test()&#123; for (int i = 0; i &lt; 1000; i++) &#123; printf("Hello World!\n"); &#125; _CALLED_;&#125;int main(int argc, char *argv[])&#123; computeTotalTime(test); return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 本来是想在网上找一个的，谁知道并没有找到，就只有自己动手实现一个了 ╮(╯_╰)╭。后面使用了一下该函数，发现好像并没有提高生产力 o(╯□╰)o，所以就没人放在网上？-_-!，不过确实从实现过程中学到了一些东西 ↖(^ω^)↗。参考资料[1] C/C++之回调函数（http://www.cnblogs.com/danshui/category/345046.html）[2] c/c++在windows下获取时间和计算时间差的几种方法总结（http://blog.csdn.net/coder_xia/article/category/837943）[3] (转)用宏获取函数名（http://www.cnblogs.com/steady/category/264974.html）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>c/cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论如何科学的上网]]></title>
    <url>posts/df943c4f.html</url>
    <content type="text"><![CDATA[科学式上网推荐组合：Chrome，Proxy SwitchyOmega，Lantern 等代理工具。前言 所谓的科学式上网，懂的自然懂，Shaun 也就不做过多解释了。本来一直在用别人免费提供的 pac 代理，但最近可能别人关掉了，上不了 google 了，就只能另寻他路了。所谓的另寻他路也就是尝试云端框架网站站长 枂下 提供的另外几种科学式上网攻略。本文只是对 枂下 站长的攻略做一下试验记录，若想看原滋原味的攻略，还请移步 云端框架。科学的上网方法 尽量使用 Chrome 进行科学式上网，因为其有一个代理管理插件 Proxy SwitchyOmega，该插件称之为代理切换神器也不为过，网上大量的教程和配置文件也是基于该神器做的。使用 Proxy SwitchyOmega 需要进行配置，这对初学者有一定的难度，这里 Shaun 推荐直接使用站长 枂下 提供的配置文件，至于 SwitchyOmega 的配置文件可以去站长的 云端框架 网站上去下，也可以联系 Shaun 。至于代理工具请看下文，Shaun 目前也只尝试过使用以下几种工具。lantern 其实 Shaun 最先尝试的工具是 XX-NET，但是其配置起来稍显繁琐，而且在第一步的时候必须处在科学式上网环境，而 Lantern 就比较简单了，只要装上之后再稍微动动手脚就可以了，所以就把 lantern 写在第一位了。从站长 枂下 那下载【蓝】灯电脑破解版压缩包，不过 Shaun 觉得应该随便在哪里下载个原版 lantern-2.2.5 安装都可以，只要后续的破解方法一样即可。 具体破解方法为：主要是令 lantern 一直保持在 2.2.5 版本不变。但是一般来说 lantern 在安装之后会自动更新到最新版（Shaun 在两台电脑上都安装过 lantern，其中一台安装完之后打开 lantern 安装文件夹发现其已更新，而另一台却没有更新，这就有点玄学了 -_-!），至于判断 lantern 有没有更新的办法是：首先进入 lantern 的安装文件夹：C:\Users\XXX\AppData\Roaming\Lantern（将XXX改成自己的用户名），1、看 lantern.exe 文件的修改日期，如果还是 2016 年的，就说明其还没更新；2、显示隐藏文件，看有没有 .lantern.exe.old 文件，如果没有，则也还没更新。如果已经更新了，参考站长 枂下 的说法：删除lantern.exe文件，修改.lantern.exe.old为lantern.exe这样就又可以回退至 lantern-2.2.5 版。如果没更新的话就不用进行删除回退这一步，直接进行下一步。 下一步为修改 lantern-2.2.5.yaml 文件中的更新路径 updateserverurl，使 lantern 永远不再更新，一直维持在 2.2.5 版本不变。具体更改方式为：将其中的updateserverurl: https://update.getlantern.org修改为updateserverurl: https://pic.black1ce.com修改完之后保存退出。这里 Shaun 觉得可以随便将其修改成其它路径即可，毕竟只是让其不更新而已，这个路径应该除了更新就没有其它作用了，这纯属 Shaun 拙劣的猜测，有（ai）兴（gao）趣（shi）的童靴可以试试 :-P。 原本以为到这一步就完成了，但是 枂下 站长后来又补发了一步，就是上面几步只是让 lantern 不再更新，而 500M 流量之后限速的问题仍然存在（Shaun 目前还没超过 500M，所以不知道这个问题，但抱着有备无患的心态先把 枂下 站长的攻略记一下 O(∩_∩)O~），所以接下来才是上正菜，破解“限制500M流量”问题的具体方法为：当使用 lantern 流量超过 500M 时，打开 lantern 的安装目录，打开 lantern-2.2.5.yaml 文件，修改其中第九行的设备号，随意更换一个数字或者字母即可。按 枂下 站长的说法是 8 位随机字母数字大小写均可，只是为方便起见推荐只改动某位即可。eg：Shaun 目前第 9 行为：deviceid: Gu25Sfoz，一旦 500M 流量用完了，Shaun 就只需要将其修改为 deviceid: Gu25Sfoa 即可。到这一步 lantern 的破解算是基本完成了吧，如果 枂下 站长有新的更新且被 Shaun 看到的话再进行实验更新吧。XX-NET 该工具应该是 Shaun 尝试配置的首款代理工具，不得不说其配置和 lantern 相比实在是太复杂了，而且其中有一步还必须处在科学式网络环境中，Shaun 还是借助别人的 VPN 上的（当时还没用 lantern，所以没用其 500M 免费不限速的流量 ~o(&gt;_&lt;)o~）。Shaun 经过实测 XX-NET 无法在 Firefox 中用 google 搜索，一用 google 搜就会报错：您的连接并不安全www.google.com 的网站管理员未正确配置网站。为避免您的信息被窃，Firefox 没有与该网站建立连接。此网站采用了 HTTP 严格传输安全（HSTS）机制，要求 Firefox 只能与其建立安全连接。正因如此，您也不能将此证书加入例外列表。www.google.com 使用了无效的安全证书。 该证书因为其颁发者证书未知而不被信任。 该服务器可能未发送相应的中间证书。 可能需要导入一个额外的根证书。 错误代码: SEC_ERROR_UNKNOWN_ISSUERhttps://www.google.com/search?q=test&amp;ie=utf-8&amp;oe=utf-8对等端的证书颁发者不受认可。HTTP 严格传输安全（HSTS）：false HTTP 公钥钉扎：true证书链：—–BEGIN CERTIFICATE—– MIIDkzCCAnugAwIBAgIQSu4RvcIwnqiEQE6Z68FlaDANBgkqhkiG9w0BAQsFADBz MQswCQYDVQQGEwJDTjERMA8GA1UECAwISW50ZXJuZXQxDzANBgNVBAcMBkNlcm5l dDEQMA4GA1UECgwHR29BZ2VudDEVMBMGA1UECwwMR29BZ2VudCBSb290MRcwFQYD VQQDDA5Hb0FnZW50IFhYLU5ldDAeFw0xNzA5MTYxNDIzMjRaFw0yNzA5MTQxNDMz MjRaMHgxCzAJBgNVBAYTAkNOMREwDwYDVQQIDAhJbnRlcm5ldDEPMA0GA1UEBwwG Q2VybmV0MRcwFQYDVQQLDA5Hb0FnZW50IEJyYW5jaDEVMBMGA1UEAwwMKi5nb29n bGUuY29tMRUwEwYDVQQKDAwqLmdvb2dsZS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDL3K1OgwalKOJPtO4urpAiu+lioGNax/EIaYR1D2kH66AJ lpal0pYFhXF6MOYCUNfpZIqP5qAQs7JGuRmFdo7rWaLHZ+3S+TlIHdZkoLvyYBcX ENVBcLQvZ7IL7DDUZObK/R7OOKz82dEoITQnT+q/lecR9wQ7QNdNVNqn0xS0NPt7 bS76irMxkJcO2q7Lu4R56ImCox/G7dUEepjL0Po516l6fLKG3qi5org2z6ap0yl2 Etu8cRfqiqaqhO0HI1Twz+Rbp/8KUdUBgnNkjcod83HE+jJKxIUDmn18+l7J8sBi a0JvWSIYy2ccFXoR8L4lfvIa8PhTuMmpxyDkwDdPAgMBAAGjHjAcMBoGA1UdEQEB /wQQMA6CDCouZ29vZ2xlLmNvbTANBgkqhkiG9w0BAQsFAAOCAQEADiM6yWCaGNLn ggirjN0b34j5JmjgYYx3bRaKDe4We2emjlLsdskBo2ztkd/tPBfUa7DWExgFPvVq B2FeEf85Zj72kMmc2JikJBtPF1qK9fa4O1gST4VE0xIF99zGrgkDhGaYd1ocElWS qfBNQfzwsO+nl2OQf99ATMqMSCGacN7z+LJBLn65de+ODzYUkIHzhU5/xJMian3y fQzNFCAgK8OMf16excqRUcX8zfGPfvtAafDrdOYEXcGayLIvt4tGr8T+tii+MtCR O5hXK8/ABMLGI74zgLYloVFjJv21VsLrNCvvD43T5E3c+8d1MENozdEnsyzWkTkp knP4aEiLOQ== —–END CERTIFICATE—–Shaun 不知道为什么 (+﹏+)~。所以为了能正常使用科学式网络，还是老老实实的用 Chrome 吧，何况其还有 Switchyomega 神器，并且建议把 Chrome 设置为默认浏览器。具体配置流程如下： 从 枂下 站长那下载 XX-NET（Shaun 其实最先是直接在 GitHub 上下载最新的 XX-NET，但 Shaun 由于在 Firefox 上尝试失败了，当时也没在 Chrome 上尝试，以为最新版 XX-NET 有问题，后来用上 枂下 站长那下的 XX-NET 在 Chrome 上试了下可以，而 Firefox 不行，就知道可能是 Firefox 的问题，而既然已经能用了，Shaun 也没用最新的 XX-NET 在 Chrome 上尝试了），直接解压到某个文件夹，然后将 XX-Net-3.3.6 文件夹重命名为 XX-Net，即去掉末尾的版本号，据 枂下 站长说法是为了减少后续 XX-NET 出错（Shaun 这里老老实实的照 枂下 站长说的做了，所以也不知道如果没去掉版本号会有什么后果）。接着以管理员身份运行 XX-Net 目录下的 start.vbs 文件（这里右键是没有“以管理员身份运行”选项的，要想以管理员身份运行就只有使用 Windows 命令行了，具体做法就是以管理员身份运行“命令提示符”，再在其中运行 start.vbs 文件即可），运行成功后将弹出已经导入GoAgent证书,请重启浏览器.点击确定即可。再次启动默认（Chrome）浏览器，将打开 127.0.0.1:8085 页面，即为 XX-NET 的配置界面。将看到 GAEProxy 状态信息（可能是由于 google 取消了公共 APPID，所以 Shaun 看到的不是“您正在使用公共APPID，….”这条消息，而是另外一条消息（具体什么消息 Shaun 忘记了 o(╯□╰)o）），打开显示详细信息（其实也没用，Shaun 并看不懂这么多 -_-|||），先放这里吧，部分信息以后再说，先进入正式配置步骤。首先点击左边的“高级”选项，据枂下站长说，将自动调整扫描线程数关掉，最大扫描线程数设为 200，点击提交（可能这样连接速度更快一些）。Shaun 这里这里没有照做，而是保持默认设置，Shaun 只是要求能上就可以了，对速度要求可以稍微放松一点（或许以后会调成站长推荐的配置）。接下来点击“部署服务端”选项，填写 AppID，点击“开始部署”。但是这一步，Shaun 并没有 AppID，所以只能上 google 申请，这样最麻烦的一步就来了。照着 枂下 站长的指引，Shaun 一步步的申请了 AppID。具体申请步骤如下（这一步需要登录 google 账号，必须处于科学式网络环境）：点击 打开Appid申请页面，登录 google 账号，创建项目，并在新建项目中修改项目 ID（这就是第一个 AppID ），为方便，建议直接以“项目名-00”的方式按顺序命名 AppID，创建成功后继续点击“Google Cloud Platform”旁的一个小三角，点击弹框的“+”，按上述方式进行创建新的 AppID，如此重复，Shaun 总共创建 10 个 AppID，10 个之后会提示配额已用完，硬是要创建只会覆盖掉第一个 AppID。接下来就是需要选择语言和地区，只有为每个 AppID 选择语言和地区之后，该 AppID 才会生效。语言和地区的选择界面可以从“App Engine”界面中进入，也可以直接在添加 AppID 界面的那个弹框中点击相应的 AppID 进入，当然如果是第一个 AppID 选择语言可以直接点击界面上的“选择一种语言” 。语言选择 Python，地区选择亚洲（asia-northeast1），选错了后果自负（当然可以覆盖掉该 AppID 重新设置）。其实可以照 枂下 站长那样设置完第一个 AppID 的语言和地区之后直接修改浏览器的地址栏的 url 以快速设置 AppID 的语言和地区。具体修改方法为：将 url 地址末尾的 project 参数的值改为你想要设置的下一个 AppID，eg: Shaun 当前 AppID 为 test-00，对应的浏览器 url 地址末尾的参数为 lang=python&amp;project=test-00，Shaun 想设置的下一个 AppID 为 test-01，则只需将其修改为 lang=python&amp;project=test-01 回车即可快速设置 test-01 的语言和地区。如此重复，就可以设置完全部的 AppID 语言和地区。设置完之后，这些 AppID 就能进行部署了（据说每个 AppID 每天有 1G 的流量可以使用，并于每天下午三点更新，也就是 Shaun 每天有 10G 流量，一般是够用了 :-D）。将上文申请并设置完成的 AppID 放入“GAE AppID”文本框中，多个 AppID 可以按这样的格式放入：test-01|test-02|test-03，两个 AppID 以|分隔即可。点击“开始部署”，会弹出一个登录 google 账号的标签页，登录并允许即可，等待 2~5 分钟，可发现日志页面出现 Done!和Deploy 10 appid successed. 等字样即表示服务端部署成功。点击“部署”选项，将上面部署服务端的 AppID 以相同格式输入“GAE AppID”文本框中，点击“保存”即可。保存完之后，即可在状态信息界面显示详细信息中 Appid 发现当前工作 AppID 就是部署的 AppID ，至于那个配置下的监听代理就是设置代理的地址和端口。这样 XX-NET 就算是配置完成了，至于 枂下 站长说的扫描 ip，Shaun 就没做实验了，因为这样配置完就可以科学式上网了。 以上代理工具配置完成后，即可在 Chrome 中畅游 Internet 了，但是正确的科学式上网姿势应该是：国内的网站走本地连接，而国外被屏蔽的网站才走代理。这就需要 Proxy SwitchyOmega 这款插件了，它能按照一定的规则自动选择走本地还是走代理，这样既不会浪费流量，也能使国内的网站联网速度不受影响。导入前文推荐的配置文件后，就可选择对应的代理方式。这里当然是选择自动切换，至于虚拟切换是选择 Lantern for 8787 还是 XXNET for GAE 就随便个人的喜好了（在走代理的时候别忘了把相应的代理工具开启）；如果直接选择其中一种代理方式就相当于全局代理，这也就失去这款插件的作用，只有自动切换加上虚拟切换才能充分发挥这款神器的真正作用。匿名网络 要想使用匿名网络，当然少不了专用的浏览器：Tor Browser，下载并安装（下载时需要身处科学式网络环境，安装时最好改变一下目录，而且路径中最好不要有中文）。接下来就是配置了 Tor 网络了。具体配置流程如下： 首先，它问直接连接 Tor 网络还是配置网桥或代理，这里当然是选择配置；其次它问互联网服务提供商( ISP )是否对 Tor 网络连接进行了封锁或审查，这里选否，据枂下站长所说因为国内网桥大部分已失效，连接网桥没有意义还会拖慢速度；然后它问是否本地代理访问互联网，这里当然选择是；最后填写本地代理配置，这里需要注意，枂下站长提供的部分代理配置是：SSR/SS Socks5//127.0.0.1 : 1080Seed HTTP//127.0.0.1 : 1080Lantern Socks5//127.0.0.1 : 8287（2系列），三系列的在Lantern设置页面查看Psiphon 可以在配置页面自定义 其中经 Shaun 实测，上面 Lantern 的代理配置是连接不上的，Shaun 后来参考 SwitchyOmega 配置文件中 Lantern 的代理为 HTTP//127.0.0.1 : 8787，经尝试如此配置可以连接 Tor 网络，所以 Lantern 的正确配置应为：Lantern HTTP//127.0.0.1 : 8787（2系列），三系列的在Lantern设置页面查看设置完成后等待片刻就能连上 Tor 网络了，最好就保持原来的 DuckDuckGo 搜索引擎，不要更改，接下来就可随心所欲的畅游 Internet 了。 至于想访问暗网，可以参考Hacking/整理的暗网网址Tor.txt和Working Links to the Deep Web或者直接用站长枂下给的网址：torlinkbgs6aabns.onion和xmh57jrzrnw6insl.onion。据枂下站长回答：XX-Net可以作tor的前置代理吗？不行的，xx-net是假http协议所以 XX-NET 不能用作 Tor 的代理配置。 最后再简要记录一下 Chrome 调用 Tor Browser 的代理吧。Shaun 没有像 枂下 站长那样用命令行去实验，只是享受了一下 ta 的试验成果（O(∩_∩)O谢谢）。总而言之，还是利用 SwitchyOmega，代理方式选择 Tor for 9150，就可以在 Chrome 中调用 Tor Browser 的代理，畅游 Internet 了。更新于：2017-11-27 时久达期间及之后，lantern 的那种破解方式从时灵时不灵，到完全失效，而 XX-NET 则一开始就失效了，这见证了 Google 和 GFW 的斗智斗勇（๑乛◡乛๑），但很明显，google 失败了，事实证明没有 GFW 封不了的，只是看它想不想封 (๑•ั็ω•็ั๑)。至于 lantern 和 XX-Net 的复活方式请移步 枂下 站长的网站，Shaun 这里就不再赘述了。这里需要更新的一点是：Tor 的网桥配置采用“meet-amazon”（亚马逊的云计算平台）或者“meet-azure”（微软的云计算平台）传输也能实现科学式上网，但速度很慢，仅能浏览网页而已，可以当做备选临时用用。更新于 2017-12-24：今天使用了下 赛风（Psiphon），其操作完全傻瓜式，简直不要太好用，而且为单个绿色文件，携带也方便，用的时候只要设置一下端口就行。不出意外的话，妈妈再也不用担心 Shaun 搞科研了（؏؏☝ᖗ乛◡乛ᖘ☝؏؏）。更新于 2018-03-14：现在最新版的 Firefox 59.0 也有 Proxy SwitchyOmega 插件了，虽然还是测试版，但还是能够正常使用，既然 Firefox 有了这款神器，Shaun 也就有动力将 Firefox 使用 XX-Net 连接 Google 搜索出现的问题解决了，首先进入 Firefox 的 「选项」或设置 ==》「隐私安全」，下滑到最下面的「证书」，点击「查看证书」，在弹框中选中「证书机构」，点击「导入」，添加 XX-Net\data\gae_proxy目录下的 CA.crt 证书，在导入中出现的弹框全部选中信任，将会在上方的证书栏中出现 GoAgent XX-Net 证书，这样就能解决上文出现的问题，参考自：【已解决】Firefox报错：github.com 使用了无效的安全证书。 证书因为未提供证书发行链信而不被信任。 （错误码： sec_error_unknown_issuer）后记 最后的匿名网络是 Shaun 弄着好玩的，像暗网这种东西 Shaun 这种遵纪守法的好公民才不会访问呢 (ಡωಡ)。等以后时机到了再去买个国外 VPS 自己搭建一个科学式上网环境吧。最后感谢 枂下 站长的无私分享。附录 原本还以为 Shaun 搭建的 Hexo+GitHub 个人博客站点还是个深网，没想到搞完科学式上网后用 google 搜索竟然能搜到，虽然 Shaun 没做什么，但 google 仍然能搜到，google 的蜘蛛还挺厉害的，不过如果百度的蜘蛛没被 GitHub 屏蔽的话百度可能也能搜到（从某些原因上来说，GitHub 把百度屏蔽掉也好 O(∩_∩)O~）。既然已经被 google 收录了，Shaun 也就不去搞那个站点地图了，等以后想搞 SEO 了再去做吧。参考资料[1] Switchyomega超详细教程之Chrome与Firefox版本[2] 【蓝】灯电脑破解版之2系列禁止自动升级最终办法[3] XX-NET史上最详细完整教程[4] XX-NET史上最详细完整教程之第一部分：Appid创建部分[5] Tor Browser在国内Windows平台下的超详细教程[6] Chrome等其他程序如何完美调用Tor Browser的代理来上网[7] “如何翻墙”系列：TOR 已复活——meek 流量混淆插件的安装、优化、原理（https://program-think.blogspot.com/search/label/IT）[8] 如何翻墙？——写在 BlogSpot 被封之后 {2015-08-28}]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>gfw</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的SPFK主题修改小记]]></title>
    <url>posts/b1e9411b.html</url>
    <content type="text"><![CDATA[前言 Shaun 一直在对 Hexo 的 SPFK 主题进行持续修改以符合 Shaun 自己的需求，在修改当中也会遇到一些小问题，以防遇到重复问题，特此记录所遇小问题，至于大问题可能会另外开篇。修改篇1、修改 aboutme 排版问题修改日期：2017-09-16需求描述：Shaun 为了使 aboutme 排版好看一点，使“关于我”的内容更有段落感，Shaun 尝试在主题配置文件中 aboutme 对象的内容添加各种换行转义符号均于事无补，如 \n、\r\n、&amp;#13;、&amp;#10;、&lt;br /&gt; 等，站点不仅不会换行，还会直接将转义符号都显示出来 (╯﹏╰）。解决办法：既然 Shaun 基本把所有的换行方法都试过了，还没有任何作用，那就只能是问题出在其它地方了。Shaun 首先找到显示 aboutme 内容的地方，其位于主题文件夹下 \layout\_partial\left-col.ejs，显示 aboutme 内容的代码为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%=theme.aboutme%&gt;&lt;/div&gt;，查阅相关资料，具体为 与大家分享ejs源码阅读心得，其中有这样一段话：关于ejs模板的五种模式对应几种指令ejs主要提供了如下几种指令:&lt;%, 该指令主要通过js中的eval来执行js代码, 如上模板代码&lt;% [1,2].forEach(function(v){ %&gt;将通过eval编译成; [1,2].forEach(function(v){即直接可执行的js代码, 并且不会存放到__output函数中输出.&lt;%=, 该指令主要用于输出变量内容, 如上模板代码&lt;%= v %&gt;将通过escape函数编译成__append(escape(v)), 可以看到该指令用于输出变量内容, 最后将通过__output输出内容.&lt;%-, 该指令与&lt;%=区别是, &lt;%=指令使用escape函数来对特殊字符进行编码, 如将&gt;转为%3E, 查看关于escape函数.&lt;%#, 该指令主要用于模板内注释, 既不会执行也不会输出.&lt;%%, 主要用于输出字面值%.关于以上各个指令对应的解析, 可参考ejs源码根目录lib/ejs.js文件中的scanLine函数.从中可得知 &lt;%= 指令会将变量内容中一些特殊字符先转义，再原封不动的输出，所以 Shaun 无论怎么修改主题配置文件中 aboutme 对象的值，其输出内容都会是原封不动的 aboutme 对象的值。为了让其输出内容可以有相应的特殊格式，就不能让其转义，只能用 &lt;%- 指令，将其修改为 &lt;div id=&quot;js-aboutme&quot;&gt;&lt;%-theme.aboutme%&gt;&lt;/div&gt;，这样就能使输出内容可以自定义特殊格式，Shaun 最后在 aboutme 对象的内容中需要换行的地方添加了 &lt;br /&gt;，实测如此修改后可以换行。2、给左栏添加滚动条修改日期：2017-09-18需求描述：SPFK 主题是双栏的主题。因为左栏主要是用来显示一些菜单和头像等内容，这些内容也不多，所以原作者就没有添加滚动条。但是由于 Shaun 添加了个本地搜索功能，在刚开始文章少的时候还不受影响，但是随着文章的增多，搜索功能就会影响左栏的布局，这是就必须添加一个滚动条了。本以为添加滚动条很简单，就是添加一个 overflow: auto;，谁知道还没这么简单 ╮(╯﹏╰）╭。解决办法：Shaun 对问题的定位没问题，就是修改主题文件夹下的 \source\css\_partial\main.styl 文件中 .left-col 样式，问题在于怎么修改，本想直接在其中加入 overflow: auto;，按道理说问题就能解决的，但是 Shaun 去搜索试试，发现搜索框上方的头像，文字等全部消失了，滚动条没起到作用，而下方的菜单可以通过滚动条看到。于是 Shaun 觉得可能是 div 上界没撑开，而超出的地方却隐藏了，但下界为什么能撑开，Shaun 这里还是很不明白 ?_?。既然是这里隐藏了，Shaun 就去看相关标签有没有 overflow: hidden; 属性，谁知道要么是没有，要么是即是关闭了也没有作用，那问题应该不是出在这里。就只能是这些元素所在的子 div 里了，Shaun 找到其子 div 属性 .intrude-less，其中虽有 overflow: auto; 但没设置 height 属性，所以就不能发挥其作用，Shaun 于是给它加上 height 属性，搜索后发现有两个滚动条，这显然不简约，于是 Shaun 把 .intrude-less 的 overflow: auto; 属性注释掉，没想到居然能完美解决问题，可能是因为加上高度属性之后就能撑大父元素 div 了吧（来自某业余前端的猜测 (⊙_⊙)）。后面为了更美观，Shaun 把下方菜单区域的 div 样式 .switch-area 高度 min-height 改小了一点，顺便也把主题文件夹下的 \layout\_partial\left-col.ejs 文件中首行注释掉 &lt;!-- &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt; --&gt; 。Shaun 也曾想把 height 改为 min-height，谁知道又出现相同的问题，不得不又改回去。虽然这次已经解决了问题，但有些细节问题还是不太明白，只有等以后前端水平上去了再去想了，如有大佬知道还望不吝赐教 (^人^)。3、更换鼠标指针修改日期：2017-9-26 ~ 2017-9-27需求描述：Shaun 在玩《Ori and the Blind Forest》这款游戏的时候觉得其鼠标指针很酷炫，于是想把其鼠标指针放在 Shaun 的博客站点中 (๑´ڡ`๑) 。解决办法：要想更改指针，首先需要找到对应的指针文件，最终在万能的贴吧得到指引，在 RealWorld Graphics 上找到两个 ori指针 文件，一个是 动态的 ani指针文件，还有一个是 静态的 cur指针文件（好像该游戏的作者也在 steam 上的评论中提供了游戏中的指针文件，详见：I wanna use this games cursor. ）。既然已经找到了指针文件，就可以开始更换炫酷的鼠标指针 (•̀ᴗ•́)。具体更改方法如下：将下好的指针文件放在主题文件下的 \source\img 文件夹中，在主题配置文件中添加 cursor 属性：12345# set cursor | 设置鼠标指针图标cursor: on: true cursor_0: img/cursor.ani # 首选指针 cursor_1: img/cursor.cur # 备选指针其中 cursor_0 和 cursor_1 代表使用哪个指针，因为 firefox 和 chrome 不支持 ani文件 的指针（好像是 ani 文件有很大的漏洞），所以 ani 动态指针是用不了的，只能用 cur 格式的静态指针，而 IE 是可以加载 ani 格式的动态指针，所以 Shaun 这里就将两个指针文件全放上去了，首选加载动态指针；最后增加相应的代码调用 cursor 属性，加载指针文件，在主题文件夹下 /layout/_partial/background.ejs 文件末尾添加：12345678&lt;% if (theme.cursor.on)&#123; %&gt; &lt;style&gt; body&#123; background: #3f3f3f; cursor: url(&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_0 %&gt;), url(&quot;&lt;%- config.root %&gt;&lt;%- theme.cursor.cursor_1 %&gt;&quot;), auto; &#125; &lt;/style&gt;&lt;% &#125; %&gt;如此更新站点之后即可使用新鼠标指针样式，可能需要先进行 hexo clean 再发布。BTW：这次修改是一个月之前的了，当时不知怎么的忘记记录了，还好 Shaun 的 git 提交记录比较详细，对应的提交记录为：add a function – change cursor和update set cursor function 。4、修改打赏问题修改日期：2017-10-13问题描述：Shaun 突然想玩一下那个打赏小东西，但照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性，没有任何作用，于是去主题文件夹搜索 reward 属性相应的代码，结果是“找不到结果”（坑爹了这是，摔！（╯‵□′）╯︵┴─┴ ）。解决办法：既然 reward 属性找不到就只有搜索 reward_type 属性，最终在主题文件夹下 \spfk_c\layout\_partial\article.ejs 文件中找到这样一条语句 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.toc)) &amp;&amp; !index){ %&gt;，其下面就是打赏相关的代码，查看 SPFK 主题原作者介绍信息（Hexo 主题：SPFK）发现 toc 属性是用来显示目录的（一个用来打赏的代码怎么与文章目录相关了 -_-#），所以上面的 toc 应该改成 reward，修改后的代码为 &lt;% if ((theme.reward_type === 2 || (theme.reward_type === 1 &amp;&amp; post.reward)) &amp;&amp; !index){ %&gt;，这时照配置文件中指示的那样在文章开头 ymal 格式中加入 reward: true 属性就能在相应的文章后面看到一个大大的“赏”字。本来写到这里应该打赏这玩意应该完结了，但 Shaun 无意中在该文件的下面发现这样一段代码：123&lt;% if (!index &amp;&amp; post.toc != false &amp;&amp; !is_page())&#123; %&gt; &lt;%- partial(&apos;_partial/toc&apos;) %&gt;&lt;% &#125; %&gt;这是和 toc（即文章目录）真正相关的代码，功能大概就是判断是否加载文章目录相关的代码，如果在文章开头设置 toc: false，则该文章不会显示目录，但是如果在文章中不加 toc 属性，也会显示文章目录，但上面的打赏却不会显示，看起来 post.toc != false 和 post.toc 应该逻辑差不多，这里是 Shaun 感到十分奇怪的一个地方？后面查阅相关资料（JavaScript undefined 属性）得知:注释：null 表示无值，而 undefined 表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。而本文这里因为没有在文章开头设置 toc 属性，所以其为 undefined，其既不为 false 也不为 true，只为 undefined，当在 if 语句中做判断，会执行 else 分支，作 ! 运算，结果则为：true。所以 if(post.toc) 不能执行其下代码，因为 post.toc 为undefined，不为 true 也不为 false，而 if(post.toc != false) 能执行其下代码，因为 post.toc != false 为真。至于 javascript 中 if(a == ture) 和 if(a) 的区别具体为：前一种是 a 必须为 1 或者 true 才执行；而后一种只要 a 不为 false undefined null 0 -0 NaN &quot;&quot; 这 7 个字符中的其中任何一个都能执行。5、交换内容栏和左侧栏位置修改日期：2017-11-22 ~ 2017-11-23需求描述：Shaun 最近逛网站时发现，好像一些博客网站基本都是把内容放在左侧，百度和 google 的搜索结果也是在左侧，可能是内容在左侧要好一点吧，于是 Shaun 略微修改之后，将内容放在左侧，而原来的左侧栏放到最右侧，好像是顺眼了一点（不排除是心理作用 (ಡωಡ)），如果以后还觉得不错的话，再把相关的变量名换掉吧（此次修改仅仅是将 CSS 相关的值改变，div 类名没变）。解决办法：首先当然是定位左侧栏 .left-col，它在主题文件夹下 source/css/_partial/main.styl 文件中，为其添加 right: 0px; 属性，使左侧栏靠右侧停放；在定位内容栏 .mid-col ，将 right:0; 改成 left:0;，将 left: 300px; 改成 right: left-col-width;，使内容栏靠左侧停放，同时使其距离右侧有左侧栏的宽度。最后就是再修改其他一些小东西（比如目录按钮和目录内容 div 等）的 css 值，关于这个 Shaun 就不细述了，反正也就是更改 left、right、bottom 以及 top 属性及其值，具体修改了哪些内容可以见 Shaun github 提交记录。BTW：诶呀呀！昨天忘记测试手机端，今天用手机打开一看，手机端页面也距右边 left-col-width 宽度，这使得内容全挤在一起了，完全没法看 ರ_ರ …。所以不得不添加手机端样式，定位手机端 .mid-col，它在主题文件夹下 /source/css/_partial/mobile.styl 文件中，为其添加 right: 0; 属性值；后面看见回到顶部、回到底部的导航栏也有点问题，就在该文件中 /*导航*/ 下面 .scroll 上面添加：123#scroll&#123; right: 0;&#125;使得该导航栏靠右停靠。6、更新站点部分 CSS 文件和代码结构修改日期：2017-12-04 ~ 2017-12-06更新日志：Shaun 将 left-col 相关的东西（比如 css 样式和 ejs 文件）全部重名为 right-col，毕竟经过几天的适应，感觉放在右侧还不错，就干脆也将其重命名算了，所以原左侧栏 left-col 从现在开始就完全变成右侧栏 right-col 了；原来的本地搜索框有两个 .search 样式，本次修改将两个 .search 样式合并了，删除重复的样式，只留下一个合并后的 .search 样式；Shaun 同时还优化了一下本地搜索功能的结构，将原来主题配置文件中的 search_box 属性删掉，给 search 属性添加一个 on 的属性来代替 search_box 属性，这样让结构不那么混乱，只由一个 search 属性决定本地搜索功能的开启和关闭及功能的实现，而不是像以前那样由 search_box 属性决定右侧栏搜索框的显示，而 search 属性决定本地搜索功能的实现；更改右侧栏 right-col 的 overflow 样式，原来是右侧栏 right-col 垂直超出滚动，水平超出隐藏，这样在屏幕比较窄的情况在右侧会出现两条滚动条，很不美观。现在 Shaun 将 overflow 样式改成 &amp;:hover {overflow-y: auto; overflow-x: hidden;} ，这样只有在鼠标指针悬浮在右侧栏 right-col 上时才会再右侧栏出现滚动条，这样虽然不能从根本上解决问题，但稍微缓解了一下，等以后再看能不能彻底解决滚动条的问题 ರ_ರ …；Shaun 以前添加 RevolverMaps 这个小部件的时候只是简单粗暴的添加 div 及对应的样式，完全没考虑到主题的扩展性和易修改性。于是 Shaun 将其改成配置文件的形式，在主题配置文件中添加 visual_visitor 属性，只要将其值设置为 RevolverMaps官网 获取的那串 script code，eg：&lt;script type=&quot;text/javascript&quot; src=&quot;//ra.revolvermaps.com/0/0/8.js?i=0lpycb5p234&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt;，即可在右侧栏菜单下的访问情况中看到一个 3D 地球实时显示访客的位置信息，Shaun 为了优化异步访问信息，将其中的 async=&quot;async&quot; 改成 defer=&quot;defer&quot;，这样好像能优化加载次序。这两者的区别可参考 defer和async的区别，好像是都能异步加载，只是 async 是该 script 加载完立即执行，而 defer 是该 script 加载完之后在整个页面结束加载之前执行，也就是最后执行的；最后还修改了 MathJax 的 CDN 地址及配置属性。MathJax 的配置属性可参考 加载和配置MathJax，具体如下：第一种配置Mahtjax的方法就是使用配置文件。MathJax附带了很多种预制配置文件。它们存储在MathJax/config 目录。主要有其中以下几个：default.js：这个文件包含了所有MathJax可用的配置选项，并附有注释和说明，你可以编辑它们来满足你的需要。TeX-AMS-MML_HTMLorMML.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS_HTML.js：允许使用 TeX 或者 LaTeX 符号书写公式。使用Html和Css渲染。MML_HTMLorMML.js：允许使用 MathML 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。AM_HTMLorMML.js：允许使用 AsciiMath 符号书写。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。TeX-AMS-MML_SVG.js：允许使用 TeX, LaTeX, 或者MathML 符号书写公式。使用SVG产生输出。TeX-MML-AM_HTMLorMML.js：允许使用 TeX, LaTeX,MathML,或者 AsciiMath 符号书写公式。如果浏览器支持就处理为MathML，否则就使用Html和Css渲染。第一个文件是提供给你修改的。它基本上包含了MathJax的所有配置选项，同时有注释解释。其他的文件就是我们联合配置文件。它们不仅仅配置Mathjax,还预加载了一些配置所需的文件。这些文件内容在 联合配置 中有详细的解释。原来的 CDN 地址 cdn.mathjax.org 已经在 2017-04-30 日关闭，所以必须更新 CDN 地址，其推荐的 CDN 地址为 cdnjs.cloudflare.com/ajax/libs/mathjax，而新的 MathJax 也提供一种一种新的配置文件 TeX-MML-AM_CHTML（允许使用 TeX, LaTeX,MathML或者 AsciiMath 符号书写公式，使用 CommonHTML 产生输出），新的 MathJax 推荐使用的就是这种配置文件，因为它计划在 V3.0 将 HTML-CSS 输出格式丢弃，只留下 CommonHTML 和 SVG 这两种输出格式。而且新的 CDN 地址不支持 /latest/MathJax.js 这种格式，必须指定一个确定的版本，截止 Shaun 此次修改日期之前，最新的版本为 2.7.2，所以比较推荐的一种加载格式为：&lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt; 。7、添加 404 页面和一些插件等修改日期：2017-12-09 ~ 2017-12-10更新日志：修改文章内 a 标签的高度，即 .article-entry p a 中 padding 的上下边距。文章内的 a 标签在外面加个虚线框本来就很突出了，还设置上下 padding 为 8px，这就显得有点浮夸了 :) 。最后将其上下边距设为 0px；添加 404 页面，具体参考自：在 Hexo 中创建匹配主题的404页面，启动 Git Bash，进入 Hexo 所在文件夹，输入 hexo new page 404 ；打开刚新建的页面文件，默认在 Hexo 文件夹根目录下 /source/404/index.md；在顶部插入一行，写上permalink: /404，这表示指定该页固定链接为 http://&quot;主页&quot;/404.html12345title: 404 Not Found：该页面无法显示toc: falsecomments: falsepermalink: /404---添加 hexo-abbrlink 插件，使文章生成唯一永久链接。这个插件最好是在建站之初就加上，不然写了很多文章之后又都得重新生成链接，搜索引擎需要再次抓取新链接，不利于 SEO，Shaun 这里也就只有等 Google 慢慢抓取更新，还好写的不多，不算太迟。安装完之后 Shaun 在站点配置文件中添加：1234permalink: posts/:abbrlink.html # 需安装hexo-abbrlink插件abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex※BTW：需要将原来的 permalink 注释掉或直接删除。更多设置可参考 hexo-abbrlink 。添加 hexo-all-minifier 插件，快速压缩代码，分别对 html、css、js、images 进行优化。Shaun 这里就直接使用推荐的配置了，直接在站点配置文件中添加：1all_minifier: true # 需安装hexo-all-minifier插件更多设置可参考 hexo-all-minifier 。原来文章标题不可点击，反而日期可点击，这有点奇怪 ◔ ‸◔?。本次修改之后，点击文章标题即为刷新页面。更新日期：2017-12-19 ~ 2017-12-19具体修改内容：主要更新了 404 页面上面的动图，个人偏好喜欢一些星系漩涡之内的动图，偶然发现这个东西（HTML5+Three.js实现的3D可拖拽银河星系旋转动画特效源码），于是将它的源码略作修改放进 Shaun 的 404 页面，将相关的 js 文件放入主题文件夹中 \source\js 文件夹里，最初时是将相关 js 文件引入路径当成相对路径引入，没想到这样造成有的 404 页面会显示旋转动图，而有的 404 页面则不会显示，后面参考网上资料（解惑页面中的相对路径和绝对路径）了解到：html 中引入的资源（包括js、css、img）相对路径：相对的是 网页本身的 URL ；绝对路径：相对的是 网页 URL 的根路径 ；css 中引入的资源相对路径：相对的是 css 文件本身的 URL ；绝对路径：相对的是 网页 URL 的根路径；结论： html 中引入资源的相对路径与 网页的 URL 有关，而css中则与 css 资源本身 URL 有关。但使用绝对路径时，不管是在 html中，还是css中，都只与 网页 URL的根路径有关。将相对路径改为绝对路径，即可在 Shaun 博客域名下所有 404 页面正常显示旋转动图。8、添加 Gitalk 评论系统修改日期：2017-12-16 Gitalk 是一款类似 gitment 的评论系统，Shaun 先是照着它提供的配置添加之后，发现居然与 spfk 主题中的 require-2.1.6,jquery-1.9.1.min.js 冲突，显示不了 Gitalk，Shaun 以为是 bug，所以就去提了个 issue，作者 booxood 还是挺认真负责的（°Д°）Ъ，耐心的解决 Shaun 的问题，原来是 Shaun 的引用方式有问题，需要用 require 方式引用，大佬就是大佬 ○|￣|_，小白还是小白，萌新完全没见过还有这种操作，也算是开眼界了 ✪ω✪。由于大佬解决完问题之后就直接把 issue 关闭了，所以 Shaun 就只有在这里表示感谢了 /つ∇T)。Shaun 最后添加 gitalk 的 ejs 代码如下：123456789101112131415161718&lt;div id=&quot;comments&quot; class=&quot;gitalk&quot;&gt; &lt;div id=&quot;gitalk-container&quot; class=&quot;article article-inner article-entry&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&apos;https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js&apos;], function (Gitalk) &#123; var gitalk = new Gitalk(&#123; clientID: &apos;&lt;%= theme.gitalk.client_id%&gt;&apos;, clientSecret: &apos;&lt;%= theme.gitalk.client_secret%&gt;&apos;, id: window.location.pathname, repo: &apos;&lt;%= theme.gitalk.repo%&gt;&apos;, owner: &apos;&lt;%= theme.gitalk.owner%&gt;&apos;, admin: &apos;&lt;%= theme.gitalk.admin%&gt;&apos;, // facebook-like distraction free mode distractionFreeMode: true &#125;) gitalk.render(&apos;gitalk-container&apos;) &#125;) &lt;/script&gt;&lt;/div&gt;还有其它的一些修改也是仿照 gitment 的代码添加的，我这上面没有添加 css 文件是因为 gitalk 原有的 css 文件与 Shaun 的主题不相符，所以就稍微修改了一下。※BTW：上次修改文章内a标签的高度后突然发现打赏的“赏”字背景圆形变成椭圆了 o(╯□╰)o，后面发现原来它也继承文章内 a 标签的属性，没有自己的 padding，后面只有给 .dashang 添加个独立的 padding: 8px;。9、Fix Bugs修改日期：2017-12-20修复bug：鼠标悬浮 a 标签之上会出现显示 a 标签 title 内容的气泡，当 title 内容过多时，会造成气泡位置下调，从而遮住相应 a 标签内容的 bug。解决方案为：定位气泡文件为主题文件夹下 \layout\_partial\post\TipTitle.ejs 文件，将其中气泡出现的位置改变，原来气泡的位置确定由 top 和 left 决定，现改为 bottom 和 left，毕竟气泡是出现在 a 标签上方，如果将 top 确定，则 title 内容过多时，其只能向下扩张，造成气泡位置下移现象，从而遮住原来的 a 标签内容，改为 bottom 确定之后，气泡只会向上扩张，气泡位置相对稳定，不会遮住原来的 a 标签内容。具体修改内容为，将 top: offset.top - a.outerHeight() - 15 替换为 bottom: window.innerHeight - offset.top + 10 ，其它内容保持不变。修改日期：2017-12-26BUG描述：由于 spfk 主题启用的是百度分享，而原作者没有为其添加邮件分享，Shaun 为了好玩就添加个邮件分享，但是在添加过程中，Shaun 发现了个 BUG，就是为其添加的 title 属性没有作用，它会自动更改 title 内容，而 spfk 主题有显示 title 的气泡 TipTitle，所以不需要用默认的东西显示 title 内容，但是，这个百度分享还是强制默认显示，TipTitle 并不能消除其 title 内容。解决方案：定位百度分享强制添加 title 的代码，其位于主题文件夹下\source\static\api\js\view\share_view.js 中，具体代码如下：1234function(e)&#123; var i=e.partners,s=i[n]?"\u5206\u4eab\u5230"+i[n].name:""; !r(t).attr("title")&amp;&amp;s&amp;&amp;r(t).attr("title",s)&#125;因为 TipTitle 会首先将 title 去掉，所以这里会强制添加百度分享自己的 title，所以需要将其注释掉，具体注释代码为：/*&amp;&amp;r(t).attr(&quot;title&quot;,s)*/。本来这样就可以了，但是 Shaun 发现添加邮件分享之后，布局又不对，所以定位主题文件夹下 \source\css\_partial\baidushare.styl 文件，发现它的居中布局居然是有宽度决定的，于是 Shaun 为其添加 text-align: center; 谁知还是没变，不能自动居中，后来在主题文件夹下找到 \source\static\api\css\share_style2_24.css 文件，发现 .bdshare-button-style2-24 a 设置了浮动样式，难怪（⊙﹏⊙），最后将其注释掉就能自动居中了。最后还需要更改移动端 \source\css\_partial\mobile.styl 中 .bdshare-button-style2-24 的样式设置为自动居中就可以了。10、使文章目录可折叠修改日期：2017-12-28首先声明，本次修改完全参考：为 Hexo 添加可折叠的文章目录，所用代码也来自其文（Shaun 只是做了点微不足道的修改），在此表示感谢 Yelee 主题的作者 MOxFIVE 👍 。具体修改如下：首先在主题文件夹下 \layout\_partial\toc.ejs 中添加 js 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!-- 折叠目录 --&gt;&lt;script type=&quot;text/javascript&quot;&gt; // -------------添加小图标-------------- var $itemHasChild = $(&quot;#toc .toc-item:has(&gt; .toc-child)&quot;); var $titleHasChild = $itemHasChild.children(&quot;.toc-link&quot;); $itemHasChild.prepend(&quot;&lt;i class=&apos;fa fa-caret-down&apos;&gt;&lt;/i&gt;&lt;i class=&apos;fa fa-caret-right&apos;&gt;&lt;/i&gt;&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); $iconToExpand.addClass(&quot;hide&quot;); // --------------点击小图标-------------- var clickIcon = function () &#123; $(&quot;#toc .toc-item &gt; i&quot;).click(function () &#123; $(this).siblings(&quot;.toc-child&quot;).slideToggle(100); $(this).toggleClass(&quot;hide&quot;); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) &#125;() // 默认展开目录，所以隐藏掉表示“目录已展开”的图标（向下的小三角） var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); $iconToExpand.addClass(&quot;hide&quot;); // ------------点击大标题----------------- var clickTitle = function () &#123; $titleHasChild.dblclick(function () &#123; $(this).siblings(&quot;.toc-child&quot;).hide(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125;) // After dblclick enent $titleHasChild.click(function () &#123; var $curentTocChild = $(this).siblings(&quot;.toc-child&quot;); if ($curentTocChild.is(&quot;:hidden&quot;)) &#123; $curentTocChild.show(100); $(this).siblings(&quot;i&quot;).toggleClass(&quot;hide&quot;); &#125; &#125;) &#125;() // ---------点击总标题----------------- var clickTocTitle = function () &#123; var $iconToExpand = $(&quot;.toc-item &gt; .fa-caret-right&quot;); var $iconToFold = $(&quot;.toc-item &gt; .fa-caret-down&quot;); var $subToc = $titleHasChild.next(&quot;.toc-child&quot;); var $tocTitle = $(&quot;#toc .toc-title&quot;); // 当包含多级目录时再执行 if ($titleHasChild.length) &#123; $tocTitle.addClass(&quot;clickable&quot;); $tocTitle.click(function () &#123; if ($subToc.is(&quot;:hidden&quot;)) &#123; $subToc.show(150); $iconToExpand.removeClass(&quot;hide&quot;); $iconToFold.addClass(&quot;hide&quot;); &#125; else &#123; $subToc.hide(100); $iconToExpand.addClass(&quot;hide&quot;); $iconToFold.removeClass(&quot;hide&quot;); &#125; &#125;) &#125; &#125;()&lt;/script&gt;然后添加相应的 css 样式，在主题文件夹下 \source\css\_partial\article.styl 中 #toc 样式里添加 css 样式：1234567891011121314151617181920212223242526ol.toc li.toc-item i &#123; display: inline-block; margin-left: -0.9em; width: 0.9em; color: #b3b3b3; font-weight: bold; cursor: pointer; &amp;:hover &#123; color: #000; &#125; &amp;.hide &#123; display: none; &#125;&#125; .toc-title.clickable &#123; cursor: pointer; &amp;:hover &#123; color: #88acdb; &#125; &amp;:active &#123; color: #d3d3d3; &#125;&#125;以上两步做完之后，点击目录前的小三角符号或双击目录名就能折叠相应目录，点击“文章目录”就能折叠所有目录。待续。。。后记 先就写到这里，如后续修改中发现问题再继续记录吧 ↖(^ω^)↗。]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Qt中Qlabel显示OpenCV的Mat数据图像产生扭曲现象问题]]></title>
    <url>posts/22c3daf1.html</url>
    <content type="text"><![CDATA[前言 曾写过一个程序，需要有一个界面，但 Shaun 不想使用 MFC，因缘巧合，在网上看到 Qt，就尝试用了一下，遂有此文。Shaun 的 Qt 版本为 qt-opensource-windows-x86-msvc2013-5.6.2，看其名字就知道该版本的 Qt 可以通过 Visual Studio 2013 开发 Qt 程序（各位看官猜的没错，Shaun 并没有直接使用 Qt Creator 开发 Qt 程序，而是通过 VS 开发 Qt 程序的 \(^o^)/），一来是熟悉 VS 开发，对 Qt Creator 完全没用过；二来是已经在 VS 配好全套的开发环境了（画外音：说白了就是懒嘛 ╭(╯^╰)╮）。但是在 VS 中开发 Qt 程序还需要一些其它的配置。准备篇 在 VS 中开发 Qt 程序首先需要安装一个 addin 外接程序，下载并安装 qt-vs-addin-1.2.5.exe（http://download.qt.io/archive/vsaddin/），（网上说该程序已不支持 VS2013 及以上版本的 VS，原因是 VS2013 及其以上版本的 VS 都不支持该种类型的插件，新版本的 VS 需要安装新型插件 qt-vs-tools-msvc2013-2.1.1.vsix 或 qt-vs-tools-msvc2015-2.1.1.vsix），但是经 Shaun 实测，Shaun 的 VS2013-update5 英文旗舰版通过 qt-vs-addin-1.2.5 编写 Qt 程序完全没问题，不过 VS2015 就不知道了，可能真需要安装新型插件。下载安装好相应的软件之后需要在 VS 中配置 Qt 环境，虽然不配置也能正常编译，但是会在 Qt 相关的语句下面出现红色波浪线，Shaun 轻微强迫症表示不能忍 ╭(╯^╰)╮。具体配置如下：选中“VC++目录”，在“包含目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\include在“库目录”中添加：C:\Qt\Qt5.6.2\5.6\msvc2013\lib配置完成之后即可发现红色波浪线已消失。使用篇 VS 中如何开发 Qt 程序请详见参考资料，懒癌发作，不想写了 =_=（其实是因为要写的话只能贴图了，Shaun 表示不想使用图片 (╯﹏╰) ）。问题篇问题描述：Shaun 在用 Qt 显示 OpenCV 的 Mat 数据图像时，有时会发生扭曲现象（图像从对角线分开，两边颠倒，扭曲），有时却不会，为了撤了解决问题，查阅了相关资料，终于发现症结所在，原来是图片数据格式不符合 Qt 的图片数据格式。解决办法：正文来喽 ~\(≧▽≦)/~，就不说废话了，“Talk is cheap. Show you the code”，具体完整正确显示C++代码为：123456789101112131415161718192021222324void showMatWithQtQlabel(const cv::Mat &amp;img, QLabel *label)&#123; // [Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决](http://lovelittlebean.blog.163.com/blog/static/11658218620125208212189/) QImage q_img; if(img.channels() == 3) // RGB image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB888).rgbSwapped(); &#125;else if (img.channels() == 4) // RGBA image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_RGB32); &#125;else // gray image &#123; q_img = QImage((const uchar*)(img.data), img.cols, img.rows, img.cols*img.channels(), QImage::Format_Indexed8); &#125; // -------------- 图片自适应label ------------------- QImage q_label_img = q_img.scaled(label-&gt;size(), Qt::IgnoreAspectRatio, Qt::SmoothTransformation); // 图片自适应label大小 label-&gt;setPixmap(QPixmap::fromImage(q_label_img)); // 将图片显示到label上 // -------------- label自适应图片 ------------------- /*label-&gt;setPixmap(QPixmap::fromImage(q_img)); // 显示在label中 label-&gt;resize(label-&gt;pixmap()-&gt;size()); // 改变label的尺寸以自适应图像 label-&gt;show(); */&#125; rgbSwapped() 函数是为了使 Qt 中显示图形颜色更自然，因为 OpenCV 的 Mat 数据 RGB 图像是以 BGR 的顺序排列，而 Qt 中是以 RGB 的顺序排列，所以需要 rgbSwapped() 交换一下颜色通道排列顺序。附录1、摄像头数据采集问题注意：如果是从摄像头实时采集显示图像，在显示时需先判断图像有没有数据1234567if (image.data)&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;或1234567if (!image.empty())&#123; // 执行显示操作 showMatWithQtQlabel(mat, ui.label); // 执行其它操作...&#125;具体原因可参考 Shaun 的一篇文章 解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题 。2、信号与槽的连接函数问题Qt4 中信号与槽的连接函数语法为：1connect(&amp;theTimer,SIGNAL(timeout()),this,SLOT(getFrame())); // 超时就去取下一帧而 Qt5 中信号与槽的连接函数新语法为：1connect(&amp;theTimer, &amp;QTimer::timeout, this, &amp;QtTest::getFrame); //超时就去取下一帧推荐使用 Qt5 新语法，具体原因可参考 qt5中信号和槽的新语法 。个人粗浅理解：信号函数一般是 Qt 中控件的库函数，比如按钮控件 QButton 的 QButton::clicked () 函数，定时器 QTimer 的 QTimer::timeout () 等函数；而槽函数是响应函数，一般由用户自己编写，也可以使用 Qt 中库函数。 使用 Qt 中可能会遇到的一些错误请参考 使用VS2010开发Qt程序的一点经验（http://www.cnblogs.com/csuftzzk/category/445772.html）。后记 本来其实就想把问题篇写出来的，毕竟主要就是想记录一下那个显示函数，但是感觉有点没头没尾，就把 VS 集成 Qt 开发环境也稍微写了一下，而使用篇确实是因为参考资料已经写的很详细了，所以就直接一笔带过了。参考资料[1] QT +openCV 实现摄像头采集以及拍照功能（http://blog.csdn.net/llh318724/article/category/930663）[2] VS2010 + QT5.2+ QT-VS-Addin1.2.2开发环境配置（http://blog.csdn.net/qqmindyourwill/article/category/5990841）[3] Qt+OpenCV界面（http://blog.csdn.net/fm0517/article/category/1110960）[4] Qt中用QLabel显示OpenCV中Mat图像数据出现扭曲现象的解决（http://blog.csdn.net/loveaborn/article/category/1164072）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决OpenCV-2.4.11调用摄像头显示拍摄视频出错问题]]></title>
    <url>posts/509ee93b.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-2.4.11，编程语言为 C++。前言 本文其实是以前在刚学 OpenCV 时遇到的一个问题，当时我的环境还是：Win7，VS2010，opencv-2.4.11。当初就记录了下来，现在再来重新梳理一下。问题篇问题描述：使用 OpenCV-2.4.11 调用摄像头显示拍摄视频时报 runtime error，控制台窗口出现 OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, file ……...cpp, line 261。解决办法：在显示图片时先判断是否有图像数据，如下：1234if (!image.empty()) &#123; imshow("window", image);&#125;或1234if (image.data) &#123; imshow("window", image);&#125;原因可能是：用 imshow() 显示图像时，其 image 必须有数据，如果它为空则程序会报错，而一般打开摄像头会有一定时间的延迟，这时程序已经启动，而摄像头由于启动延迟，不一定能及时获取图像，造成要显示的 image 为空，因此报错。个人粗浅理解，板砖轻拍 ⊙﹏⊙b。而网上有人也认为：我也是遇到这个问题，不过看到一个帖子写得不错（英文的），里面给出了一个可能的理由，就是我们用 opencv 打开视频的时候，会自动先监测摄像头有没有读到帧，如果没有，就会报错，然后再执行你的程序，加一个if判断就是跳过系统自己的判断，直接执行我们的程序。来自：https://zhidao.baidu.com/question/1831122325089024420.html有人说的原因是在 VideoCapture 刚开始获取摄像头视频流的过程不返回信号，所以判断 Mat 是否为空，并不断循环去获取 Mat。来自：http://www.cnblogs.com/tiny656/p/3538115.html附最终完整示例程序：12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt;// 调用摄像头void videoCaptureTest()&#123; //cv::VideoCapture cap(0); // 打开默认摄像头，参数0代表默认摄像头的ID cv::VideoCapture cap; cap.open(0); // 设置摄像头 cap.set(CV_CAP_PROP_FRAME_WIDTH,640); cap.set(CV_CAP_PROP_FRAME_HEIGHT,480); // 确认是否成功打开摄像头 if (!cap.isOpened()) &#123; printf("打开摄像头失败，退出！\n"); exit(-1); &#125; cv::namedWindow("Capture", CV_WINDOW_AUTOSIZE|CV_WINDOW_FREERATIO); while (1) &#123; cv::Mat frame; cap &gt;&gt; frame; // 获取帧 // 对摄像头获取的帧进行各种处理 if (!frame.empty()) // 最好加上该判断，并在该判断中对帧进行处理 &#123; cv::imshow("Capture", frame); &#125; if(cv::waitKey(30) &gt;= 0) break; // 每30ms取一帧 &#125;&#125;int main(int argc, char *argv[])&#123; videoCaptureTest(); return 0;&#125; 其实也可以通过在获取帧时，反复获取帧，直到取到的帧有数据为止，这样就不需要判断语句了，直接显示即可，具体代码如下：123456do&#123; cap &gt;&gt; frame;&#125;while(frame.empty());cv::imshow("Capture", frame);参考自：https://stackoverflow.com/a/9285151 。后记 本文还是当初在国内某平台写博客时写的，但现在再回头看，又稍微有了点新的思路，温故确实能知新 (*^__^*) 嘻嘻……。参考资料[1] OpenCV2.3使用摄像头和视频（http://blog.sina.com.cn/s/articlelist_2749877462_3_1.html）[2] OpenCV Error: Assertion failed (size.width&gt;0 &amp;&amp; size.height&gt;0) in cv::imshow, fi 这个问题怎么办？[3] OpenCV打开摄像头出现运行错误OpenCV Error：Assertion failed (size.width&gt;0&amp;&amp;size.height&gt;0)in cv::imshow，……（http://blog.csdn.net/czl389/article/category/6381887）[4] [OpenCV]获取摄像头视频（http://www.cnblogs.com/tiny656/category/550972.html）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加各种小部件]]></title>
    <url>posts/3bc0decc.html</url>
    <content type="text"><![CDATA[前言 Shaun 目前还在使用对 Hexo 的主题 SPFK 自行魔改的那个主题（所谓的魔改也就是对照着 black-blue 主题修改了部分 CSS，然后又添加了一个站内搜索功能 (&gt;^ω^&lt;)），主题 SPFK 主体的东西其实都没改变。现在正逐渐将其完善中，遂有此文。添加 QQ 邮箱联系添加日期：2017-9-15 进入 QQ邮箱开放平台，点击“获取邮我按钮”，登录 QQ 之后继续点击该按钮，因为 Shaun 不需要其样式，只需要其链接即可，所以就默认样式，直接点击“获取代码”即可，Shaun 默认的“HTML代码”为：1&lt;a target="_blank" href="http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ" style="text-decoration:none;"&gt;&lt;img src="http://rescdn.qqmail.com/zh_CN/htmledition/images/function/qm_open/ico_mailme_01.png"/&gt;&lt;/a&gt;提取其中的 href，即http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ，将该链接添加到 主题配置文件 中，具体如下：12subnav: mail: "http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=qNvAyd3G0d3JxujOx9DFycHEhsvHxQ"重新部署站点即可发现对应的邮箱图标，点击该图标可直接给 Shaun 发邮件。添加 QQ 交谈链接添加日期：2017-9-15 进入 QQ推广，点击上方的“推广工具”，若没登录 QQ 则先登录 QQ，组件样式同样默认即可，这里需要注意的是，需要点击左边的“设置”，下滚页面，找到“安全级别设置”，如下安全级别设置完全公开（推荐商家，客服等用户使用，代码中显示QQ号码，易于推广）安全加密（推荐博主，论坛用户等使用，代码中不显示QQ号码）选中“安全加密”，不然该选项默认的为完全公开，这样 QQ 号码就直接会显示在代码中，不利于隐私保护，选中之后，点击“保存”。保存之后，再次点击“推广工具”，即可发现下方的复制代码区域的 HTML 代码已看不到明码显示的 QQ 号，（若还是能看到 QQ 号，没有任何变化，可关闭该界面，重启浏览器重新进入该界面），Shaun 的“复制这段代码并将其粘贴到您的网页上”下方区域的默认的代码为：1&lt;a target="_blank" href="http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422"&gt;&lt;img border="0" src="http://wpa.qq.com/imgd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422&amp;pic=52" alt="点击这里给我发消息" title="点击这里给我发消息"/&gt;&lt;/a&gt;提取其中的 href，即http://sighttp.qq.com/authd?IDKEY=b1afd83745b30922bc98e020847b86a5148d2114e62e8422，将该链接添加到 主题配置文件 中，具体如下：12subnav: QQ: "http://sighttp.qq.com/authd?IDKEY=4faf682653b3b7f5f47b9cb6d2bb8b81de8fa7a8fb8cee12"重新部署站点即可发现对应的 QQ 图标，点击该图标可直接给 Shaun 发临时 QQ 消息。添加用户访问统计信息小工具 —— RevolverMaps添加日期：2017-10-12 由于 Shaun 暂时不想搞 SEO，所以就没有搞站点地图，更没有将 Shaun 的站点提交到百度和 Google 的站长平台上。但 Shaun 又想查看用户访问信息（是不是很矛盾 o(╯□╰)o），而正好 Shaun 看到有个很酷炫的 3D地球 能满足 Shaun 的需求（其实很酷炫才是主要原因 O(∩_∩)O~），所以 Shaun 决定将其加入 Shaun 的站点中（当做一部分装饰品 ๑乛◡乛๑）。该插件的名称为 RevolverMaps，具体样式可以去其官网看，Shaun 就不贴图了。设置完前三步之后，第四步让用户复制代码到自己的站点上，注意第四步会让你选“new map”还是“update”，由于 Shaun 是初次使用，当然是选择默认的“new map”，如果是以前使用过，就选择“update”，并将原来使用的 script 代码输入出现的文本框并提交，这样就只是更改 3D 地球样式而不会丢失用户访问信息数据。 具体添加方法为：将复制的 script 代码放入想显示的某个 div 中。Shaun 得到的 script 代码为：&lt;script type=&quot;text/javascript&quot; src=&quot;//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 由于 Shaun 的博客是双栏的，Shaun 当然是把 RevolverMaps 放入左栏中，Shaun 刚开始是把得到的 script 代码放入主题文件夹下 \layout\_partial\left-col.ejs 文件末尾的12 &lt;/header&gt; &lt;/div&gt;&lt;/header&gt; 标签之前（即在 header 的最下端显示 RevolverMaps ），但实际用起来有点不好看；Shaun 又想干脆另外创造一个 div 放置地球，具体思路为：在 birdhouse 图标旁创建一个新的地球图标，再做一个像 birdhouse 图标一样的动画，鼠标移到地球图标时，出现一个 div，该 div 用来放置 RevolverMaps，这一步做到一半（即将一个新的地球图标并排放在 birdhouse 图标旁）发现这个效果感觉更不好看了，如果要改就需要大改了，有点麻烦 o(︶︿︶)o唉；于是 Shaun 看到鼠标放在 birdhouse 图标出现的菜单栏上，想到何不如将该菜单栏在添加一栏，创建一个 div 用来显示 RevolverMaps？事不宜迟，马上就动手添加该 div，具体添加步骤如下：首先当然是添加一个“访问情况”的列表名称，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;ul class=&quot;tips-inner&quot;&gt; 下最后一个 &lt;li&gt; 后即 &lt;/ul&gt; 前添加 &lt;li&gt;访问情况&lt;/li&gt;；接着像其它的列表一样（点击该列表 birdhouse 图标就会改变成相应的图标），点击“访问情况”会将 birdhouse 图标改变成一个地球小图标，经查阅相应的 css 文件，其它的列表对应的图标好像是利用 div 的边框属性画出来的（某业余前端的猜测+_+），Shaun 目前还没有这样的才能，就只有投机的采用 Font Awesome 中的 globe 图标了。在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;icon-ctn&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;div class="icon-wrap icon-globe hide" data-idx="4"&gt; &lt;i class="fa fa-globe fa-spin fa-2x" aria-hidden="true"&gt;&lt;/i&gt;&lt;/div&gt;这样点击“访问情况”会将 birdhouse 图标变成一个旋转的地球小图标了；接下来就需要创建“访问情况”对应的 div 了，在主题文件夹下 \layout\_partial\left-col.ejs 文件中 &lt;div class=&quot;switch-wrap&quot;&gt; 下最末尾即其对应的 &lt;/div&gt; 前添加：123&lt;section class="switch-part switch-part5"&gt; &lt;script type="text/javascript" src="//rf.revolvermaps.com/0/0/8.js?i=50om5cdoa3h&amp;amp;m=7&amp;amp;c=ff0000&amp;amp;cr1=ffffff&amp;amp;f=arial&amp;amp;l=49" async="async"&gt;&lt;/script&gt;&lt;/section&gt;这样点击“访问情况”就能出现酷炫的 3D 地球了，才怪 :p。这样只能让 3D 地球出现在菜单界面，还需要添加修改相应的 css；最后就是改 css 样式了，本以为这一步很简单，没想到这一步花费 Shaun 最多时间 ╮(╯_╰)╭，修改的样式位于主题文件夹下 \source\css_partial\main.styl 文件中，首先为 switch-part5 添加对应的样式，在 .switch-part4 样式后添加：123456.switch-part5&#123; left: 400%; width: 100%; //height: 200px; //margin-left: 47px; &#125;做完这一步会发现 3D 地球显示不完全，下面会缺一点，所以还需要继续修改，修改过程如下：Shaun 曾将该 width 减小（如上面代码中的注释），这样确实能让 3D 地球显示完全，但有点小，不是很好看；后面想到没显示完全可能是上层 div（.switch-area）太小且设置了 overflow: hidden;，于是这里 Shaun 首先增加了 .switch-area 的高度，这样确实能解决问题，但会使左栏的滚动条显示出来；所以 Shaun 接着尝试将 .switch-area 的 overflow: hidden; 注释掉，谁想注释掉之后出现了横向滚动条，这样更不好了，于是 Shaun 又更改为 overflow-x: hidden; ，谁想 .switch-area 又出现了竖直滚动条（感觉像拆东墙补西墙 -_-|||），查阅相关资料（CSS-overflow特性及总结）得知若 overflow-x 为 hidden，overflow-y 不为 hidden，则 overflow-y 将会自动重置为 auto，所以这里不能这样改，但 overflow: hidden; 还是得注释掉，不然上层 div 撑不开，而且不增加高度的话，还是不能完全显示 3D 地球，因为超出就隐藏了嘛；因为注释掉之后会出现横向滚动条，而又不能修改 .switch-area 的 overflow-x，所以就只能改更上层的 div，这里 Shaun 突然想起上次给左栏添加滚动条时，在 .left-col 下添加了 overflow: auto;，这次不如还修改这里，毕竟 Shaun 只想要竖直滚动条（其实不要滚动条却能滚动最好，但 Shaun 目前还没找到好的解决方案 (╯﹏╰)b），不要横向滚动条，于是将其修改为：12overflow-y: auto;overflow-x: hidden;没想到这样也能解决问题，虽然还是会在左栏出现滚动条，但这样感觉比增加 .switch-area 的高度要好（嗯，应该要好吧 (～ o ～)Y）。看以后能不能改成点击“访问情况”时才出现滚动条，点击其它列表则不出现滚动条（其实把滚动条隐藏最好，但网上那个两个 div 嵌套的方法 Shaun 尝试过会出现一些奇怪的问题，等以后再试试吧 ↖((^ω^)↗）。待续。。。后记 目前就添加这些小组件，以后应该会陆续添加一些其它的小东西 ↖(^ω^)↗。参考资料[1] 如何在自己网站上或者博客上放置QQ邮箱联系反馈（http://jingyan.baidu.com/tag?tagName=%E9%82%AE%E7%AE%B1）[2] 如何在自己的博客添加QQ组件（http://www.29mo.com/category/wltg）[3] 一步一步教你给自己博客添加QQ在线（http://www.feizl.com/feizhuliu/QQbaodian/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中显著性检测算法的使用]]></title>
    <url>posts/fd0f8195.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV 中实现了两种显著性检测算法，分别为 Spectral Residual 算法,出自 Xiaodi Hou and Liqing Zhang. Saliency detection: A spectral residual approach. In Computer Vision and Pattern Recognition, 2007. CVPR’07. IEEE Conference on, pages 1–8. IEEE, 2007. 和 Fine Grained Saliency 算法,出自 Sebastian Montabone and Alvaro Soto. Human detection using a mobile platform and novel features derived from a visual saliency mechanism. In Image and Vision Computing, Vol. 28 Issue 3, pages 391–402. Elsevier, 2010.。这两种算法同样是在扩展包 opencv_contrib-3.2.0 中，也是由于 opencv 官方示例程序对初学者不友好（主要是 Shaun 境界不够 o(╯□╰)o），所以 Shaun 对照其官方文档重新整理了一下。说明篇 使用 OpenCV 中实现的显著性检测算法进行显著性检测十分方便简洁，利用以下三个函数就可以：创建 Spectral Residual 算法显著性检测对象：static Ptr&lt;StaticSaliencySpectralResidual&gt; cv::saliency::StaticSaliencySpectralResidual::create();Spectral Residual 算法计算显著性图：bool cv::saliency::StaticSaliencySpectralResidual::computeSaliency(InputArray image, OutputArray saliencyMap);Fine Grained Saliency 算法显著性检测对应的函数声明同 Spectral Residual 算法类似。计算显著性图的二值图：bool cv::saliency::StaticSaliency::computeBinaryMap(InputArray _saliencyMap, OutputArray _binaryMap) ;具体使用方法可参考实例篇。实例篇 使用 OpenCV 中的显著性检测算法需要包含头文件#include &lt;opencv2/saliency.hpp&gt;，具体示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/saliency.hpp&gt;//******************************************************// [opencv_contrib/modules/saliency/src/saliency.cpp](https://github.com/opencv/opencv_contrib/blob/b7dcf141507edbe544e75820c76769a7769223ac/modules/saliency/src/saliency.cpp)////Ptr&lt;Saliency&gt; Saliency::create(const String&amp; saliencyType)//&#123;// if (saliencyType == "SPECTRAL_RESIDUAL")// return makePtr&lt;StaticSaliencySpectralResidual&gt;(); //computeSaliency返回的是32FC1// else if (saliencyType == "FINE_GRAINED")// return makePtr&lt;StaticSaliencyFineGrained&gt;(); //computeSaliency返回的是8UC1// else if (saliencyType == "BING")// return makePtr&lt;ObjectnessBING&gt;();// else if (saliencyType == "BinWangApr2014")// return makePtr&lt;MotionSaliencyBinWangApr2014&gt;();// return Ptr&lt;Saliency&gt;();//&#125;//// [opencv_contrib/modules/saliency/src/staticSaliency.cpp](https://github.com/opencv/opencv_contrib/blob/41b0a71ac826b1489d3e5c208ac7a95e58556caf/modules/saliency/src/staticSaliency.cpp)//computeBinaryMap()要求输入的saliencyMap为浮点数（eg:32FC1）//*****************************************************void spectralResidualTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入最真实的原始图像 cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); // [OpenCV实现显著性检测中的谱残差法（Spectral Residual Method）涉及到了傅立叶正反变换](http://blog.csdn.net/kena_m/article/details/49406687) if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Mat planes[] = &#123; cv::Mat_&lt;float&gt;(src_img), cv::Mat::zeros(src_img.size(), CV_32F) &#125;; cv::Mat complex_img; //复数矩阵 merge(planes, 2, complex_img); //把单通道矩阵组合成复数形式的双通道矩阵 dft(complex_img, complex_img); // 使用离散傅立叶变换 //对复数矩阵进行处理，方法为谱残差 cv::Mat magnitude, phase_angle, mag_mean; cv::Mat real_part, imaginary_part; split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; //实部 imaginary_part = planes[1]; //虚部 cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值 phase(real_part, imaginary_part, phase_angle); //计算相角 float *pre, *pim, *pm, *pp; //对幅值进行对数化 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = log(*pm); pm++; &#125; &#125; blur(magnitude, mag_mean, cv::Size(5, 5)); //对数谱的均值滤波 magnitude = magnitude - mag_mean; //求取对数频谱残差 //把对数谱残差的幅值和相角划归到复数形式 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pre = real_part.ptr&lt;float&gt;(i); pim = imaginary_part.ptr&lt;float&gt;(i); pm = magnitude.ptr&lt;float&gt;(i); pp = phase_angle.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = exp(*pm); *pre = *pm * cos(*pp); *pim = *pm * sin(*pp); pre++; pim++; pm++; pp++; &#125; &#125; cv::Mat planes1[] = &#123; cv::Mat_&lt;float&gt;(real_part), cv::Mat_&lt;float&gt;(imaginary_part) &#125;; merge(planes1, 2, complex_img); //重新整合实部和虚部组成双通道形式的复数矩阵 idft(complex_img, complex_img, cv::DFT_SCALE); // 傅立叶反变换 split(complex_img, planes); //分离复数到实部和虚部 real_part = planes[0]; imaginary_part = planes[1]; cv::magnitude(real_part, imaginary_part, magnitude); //计算幅值和相角 for (int i = 0; i &lt; magnitude.rows; i++) &#123; pm = magnitude.ptr&lt;float&gt;(i); for (int j = 0; j &lt; magnitude.cols; j++) &#123; *pm = (*pm) * (*pm); pm++; &#125; &#125; GaussianBlur(magnitude, magnitude, cv::Size(7, 7), 2.5, 2.5); cv::Mat invDFT, invDFTcvt; normalize(magnitude, invDFT, 0, 255, cv::NORM_MINMAX); //归一化到[0,255]供显示 invDFT.convertTo(invDFTcvt, CV_8U); //转化成CV_8U型 cv::namedWindow("SpectualResidual", CV_WND_PROP_ASPECTRATIO); cv::imshow("SpectualResidual", invDFTcvt); cv::Mat thresholded; cv::threshold(invDFTcvt, thresholded, 0, 255, CV_THRESH_OTSU); cv::namedWindow("Thresholded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded Image", thresholded); cv::Mat eroded; // 纵向腐蚀 cv::erode(thresholded, eroded, cv::Mat(5, 1, CV_8UC1, cv::Scalar(1)), cv::Point(-1, -1), 3); // cv::Point(-1,-1)为默认参数，代表原点（描点）为矩阵中心 cv::namedWindow("eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("eroded Image", eroded); //cv::Mat thresholded; cv::threshold(eroded, thresholded, 60, 255, CV_THRESH_BINARY); cv::namedWindow("Thresholded eroded Image", CV_WND_PROP_ASPECTRATIO); cv::imshow("Thresholded eroded Image", thresholded);&#125; // 显著性检测算法基类void saliencyTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::Saliency&gt; saliency_algorithm = cv::saliency::Saliency::create("SPECTRAL_RESIDUAL"); // FINE_GRAINED为Fine Grained Saliency算法 cv::Mat saliency_map; if (saliency_algorithm-&gt;computeSaliency(src_img, saliency_map)) // 计算显著性图 &#123; cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", saliency_map); cv::Mat saliency_map_show(saliency_map.size(), CV_8UC1); normalize(saliency_map, saliency_map_show, 0, 255, CV_MINMAX); //归一化到[0,255]供显示 saliency_map_show.convertTo(saliency_map_show, CV_8U); //转化成CV_8U型 cv::namedWindow("saliency_map_show", CV_WND_PROP_ASPECTRATIO); cv::imshow("saliency_map_show", saliency_map_show); cv::Mat binary_map; cv::saliency::StaticSaliencySpectralResidual spec; if (spec.computeBinaryMap(saliency_map, binary_map)) // 对显著性图进行二值化 &#123; cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); &#125; &#125;&#125;// Fine Grained Saliency算法void FGSTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencyFineGrained&gt; fgs = cv::saliency::StaticSaliencyFineGrained::create(); cv::Mat fgs_saliency_map; fgs-&gt;computeSaliency(src_img, fgs_saliency_map); cv::namedWindow("FGS saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("FGS saliency map", fgs_saliency_map); //cv::imwrite("../data/T_S.png", fgs_saliency_map); cv::Mat binary_map; cv::threshold(fgs_saliency_map, binary_map, 0, 255, CV_THRESH_OTSU); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map); //cv::imwrite("../data/T_S_B.png", binary_map);&#125;// Spectral Residual算法void SRTest()&#123; cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); cv::namedWindow("src_img", CV_WND_PROP_ASPECTRATIO); cv::imshow("src_img", src_img); if (src_img.empty()) exit(-1); if (src_img.channels() == 3) cv::cvtColor(src_img, src_img, CV_BGR2GRAY); cv::Ptr&lt;cv::saliency::StaticSaliencySpectralResidual&gt; sr = cv::saliency::StaticSaliencySpectralResidual::create(); cv::Mat sr_saliency_map; sr-&gt;computeSaliency(src_img, sr_saliency_map); cv::namedWindow("SR saliency map", CV_WND_PROP_ASPECTRATIO); cv::imshow("SR saliency map", sr_saliency_map); cv::Mat binary_map; sr-&gt;computeBinaryMap(sr_saliency_map, binary_map); cv::namedWindow("binary map", CV_WND_PROP_ASPECTRATIO); cv::imshow("binary map", binary_map);&#125;int main(int argc, char *argv[])&#123; //spectralResidualTest(); //saliencyTest(); //FGSTest(); SRTest(); while (cv::waitKey(0) != 27) &#123; &#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。 这里面有个小东西需要注意，就是 computeBinaryMap() 函数，看其文档描述其中使用 K-means 算法和 Otsu 算法对显著性图进行二值化处理，其输入的显著性图数据类型应该为浮点数，OpenCV 中 Spectral Residual 算法 computeSaliency() 返回的结果为浮点数，而 Fine Grained Saliency 算法 computeSaliency() 返回的结果却是整型数据，所以这一点需要注意 Fine Grained Saliency 算法返回的结果不能直接使用 computeBinaryMap() 函数，一般对其结果直接使用 OTSU 算法进行阈值分割即可。后记 本文使用的这两种算法在 Shaun 的电脑上运行时间都较长，基本不可能用来处理视频流，而且在 Shaun 的这次实验中效果也不太理想，毕竟这是用来处理静态图像的两种显著性方法。不过 OpenCV 中也有用来处理视频流的显著性检测算法，其为 BING 算法,出自Ming-Ming Cheng, Ziming Zhang, Wen-Yan Lin, and Philip Torr. Bing: Binarized normed gradients for objectness estimation at 300fps. In IEEE CVPR, 2014.，实际上这是一种快速提取目标候选框的算法。]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCV中Selective Search算法的使用]]></title>
    <url>posts/35132cb7.html</url>
    <content type="text"><![CDATA[本文所用的 OpenCV 版本为 opencv-3.2.0，编程语言为 C++。前言 OpenCV-3.2 中的 Selective Search 算法是在其扩展包中，所以要想使用该算法需自行编译 opencv_contrib-3.2.0。由于扩展包中的示例程序有点简陋，对初学者也不友好（Shaun 编程水平有限，粗浅评价，勿怪 (*^__^ *) 嘻嘻……），所以 Shaun 参考其官方文档及其官方示例程序写下此文。说明篇 该算法是选取 region proposal（一般翻译成候选区域 / 区域建议）领域中当时的 state-of-the-art。其算法具体思想出自 Jasper RR Uijlings, Koen EA van de Sande, Theo Gevers, and Arnold WM Smeulders. Selective search for object recognition. International journal of computer vision, 104(2):154–171, 2013.，若英文水平不够，还想了解其中文思想请参考文末参考资料。 OpenCV中实现的相应函数：void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addGraphSegmentation(Ptr&lt;GraphSegmentation&gt; g);：添加相应的图割算法；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addImage(InputArray img) ; ：添加待处理的图片；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::addStrategy(Ptr&lt;SelectiveSearchSegmentationStrategy&gt; s); ：添加相应的策略（颜色相似度、纹理相似度、尺寸相似度和填充相似度）；void cv::ximgproc::segmentation::SelectiveSearchSegmentation::process(std::vector&lt;Rect&gt; &amp;rects);：结合图割算法和相应策略进行处理，返回候选框。实例篇 使用 Selective Search 算法需包含#include &lt;opencv2/ximgproc.hpp&gt;，完整示例程序如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/ximgproc.hpp&gt;void SSTest()&#123; // [Image segmentation](http://docs.opencv.org/3.2.0/d5/df0/group__ximgproc__segmentation.html#ga5e3e721c5f16e34d3ad52b9eeb6d2860) cv::Mat src_img = cv::imread("../data/true.png", CV_LOAD_IMAGE_ANYDEPTH | CV_LOAD_IMAGE_ANYCOLOR); // 载入原始图像 cv::namedWindow("src_img", CV_WINDOW_KEEPRATIO); cv::imshow("src_img", src_img); //// 转换为灰度图 //cv::Mat gray_img; //cvtColor(src_img, gray_img, cv::COLOR_BGR2GRAY); // 图割算法 cv::Ptr&lt;cv::ximgproc::segmentation::GraphSegmentation&gt; gs = cv::ximgproc::segmentation::createGraphSegmentation(); cv::Mat graph_segmented; gs-&gt;processImage(src_img, graph_segmented); normalize(graph_segmented, graph_segmented, 0, 255, CV_MINMAX); // 归一化到[0,255]供显示 graph_segmented.convertTo(graph_segmented, CV_8U); // 数据类型转化成CV_8U型 // cvtColor(graph_segmented, graph_segmented, CV_GRAY2BGR); cv::namedWindow("graph_segmented", CV_WINDOW_KEEPRATIO); imshow("graph_segmented", graph_segmented); // 为selective search算法添加图割算法处理结果 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;addGraphSegmentation(gs); ss-&gt;addImage(src_img); // 添加待处理的图片 // 自定义策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_color = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyColor(); // 颜色相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_texture = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyTexture(); // 纹理相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_size = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategySize(); // 尺寸相似度策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss_fill = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyFill(); // 填充相似度策略 // 添加策略 cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentationStrategy&gt; sss = cv::ximgproc::segmentation::createSelectiveSearchSegmentationStrategyMultiple(sss_color, sss_texture, sss_size, sss_fill); // 合并以上4种策略 ss-&gt;addStrategy(sss); std::vector&lt;cv::Rect&gt; regions; ss-&gt;process(regions); // 处理结果 // 显示结果 cv::Mat show_img = src_img.clone(); for (std::vector&lt;cv::Rect&gt;::iterator it_r = regions.begin(); it_r != regions.end(); ++it_r) &#123; cv::rectangle(show_img, *it_r, cv::Scalar(0, 0, 255), 3); &#125; cv::namedWindow("show_img", CV_WINDOW_KEEPRATIO); imshow("show_img", show_img); // -------忽略上述步骤，直接采用方便算法提取候选区域------------------------ /*************************************************************************** cv::Ptr&lt;cv::ximgproc::segmentation::SelectiveSearchSegmentation&gt; ss = cv::ximgproc::segmentation::createSelectiveSearchSegmentation(); ss-&gt;setBaseImage(src_img); // 采用switch* functions提取候选区域 ss-&gt;switchToSelectiveSearchFast(); // 快速提取区域 std::vector&lt;cv::Rect&gt; rects; ss-&gt;process(rects); int nb_rects = 10; char c = (char)cv::waitKey(); while (c != 'q') &#123; cv::Mat wimg = src_img.clone(); int i = 0; for (std::vector&lt;cv::Rect&gt;::iterator it = rects.begin(); it != rects.end(); ++it) &#123; if (i++ &lt; nb_rects) &#123; cv::rectangle(wimg, *it, cv::Scalar(0, 0, 255), 3); &#125; &#125; cv::namedWindow("Output", CV_WINDOW_KEEPRATIO); imshow("Output", wimg); c = (char)cv::waitKey(); if (c == 'd') &#123; nb_rects += 10; &#125; if (c == 'a' &amp;&amp; nb_rects &gt; 10) &#123; nb_rects -= 10; &#125; &#125; ********************************************************/&#125;int main(int argc, char *argv[])&#123; SSTest(); while (cv::waitKey(0) != 27) &#123;&#125; return 0;&#125;以上代码在 Win10 VS2013 中编译运行成功。后记 使用该算法，要想达到理想效果，一般需要调整图割算法的参数或注释中方法 switchToSelectiveSearchFast() 的参数。Shaun 的这次实验为了达到理想的选取的效果，其调整参数花了不少时间，而且该算法运行时间在 Shaun 电脑上略显长。GitHub 上也有大神自己用 opencv 实现了该算法，参考 watanika/selective-search-cpp，该算法的参数感觉比 OpenCV 自带的 Selective Search 算法要好调一些，但优化效果没有 opencv 好，其运行时间在 Shaun 电脑上更长，毕竟 OpenCV 是 Intel 的亲儿子，Intel 肯定针对处理器对 OpenCV 底层做了一定的优化。参考资料[1] 论文笔记：Selective Search for Object Recognition（http://jermmy.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/）[2] Selective Search for Object Recognition(阅读)（http://blog.csdn.net/langb2014/article/category/5772811）[3] 论文笔记 《Selective Search for Object Recognition》（http://blog.csdn.net/csyhhb/article/category/6048588）]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[别了，漆黑的象牙塔]]></title>
    <url>posts/170c76cc.html</url>
    <content type="text"><![CDATA[前言 这是 Shaun 从朋友那里听来的一个故事。此真实事件根据故事改编，如有雷同，实属正常。序篇 故事还得从朋友大四上学期说起。大四上学期在确定能保研之后，因为这个时代只要有保研资格就可以随便去哪所学校，本校并不会干涉，由于朋友本科所在的院校并不是非常好，所以朋友就查阅了一些更好的学校（毕竟人往高处走，水往低处流，这可以理解），可惜国内顶尖的学校都要求英语很好，而朋友的英语成绩一直不好，甚至可以说是最差的，所以朋友就直接放弃了那些顶尖院校（不过也是朋友当年见识太短浅，其实除开那些真正的顶尖院校，还是有些更好的机会的），既然顶尖的学校进不去，那就去看看一流的院校吧，其中发现一所学校的要求很简单，基本不要求什么英语能力，所以朋友就考虑一下，找了一下自己真正感兴趣的东西，然后就去发邮件联系了一下那所院校研究那个方面的一个老师，当时写邮件等消息的时候，朋友的心情还是很忐忑的，终于，那边的老师回了消息：欢迎报考。 后面在推免系统中填志愿的时候，朋友就直接填了那所院校，这其中发生了些小插曲，就是朋友当时很年轻，想着读个学硕试试，结果等了一天，没有消息，朋友的身边有个同学已经拿到了学硕录取通知，所以第二天一大早朋友就直接给那边招生的地方打了个电话，问那边是否学硕名额是否招满了，专硕还有没有招满，当听到学硕已经招满，但专硕还没招满时，朋友心里当时还是有点失落的，但没办法，只能将学硕的志愿改成专硕了，还好最后顺利的进入了那所学校。拿到录取通知后，朋友试着和那位老师接触了几次，在接触的过程中发现，这位老师应该不是朋友理想中的老师，甚至可以说有点差劲了，但朋友当时还是太年轻，脸皮薄，不好意思再去找其它的老师，因为这个时候老师还没有完全确定，其实还是可以换老师的。说到这里，朋友总结了几点教训，算是给后来者的参考吧，由于朋友没考过研，所以不知道考研是怎么回事，以下几点主要针对可能保研的童靴：一般的学校可能要到大四上才能完全确定保研资格（有的学校大三下就完全确定了），而有些研究生机构在大三暑假期间可能就把录取名额基本确定了，所以如果在大三下觉得自己能保研并且有保研的想法，判断自己能不能保研很简单，拿着上一届保研的人数百分比，在计算一下自己在专业排名前百分之多少，再考虑一下排名后面的保研加分情况，就能判断自己能不能保研，毕竟不出意外的话，同一个专业的保研比率是基本变化不大的，朋友当年对自己很没自信，所以就丧失了一些机会，不过朋友在本科期间也确实没有什么能拿的出手的成绩，所以就算有这些机会也没用。在判断自己能保研之后，就可以去网上查阅资料，看哪些院校机构是在暑假或9月份就确定录取名额的，可以选择报名参加对方的夏令营或类似活动了，这里需要注意，有些院校机构保研录取对夏令营很看重，而有些夏令营活动则基本没用，报名之前多查查问问吧。在选老师时，如果没有找好确切的目标，就不要去随意的联系一个老师，最好做好调查再去，因为没人会想把自己未来几年的生活赌在虚无缥缈的命运上吧，毕竟研究生的老师直接决定研究生生涯过的咋样，老师很差劲，可能一辈子都毁了，至于如何找一个相对理想的老师，以下两类老师不要优先考虑：1、50岁以上不在科研一线的老师，因为年纪大而又不在科研一线基本就和科研完全脱离了，而这个岁数的老师既要为父母孩子考虑还要为自己退休考虑，所以基本上会尽量去捞钱，而且由于他们在象牙塔里呆了一辈子，基本也和外面的社会脱节了，所以别想着他们会对学生有任何帮助，不阻碍学生的发展就是积阴德了，而且这个年纪的老师有一部分思想还停留在旧社会，认为学生即学徒，是师傅的奴隶，极其不尊重学生；2、女老师，这不是朋友性别歧视，而是以朋友这些年的见识来看，女老师的一堆屁事确实比男老师要多一点，要学生干着干那的，写文档写报告拿快递，甚至还有备课等等，当然并不是所有的女老师都是这样，甚至有些女老师比男老师还要好很多，这个不能一概而论，只是从朋友有限的见识来看，碰到一个好女老师的可能性有点低，不过如果能百分百确信该老师是个真正的好老师，就放心大胆的报吧。因为这两类老师能够非常直观的知道，当然还有一类相对来说也比较容易知道，那就是太闲的老师，一个很好的判定标准就是：经常呆在办公室的老师一般很闲。太闲的老师一般闲着没事干，没事干就会想着怎么给学生找点事做，顺便也充实下自己的工作生活，于是学生就不好过了。其它的可能就必须要亲身体会才能知道了，这就基本很难查到了，朋友就不谈了，反正只要知道一个，就是好老师都是相似的，而坏老师各有各的坏，好老师是能真正为学生考虑的，知道学生想要什么，而不是打着“为你好”的旗号行各种各样损人而又不一定利己的坏事。至于如何调查一个老师，首先当然是院校老师的主页，其次就是知网（可别问 Shaun 什么是知网），再次就是谷歌学术（也别和 Shaun 说不存在这个网站），最后是科学网等一些网站了，基本查完这些，就能对老师的学术水平有一定的认识，甚至对人品也会有一点了解，会不会抢学生的一作，至于老师真正的人品咋样，如果能联系上在 ta 手下读研且已经毕业的学长学姐是最好的，如果联系不上那就听天由命吧，毕竟人与人之间的相处是玄学，你与我相处不好，但和别人相处很好。还有就是老师作为一个人，一般就拥有人的一些特性，其对待同事一个样，对待朋友一个样，对待。。。。。。，对待学生一个样，所以作为一个学生最好的就是从老师的学生处打听，当然基于某些原因别人一般也不会如实说，更重要的是，随着老师的年纪和在学院的地位不断提升，简而言之，就是老师在其教学生涯的不同时期对学生的态度也是不同的，所以选择一个老师，其实还是挺看运气的。PS： 当一个实验室有很多个老师而实验室大老板控制欲很强时，慎选该实验室，要选也优先选大老板。如果在大三下学期没有认真准备保研的事，而是在拿到确切的保研名额之后才着手保研的事，那么就不要吝啬电话费了，碰到心仪的院校机构就去打电话一个一个的问吧，万一运气不错，还有在招的呢。其次就是对于已经填了志愿的人，一般院校机构会在第一天就把学硕的名额确定下来（也有特殊，可能第一天就把学硕专硕名额都确定下来，也有可能还没开始确定录取名额），所以如果第一天没有任何消息，第二天就最好打个电话去问一下，像朋友那样，还能马上改志愿，没记错的话，填一个志愿会锁定三天，除非填的志愿院校帮你主动解锁。录取之后就可以着手找老师了，毕竟录取之后和确定导师之间还是有一段时间的，当然如果着急的话，可以在拿到保研名额之后马上去找老师，如果找的老师能量比较大的话，说不定还会对录取有帮助，不过有些老师不太喜欢还没有被录取的人去找 ta，所以这个就看个人情况了，等到完全确定好老师之后，最好就不要去找老师了，好好在本校完成毕业设计，享受未来几十年里可能是最美好的半年吧，不过有一点就是如果在还没完全确定老师之前，如果发现自己之前选的老师有点差劲，尽快联系新的老师，最好不是同一个研究方向的，不是同一个研究团队的，然后想一个冠冕堂皇的理由说服两位老师，最好在找到之后才把你之前联系过一位老师的事和新老师说一下，不过一旦决定要找新老师，就一定要一条路走到黑，一定要找到一位新老师，不然还回到原来的老师手下可能不会很好过，虽说老师之间是同事，但还是有不同利益集团的，所以如果要找的话，还是能找到的，前提是打听清楚。其实，从朋友角度来说，什么叫兽砖家园长都是虚的，导师的为人才是最重要的，人好的话选个刚博士毕业的讲师都可以。针对保研在本校的童靴，有些童靴不想去外校，关于这点，朋友也只能感叹人各有志，但是有一点想说，本科的教学老师和研究生导师是两副嘴脸，言尽于此，点到为止。 好了，关于朋友总结的教训就写到这里了。上文说到朋友虽然觉得找的老师可能会很差劲但由于胆子小脸皮薄没有另找其它的老师，所以就确定是这个老师了，但后面大四下学期的时候，那个学校通知朋友去签约的时候却是另一位老师，朋友之前没经历过，觉得又忐忑又奇怪，最后签约的时候被告知，以后的研究生导师就是这位签约的导师了，朋友当时感觉其实挺莫名其妙的，但后面想了想，换个老师说不定也是个好事，就没去在意了，只是觉得原来的老师是真的不行，拿着手下的学生送人情，这玩的一手好牌啊，接不了这么多，就直接回绝或者另外推荐啊，后面读研究生的时候，对那位导师有了进一步的认识，发现还真是个坑逼，还好没真的进去，但朋友真正读研的这个实验室也并不是个什么好去处，差劲的老师各有各的差劲法。接下来就是朋友真正读研时的故事了。正篇 本科快毕业的时候，朋友还满心以为自己还有一个暑假，谁知在刚毕业的时候就被导师叫去实验室了，由于此时还不是正式的研究生，所以学校也不安排住宿，只能去外面找房子住，两个月短租的房子确实不好找，导师叫朋友自行解决，住宿费也自行解决（叫学生过来住宿的地方不解决就算了，房租也不能报销 🤮），朋友好不容易找到了房子（最后租房到期的时候还被恶心的二房东坑了押金，还没正式步入社会就被上了一课），于是开始研究生的熟悉阶段，同时也开始了噩梦般的两年。 在暑假刚开始第一次例会时，朋友和同学做了下自我介绍，随后开始听师兄师姐们的汇报，只觉得师兄师姐们研究的东西都十分高大上，完全听不懂，平均每个人的例会时间在半个小时左右，先是师兄师姐们讲 ppt，然后导师提问题，然后指出不足的地方（是不是觉得很正常，接着看吧 ๑乛◡乛๑），整个实验室例会搞完之后，一个上午就过去了，导师就开始总结，说我们实验室是要求发论文的，朋友当时年轻，就想着发论文好啊，这实验室还可以啊，接着说像朋友这些刚进来的学生下周开始也要做 ppt，像师兄师姐一样汇报工作了，朋友一听这就懵了，做 ppt？怎么做？以前没搞过啊，只好去问问师兄师姐了，于是师兄师姐就给了些模板，至于内容，就下周再做吧。过了一周，第二次例会的时候，从开始的时候，朋友就感觉有点不对劲，由于师兄师姐的研究一直没有好的进展，导师就像吃了火药一般，疯狂的怼人，好好的一次例会，硬是开成了一场批斗会，于是有一部分同学顺利的推迟到下午汇报了。在中午吃饭的时候，朋友就问师兄师姐导师今天怎么了，师兄师姐就告诉朋友，这是经常发生的事，别太放在心上，ta 怼人完全只凭自己的喜怒，和你做的 ppt，和你上周的研究工作情况都关系不大，有时心情好就不怼，有时心情不好就使劲挑刺，你以后就知道了。到了下午的时候，导师又把全实验室的同学（包括上午汇报过的）叫去了会议室继续上午的例会，美其名曰让实验室同门多听听其它人的汇报，多交流交流，但朋友看师兄师姐们平时基本不交流科研，毕竟每个人搞的方向都不一样，甚至有些连大方向都不一定相同，这交流起来太困难了，师兄师姐们也基本上是各搞各的，于是汇报完自己的东西之后，都在底下玩手机了。于是朋友就这样在一周一周的例会当中度过了自己的暑假，熟悉了实验室，也对导师有了更深的认识，当然也还是漫无目的的看着论文，没有找到确切的研究方向，导师也只是在每次例会上说些套话，建设性的意见不多。 暑假就这样过完了，终于开学了，朋友也搬到了学校的宿舍住了，由于开学时，研二的师兄师姐们要找工作，研一的也要上课，所以就停了一个半月的例会（对，没错，导师只给了朋友师兄师姐们一个半月的找工作时间），朋友说研究生上课和本科生上课没什么两样，都是玩手机 ๑乛◡乛๑。一个半月之后，就又开始了正常的例会，包括研一还要上课的，导师会选择一个合适的时间，朋友又开始了新一轮的批斗大会。在这次例会中，很明显能看出导师开始催研二的论文了，甚至直接开口说，如果发不出论文，第二年就可以考虑延毕了，当然，到最后，师兄师姐们没有发出论文，导师最后还是让他们毕业了，只是这其中的过程实在是恶心，甚至有两位都被单独叫出去约谈说要延毕。 不过，师兄师姐们好歹是顺利毕业了，朋友能不能顺利毕业当时还未可知，师兄师姐们走了，朋友的保护伞也没了，只有自己硬着头皮迎接狂风暴雨了。在师兄师姐们走后的第一次例会，导师就说，你们不要学你们的师兄师姐，他们的论文一拖再拖，也是我不忍心，所以就让他们毕业了，但你们不同，你们必须要给我发出一篇论文来，下周就准备你们的开题报告，这个暑假有一部分人需要到外地做项目，因为接了个横向项目，也是为了实验室的经费。6 月底就准备开题报告，估计在朋友那学院里也是罕见的了，至于做项目这事，朋友到没啥抵触，做完项目不发论文能顺利毕业就行，于是在接下来的一次例会中，朋友及部分同学幸运的被选中去外地做项目了，但此时朋友高兴的太早了，虽然做项目不用例会，但导师要求还是比较严，甚至要求在空闲时间继续看论文，更重要的是朋友忽略了一件大事。 这件大事就是找工作，因为去外地做项目势必会影响找工作，做项目势必会影响找工作的准备阶段，准备的时间肯定会变少，因为白天要上班，虽然导师安排了住的酒店，但是在酒店里确实不好复习，虽然晚上在上班的地方能比较好的复习，但据朋友说，导师晚上也会在，这样就没法复习了。朋友原以为导师应该不会去多久，没想到，导师有大半的时间都在那边，监督朋友干活，真的只是监督，一些需求让朋友那些同学和甲方自己讨论，自己一般做甩手掌柜，不过有时为了表现自己，体现自己的存在感，会急功近利的提出一些不太明确的需求让朋友那些同学快点做完，最后可能又会推翻重做，有时甚至会提出一些和甲方不一样的需求，白白浪费朋友那些同学的时间。导师插手的需求，朋友那些同学一般做的十分痛苦，因为导师会催促朋友那些同学快点做完，每天来看个好几次，问一下进度怎么样了，有时甚至要求加班也要做完。甲方那边也有一个懂技术的小领导，ta 会看朋友那些同学的具体实现，让朋友那些同学完全照着 ta 的想法写，但是 ta 事先说明的又不清楚，因为 ta 自己也忘记了这个项目里的一些具体细节，导致朋友那些同学有些功能明明已经实现了，最后又要照着 ta 的想法重写。虽然朋友那些同学在外地做项目碰到这样那样的蛋疼事情，但总的来说还是比呆在实验室要开心一些的，每周一次批斗大会实在是太难受了，唯一不好的是确实是影响找工作，导师不在的时候还好，至少晚上和周末还能在上班的地方准备准备，但是也提心吊胆的，因为甲方有极小的可能性会来检查，导师在的话，就别想准备了，因为导师肯定会在旁边看着，酒店里又实在不方便准备。等到 8 月底，导师觉得朋友部分人应该要回去校招了，于是让他们把手上的事情快点做完，让甲方验收一下，然后就可以买票回学校了。 回学校的第二天，朋友就迎来了人生中第一场面试，因为在那边已经做过几场笔试了，不出意外，当然是挂了。当朋友听到面试官说，好了，今天的面试就到这里了，你可以先回去了，有消息我们会通知你的。还天真的以为真的会有消息通知，而不曾想到这是约定俗成的套话，表示你面试挂了。不得已，朋友只好一边面试一边预习相关的面试资料，顺便在网上找点面经突击一下，不得不说，找面经突击还是有用的，一般面试官都是直接从题库中选几道题出来问，同一个面试官问相同题目的概率也比较大，所以朋友说面经确实有用，而且面的的多了就会发现，一些基本的题面试官都会问，所以朋友从刚开始的只能回答一部分到后面的面试基本都能回答上，所以整个秋招还是拿了些 Offer，最终朋友挑选了个看好的。整个找工作过程中，朋友算是安稳的度过了近 2 月，但其中还是有件很操蛋的事，就是在找工作的高峰期，导师仍然朋友去外地干了一星期活，理由是甲方上头那段时间要检查，必须去甲方那把部分活快点搞完，这搞得朋友直接放弃了几场还算好的公司的面试，又耽误了朋友不少找工作的时间，要知道朋友那年校招就那两星期，基本大公司全在那两星期搞完，就这还浪费了一星期，朋友当时想死的心都有了，tmd 读个研不就是为了找个好工作，专硕搞个屁的科研，就为了导师的钱途可以直接忽略学生的前途，甚至耽误学生的下半辈子。 10 月底，导师就说，朋友这一届的不管找没找到工作，都必须到实验室来正常搞论文了。所以虽然朋友还在等一些公司的消息，但还是只能先停下找工作的事，乖乖的每天去实验室，开始正常的每周例会，一开就又要浪费半天甚至一天。开了一两周例会后，由于甲方那边又有事情要做了，所以导师就又叫朋友那些同学去外地接着干活了，没办法，论文的事只能又暂时放下了。就这样，又平静的度过了一个半月的做项目时间，同时也迎来了朋友学生生涯中的最后一个寒假。还好在寒假中，导师并没有打扰朋友，据朋友说，朋友见过有一个导师连两个多星期的寒假都不让学生好好过，每天都让学生汇报昨天做了啥。 如果说，前面一年半只是噩梦，那最后半年就是真正的地狱，朋友每周的定时批斗大会从不会落下，平均算下来，除了前面几分钟的 ppt 时间，至少要批斗半小时，又从来都没有提出任何有建设性的意见，全是些套话，不回话还好，一回话就各种花式怼，即使导师自己用来怼的话前后矛盾，纯粹的为怼而怼，从全方面否定学生的工作，这也不行，那也不行，就差没直接人身攻击了。朋友每周都承受着巨大的心理压力撰写论文，在临近提交论文的时候，朋友看了下别人的论文，心理只能苦笑，那样的论文在朋友实验室怕是要延毕了，但别人照样顺利毕业了，可见能不能顺利毕业和导师的关系更大一些，朋友在答辩后听过一个更荒诞的真实故事，就是一个学生因为没有帮导师做事，偷偷去外面实习了，最后论文完整的写完了，在答辩的时候，那位老师直接说，这位同学没做什么事，于是直接挂了，只能延毕了，而另一位同学十分仓促的把论文写完了，因为一直在外地帮导师干活，在答辩的时候，导师直接说，这位同学做了很多事的，于是拿了个大修，还是顺利毕业了。 总而言之，朋友最终还是顺利毕业了，也算是一大幸事，导师虽然对朋友的未来造成了一定的影响，但至少还没有完全毁掉，只是留下了两年刻骨铭心的心理阴影，可以说是至少击败了全国 10% 的研究生吧，以乐观派观点看待朋友导师，勉强还行吧。槽篇 槽篇，Shaun 纠结了很久到底要不要发出来，最终还是决定把它发出来罢。 据朋友吐槽，导师曾经在每周例会上直接 diss 人家的顶会论文，可是自己一辈子看的英文论文都没有学生两年看的多，至于自己发英文论文，那怕是个笑话了，就这样，还每次例会都要教学生怎么写，教学生怎么发 C 类论文 🤣。在每次例会上，导师干的最多的事就是毫无道理的杠学生，怼学生，钻牛角尖，举一些奇葩的例子杠学生，以表现自己的优越感，而为了维持自己在学生面前的这种优越感，总能够从某个刁钻的角度证明学生是错的，即使自己说话前后矛盾，上次例会为怼学生说的话，到了这次例会为怼学生而能说出完全相反的话，为怼学生真是可以不惜一切代价，即使说话像放屁一样。在李笑来的「韭菜的自我修养」中有这样一句话，把自己做过的错事合理化，对李这个人 Shaun 不做评价，但他关于合理化愚蠢行为即为傻Ⅹ 的说法 Shaun 还是认可的。 朋友导师有时会怀着恶意随意揣测学生的想法，自己听不懂手下学生的汇报，就直接开怼，说学生自己思路不清晰，没有想法，当学生没做出成果的时候，导师有时甚至会很开心的样子，因为这证明了学生的路子错了，而当学生有成果时，就会用奇葩的例子开怼学生了，直到学生说在这个情况下效果不好，如果学生说暂时还没试过这种情况，导师又会用严厉的语气说那你马上去试试啊，或者直接说，你考虑一点都不周到，没有搞科研的样子，反正要证明学生错了，导师就开心了。 最有意思的是，在朋友临近找工作时，导师竟然说，就瞄准一两个目标投就好了，别广撒网，挑挑拣拣的了，选择一个合适的就好，乍一听，这话挺有道理的，确实投太多的公司会分散一些精力，但仔细一想，这话没有一点道理，说的好像投了就能拿到 offer 一样，而且请注意，导师并没有给朋友找工作的准备时间，朋友是边找工作边看相关资料，最后才好不容易拿到几个 offer，如果真听导师的话，那朋友可以直接准备社招了。一个一辈子都呆在象牙塔里，从来不需要主动找工作的人居然教手下的学生如何找工作，真 tm 有意思 🙂。PS： 如果听到有哪位老师会主动帮学生找工作，那不用想了，99% 的可能性是坑逼 。 在朋友临近毕业时，导师对朋友毕业论文的格式仍存有疑问，要知道朋友是直接在上一届师兄师姐们的论文格式上填充内容的，可以说在格式上和上届基本一模一样了，上届能顺利毕业，到了朋友这届就要被怼了，虽然朋友最后还是拿着这种格式毕业了，不过到毕业还要恶心人，朋友想必是十分难受了。朋友导师看了一辈子的毕业论文，到最后都没有个固定的论文模板，只知道让学生去官网上看，但官网上的文件已经快十年没更新了，还哪来的模板，这种情况下，上届的模板不就是最好的格式模板吗？ 据朋友所说，导师也是看人行事的，对于极少部分手下的学生还是能够以正常的态度交流，对于大部分当然就是使劲的怼了，该导师会认为自己本校的学生很优秀，不会说什么，但对于外校的学生认为其很垃圾，写的东西也很垃圾，一无是处，但是碰到什么事又会让外校的学生做，很奇葩的思想。这样的导师挂名是烟酒僧的指导老师，但行事怎么看都是在阻碍自己手下烟酒僧的发展，绞尽脑汁的想着如何驱使自己手下的烟酒僧，为自己牟取更多的利益，从来不会想着自己做了多少事，对手下烟酒僧的影响如何，自己的晋升和项目收入 90% 以上都要依靠自己手下的烟酒僧，只要出一点微不足道的力就能拿到全部的功劳，真 tm 是好买卖。此类阻碍老师，吃着学生的人血馒头以肥自身，就算只是一点蝇头小利，若是需要牺牲自己手下烟酒僧的前途未来，估计也会在所不惜，毕竟手下的烟酒僧就这么两三年，不用白不用，管他死活。更有甚者，若是手下烟酒僧不能给自己带来一些利益，就会对其冷眼相待，甚至背地里穿小鞋。这种阻碍老师也就只能在自己手下的烟酒僧面前耀武扬威了，在外面的金主爸爸面前，就像条🐶一样，不过这或许就是人吧。 这样的环境和象牙塔之外的环境有何区别，甚至还不如，毕竟在外面的环境下，员工能拿到的东西远远要比学生拿到的要多，虽然对老板和导师来说，不能为自己创造价值的都是应该被丢弃的垃圾。不过这毕竟是象牙塔，难道就没有一丁点师者行为，只剩下赤裸裸的权利关系，这样的象牙塔，完全被这些阻碍老师给污染了，变成了漆黑的象牙塔。或许等这一代的那些阻碍老师全部退休之后，或许国内的整个教育环境会好一点，不过也或许是另一个勇者斗恶龙的故事，从 Shaun 目前的见识来看，由一个勇者成为恶龙的可能性更大一点，毕竟环境造就人材，很少有人能够跳脱环境的束缚。 虽然有这么多阻碍老师存在，但也有真正的好导师存在，就朋友的见识，有童靴读研究生比读本科还要轻松自在许多，这只能感叹人与人之间的差距真的可能比天堂和地狱之间的差距还要大。虽然朋友个人对于读研的累和轻松没有太多的看法，毕竟身体上的劳累和轻松是由自己决定自己感受的，朋友唯一在意的是心累，和一个阻碍老师交流一次真的是身心俱疲，尤其是还每周都要这样交流一次，一般上班都不会有这么累，朋友是真的心累。 有些看客可能会觉得朋友经历的事情并不怎么样，甚至会觉得这点小事就受不了了，还怎么成大事，这里 Shaun 只能说，有些事情只有自己亲身经历过才能体会，别人说啥都没用的，事情没有发生在自己头上，永远不会知道自己会有什么反应，而且就算是同一件事发生在不同人身上也会造成不同的后果，站着说话不腰疼的人希望您在学习工作生活中多碰到一些像朋友导师这样的老师上级长辈吧。吃瓜群众就当看个故事爽爽吧，信则有之，不信则无。后记 这算是 Shaun 目前为止写的最长的一篇了，主要是那天和朋友碰面后，出于好奇，就问了下朋友烟酒僧的情况，没想到朋友居然过的这么惨，于是 Shaun 根据当时的回忆就记录了一下，证明其存在过，朋友也经历过，也顺便提醒一下后来者，烟酒僧导师可是直接关乎整个研究僧阶段的学习生活等方方面面，所以在选的时候一定要慎重，差的导师甚至能直接毁掉学生的一辈子，当然 Shaun 在这里无论怎么说可能也没用，因为学生基本没有选择的权力，唯一的权力是选择不读，之所以还说是为了让后来者有个心理准备，当然好的导师也有不少，只能说朋友运气太差眼光也太差。附录附朋友导师经典语录，括号里的是朋友的心声 ๑乛◡乛๑：你这做的事情没什么价值，你这做的没有任何意义。（以前做这个的时候不是您同意的？）你没花时间。（每天 8 点半上班工作到晚上 10 点，周末还来实验室了，您看不见啊？）你们是来搞科研的，不是来学习的。（搞科研不用学习？搞科研不用看书？搞科研不能看经典知识，直接建空中楼阁。）你的计划是什么？实验预期你觉得怎样？有没有理论支撑？效果不好怎么办？（搞科研哪有这么多计划，也不是什么基础研究，先来个理论推导，效果不好只能重新找方法再试呗，搞科研要真能有全面的计划并且能取得理想的效果，那科研也就没有难度了，科研本就是需要不断实验改进，当然理论推导也是有必要的，但结果终究才是最重要的）这个不是难事，很简单。（别光说啊，您来做啊。）你这全是别人的东西，没有一点自己的东西。（拿着他山之石，攻另一块璞玉，难道不是科研？难道只有凭空造一颗石头去攻玉才是您眼中的科研？）就像爬山一样，别人早就从一条路上登上山顶了，你从另一条路登上山顶还有什么意义。（对，没有任何意义 🤣）你们这些年轻人，周末也要一天干 21 个小时，不要混日子，没干 21 小时说明你们对计算机没兴趣，既然没兴趣，我劝你们早点转行，去做个公务员。（照这个说法，没人对计算机有兴趣，统统应该去做公务员，因为对计算机有兴趣的人应该都死了吧。）]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10以树形结构显示文件目录结构]]></title>
    <url>posts/c3f26b1.html</url>
    <content type="text"><![CDATA[前言 本文其实可以算是标题党，Windows本身并不能以树形结构显示文件目录结构，一般需要借助第三方工具（后面去网上搜索了一下，发现 Windows 居然也有一个 tree 命令 o(╯□╰)o），Windows 虽然能用命令行显示树形结构文件目录，但不像 Linux 那样可以输入一些参数控制其输出。Win10 有个特殊的功能，就是可以使用 Ubuntu 的 bash，只需要开启这个有趣的功能，就可以将 Win10 当 Ubuntu 使用，从而像 Linux 那样只输入相关命令即可显示树形结构文件目录。*注：值得注意的是 Win10 中的 bash 目前不支持中文输入，只能切换到英文输入才能正常输入。准备篇首先需要在 Win10 下开启 bash 功能。具体开启方法为：打开 Win图标 ==》 设置 ==》 更新和安全 ==》 针对开发人员（左侧），选中开发人员模式，打开 Win图标 ==》 设置 ==》 应用 ==》 应用和功能（左侧） ==》 程序和功能（最下面的相关设置中） ==》 启用或关闭Windows功能（左侧），选中适用于Linux的Windows子系统(Beta)后点击确定。重启计算机。打开 bash，打开 bash 的方法很多，这里列出三种：1、直接在微软小娜中输入关键字“bash”搜索 Bash on Ubuntu on Windows；2、Win键+R，输入 bash，点击确定即可打开 bash；3、Win键+R，输入 cmd，在 cmd 中输入 bash，回车即可打开 bash。打开 bash 后将会提示你是否下载安装 Ubuntu on Windows，输入 y 继续，稍等片刻即可完成下载安装。设置篇 安装完成后系统将会提示你设置用户名和密码。（如果这一步设置成功可以直接跳过设置篇直接看使用篇）。不知道怎的，Shaun 这一步没有完成，每次系统都是直接以 root 用户登录，而且没有密码，为了安全考虑，也幸好登录时是 root 用户，可以自由对系统修改。所以 Shaun 需要对 root 密码进行修改，并创建新的用户。具体过程需执行以下命令：root 用户下，修改用户密码：1passwd 用户名 (修改密码) 由于 Shaun 需要修改 root 密码，所以该用户名即为 root，执行之后需要输入新密码（在 *nix 哲学中，密码是不会显示在输入屏幕中的，所以如果在输入密码时发现屏幕没有任何变化是没关系的，只管输入即可 ↖(^ω^)↗），两次输入完成后会显示密码更新成功。接下来需要创建新的普通用户，在 root 用户下执行：1adduser xxx # 这样的命令会在home目录下添加一个帐号或者1useradd xxx #仅仅是添加用户，不会在home目录添加帐号 推荐使用前者，这样可以很明确已经成功创建新用户，而且如果用户需要存放一些文件也更安全和方便。 在 *nix 中，绝对不推荐直接使用root用户对系统执行各种命令，毕竟其权限太大，一旦误操作将造成无法挽回的后果。有些命令普通用户可能没有权限执行，这时需要提高其权限，普通用户临时获取 root 权限的方法为：在需要执行的命令前添加sudo，像上文中如果普通用户需要创建新用户 xxx 则需要执行sudo adduser xxx，执行以上命令后同样需要输入新用户的密码。使用篇 先切换至普通用户，执行su xxx切换用户，即可发现 shell 提示符由#变为$，前面的用户名由root变为xxx；执行cd ~切换至用户目录。由于 Ubuntu 系统中本身没有 tree 这个命令，需要执行以下命令安装 tree 命令工具：1sudo apt install tree 直接输入tree命令，系统将会自动以树形结构列出当前目录中所有文件及文件夹；执行tree -L N 命令，以树形结构查看当前 N 级的目录和文件，eg：以树形结构查看当前目录二级文件结构，则执行tree -L 2。若想将输出的2级文件结构保存至上一层文件的tree.txt文件中，可执行tree -L 2 &gt; ../tree.txt，进入上一层目录cd ..，打开 tree.txt 即可发现该目录的文件结构。后记 遇事还是需要多查证一下啊，想当然果然是会出问题的，文章开头差点就犯错误了 ~\(≧▽≦)/~。本文其实是在写 Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 时，为了方便显示输出文件结构而查找的相关资料。参考资料[1]linux tree命令以树形结构显示文件目录结构（http://jingyan.baidu.com/tag?tagName=linux）[2] win tree命令 tree导出目录 tree显示树形结构（http://jingyan.baidu.com/tag?tagName=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F）[3] win10下linux系统的安装（开启）和使用[4] Ubuntu建立和删除用户[5] linux修改root密码和linux忘记root密码后找回密码的方法]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>unix-like</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACGN作品个人印象简评]]></title>
    <url>posts/68065b99.html</url>
    <content type="text"><![CDATA[前言 Shaun 无意向任何人推荐任何东西，毕竟那个年纪已经过去了，有些东西还是独自品味比较好，写这些东西只是单纯的想留个纪念。本文主要是分享一下 Shaun 看过的一些 ACGN 作品及相应的感觉感受，也算是记录一下，以免雁过不留痕，看过的就这样看过了。以下作品只是简单排列，没有的所谓的排名之分，只凭个人当时主观印象深浅，简单来说就是想到哪就写到哪。※注：本文所指的 ACGN 只是单纯的指 Animation（动画）、Comic（漫画）、Game（游戏）、Novel（小说）四个独立并列的部分，不是通俗意义上霓虹国的那种紧密联系的一个整体。Animation 篇 动画，真正接触霓虹国的动画还是在中学时代吧，那时也是在同学的推荐下入坑了「火影」（直到现在都还没去看结局，虽然前年就完结了），当时完全接受不了「海贼王」的画风，还是后来画了一个暑假追上来的。『海贼王』。Shaun 偏向于「海贼王」这个译名，个人感觉顶上战争之前和顶上战争之后完全是两部作品，还是觉得顶上战争之前比较好看，之前就像是游戏里打怪升级，能过些热血的瘾，但之后变成了只打怪不升级，而且感觉怪是强行被画败的 ╮(╯▽╰)╭，海贼王里还有个奇怪的现象，好像几乎不死人，不过也可能是侧重点不同，死人的场景没必要画出来了。『CLANNAD』。CL 或许能称作为人生，但人生却不是一部 CL，毕竟人生不可能有光玉存在，看完『AIR』之后，Shaun 并没有什么很强烈的感触，所以直接又接着看了 CL，没想到着实让 Shaun 这堂堂七尺男儿好生体验了把热泪盈眶的感觉。另，CL 和 Air 的音乐也很赞，麻枝准真提莫的不负其大魔王的称号 （°Д°）Ъ。『天降之物』。算是 Shaun 的入宅作了吧，没想到当时霓虹国的肉番也能做的这么精良，这里不得不赞一下「天降之物」的制作组，实在是太良心了，都破产了，还硬是把结局用 屁屁踢 形式放出来了，对比隔壁的『约会（pao）大作战』，可以说是有生之年了 ╮(╯▽╰)╭，不过还是比现在的肉番要好，现在的肉番只剩下肉了，还不如直接出里番 ๑乛◡乛๑ 。『进击的巨人』。Shaun 只能说制作组的经费别烧的那么快啊，不然可能又是一个有生之年，感觉每一帧都在烧钱。坐等同样制作精良的今年4月番『东京喰种』第三季 (๑´ڡ`๑) ，坐等个屁啊，『东京喰种』第三季这屎一样的剧情和画风 （╯‵□′）╯︵┴─┴，做成这样宁愿是个有生之年，还是滚去看看漫画是什么样子吧，希望 7 月番的「巨人」不要这样。『龙珠』系列。童年回忆啊，虽然目前还在更「龙珠超」，但是已经找不到童年时的感觉了。『犬夜叉』。虽说中学时代就听童靴讨论过，但 Shaun 真正接触还是在本科时代，剧情设计的很好，音乐也很赞。『死神』。感觉打完蓝染之后直接结束还是一部很好的作品。『新世纪福（quan）音（qian）战士』。以当时的社会环境看应该是很黄很暴力了，如果没看过TV版的EVA，直接看剧场版就行，剧场版差不多就是TV版的高清重制，虽然重制的画面很良心，但这也改变不了其圈钱的本质，你要出个正儿八经的完结篇或者对剧情进行完善补充该多好。『浪客剑心』。个人觉得TV版打败志志雄就可以结束了，「追忆篇」也十分不错，「巴」和「熏」都可以说是剑心的救赎者。『钢之炼金术师FA』。Shaun 没看过 03 版的钢炼，只能说 FA 不管是音乐还是剧情都堪称完美（Shaun 不知道真正的完美应该是什么样子），塑造的人物都有血有肉。『噬魂师』。这部动画的结局骨头社也做的太水了 o(︶︿︶)o，不然也是一部上佳之作。『瑞克和莫蒂』。很有意思的美漫，各种天马行空的想象，对一些事物的毒舌吐槽也无敌了 (≧ω≦)。『魔法少女小圆』。其实一开始要 Shaun 看魔圆， Shaun 是拒绝的，因为一听名字就以为是什么少女漫 (#-_-)，后面看了一下又没法接受那奇诡的画风，尤其是魔女出来的时候，卧槽，这 TM 是啥么鬼 (⊙_⊙)？后面无聊的时候看了几集勉强就能接受了，不过说好的要做「爱的战士」呢？结局就这样？(╯°□°）╯︵ ┻━┻，还好剧场版稍微补充了一下，音乐也很好听。美好的事物表面可能隐藏着最深的邪恶，丑陋的事物表面也可能隐藏着无尽的美好，当然，对于宇宙维稳来说，QB 的做法没错，但对于马猴烧酒来说，这就很残忍了，但人类也不会在意蝼蚁的想法吧，所以与其说是悲剧，不如说是真实，正如结局魔女是不存在了，但其它的魔物出现了。『零之使魔』。其实 Shaun 是看完「夏娜」第一季之后看的，虽说夏娜和露易丝的都是钉宫配的，但个人感觉还是露易丝萌一点呢 ～(￣▽￣～)，才人万人斩那里的 BGM 实在是斯巴拉西，最后居然不是后宫，啊啊啊 🔥，可惜了蒂法那么大的欧派了，说好的 naizi 即正义呢 _(:з」∠)_。『Angle Beats!』。AB 是曾经的一个室友推荐看的，说实话不知道是 Shaun 没看懂还是咋的，没看出什么名堂啊，只能说 OP 很赞。『潜行吧！奈亚子』。吐槽能力很有意思啊，还有全宇宙最长的呆毛，可以说很萌了，搞不懂为啥会被禁，难道是奈亚子表达爱意的方式太露骨了 (ಡωಡ)。『夏洛特』。网易云音乐推荐的，ED 很好听啊，看了动画只记得主角好像把全世界的超能力都吸收了，其它的剧情也不记得了，初次看到奈绪的图片还以为是奈亚子（雾）。『紫罗兰永恒花园』。个人还是有点无法体会剧中的感情，只能说画面做的很精致。一开始还以为是神马科幻战争片，毕竟女主的手摆在哪里 （雾）。『少女终末旅行』。也是网易云推荐的，主要是第五集的插曲很好听呢，以一种轻松的心态看这种沉重的番另有一番滋味。emmm……，知道漫画的结局之后还是感觉很沉重，（哇的一声就哭了 😭），这或许就是最深的绝望了吧，堪比「迷雾」，想必漫画作者的刀片应该收了不少呢，（突然黑化 ヾ(▼ﾍ▼；)ｵｲｺﾗ）。其实第 9 集的ED也很好听，可惜 OST 没有收录，MMP，只能截取音频听听了。『来自深渊』。不行，刚看完「末旅」，心情太沉重了，要看点稍微轻松的冷静一下，抚慰一下 Shaun 受伤的心灵，「深渊」虽然相比日常番还是沉重一些，但至少不绝望，感觉还是有 “希望” 的，期待下一季。『宝石之国』。骨肉魂的设定很有意思，只记得第九集台词老师说：“强大的力量总伴随着孤独”，也正如「B站」下的某个评论所说：“或许这就是成长所需要的代价”。个人感觉人的成长也是如此，成长意味着不再天真，不再给别人添麻烦，但这中间会失去许多，人与人之间的隔阂也越来越大，至于是好事还是坏事就只有自己知道了，有些东西只有直接接触之后才知道是好是坏。成长之后就会自然而然的开始求真，当然有很大一部分人会在求真之路上迷失自我，继续浑浑噩噩，却又不似初始的天真，而是成为一种活死人状态，成为社会这个大机器上的一个微小零件，少一个不少，多一个也不多。如果说第一季是成长之路，那下一季应该就是求真之路了。『滑头鬼之孙』。百鬼夜行时的 BGM 很赞呀！只怕是天国的第三季了。『Kill La Kill』（又名双斩少女、斩服少女）。emmm，这中文名怎么说呢，其实还挺符合剧情的，但总感觉哪里不对。作为一部热血番，剧情 bug 一点也可以理解，想必「真子」为这番拉了不少人气（官方鬼畜代表，好萌 ╭(╯3╰)╮）。『恶魔人 Crybaby』。地狱空荡荡，恶魔在人间，达成成就在恶魔人里看恶魔人，音乐很带感，rap 也很棒，愚昧的人做出的恶行更让人感到可悲。『NEW GAME!』。一部标准的日常番，作为一名即将成为社畜的秃头人，希望能碰到不错的上司和同事吧。『怪诞小镇』。和「瑞克和莫蒂」有点类似，也是一集一个小故事，不过更侧重家人之间的相处。『爱，死亡和机器人』。少儿不宜，成人动画看起来真爽，暴力血腥涩清一个都不少，连 jier 都做出来了，CG 也很不错，有几集的脑洞还是可以的。『虫师』。设定非常好，音乐也好听，一集一个小故事，至于主线剧情就算了，两季都很模糊。『游戏人生』。王女是本番的福利担当了，空白就是少年漫画的主人公，op和ed都挺好听的，可惜应该是天国的第二季了。『剑豪生死斗』。里面没有一个世俗意义上的好人，剑之极致或许确实只需要一招。『精灵守护者』。为救人而杀人，根本毫无意义，整个世界的设定和虫师有点类似，都是两个世界并存，叫精灵旅人感觉更好。『关于我转生变成史莱姆这档事 』。和“骨王”的设定有点类似，一出山就基本无敌了，而且还不知道自己有多强，萌就完事了，不会期待下一季了。『哥布林杀手』。就算是简单的小事做到极致也很不简单，总感觉这番还有个里版。『火之鸟』。生命的延续，「异形篇」在当时那个年代确实很惊艳，但剧情缺陷在于女主留在寺庙不就是给自己增加罪恶，最好的办法难道不就是悄无声息的离开？反正能离开寺庙也说明其罪已赎完。『新石纪 Dr.STONE』。虽然漏洞很明显（一人记住一个文明的知识，6 人创造一个绵延两千多年的村落），但设定比较有意思，勉强可以算是瑕不掩瑜，第二季也就随缘了。『Hell Sing OVA』。据说一定要看 OVA 版， 出于某些原因，Shaun 找了一段时间终于找到了一个能在线看的，成人动画看起来确实爽快，后期的音乐也很不错，和 「黑街」一样都是大叔风，可惜 黑街 估计没第二季了 😔。『一拳超人』。打斗的作画确实很精良，和搞笑漫画的主角打架就是在找死 ๑乛◡乛๑ 。『天元突破红莲螺岩』。单纯的中二热血，剧情感觉有点没意思，男主算是比较惨的，中后期的政治游戏稍微有点意思，但剧情杀剧情活就一点意思都没得了。『希德尼娅的骑士』。难得的硬科幻动画了，虽然碍于动画表现内容少，部分剧情有些突兀，但能接受，作者的「BLAME!」宇宙设定真的很可以，希望全系列以后都能动画化，第一季的 OP 也好听 ♪(´▽｀) 。『异兽魔都』。第一季都是谜团啊，剧情 和制作都还可以，期待第二季。『大剑』。这番没有男主，有的只是故事的见证者，万恶的组织，迪妮莎的设定太强了，又被剧情杀，导致后期的人物再强都有种违和感，相反 天元突破 中大哥的处理就很好。Comic 篇 漫画，Shaun 看的比较少，了解也不多，就不做评价了。印象里比较深的就是『伊藤润二』系列中的「漩涡」了，看完这个 Shaun 只能感叹作者的奇思妙想了。还有就是当年在追三大民工漫的时候，有时为了提前了解剧情，也会去看一下其漫画。当然偶尔也会看一下那个，，，那种漫画 (⁄ ⁄•⁄ω⁄•⁄ ⁄) ，毕竟刺激性更强，画面感更强，像那个「搞笑漫畫日和」什么的（诶，在想什么呢 (￣ε(#￣)☆╰╮(￣▽￣///)）。Game 篇 游戏，Shaun 也玩的比较少，小时候在小伙伴家里偶尔会蹭一下 FC 游戏，中学时陪同学玩街机，也两下子就把游戏币给玩没了 Σ(ﾟдﾟ;)，大学时玩通两三个单机，专注的玩了一个手游，至于什么网络游戏就根本没玩过，Shaun 还是偏向于动作冒险类游戏。『奥日与黑暗森林』（Ori and the Blind Forest）。巨硬出品，必属精品，不管是画质，画风，音乐都是五星好评，但是手残党伤不起啊，有些关卡的难度简直是阶跃性的 /つ∇T)。期待续作『奥日与精灵意志』（Ori and the Will of the Wisps）。『鬼泣』系列（Devil May Cry）。这个系列 Shaun 没一个通关的，只是稍微玩过一下，不得不说卡普空公司虽然经常炒冷饭，但是其制作也确实精良，可以说是动作类游戏的代表作了，打击感和连招特效都超带感，dei劲，以后有时间再给它通关。『艾希ICEY』。算是国产游戏的佳作了，只是碍于其独立游戏的经费，最大的不足之处就是其体量也太小了吧，两个小时打通绰绰有余，而且通关之后就没有欲望玩第二次了，玩法比较单一。『菲斯 Fez』。「纪念碑谷」就是受到这款游戏的启发，其中的一些玩法和游戏元素也借鉴了这款游戏，这款游戏简直太斯（sang）巴（xin）拉（bing）西（kuang），还有依靠 BGM 解谜的，这种操作还真没见过（也有可能是 Shaun 游戏玩的太少了 o(╯□╰)o），这是 Shaun 玩的第一个多周目游戏，每周目都会有新的体验，而且这游戏的世界观真是惊人，数学中的维度在这游戏里面会有一种非常直观的体验，尤其是每周目结束时的剧情动画。Novel 篇 小说，也算是中学时代入的坑吧，在本科前两年达到顶峰，目前处于逐渐退坑的状态，一来确实是没有什么小说吸引 Shaun 了；二来是没那么多时间看小说了。『驭兽斋』，作者：雨魔。可以算是 Shaun 这么多年的网络小说生涯的入坑之作了，现在虽然剧情忘记了，但当年看的如痴如醉的感觉却没忘。『仙逆』，作者：耳根。还是当年在小白时代看的，可以说印象非常深了，个人感觉「凡人修仙传」和它没法比。『幽冥仙途』，作者：减肥专家。这个是 Shaun 渡过小白时代书荒的时候在书荒吧看到别人推荐的，这简直是暗黑系的典范，或许李珣的人生才是人生该有的样子。『贩罪』，作者：三天两觉。很有意思的写法，各种插叙蒙太奇手法，画面感极强，作者的吐槽能力MAX啊。『死人经』，作者：冰临神下。Shaun 武侠小说看得极少，像什么金庸、古龙等人的小说 Shaun 一部也没看看过，只是看过相关的影视作品，但这部小说确实 Shaun 痴迷的看完了，虽然以当前的眼光看其好像还是有点金庸那种 “掉进悬崖就能得到绝世武功” 的味道，但是主角却还是慢慢成长变化的，并不是一触而就的状态。『亵渎』，作者：烟雨江南。这本书还是 Shaun 入坑时期看的，所以一些剧情完全忘记了，只记得有一只很有意思的骷髅。回想当年看书真是不挑剔啊，无论什么书，只要知道个名字就会去看完，也是在那段时间，把番茄、唐三、辰东等的作品都看完了，也逐渐脱离小白时代，不得不说，当年这些作品对 Shaun 三观的形成还是有很大影响的。另外以现在的眼光来看就是感觉这些作者的作品只需要选择一本代表作看看就行（eg：唐三（斗罗大陆）、土豆（斗破苍穹）、番茄（盘龙）、辰东（神墓）），毕竟一个作者的风格确实很难改变，其它的也是差不多的套路，一般来说一个作者因一部作品封神之后，很难再写出超越之作，从某种意义上来说这并不是江郎才尽，而只是人只有在特定的时候才能有特定的想法，发挥比较好而已。『 无极魔道』，作者：逆苍天。后期书荒时偶然看到的，没想到还是一部很不错的作品，快意恩仇，最后居然把所有人都坑杀了。『庆余年』，作者：猫腻。也是后期书荒看，本来 Shaun 是不大想看这种架空历史小说的，但是看了之后感觉里面的权谋很有意思。『紫川』，作者：老猪。这本书 Shaun 没读完，主要是当时的状态不适合看这本书，里面有些情节以当时的状态实在是没法看下去。『佣兵天下』，作者：说不得大师。这本书也是 Shaun 小白时代看的，记得这本书当年好像是在看完「静官」的『兽血沸腾』之后看的，当时只感叹其友情。『诛仙』，作者：萧鼎。以 Shaun 现在的眼光来看感觉有点名过其实。『鬼吹灯』，作者：天下霸唱。这本书 Shaun 也没看完，其实 Shaun 是先看的『盗墓笔记』，后面才去看鬼吹灯，所以也稍微了解了一下这两部作品的渊源，个人感觉，盗墓笔记还是很大一部分借鉴了鬼吹灯，而且盗墓笔记感觉后面有点胡乱写的味道。『恶魔法则』，作者：跳舞。Shaun 小白时代看的作品，剧情也全都忘记了，不做评价，依稀记得好像有点搞笑。『七界传说』，作者：心梦无痕。算是 Shaun 看的第一本这种风格的小说——主人公刚出山就差不多是无敌之姿了，后期的对手也不是庸人，感觉十分有意思。『升邪』，作者：豆子惹的祸。读起来感觉很轻松的一本小说。『宠魅』，作者：鱼的天空。记得当时看这本小数是为了找一本类似于 驭兽斋 描写宠物的小说，于是就找到了这本，感觉结局还是有点虐心，现在想起来还是有点不好受。『长生不死』，作者：观棋。里面的计谋还是很有意思，居然用传销之法颠覆一个国家的经济，好像是的吧。『风姿物语』，作者：罗森。不愧是誉为“现代玄幻小说鼻祖”的网文，后面玄幻小说的模式或多或少都能在这里看到影子。作者也真是个人才，不仅正经的网文写的不错，而且小 h 书也写的很溜，像小黄书中的典范，「阿里布达年代祭」和「六朝」系列等。『星空倒影』，作者：弦歌雅意。很有意思的写作角度，从旁观者的角度见证英雄的大起大落，虽说整个故事和其它的西幻套路差不多，但胜在短小精悍，角度新颖。『仙路烟尘』，作者：管平潮。很有古典仙侠意味的一部的小说，作者的文采也是一流的，但对主角性格把控的不是很到位，导致有些章节读起来有点突兀，不是那么连贯。『巫师之旅』，作者：一行白鹭上青天。作者的设定很厉害，很久没看过这么新奇的小说了。『全球进化』，作者：咬狗。关于生命体进化层次的设定很有意思。『雪中悍刀行』，作者：烽火戏诸侯。中间有些部分的设定很迷，应该是作者断更时间太长了，自己也记不清楚了，不过整体来说文笔还行，铺垫很长，至于收尾就不说了。『仙葫』，作者：流浪的蛤蟆。反派都是运气极差，能力无法发挥，而且都是睿智。『神秘之旅』，作者：滚开。算是无限流，各个世界穿越，为剧情需要，部分章节前后设定矛盾。『飞升之后』，作者：皇甫奇。设定很有意思，算是打怪升级的改进版。『恶魔狂想曲之明日骄阳』，作者：胡鳕。短小精悍，快的话一天就能看完，但内容确实可以，不过也许是太短的缘故，Shaun 竟然完全没有印象，在看第二遍的时候才发现好像看过。『人道纪元』，作者：亲吻指尖。写的很混乱，尤其是到后期，有些剧情完全圆不过来。『走进修仙』，作者：吾道长不孤。作者很强，应该看过很多东西，看得出里面也有很多设定是直接借鉴别人的，里面的梗也很多，总的来说还是很值得一看的。『随身带着异形王后』，作者：龙青衫。当时看的时候还觉得挺有意思的，就是 YY 异形在异界如何横行，没记错的话，异种还被娘化了。『圣者』，作者：九鱼。很久没看西幻了，这部的设定很不错，剧情可以说旧瓶装新酒吧，同样的打怪升级流，看起来却有着不同的意味。『明日之劫』，作者：熊狼狗。虽然套路很小白，但里面有些桥段设计的却很可以，融合了很多梗，再里面能看到很多书和电影动漫的影子。『尘缘』，作者：烟雨江南。后期还是有点烂尾了，基本一天就能看完，江南的文采还是可以的。『修真四万年』，作者：卧牛真人。 虽然很长，但是还是很值得的一看的，作者算是网文写手里难的有思想的一批了，可惜后期收不住了，有点烂尾的感觉。『民调局异闻录』，作者：耳东水寿。总体还是感觉有点幽默的，就是看的主角很憋屈，尤其是第一人称，后期战斗力和反派有点太崩了。『知北游』，作者：洛水。时间数值设定太崩了，文采还行，普通玄幻小说套路。『灵舟』，作者：九当家。后宫文，擦边球打的挺好的 ๑乛◡乛๑ ，设定还可以，不过有些剧情还是很多余，和大部分小说一样，后期的进度都崩了。后记 以后有看过或回想起看过的作品再继续更新吧 （↖(^ ω ^)↗）。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加站内本地搜索]]></title>
    <url>posts/4f6225b7.html</url>
    <content type="text"><![CDATA[前言 虽然 Shaun 博客目前数量不多，质量也不高，但抱着搞事的心态，先弄它一个站内本地搜索再说。准备篇 要想使用本地搜索功能，首先需要安装相应的搜索插件 hexo-generator-searchdb，网上可能大多数用的是 hexo-generator-search 这个插件，也有都装的，但 Shaun 就只安装这一个了，好像 hexo-generator-searchdb 更完善一点，由于 Shaun 前端接触的极少，所以就没有一一对比了，网上也没查到具体对比情况，有兴趣的童靴可以试试 (╯▽╰)。至于具体安装如下，在站点根目录执行：1npm install hexo-generator-searchdb --save 安装完之后重新生成页面，将会发现 public文件夹 下多出一个 search.xml 文件。然后在配置文件 _config.yml 中添加：1234# 站点本地搜索search: path: search.xml field: all其中：path - 指定生成的索引数据的文件名。默认为 search.xml 。field - 指定索引数据的生成范围。可选值包括：post - 只生成博客文章（post）的索引（默认）；page - 只生成其他页面（page）的索引；all - 生成所有文章和页面的索引。 至于是在 主题配置文件，还是在 站点配置文件 中添加，个人觉得都没关系，附：Shaun 是在主题配置文件中添加的。接下来就需要修改原主题的代码了。改码篇 由于 Shaun 博客主题是基于 SPFK 对照着 black-blue 进行修改的，而且因为 black-blue 是有搜索的（Shaun 不知道 black-blue 主题的作者是如何完成的，借助了什么技术），所以 Shaun 就看 black-blue 的搜索功能是修改了 SPFK 哪个地方，再将相应的代码添加至 SPFK 中（其中相应的代码来自让 Hexo 博客支持本地站内搜索），从而逐渐完成本次搜索功能。首先找到 spfk 主题下的 left-col.ejs 文件，对其修改如下：123456789101112&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;form&gt; &lt;input type=&quot;text&quot; class=&quot;st-default-search-input search&quot; id=&quot;search&quot; placeholder=&quot; Search...&quot;&gt; &lt;/form&gt; --&gt; &lt;form id=&quot;search-form&quot;&gt; &lt;!-- 搜索框相关 --&gt; &lt;input type=&quot;text&quot; id=&quot;local-search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;Search...&quot; class=&quot;search form-control&quot; autocomplete=&quot;off&quot; autocorrect=&quot;off&quot;/&gt; &lt;i class=&quot;fa fa-times&quot; onclick=&quot;resetSearch()&quot;&gt;&lt;/i&gt; &lt;!-- 清空/重置搜索框 --&gt; &lt;/form&gt; &lt;div id=&quot;local-search-result&quot;&gt;&lt;/div&gt; &lt;!-- 搜索结果区 --&gt; &lt;p class=&apos;no-result&apos;&gt;No results found &lt;/p&gt; &lt;!-- 无匹配时显示，注意请在 CSS 中设置默认隐藏 --&gt; &lt;%&#125;%&gt;其次找到 spfk 主题下的 after-footer.ejs 文件，将其修改如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140&lt;% if (theme.search_box)&#123; %&gt; &lt;!-- &lt;script type=&quot;text/javascript&quot;&gt; window.onload = function()&#123; document.getElementById(&quot;search&quot;).onclick = function()&#123; console.log(&quot;search&quot;) search(); &#125; &#125; function search()&#123; (function(w,d,t,u,n,s,e)&#123;w[&apos;SwiftypeObject&apos;]=n;w[n]=w[n]||function()&#123; (w[n].q=w[n].q||[]).push(arguments);&#125;;s=d.createElement(t); e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e); &#125;)(window,document,&apos;script&apos;,&apos;//s.swiftypecdn.com/install/v2/st.js&apos;,&apos;_st&apos;); _st(&apos;install&apos;,&apos;A1Pz-LKMXbrzcFg2FWi6&apos;,&apos;2.0.0&apos;); &#125; &lt;/script&gt; --&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 激活搜索框时才搜索 var inputArea = document.querySelector(&quot;#local-search-input&quot;); var getSearchFile = function()&#123; // 调用搜索函数 var search_path = &quot;&lt;%- config.search.path %&gt;&quot;; if (search_path.length == 0) &#123; search_path = &quot;search.xml&quot;; &#125; var path = &quot;&lt;%- config.root %&gt;&quot; + search_path; searchFunc(path, &apos;local-search-input&apos;, &apos;local-search-result&apos;); &#125; inputArea.onfocus = function()&#123; getSearchFile() &#125; // 搜索重置 var $resetButton = $(&quot;#search-form .fa-times&quot;); var $resultArea = $(&quot;#local-search-result&quot;); inputArea.oninput = function()&#123; $resetButton.show(); &#125; resetSearch = function()&#123; $resultArea.html(&quot;&quot;); document.querySelector(&quot;#search-form&quot;).reset(); $resetButton.hide(); $(&quot;.no-result&quot;).hide(); &#125; // 屏蔽回车 inputArea.onkeydown = function()&#123; if(event.keyCode==13) return false&#125; // 无搜索结果 $resultArea.bind(&quot;DOMNodeRemoved DOMNodeInserted&quot;, function(e) &#123; if (!$(e.target).text()) &#123; $(&quot;.no-result&quot;).show(200); &#125; else &#123; $(&quot;.no-result&quot;).hide(); &#125; &#125;) // 搜索函数 var searchFunc = function(path, search_id, content_id) &#123; &apos;use strict&apos;; $.ajax(&#123; url: path, dataType: &quot;xml&quot;, success: function( xmlResponse ) &#123; // get the contents from search data var datas = $( &quot;entry&quot;, xmlResponse ).map(function() &#123; return &#123; title: $( &quot;title&quot;, this ).text(), content: $(&quot;content&quot;,this).text(), url: $( &quot;url&quot; , this).text() &#125;; &#125;).get(); var $input = document.getElementById(search_id); var $resultContent = document.getElementById(content_id); $input.addEventListener(&apos;input&apos;, function()&#123; var str=&apos;&lt;ul class=\&quot;search-result-list\&quot;&gt;&apos;; var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/); $resultContent.innerHTML = &quot;&quot;; if (this.value.trim().length &lt;= 0) &#123; return; &#125; // perform local searching datas.forEach(function(data) &#123; var isMatch = true; var content_index = []; var data_title = data.title.trim().toLowerCase(); var data_content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;).toLowerCase(); var data_url = data.url; var index_title = -1; var index_content = -1; var first_occur = -1; // only match artiles with not empty titles and contents if(data_title != &apos;&apos; &amp;&amp; data_content != &apos;&apos;) &#123; keywords.forEach(function(keyword, i) &#123; index_title = data_title.indexOf(keyword); index_content = data_content.indexOf(keyword); if( index_title &lt; 0 &amp;&amp; index_content &lt; 0 )&#123; isMatch = false; &#125; else &#123; if (index_content &lt; 0) &#123; index_content = 0; &#125; if (i == 0) &#123; first_occur = index_content; &#125; &#125; &#125;); &#125; // show search results if (isMatch) &#123; str += &quot;&lt;li&gt;&lt;a href=&apos;/&quot;+ data_url +&quot;&apos; class=&apos;search-result-title&apos; target=&apos;_blank&apos;&gt;&quot;+ &quot;&gt; &quot; + data_title +&quot;&lt;/a&gt;&quot;; var content = data.content.trim().replace(/&lt;[^&gt;]+&gt;/g,&quot;&quot;); if (first_occur &gt;= 0) &#123; // cut out characters var start = first_occur - 6; var end = first_occur + 6; if(start &lt; 0)&#123; start = 0; &#125; if(start == 0)&#123; end = 10; &#125; if(end &gt; content.length)&#123; end = content.length; &#125; var match_content = content.substr(start, end); // highlight all keywords keywords.forEach(function(keyword)&#123; var regS = new RegExp(keyword, &quot;gi&quot;); match_content = match_content.replace(regS, &quot;&lt;em class=\&quot;search-keyword\&quot;&gt;&quot;+keyword+&quot;&lt;/em&gt;&quot;); &#125;) str += &quot;&lt;p class=\&quot;search-result\&quot;&gt;&quot; + match_content +&quot;...&lt;/p&gt;&quot; &#125; &#125; &#125;) $resultContent.innerHTML = str; &#125;) &#125; &#125;) &#125; &lt;/script&gt;&lt;%&#125;%&gt;最后找到 spfk 主题下的 main.styl 文件，在其末尾添加：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/*搜索框*/.search &#123; width: 68%; height: 18px; margin-top: 1px; padding: 0; font-family: inherit; border: 2px solid transparent; border-bottom: 2px solid #d3d3d3; border-radius: 2px; opacity: 0.65; background: none;&#125;.search:hover &#123; border: 2px solid #d3d3d3; opacity: 1; box-shadow: 0 0 10px rgba(0,0,0,0.3);&#125;/*搜索重置按钮*/#search-form .fa-times &#123; display: none; padding: 1px 0.7em; box-shadow: 0 0 3px rgba(0,0,0,0.15); cursor: pointer; color: #4094c7;&#125;#search-form .fa-times:active &#123; background: #d3d3d3;&#125;#search-form .fa-times:hover &#123; zoom: 1.1; padding: 1px 0.6em; border: 1px solid #d3d3d3; box-shadow: 0 0 6px rgba(0,0,0,0.25);&#125;/*搜索结果区*/#local-search-result &#123; //margin: auto -12% auto -6%; margin: 0; font-size: 0.9em; text-align: left; word-break: break-all; box-shadow: 4px 4px 6px rgba(0,0,0,0.46);&#125;#local-search-result ul.search-result-list li:hover &#123; font-weight: normal;&#125;/*单条搜索结果*/#local-search-result li &#123; margin: 0.5em auto; border-bottom: 2px solid #d3d3d3;&#125;#local-search-result .search-result-list li:hover &#123; background: rgba(47,46,46,0.8); box-shadow: 0 0 5px rgba(0,0,0,0.2);&#125;/*匹配的标题*/#local-search-result a.search-result-title &#123; line-height: 1.2; font-weight: bold; color: #4094c7;&#125;/*搜索预览段落*/#local-search-result p.search-result &#123; margin: 0.4em auto; line-height: 1.2em; max-height: 3.6em; overflow: hidden; font-size: 0.8em; text-align: justify; color: #ffffffb3;&#125;/*匹配的关键词*/#local-search-result em.search-keyword &#123; color: #f58e90; border-bottom: 1px dashed #f58e90; font-weight: bold; font-size: 1em;&#125;/*无匹配搜索结果时显示*/p.no-result &#123; display: none; margin: 2em 0 2em 6%; padding-bottom: 0.5em; text-align: left; color: #808080; font-family: font-serif serif; border-bottom: 2px solid #d3d3d3;&#125; 这里请注意，当对 main.styl 文件做以上修改时，可能会发现有两个 .search 样式，而且相差不大，这时，不要对其原有的 .search 进行修改，更不要去注释掉它，只做上述修改就不用管了，不然可能会发生一些奇怪的事 o(&gt;﹏&lt;)o。Shaun 当时做以上修改时，将其原有的 .search 样式注释掉之后，整个页面的 css 布局全部都乱了 (╯﹏╰)，不知道为什么 (⊙_⊙?)，这两个同名样式看起来明明差不多的，最后只能维持现状了，等以后有机会再看看吧，业余前端伤不起啊! ╮(╯_╰)╭。 至此整个站内本地搜索功能基本完成，勉强可以使用站内搜索功能了。问题篇 *注：以下问题于 2018-03-02 都已经解决 ╮(╯▽╰)╭。1、搜索函数返回的 url 地址有问题。 问题描述：当点击搜索结果时，新弹出的标签页地址栏中 url 地址会有部分乱码情况；当鼠标移到搜索的结果列表上时，浏览器左下角显示的 url 地址虽然没有乱码情况，但其中有一个重复的/符号。所幸这两个问题并没有造成浏览器解析错误，浏览器还是可以正常显示页面的。================= 修改日期：2018-03-02 ================= 解决办法：将 \blog\node_modules\hexo-generator-searchdb\templates\xml.ejs 文件中的 &lt;url&gt;&lt;%- encodeURIComponent(config.root + post.path) %&gt;&lt;/url&gt; 修改为 &lt;url&gt;&lt;%- encodeURI(post.path) %&gt;&lt;/url&gt; ，使其中一些 url 中常见的字符（如：&amp;, ?, /, =）不被十六进制的转义序列进行替换。参考：escape,encodeURI,encodeURIComponent有什么区别? 和 JavaScript encodeURIComponent() 函数 。=====================================================2、搜索结果区布局有问题。 问题描述：当显示搜索结果时，搜索结果区会上下扩张，从而将其上下本来存在的一些布局挤开，造成布局混乱。这其实不算是一个 spfk 主题或者新添加的搜索功能的问题，而是新添加的一个东西又没有相应的和原本布局结合的布局文件，那就极大可能会有布局混乱的问题，至于这个要和原本布局契合的搜索结果区布局文件就只有等 Shaun 以后有机会有时间再完善去喽 ╮(╯▽╰)╭。3、搜索框激活问题。 问题描述：搜索框激活延迟很大，有时过很久或者需要切换站内页面它才能激活，给人的感觉就是好像没有搜索功能似的。添加搜索框激活功能据作者 MOxFIVE 所说是为了不让索引文件影响页面加载速度，MOxFIVE 同时也在文末指出了一些不足之处，如果索引文件太大，可能还是会造成一些问题，但 Shaun 的博客数量又不多，所以估计还是 Shaun 的代码混合问题，而且 MOxFIVE 的博客搜索功能好像没这个问题（至少 Shaun 目前没发现）。这个问题同样只有等以后再说了 (*^__^*) 嘻嘻……。后记 本文添加的本地搜索还很粗糙，还有很多地方需要以后去完善。但这好歹是一个好的开始，搜索功能至少勉强能够正常使用，总比以前是个空壳要好，以后有机会再慢慢去去完善吧 ↖(^ω^)↗。参考资料[1] jQuery-based Local Search Engine for Hexo（http://www.hahack.com/categories/codes/）[2] 让 Hexo 博客支持本地站内搜索（http://moxfive.xyz/tags/Hexo/）[3] Hexo博客添加站内搜索（https://www.ezlippi.com/categories/hexo/）[4] Hexo本地搜索及部分SEO优化 （https://www.oyohyee.com/categories/Note/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用OpenCV显示OpenGL图形]]></title>
    <url>posts/302a6244.html</url>
    <content type="text"><![CDATA[前言 本文就是一个小实验，试验 OpenCV 到底能不能支持 OpenGL 图形显示。正文 如果在 OpenCV 用 CMake 编译时勾选 WITH_OPENGL 且编译一切顺利的话，编译和配置的具体步骤和情况可以看 Shaun 写的一篇文档：Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0 ，那么就可以用 OpenCV 窗口显示 OpenGL 图形。 在 VS 下使用 Windows 原有的 OpenGL 函数需要包含以下头文件和库文件：123456#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib") 在 OpenCV 中显示 OpenGL 图形需要 cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL)，在 namedWindow 函数中添加 cv::WINDOW_OPENGL 参数说明该窗口支持 OpenGL 图形。附示例程序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299#include &lt;opencv.hpp&gt;#include &lt;Windows.h&gt;#include &lt;GL/gl.h&gt;#include &lt;GL/glu.h&gt;#pragma comment(lib, "OpenGL32.lib")#pragma comment(lib, "glu32.lib")static const float vertex_list[][3] =&#123; -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, -0.5f, -0.5f, -0.5f, 0.5f, 0.5f, -0.5f, 0.5f, -0.5f, 0.5f, 0.5f, 0.5f, 0.5f, 0.5f,&#125;;// 将要使用的顶点的序号保存到一个数组里面 static const GLint index_list[][2] =&#123; &#123; 0, 1 &#125;, &#123; 2, 3 &#125;, &#123; 4, 5 &#125;, &#123; 6, 7 &#125;, &#123; 0, 2 &#125;, &#123; 1, 3 &#125;, &#123; 4, 6 &#125;, &#123; 5, 7 &#125;, &#123; 0, 4 &#125;, &#123; 1, 5 &#125;, &#123; 7, 3 &#125;, &#123; 2, 6 &#125;&#125;;static float rotate = 0;static int times = 0;GLint windowWidth = 800;GLint windowHeight = 800;GLfloat xRotAngle = -75.0f;GLfloat yRotAngle = 0.0f;GLfloat zRotAngle = -135.0f;float MIN_X = -200;float MAX_X = 200;float MIN_Y = -200;float MAX_Y = 200;float MIN_Z = -200;float MAX_Z = 200;GLfloat coordinatesize = 200.0f;GLfloat ratio = 1;void drawLine(float x1, float y1, float z1, float x2, float y2, float z2)&#123; glBegin(GL_LINES); glVertex3f(x1, y1, z1); glVertex3f(x2, y2, z2); glEnd(); glFlush();&#125;// 绘制立方体void DrawCube(void)&#123; int i, j; glBegin(GL_LINES); for (i = 0; i &lt; 12; ++i) // 12 条线段 &#123; for (j = 0; j &lt; 2; ++j) // 每条线段 2个顶点 &#123; glVertex3fv(vertex_list[index_list[i][j]]); &#125; &#125; glEnd(); glFlush();&#125;void reshapeOperate()&#123; glMatrixMode(GL_PROJECTION); glLoadIdentity(); if (ratio &lt; 1) glOrtho(-coordinatesize, coordinatesize, -coordinatesize / ratio, coordinatesize / ratio, -coordinatesize, coordinatesize); else glOrtho(-coordinatesize*ratio, coordinatesize*ratio, -coordinatesize, coordinatesize, -coordinatesize, coordinatesize); glMatrixMode(GL_MODELVIEW); glLoadIdentity();&#125;void reshape(int w, int h) &#123; if ((w == 0) || (h == 0)) return; glViewport(0, 0, w, h); ratio = (GLfloat)w / (GLfloat)h; reshapeOperate();&#125;GLfloat AngleX = 45.0f;GLfloat AngleY = 315.0f;void reshape1(int w, int h)&#123; GLfloat aspect = (GLfloat)w / (GLfloat)h; GLfloat nRange = 100.0f; glViewport(0, 0, w, h); glMatrixMode(GL_PROJECTION); //将当前矩阵指定为投影模式 glLoadIdentity(); //设置三维投影区 if (w &lt;= h) &#123; glOrtho(-nRange, nRange, -nRange * aspect, nRange * aspect, -nRange, nRange); &#125; else &#123; glOrtho(-nRange, nRange, -nRange / aspect, nRange / aspect, -nRange, nRange); &#125;&#125;void onDraw(void*)&#123; // Draw something using OpenGL here //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); //清除所有的像素 //glMatrixMode(GL_MODELVIEW); //glLoadIdentity(); //glPushMatrix(); ////glTranslatef(-0.2, 0, 0); // 平移 ////glScalef(2, 1, 1); // 缩放 //glRotatef(xRotAngle, 1.0f, 0.0f, 0.0f); //glRotatef(yRotAngle, 0.0f, 1.0f, 0.0f); //glRotatef(zRotAngle, 0.0f, 0.0f, 1.0f); //glColor3f(1, 0, 0); //drawLine(0, 0, 0, MAX_X, 0, 0); //x轴 //glColor3f(0, 1, 0); //drawLine(0, 0, 0, 0, MAX_Y, 0); //y轴 //glColor3f(0, 0, 1); //drawLine(0, 0, 0, 0, 0, MAX_Z); //z轴 //times++; //if (times &gt; 1) //&#123; // times = 0; //&#125; //if (times % 1 == 0) //&#123; // rotate += 0.3; //&#125; //glRotatef(rotate, 0, 1, 0); //glRotatef(rotate, 1, 0, 0); //glColor3f(0, 1, 1); //DrawCube(); //glPopMatrix(); reshape1(windowWidth, windowHeight); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); glMatrixMode(GL_MODELVIEW); glLoadIdentity(); AngleX++; AngleY++; glPushMatrix(); &#123; glRotatef(AngleX, 1.0f, 0.0f, 0.0f); glRotatef(AngleY, 0.0f, 1.0f, 0.0f); glBegin(GL_POLYGON); //前表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)0);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub((GLubyte)255, (GLubyte)0, (GLubyte)255);//颜色设置为白色 glVertex3f(-50.0f, 50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //后表面 glColor3f(0.0f, 1.0f, 1.0f);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3f(0.0f, 1.0f, 0.0f);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //上表面 glColor3d(0.0, 1.0, 1.0);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3d(1.0, 1.0, 1.0);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3d(1.0, 0.0, 1.0);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3d(0.0, 0.0, 1.0);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //下表面 glColor3ub(0u, 255u, 0u);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub(255u, 255u, 0u);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glColor3ub(255u, 0u, 0u);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glColor3ub(0u, 0u, 0u);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glEnd(); glBegin(GL_POLYGON); //左表面 glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)255);//颜色设置为白色 glVertex3f(50.0f, 50.0f, 50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)255);//颜色设置为青色 glVertex3f(50.0f, 50.0f, -50.0f); glColor3ub((GLubyte)0, (GLubyte)255, (GLubyte)0);//颜色设置为绿色 glVertex3f(50.0f, -50.0f, -50.0f); glColor3ub((GLubyte)255, (GLubyte)255, (GLubyte)0);//颜色设置为黄色 glVertex3f(50.0f, -50.0f, 50.0f); glEnd(); glBegin(GL_POLYGON); //右表面 glColor3f(1.0f, 0.0f, 1.0f);//颜色设置为品红色 glVertex3f(-50.0f, 50.0f, 50.0f); glColor3f(0.0f, 0.0f, 1.0f);//颜色设置为蓝色 glVertex3f(-50.0f, 50.0f, -50.0f); glColor3f(0.0f, 0.0f, 0.0f);//颜色设置为黑色 glVertex3f(-50.0f, -50.0f, -50.0f); glColor3f(1.0f, 0.0f, 0.0f);//颜色设置为红色 glVertex3f(-50.0f, -50.0f, 50.0f); glEnd(); &#125; glPopMatrix();&#125;void opencvWithOpenGLTest()&#123; std::string openGLWindowName = "OpenGL Test"; cv::namedWindow(openGLWindowName, cv::WINDOW_OPENGL); cv::resizeWindow(openGLWindowName, windowWidth, windowHeight); cv::setOpenGlContext(openGLWindowName); cv::setOpenGlDrawCallback(openGLWindowName, onDraw, NULL); while (cv::waitKey(30) != 27) &#123; cv::updateWindow(openGLWindowName); // when needed &#125;&#125;int main(int argc, char *argv[])&#123; opencvWithOpenGLTest(); return 0;&#125;运行成功后可看到一个旋转的彩色立方体。结论 从实验结果来看，OpenCV 确实能支持 OpenGL 图形的显示，但其不足之处也很明显：没有提供鼠标和键盘的交互操作（可能是 Shaun 还没发现，毕竟只是尝试一下看它能不能显示），仅仅只是提供一个显示窗口。如果真想用 OpenGL 做一些好玩的东西，还是用 glut 和 glew 吧，不过 glut 已经停止更新许久，glew 在调试时可能会出现一些莫名其妙的错误，所以网上有人用 freeglut 代替 glut，glee 代替 glew，具体的东西 Shaun 也没试过，Shaun 目前还没做过 OpenGL 相关的事，这次用 OpenCV 显示 OpenGL 图形纯粹是为了好玩 (*^__^ *) 嘻嘻……。后记 本篇文档也是上次编译配置完 OpenCV-3.2 后做的一次小实验，但当时并没有记录，所以还有一些参考资料也已经不知道了 :-(。参考资料[1] OpenCV学习笔记（六十一）——建立支持OpenGL的OpenCV工程“Master OpenCV”chp.3（http://blog.csdn.net/yang_xian521/article/category/910716）[2] 几个opengl立方体绘制案例（http://blog.csdn.net/bcbobo21cn/article/category/3104565）]]></content>
      <categories>
        <category>Image&amp;Graphic</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>cv</tag>
        <tag>opengl</tag>
        <tag>gl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10＋VS2013＋CMake-gui编译和配置OpenCV-3.2.0]]></title>
    <url>posts/7df528b4.html</url>
    <content type="text"><![CDATA[Shaun 的系统环境：Win10_x64 英文企业版；VS2013-update5 英文旗舰版；CMake-3.6.3-win64-x64 免安装版；Qt-opensource-windows-x86-msvc2013-5.6.2。 *注：Shaun 写的这篇文档主要用来编译 x86 版的动态 debug 库，想编译其它类型的库请自行参考其它资料，做相关改变。（ 其实如果想编译 x64 版的可以在用 VS2013 编译时将上方的 Win32 平台选择 x64 平台；想编译 release 版的可以在用 VS2013 编译时将上方的 Debug 模式选择 Release 模式；想编译静态库的可以在用 CMake 生成时取消勾选 BUILD_SHARED_LIBS 选项即可。:-P ）前言 因为 OpenCV-3.2 官方的 release 版只有支持 VS2015 的库，而且不包括扩展包（ opencv_contrib ）中的库，而由于某些历史原因，Shaun 目前使用的编译器还是 VS2013，又想用用扩展包中一些有趣的算法，在加上上个月 opencv-3.3 还没有正式 release，所以上个月 Shaun 就利用 VS2013 对 opencv-3.2 进行编译。具体编译过程如下：准备篇 先在 GitHub 上下载对应的 opencv 源码包：opencv-3.2.0 和 opencv_contrib-3.2.0（https://github.com/opencv），扩展包版本一定要和 opencv 版本相同。Shaun 为了添加 Qt 后端显示支持（为了好看和方便 :-P），所以还下载安装了支持 VS2013 的 Qt-5.6.2（http://download.qt.io/archive/qt/）。再下载 CMake-3.6.3-win64-x64 免安装版（https://cmake.org/files/）。至于微软的东西，推荐直接去 MSDN 我告诉你去下载。 由于网上有的资料（具体是哪篇文章 Shaun 忘记了 o(╯□╰)o）说编译时的文件结构可能会影响编译是否成功，再加上为了方便编译管理，Shaun 编译时的文件结构为：opencv-3.2.0_build├── build└── sources​ ├── opencv-3.2.0​ └── opencv_contrib-3.2.04 directories, 0 files其中 opencv-3.2.0 用来装 opencv-3.2.0.zip 解压后的源码；opencv_contrib-3.2.0 用来装opencv_contrib-3.2.0.zip 解压后的源码；build 用来装 CMake 编译完成后的文件。编译篇 打开 /cmake-3.6.3-win64-x64/bin/cmake-gui.exe，在 Where is the source code 文本框中选择 /opencv-3.2.0_build/sources/opencv-3.2.0；在 Where to build the binaris 文本框中选择 /opencv-3.2.0_build/build，点击 Configure，在弹出的编译器选择框中选择 Visual Studio 12 2013，一直 Configure 直到红色的条变白。 网上有人在这一步可能会出现ffmpeg not downloaded和“ippicv_windows_20151201.zip”not downloaded这两个问题，Shaun 没出现这两个问题，所以没有机会验证 cmake-gui和vs2013编译opencv和opencv_contrib源码 中的解决办法是否正确。 接下来就是添加扩展包，在白色条中找到 OPENCV_EXTRA_MODULES_PATH 文本框，在其中选择 opencv_contrib 源码中 modeles 所在路径：/opencv-3.2.0_build/sources/opencv_contrib-3.2.0/modules。 至于想要支持 OpenGL 和 Qt 就需要勾选 WITH_OPENGL 和 WITH_QT 并 Configure 后选择好 Qt 的安装目录，如果配置好 Qt 的环境变量 Cmake 将会自动选择好 Qt 所在路径。 随后再次反复 Configure 直到界面不再出现红色背景，之后单击 Generate。不出意外的话，你会看到 Configure done 和 Generate done。 Shaun 在这一步出现了 VS2013_CMake_opencv3.1动态库与静态库的配置与编译 中的问题，原因是同时勾选了同时勾选了 BUILD_opencv_world 和 BUILD_opencv_contirb_world，Shaun 的解决办法是将它们全部取消勾选，再次 Configure 和 Generate。 如果上面一切顺利的话就可以进行下一步了：使用 VS2013 编译 OpenCV。打开 /opencv-3.2.0_build/build 目录，将会看到一大堆文件和文件夹，双击 /opencv-3.2.0_build/build 目录下的 OpenCV.sln，用 VS2013 打开。找到 CMakeTargets 中的 INSTALL ，然后右键选择“Project Only”–&gt;“Build Only INSTALL”。漫长的等待。。。。。。 (╯﹏╰)b Shaun 在这一步出现了一个问题，具体问题和解决方法详见问题篇。 一切顺利的话，应该会比 Shaun 下面的库多两个，Shaun 最后生成的 Debug 库为：opencv_aruco320d.libopencv_bgsegm320d.libopencv_bioinspired320d.libopencv_calib3d320d.libopencv_ccalib320d.libopencv_core320d.libopencv_datasets320d.libopencv_dnn320d.libopencv_dpm320d.libopencv_face320d.libopencv_features2d320d.libopencv_flann320d.libopencv_fuzzy320d.libopencv_highgui320d.libopencv_imgcodecs320d.libopencv_imgproc320d.libopencv_line_descriptor320d.libopencv_ml320d.libopencv_objdetect320d.libopencv_optflow320d.libopencv_phase_unwrapping320d.libopencv_photo320d.libopencv_plot320d.libopencv_reg320d.libopencv_rgbd320d.libopencv_saliency320d.libopencv_shape320d.libopencv_stereo320d.libopencv_stitching320d.libopencv_structured_light320d.libopencv_superres320d.libopencv_surface_matching320d.libopencv_text320d.libopencv_tracking320d.libopencv_video320d.libopencv_videoio320d.libopencv_videostab320d.libopencv_xfeatures2d320d.libopencv_ximgproc320d.libopencv_xobjdetect320d.libopencv_xphoto320d.lib共41个。配置篇 因为 Shaun 只编译了 x86 版动态 debug 库，所以以下环境配置都只针对 x86 版动态 debug 库。（其实要配置 x64 的库就只需将 x86 换成 x64 即可；要配置 release 模式的库就只需在添加附加依赖项中的库文件选择 release 模式的库（即数字后没有 d的 lib）；若要配置静态库就需要选择静态库文件夹以及在附加依赖项中添加相应的静态库文件。:-P） 首先把 /opencv-3.2.0_build/build/install 中的文件都提取出来，这和 OpenCV 官方 release 的 opencv 文件结构差不多，具体两层结构如下.├── bin│ └── opencv_waldboost_detectord.exe├── etc│ ├── haarcascades│ └── lbpcascades├── include│ ├── opencv│ └── opencv2├── LICENSE├── OpenCVConfig.cmake├── OpenCVConfig-version.cmake└── x86​ └── vc129 directories, 4 filesx86 文件夹就是 VS2013 生成的对应 VS 版本 32位 的各种库，include 文件夹就是 opencv 的各项模块。Shaun 将其中提取出的文件全部放入了 C:\Program Files\OpenCV\3.2.0\build 文件夹中。 首先配置环境变量，系统（或用户）环境变量如下：变量名变量值PathC:\Program Files\OpenCV\3.2.0\build\x86\vc12\binOPENCVC:\Program Files\OpenCV\3.2.0\build不然可能会报错：程序“XXXXXX”已退出，返回值为 -1073741701 (0xc000007b)。其中下面那行可以选择不要添加。 然后在 VS 中配置环境。新建工程，然后在“属性管理器”中对应项目下 Debug | Win32 文件夹右键“添加新项目属性表”。（方便一次配置，多次使用，以后再使用只要在相应项目下右键“添加现有属性表”即可），Shaun 新项目属性表取名为：opencv-3.2.0_msvc2013_x86d.props。接下来就是真正的 VS 环境配置了： 双击打开刚才新建的属性表，选中“VC++目录”，注意在进行以下配置时建议都勾选左下角的“从父级或项目默认设置继承”“可执行文件目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\bin“包含目录”中添加：C:\Program Files\OpenCV\3.2.0\build\includeC:\Program Files\OpenCV\3.2.0\build\include\opencvC:\Program Files\OpenCV\3.2.0\build\include\opencv2“库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib选中“链接器” –&gt; “常规”，“附加库目录”中添加：C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib“链接器” –&gt; “输入”，“附加依赖项”中添加 C:\Program Files\OpenCV\3.2.0\build\x86\vc12\lib 中数字后带 d 的库文件，即编译篇中 Shaun 最后生成的 41 个库文件。 配置完之后不要忘了右键该属性表进行保存处理，以便下个项目直接使用，不需要再重复进行配置。最后附示例程序：1234567891011#include &lt;opencv2/opencv.hpp&gt; int main(int argc, char *argv[])&#123; cv::Mat lena = cv::imread("lena.jpg"); //载入图像到Mat，jpg文件和该cpp在同一文件夹 cv::namedWindow("lena"); //创建一个名为 "lean"的窗口 cv::imshow("lena", lena); //显示名为 "lena"的窗口 cv::waitKey(5000); // 只对窗口机制起作用（显示5000ms，随后返回-1，即窗口关闭），若在此期间有按键按下，则马上返回按键的ASCII码。 //system("pause"); return 0;&#125;这里必须在 imshow 后加入 waitkey，因为 WaitKey 不止是 Wait Key 而已，它其实还涉及到消息响应，有这个函数 cv 内部的 WndProc 函数才能起作用，才会更新窗口。 最后程序运行成功并显示 lena 图，则说明编译和配置没问题。问题篇1、用 VS2013 编译 OpenCV 在漫长的等待阶段出现的问题。 问题描述：CVV 模块报错，TS 模块编译不出来，好在这两个模块都不是很重要，可以忽略，Shaun 强迫症也没到这种程度 O(∩_∩)O~。 解决办法： 在 CVV 模块报错后可在 CMake（不知道具体是 INSTALL 下的 CMake Rules 中的 INSTALL_force.rule，还是 ALL_BUILD 下的 CMakeLists.txt，忘记了 o(╯□╰)o）中添加 -DBUILD_opencv_cvv=OFF 忽略 CVV 模块，从而正常编译其它模块。参考 errors on build opencv with cvv module and qt5 #577。如果实在不行的话就在 CMake 生成的时候取消勾选出错模块，若是用 CMake 重新生成的话不要忘了先把 /opencv-3.2.0_build/build 目录下的文件全部删除干净。后记 这是以前写的两篇文档，现在再来整理成一篇。附录 既然能看到这里，说明是想在 VS 下使用 OpenCV，这里推荐一款 VS 下 OpenCV 开发调试神器：Image Watch，效果谁用谁知道。Image Watch 是 VS 的一个插件，不过它只支持 VS2012 及以上版本。使用方法为先设置断点（ F9 ），随后在调试（ F5 ）模式下，鼠标指针悬停在 cv::Mat 类型变量上，即可出现 ，点击查看图标即可显示相应图像。参考资料[1] cmake-gui和vs2013编译opencv和opencv_contrib源码（http://livezingy.com/category/opencv/）[2] VS2013_CMake_opencv3.1动态库与静态库的配置与编译（http://livezingy.com/category/opencv/）[3] 使用VS2015编译以及静态编译opencv3记录[4] errors on build opencv with cvv module and qt5 #577[5] VS2013中Image Watch插件的使用(OpenCV)（http://blog.csdn.net/fengbingchun/article/category/721609）]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyThoughts]]></title>
    <url>posts/17017530.html</url>
    <content type="text"><![CDATA[前言 本篇主要用来记录 Shaun 的心路历程。Thoughts日期Thought2020-04-09有 1984 那味了，甚至更可怖，设定有趣，但剧情漏洞百出，不过说不好这样的事情马上就会发生，可以简单设想一下，在微信聊天记录可作为证据的今天，若腾讯被黑或主动或被动作恶，直接伪造聊天信息，将会如何？视频以高超手段做假，又将何如？——观《真相捕捉》2020-03-27人类之前是否有智慧生物？意识的本质是啥？知识积累就如同滚雪球一般，短短几百年人类社会就颠覆了好几次，未来如何？无人知晓。唯一能确定的是，总有一天，人将非人。——读《人类简史》2020-02-16对比如今，吃人血馒头的有之，欺下瞒下的有之，病人到处乱走的有之，封锁有之，集中调配有之，社会资源紧张有之，社会动荡暂时没有，摇号有之，搞特权的同样的有之，电影里还差病人隐瞒自身情况的事迹了，瘟疫公司估计会新加一个病人表现的指标了（doge）——观《传染病》2019-06-25权力不想用，义务也不想承担，又只想拿好处，或许这就是大部分国人的现状了。2019-05-30切尔诺贝利最大的灾难是普通人一点知情权都没有，中层又极力隐瞒。——观《HBO 切尔诺贝利》2019-03-10学校是为了老师而不是学生存在的。——《李狗嗨》SP1学生终究只是学校的过客而已，不过还是感觉教育的这种存在形式很有问题，不过目前好像也没有更好的解决方案，毕竟有人的地方就需要管理，有管理的地方就有利益和权力，而有利益和权力的地方必然存在纷争。2019-01-08不要抢话，适当保持沉默。2018-06-09从维度的角度来解析信号，不愧是卡尔·萨根，或许有一天阻碍人类科技发展的事物就是维度吧。 ——观《超时空接触》2018-06-031. 白色巨塔，尸骨成堆，在通往理想之路上，医者的信念并无对错；2. 想改变什么，必先提升自己，但在提升自己之后，又很可能忘记自己的初心；3. 能屈能伸终究还是对人来说的，阶级层次之间终究有别；4. 呀吧哩钱和权才是永恒的话题，但只有生命才是最真实的。 ——观《白色巨塔》2018-05-18「暴漫」死亡的原因应该是用户基数太大，而且又不合作。嗯，大概是这样吧 ╮(╯▽╰)╭ ，至于真相是。。。。。。2018-03-14曾看到一句类似这样的话：“死刑最可怕的不是它本身，而是其漫长的等待过程”。——观《大卫·戈尔的一生》2018-03-06吃饭抢单，一如既往的高质量反转。——观《九号秘事》S03E032018-02-06每件事都有其价值，做的事不同，得到的也不同，有些人辛劳一生，却穷困潦倒，有些人游手好闲，照样荣华富贵。这取决于你的爹和你做的事。2018-01-30重复的事情总有一天都会被机器取代。2018-01-10真正的真相只掌握在少数人手里。2018-01-06老师终究只是一种职业，而学校服务的对象以老师为主，学生明明是被约束自由的一方，却还要给学校支付相应的费用，这感觉有点不正常啊。仔细想想又挺正常的，毕竟学校本身没逼你去，是你自己去的，既然要去一个本身不属于你的地方，当然要先缴各种服务费，即使物非所值。那为啥要去呢？2017-12-24当隐私荡然无存，你又会如何 🤔。——观《 菲利普·K·迪克的电子梦》S01E012017-12-21世界很渺小，差的只是一个引路人。2017-12-20无知是福，不谈国是 :）。2017-12-07社会工程学，有意思的领域。——观《我是谁：没有绝对安全的系统》2017-11-29知道的越多，不知道的也越多。2017-11-15我所理解的编程就是用尽可能简单的方法得到想要的变量值。2017-10-24读研究生两个月，最大的改变就是对人对事都比以前有更大的耐心了 :）。2017-10-21无论什么事，当ta成为一种任务的时候，都是一种负担。2017-10-20键盘侠就该看看《黑镜》S03E06，真看热闹不嫌事大啊 😒。2017-10-19人类基因组计划，真不知道是好是坏，希望是好的吧 😶。——观《黑镜》S03E052017-10-15镇定，面不改色；节奏很快，就一个晚上的事，音乐和光影也很赞 👍。——观《暗花》2017-10-07国家意志啊，让人不由得想起那年春夏之交（5月35日）的一场风波╮(╯▽╰)╭。——观《出租车司机》2017-10-04什么时候能控制情绪了，什么时候就成熟了。——观《头脑特工队》2017-10-03所谓的朋友（ta）只是在正确的时间正确的地点遇到的正确的人。2017-09-291. 有些事不知道比知道要好，但真相总还是知道要好。2. 不同层次的人心态不同，难以相互理解。2017-09-28各大（网络）小说家的风格真的很难改变啊！ 😪2017-09-231. 你想成为什么样的人，必须自己决定。——《虫师》2. 情感是最不可控的。——观《宝莱坞机器人之恋》3. 人或许只有善恶，没有好坏。2017-08-29科研之上，如何能成为一个挖坑人（开创性的结果）？ 😕2017-08-11学生最重要的两种能力是学习能力和解决问题的能力。2017-08-10爱情是需要理由的。2017-08-05无能是万恶之源。2017-07-20有些话，自己心里明白就行，绝对不能说出来，否则可能存在某种未知的危险。2017-07-18很多东西是不能向别人推荐的，比如音乐，电影，小说等自己喜欢的东西。2017-07-14有些事是交给别人判断的，自己心里知道就行；有些事是交给自己判断的，自己心里知道就行。2017-07-11走进一个学科之前，最先应该知道的是该学科的研究对象、研究方法，以及当前研究中的热点难点问题，而不应该被广告一样的花哨演示糊弄住。——《上海交通大学学生生存手册》2017-04-09真正的独立，应该是离开任何人你都能活的好好的；真正的自由，应该是任何人都不能让你做违背你意志的事。2017-02-08小提琴，悠扬，忧伤。2017-01-27唉！渐行渐远╮(╯▽╰)╭。2017-01-18不能飞的猪，就只是猪而已。——《红猪》2016-12-30梦想还是要有的，万一实现了呢，试一下又不吃亏。——观《百日梦想家》2016-12-26过去的如果就这么过去了，那以后只会越来越糟。——《驴得水》2016-12-25只有人才是最重要的。2016-12-10与人相处之道，不外乎尊重和坚强。2016-11-06烈日灼心，片如其名。——观《烈日灼心》2016-11-04后来我发现，教授们貌似不喜欢有自己想法的学生，他们更希望找到愿意“打下手”的学生，帮助实现他们自己的想法。——《王垠：我和权威的故事》2016-10-31为何总要责怪自己？为何要为没必要的人改变自己？不需要做老好人，做好自己，随便别人。——观《被嫌弃的松子的一生》2016-10-303~7的小孩的自主谎言最可怕，撒谎乃人之天性，远离无脑之人。——观《狩猎》2016-10-27世界上有三种人，一种是人渣，一种愚漠的人，还有一种是所谓的好人。第二种人最多，参考正态分布。——观《熔炉》2016-10-22面对长者（诸如领导，老师等），要多听他们说，自己尽量少说，绝对不要找理由，要多说嗯，是的，对的，没错，明白，可以等肯定语句，绝对不要说由于，因为等原因语句。更重要的是尽量少说自己不知道，忘记了，了解一点等否定语句，不要把自己差的一面表现出来；要说自己会，行，知道等肯定语句，一定要把自己好的一面表现120%出来。（※附：以 Shaun 2017-12-21的眼光来看这段话还是不妥）2016-10-02平静中的悲和喜，最悲痛。——观《那年夏天，宁静的海》2016-09-22韩国好的电影对人性的把握比较到位，但有时为了突出人性好的一面，而做的有点婊了，为了剧情而剧情。——观《摩天楼》《流感》《铁线虫入侵》《釜山行》2016-09-13这世上有很多事，不试一下永远不会知道结果。2016-09-05公式本就存在，就等有天赋的人去感知并发现它。——观《知无涯者》2016-09-03管理者需要心平气和，更要沉得住气，有耐心。2016-08-12自紧力，自紧扳手，和初中做的物理实验：把两本书夹在一起后，无论怎么用力向两边拉都拉不开，估计有点类似吧。（※附：以 Shaun 2017-12-21的眼光来看这个事感觉有点玄学）2016-08-10为什么人们总认为小孩（弱者）说的是对的？有没有想过，有时候小孩并不小，弱者并不弱。2016-08-09《人工智能》，好可怖的一个世界。——观《人工智能》2016-08-06一起做一件事能很好的增进感情。（※附：以 Shaun 2017-12-21的眼光来看也有可能增加矛盾╮(╯▽╰)╭）2016-08-04尽量不要去接手别人已经做了一部分的事物。（※附：以 Shaun 2017-12-21的眼光来看如果别人做的很好理解的话接手也可以）2016-08-021. 有时候很难理解他人，只是因为没有和他人类似的经历而已。2. 让人的本性被改变咋就这么难？读大学是掉噶果？（※附：以 Shaun 2017-12-21的眼光来看ta确实老了，也变了，或许时间能改变一切吧）2016-07-29《计算机：一部历史》，很有意思的一本计算机史。2016-07-26人们总是习惯于用固有的标准看待新事物。2016-07-24《妖尾》的世界观简直不敢苟同，世界上真有那种人，杀了或要杀自己朋友的人还能做伙伴？每遇到boss第一次总被秒杀，第二次才能完胜？这尼玛是什么逻辑。2016-07-171. 不要嘲笑别人的梦想，也不要轻易说出自己的梦想。2. 看完《活着》，心情有点沉重，难道生命的意义就在于为活着而活着？或者还是太年轻了。2016-07-161. 是待人以诚，人待以诚，还是人待以诚，待人以诚？不好说。2. 游戏能代表计算机应用技术的最高水平。2016-07-13情景不同，分类不同。2016-07-12下属（泛指），多看，多听，多想，多做，少说话。2016-07-101. 世上最痛苦的事莫过于对着自己不想看到的人谄媚。2. 不同的时刻，不同的场景，不同的心情，喜好不一样。2016-06-29口吃可能不是遗传的，也可能是婴儿学习过程中的一种畸形。2016-06-231. 何不让自己的人生多些经历。2. 世上大多数的猜忌、争论，都是由于每个人总是认为自己是对的。2016-06-161. 多媒体识别的关键在于提取图像、视频和音频的“特征”（即向量）。2. 我们周围的人是否在演戏？我们是否在戏中？人生入戏，戏如人生。——观《楚门的世界》2016-06-131. 不管变成什么样，问心无愧就好。2. 人越成熟就藏得越深。3. 完全不需要和别人比，只需和昨天的自己比。2016-06-091. 在公共环境（贴吧，评论区等）下发言，首先要做好被喷的准备，网络上从来不缺少键盘侠。2. 眼中世界不同的人，终究会分开。2016-05-27有些东西是让人看到会产生反感的，而有些东西明明被人讨厌，却因为它没有那么张扬的外面，所以很容易被人忽视的。——七月寒风《幻灵》2016-05-201. 不要随便对别人说出你的想法和理解，因为可能在别人看来，你的想法和理解完全就是个笑话和讽点。最后，最重要的是看清他人是不是和你是一个世界的，世界不同，观念，观点很难相同。2. 绝大部分老师只看结课论文的排版如何。2016-05-18儒家治国，道家处事。（※附：以 Shaun 2017-12-22的眼光来看有点不敢苟同）2016-05-16人们或多或少都有一种同情弱者的心态，所以有时候适当的处于弱势并不是一件坏事。2016-05-09大学里的成绩更多的是取决于你了不了解老师，你知不知道老师真正想要你写什么，讲什么。2016-05-02看完《浪潮之巅》才明白“软件即服务”，软件提供的实际上是某种功能，某种作用，而这种功能是软件所在平台没有的，但是却是人们使用时不可或缺的，那么企业提供这个软件，就是在提供一种服务。就像饭店里的服务员一样，上菜时饭店提供的一种服务，但不是饭店本身就有的，饭店真正提供的只是一个场所和食物。使用的人数决定市场，不管是付费还是免费，只要能抓住更多的用户，就是胜者。2016-04-29世界上有两种程序员，一种是写技术的，另一种是用技术的。（※附：以 Shaun 2017-12-22的眼光来看写者和用者并没有很明确的界线，更像是一种心态吧）2016-04-24真没想到，最近看到“人生若只如初见”才知道是什么意思，高中老师曾出了个作文题就叫这个，当时傻傻的不知道什么意思，呵呵，当年的阅历实在太浅。2016-04-07你强ta越怕，你弱ta越欺。2016-04-02黑色幽默，挺有意思的！比较推荐的有：《黑镜》、《蛮荒故事》。2016-03-311. 两个公司在技术上的竞争，除了人的竞争，就是执行力的竞争。——吴军《浪潮之巅》雅虎、惠普精兵简政2. 托尔斯泰讲，幸福的家庭都是相似的，不幸的家庭都是各有各的不幸。在信息工业中，这句话要反过来讲，成功的公司各有各的绝招，失败的公司到是有不少的共同之处。——吴军《浪潮之巅》思科 留住早期员工2016-03-24有时候，我们想要的东西就在我们面前，我们却因年代久远可能不认得，反而可能亲手毁了ta。——观《SINTEL》2016-03-21每次去以前贾里尼克都要确认我们报告的每一页内容都是已经公开发表过的。原因很简单，IBM有世界最好的科学家和工程师，他们可以用比你还快的速度将你还没发表的想法实现、申请专利并发表。盖茨意识到只要垄断了操作系统，就间接垄断了整个行业。——吴军《浪潮之巅》Microsoft在商业领域，保密性是十分重要的，尤其是一个新颖的想法。在积累了一定的用户量之后，商业化也是很简单的。商业的前提是用户。2016-03-20整个信息技术（Information Technologies，简称IT）产业包括很多领域、很多环节，这些环节之间都是互相关联的。和世界上任何事物同样，IT产业也是不断变化和发展并且有着它自身发展规律的。——吴军《浪潮之巅》IT Law万物发展自有其规律，但这个规律只是一种趋势，趋势总有其临界点，到临界点时将呈现另一种趋势，比如Moore’s Law，功耗就是其临界点。2016-03-20英特尔公司做事情非常专注，直到今天，它一直集中精力于个人微机的处理器，每一代产品的研发都是集中大量的人力和资金，每一次都是只能成功不能失败。——吴军《浪潮之巅》Intel专一，虽然能保证做好，但面太窄，一旦市场发生变化，讲很难应对。2016-03-19时不时调整内部结构，将一些非核心的、长期效益不好的部门卖掉，同时扩大核心的利润高的生意。——吴军《浪潮之巅》IBM认清自己的定位，抓牢自己的核心业务，同时开拓创新。2016-03-19当一个公司没有人对它有完全控制时，它的长期发展就会有问题。——吴军《浪潮之巅》AT&amp;T合则生，分则死。2016-03-19社会在发展，人也在发展，社会的发展体现在人周围事物的变化，而人的发展体现在人自身的变化，这种变化是好是坏，每个人的观点可能不同，没人能预料变化将带来什么，我们唯一所能判断的就是变化给我们现在带来了什么，以此判断以前的变化是好是坏，此时的变化将由未来的人判断。2016-03-19大学生和高中生的本质区别在于大学生更会思考，更加注重自学能力，遇到问题是主动去寻找解决方案，而不是像高中生那样被动的等老师来讲解。2016-03-11时间使人安稳，失去时间将使人迷失，疯狂。2016-02-17别人肯不肯帮忙主要取决于你自身的实力基础。2016-02-03生而不养，养而不教，不如不生。2016-01-26为人子女，与父母相处的机会，其实都是见一次少一次的。——罗森《万界天王》2016-01-24四十多岁的父母是最能包容你的人。（※附：以 Shaun 2017-12-22的眼光来看这里有点欠妥）2016-01-23以己度人，更多的是指包容别人的缺点，而不是抱怨别人没有的缺点。2016-01-16人之为人，在于自制。2016-01-08读高中时，我接触到靠自己；读大学时，我逐渐学会靠自己；步入社会时，我将真正靠自己。（※附：以 Shaun 2017-12-22的眼光来看是不可能真正靠自己的，总要与外界交互）2015-12-30读大学，选择不同的专业，就是选择不同的圈子，而圈子决定话题。2015-12-281. 很多时候，我们买一件东西只是因为心血来潮，而不是真正需要它。2. 贯彻落实“尽量学习”理念。尽量学习有两个方面：尽量多学和尽量精学。2015-12-07人生充满太多的偶然性。2015-11-09所谓杀心，就是去除仇恨。恨一个人也常常意味着怕这个人，只有克服了“怕”之后，“恨”才能转化为杀心，化为力量。—— 冰临神下《死人经》2015-11-08每天都学一点小知识2015-11-05有没有想过，人类也是一种寄生虫，寄生在地球，依靠于太阳，而太阳和地球也只是宇宙里的一粒微尘。——观《宇宙的奇迹》2015-09-15虽然这不是你理想中的大学，但你可以选择过理想的大学生活。2015-09-05没有对生明的敬畏，就永远无法体会到生命的可怕。2015-09-01因为在乎，所以在意。2015-05-16我虽然现在不知道，但我可以学。（※附：以 Shaun 2017-12-22的眼光来看这句话在大部分情况下行不通）2015-05-15唉！这次回去，已是物是人非，院子不再是院子。2015-05-15自杀乃傻之至极。2015-05-151. 不抱怨，不找理由。（面对教、训之终极奥义）2. 一本书，读过之后如果没有思考，相当于没读。3. 前人的言行是我们的指路明灯。2015-05-15鹿角杀死了冰原狼预示着拜拉席恩将导致史塔克的死亡。不会玩的游戏不要硬去玩，否则终将害人害己。当大雪降下，冷风吹起，独行狼死，群聚狼生。夏天时可以争吵，但一到冬天，我们必须保卫彼此，相互温暖，共享力量。——《冰与火之歌：权利的游戏》2015-05-151. 海贼王的海军每个人都有自己坚守的正义。2. 尊重不是别人施舍的，而是自己争取的。3. 环境决定年龄。4. 和平利于知识传播交流，战争利于知识创新突破。2015-05-151. 不要等到老师教，尽量去学自己想学的，要学的。2. 介绍和学习是两码事，介绍可以用PPT，而学习用板书更好。3. 电给人方便，也使人孤独，人与人的联系似存而亡。2015-04-15是为自己而活？还是为他人而活？2015-04-03有时候，人对自己的东西会突然莫名其妙的产生一种厌烦感，从而不想要，从而做错事，但其实这种厌烦感只是暂时的，过一段时间又会恢复成以前那样。2015-03-10人当想人之不能。2014-10-041. 人之成长，取决于见。2. 世风日下，好人难做。3. 在社会这个大染缸里，我只想做我自己。4. 有些雷区是不能碰的，碰，就会惹火上身。5. 每个人的注重点不一样，带出来的人也不一样。2014-09-20How did we escape from the prison? It was the work of generations of searchers who took five simple rules to heart . Question authority. No idea is true just because someone says so. Think for yourself . Question yourself. Don’t believe anything just because you want to. Believing something doesn’t make it so. Test ideas by the evidence gained from observation and experiment. If a favorite idea fails a well-desidned test, it’s wrong! Get over it. Follow the evidence, wherever it leads. If you have no evidence , reserve judgment. And perhaps the most important rule of all…… Rember, you could be wrong. Even the best scientists have been wrong about somethings. Newton, Einstein, and every other great scientist in history, they all made mistakes. of course they did – they were human, Science is a way to keep from fooling ourselves and each other. Have scientists known sin? of course. We have misused science, just as we have every other tool at our disposal, and that’s why we can’t afford to leave it in the hands of a powerful few. The more science belongs to all of us, the less likely it is to be misused. These values undermine the appeals of fanaticism and ignorance. ——《Cosmos: A Spacetime Odyssey》我们如何逃出囚笼？是因为世世代代探索者的不懈努力，并且他们发自内心地遵从这5条简单规则。质疑权威。不轻信人言。独立思考。自我质疑。不因自己想要相信，而相信任何事。相信不代表能成为现实。以依靠观察和实验得来的证据来检验想法。如果自己喜欢的想法没有通过全面的检验，它就是错的！ 乐观一点。遵循证据，无论它指向哪里。如果没有证据，不妄下结论。也许最重要的规则就是，要记住，你也会犯错。牛顿、爱因斯坦，还有历史上每一位伟大的科学家，他们都犯过错，这很正常，是人都会犯错。科学让我们不再欺骗别人和自己。科学家们有罪吗？有的。我们曾滥用科学就像手边的工具一样随意使用，因此我们不能把科学放在少数的掌权者手中。当科学更多的属于全人类时，它就越不会被乱用。科学的价值在于能阻止狂热和无知。 ——纪录片《宇宙时空之旅》2014-09-20Telling someone your goal makes it less likely to happen.告诉别人你的目标反而使目标不能实现。 ——网易公开课《不要公开宣布个人目标》2014-09-14每一个客户都是一群客户。2014-08-22快做眼前事，未来不可知。2014-08-13既然扎根于此，何不刻苦努力！2014-07-31这个世界很大，你总能找到你的伙伴。既然出生到这个世上，你绝不会总是孤身一人的。 ——《One Piece》2014-07-26There’s a time when a man needs to fight and a time when he needs to accept that his destiny’s lost. 人有必须奋战的时刻，也有必须接受现实的时刻。 ——《Big Fish》2014-07-23每个人的一生都是一部独有的长篇小说。2014-07-11就算你讨厌ta，也不要在背后议论ta的是非，毕竟议论是非之事必是是非之人。2014-06-29世事无常，计划赶不上变化，无须太过伤感。2014-06-27大 极，小 极，差，和，无大无小。2014-06-25荣耀只属于特定的时空。2014-06-161. 一个秘密有两个人知道，也便不是秘密。2. 没有做好准备就准备失败。3. 初学计算机语言，多敲代码。4. 不要太在乎别人对你的看法（不管是好是坏），不然你会活的很累。2014-06-11分数是老师给的，东西才是自己学的。2014-06-06参数——来自另一维度的手（上帝之手）（二维中的蚂蚁、三维中的蚂蚁、轻易逃脱囚笼）2014-05-301. 有些话（事）能说（做），有些话（事）不能说（做）。（要会判断）2. 不要在心情极端时做出让自己后悔的事。3. 相比于自律自觉能力，考上一个好大学显得并不是那么重要。4. 在这个人人都装逼的社会，对不对需要自己判断！2014-05-26“取法乎下，得乎下下；取法乎中，得乎其下；取法乎上，得乎其中；取法上上，得乎其上。” —— 《读大学怎么读》2014-05-211. 其实学校是第一个教会我们说谎的地方。2. 成绩只是老师给的，更重要地是在于你自己有没有学到东西，大学注重的不应是分数，而应是你真正学到的东西！2014-05-12每个人都是自己生活的主角。2014-04-211. 闲事为何事，何事为闲事！2. 距离！ 适度！3. 人生总有种种不如意之事，但也会有种种如意之事！4. 一般而言，抄不如乱写，乱写不如不写！2014-04-211. 世上的事很多，只是看你去不去做，所以何来无聊之说！2. 上大学易，读大学难，且读且珍惜！2014-04-19浑浑噩噩的一天，糊糊涂涂的人。2014-04-011. 不去争的话就什么都不会有！2. 因为在意，所以紧张！3. 人生就是一个奋斗的过程，人生也因奋斗而精彩！2014-04-011. 永远都不要以为你的时间很多！2. 深沉一点！3. 真搞不懂为什么这么多人喜欢听假话，假话比真话真的管用吗？也难怪现在有这么多假冒伪劣产品，连个话都是假的好。（※附：以 Shaun 2017-12-23的眼光来看在多数情况下假话确实比真话管用，说话也是一门学问啊）2014-04-011. 有些路还是自己走得好！2. 天下哪里有白吃的午餐，只有白痴的人。3. 做人可以懒，但不能傻！以上均为 Shaun 当时感想，也算是记录一下 Shaun 的心智成长过程吧，有不同意见请保持理智 (๑•̀ㅁ•́ฅ)。后记 哪来的后记，Shaun 的这一生还没过完呢 (╯°□°）╯︵ ┻━┻，（#-_-)┯━┯ 。]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>thought</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决写上篇文档“Hexo+GitHub搭建个人博客”遇到的问题]]></title>
    <url>posts/7d5bc07b.html</url>
    <content type="text"><![CDATA[超链接网址问题 问题描述：使用正常的 markdown 超链接格式[]()没问题，然而当直接将一个网址链接放入该文档时，它会将该链接后面的文字也当成是该链接的一部分，直接点击链接时，会将后面的文字也放入浏览器地址栏，从而出现网页 404 错误：404: Page could not be found。 解决办法：在网址链接后输入一个空格以隔开网址链接和后面的文字或用&lt;url&gt;将网址括起来。超链接样式问题 问题描述：Shaun 使用的 hexo 主题是基于 spfk 主题稍微修改过的，spfk 主题能自动修改超链接原有的样式，挺好看的 :D，但是当 Shaun 在 markdown 中数字编号列表，即有序列表中添加超链接时，其样式并没有修改，还是普通的超链接样式。 解决办法：没有解决。最后只是跳过了这个问题，就用中文的序号表示列表。文本段落问题 问题描述：为了使文本有段落感，一般都会在段落首字前空两格，但是在 markdown 中空两格，用 hexo 发布后并没有空两格，这使得文档没有段落感，阅读体验有点差。 解决办法：将中文输入法由半角切换至全角，在段落首字前输入两个空格即可。显示英文尖括号问题 问题描述：由于上篇文档需要在文档中显示&lt;youname&gt;，但由于 Hexo 可能将其当做一个 xml 标签处理了，所以发布之后的文档没有显示该文字。 解决办法：首先 Shaun 尝试了转义字符\，谁曾想它只出现了一个转义字符，该文字还是没显示，Shaun 差点又要跳过这个问题，将其用另一种表示法了。后来 Shaun 想到这最后不是会转为 html 吗，Shaun 就直接用 html 中尖括号的表示法不就行啦 :p，于是参考HTML语言中括号(尖括号)的字符编码，用&amp;lt;代替&lt;，用&amp;gt;代替&gt;，最后该文字终于出来了。给文字添加颜色问题 问题描述：Shaun 想给注意事项上的需要注意的问题添加醒目的颜色，但 markdown 本身不支持给文字添加颜色。 解决办法：由于 Hexo 最后会将 markdown 文档转换为 html 文档发布，所以直接将 html 标签写进 markdown 文档，最后自然会出现 html 样式，Shaun 这里参考CSDN-markdown编辑器语法——字体、字号与颜色，给想要变色的文字添加&lt;font color=#FA8072&gt;&lt;/font&gt;标签。参考资料[1] HTML语言中括号(尖括号)的字符编码（http://liuxufei.com/weblog/jishu）[2] CSDN-markdown编辑器语法——字体、字号与颜色（http://blog.csdn.net/testcs_dn）]]></content>
      <categories>
        <category>Problems</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客]]></title>
    <url>posts/d7965b48.html</url>
    <content type="text"><![CDATA[Shaun 的系统环境：Win10_x64。前言 本来是想在国内某网站上继续写的，毕竟完全不需要自己管理，只需要负责写好文档就可以了，但某一天，该网站由于响应国家的号召，要实名验证，本来实名验证也没什么，就输入手机号，并填写验证码即可，但该网站实名验证的方式给人的感觉特别不爽，于是就决定自己搭建博客，这样虽然有点麻烦，但由于完全是自己管理，自己完全拥有该文档的所有权，也不用担心哪天别的网站突然出现的各种破问题，相比这种完全自由支配、无比爽快的感觉，管理这种麻烦就是小事了。GitHub + Hexo 个人博客搭建准备篇在 GitHub 上搭建博客的要求： 1、要有 GitHub 账号。（没有怎么办，没有就去注册啊）使用 Hexo 框架的要求： 1、需要安装 node.js。（电脑上没有安装怎么办，没有安装就去下载（https://nodejs.org/en/download/）安装啊） 2、需要安装 git。（没有安装就去下载安装，附 git学习教程）GitHub 篇 满足上文的要求之后，就可以开始搭建了，首先在 GitHub 中新建一个仓库（ New repository ），在 Repository name 下填写 &lt;yourname&gt;.github.io ，其它可默认，点击 Create repository。 新建仓库完成后，点击 Create new file 新建一个 README.md 文件，随便写点什么，比如 “It's my blog website”。 点击上方横条选项中的 Settings ，查看 GitHub Pages 里的设置，上方应该有绿色框，框中“Your site is published at https://&lt;yourname&gt;.github.io”，该网址即为博客主页，Source 应该是 master branch，自此 GitHub 上的设置可以算是完成了，但为了方便和防止误删，一般把 Hexo 文件也放入 GitHub 中，为方便管理，可以新建另一分支专门放 Hexo 文件。 在仓库 code 界面中点击 Branch：master，在出现的框中输入 hexo 新建 hexo 分支，在 branches 中 Change default branch 设置 hexo 为默认分支。Hexo 篇 将刚才新建的仓库克隆到本地：git clone https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git当前在 hexo 分支。在 &lt;yourname&gt;.github.io 文件夹下执行12345npm install hexo-cli -ghexo init blogcd blognpm installnpm install hexo-deployer-git --save 按这样一连串执行，如果没出问题的话就会在 &lt;yourname&gt;.github.io 文件夹里生成一个 blog 文件夹，该文件夹有一大堆 Hexo 有关的文件。配置 Hexo Hexo 的配置文件为 blog 文件夹中的 _config.yml 文件。 修改配置文件不要使用 windows 自带的记事本，Shaun 使用的 VS Code，或者 Notepad++ 和 Sublime Text 2 等编辑器都可以，以防文件编码改变，具体修改如下：123456789101112131415# Sitetitle: &lt;你的blog名&gt;author: &lt;作者名称&gt;language: zh-CN&lt;网站所用语言，中国大陆选择zh-CN即可&gt;# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://&lt;yourname&gt;.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/&lt;yourname&gt;/&lt;yourname&gt;.github.io.git branch: master其它的默认即可，具体参数信息详见 Hexo官方文档。配置 git 用户信息12git config --global user.name "&lt;yourname&gt;"git config --global user.email "&lt;yourname&gt;@xxxxxx.com" 如果是个人电脑的话推荐加上 –global 全局参数，因为这样更加方便，如果不加的话，还要在 \&lt;yourname&gt;.github.io\.deploy_git\.git 中 config 里加入 git 用户信息，不然可能提交会出问题，稍显麻烦。部署 Hexo在 blog 文件夹下执行：123hexo g #generate 生成静态文件hexo d #deploy 部署网站.部署网站前,需要预先生成静态文件hexo s #server 启动服务器或者执行：1hexo g -d快速部署个人 blog。 在浏览器中输入http://localhost:4000/，将会出现 Hexo 的 Hello World 界面，更多 Hexo 命令详见 Hexo官方文档。最后将 Hexo 文件提交到 GitHub 远程仓库，具体提交命令为：123git add .git commitgit push origin hexo 在浏览器中输入https://&lt;yourname&gt;.github.io同样会出现 Hexo 的 Hello World 界面，自此整个个人 blog 的框架已经完全搭好了。其它篇主题选择 主题可以去官网上的主题界面去找，目前比较受欢迎主题有 next 和 yilia，去别人 GitHub 上的主题仓库上去下载或 clone 均可，Shaun 目前用的主题为black-blue，这个主题 Shaun 在用的时候还有些问题，或许会换，或许会自己魔改。最后由于术业有专攻，实在不知道该改哪里，所以决定换 black-blue 的原版主题 SPFK ，对照着 black-blue 对 spfk 进行修改。具体换主题的方法为： 先将下载好的主题整个放在 \blog\themes 文件夹中，再修改 blog 文件夹中的配置文件 _config.yml：12# theme: landscapetheme: black-blue black-blue 为打包主题文件并放入 \blog\themes 文件夹中的文件夹名，并不是原主题名，只是 Shaun 恰好将其重命名为主题名。文章发布发布文章需要在 blog 文件夹中执行：1hexo new "test" 将会在 _posts 文件夹中生成 test.md 文件，随后编辑 test.md 文件即可，Shaun 使用的 Markdown 编辑器为 Typora。至于给文章打标签和分类什么的，请参考 Hexo官方文档。写完文章之后推送到 GitHub 中，需要执行：123git add .git commit -m "add test.md"git push origin hexoHexo 文件配置同样需要同步一下：123hexo ghexo cleanhexo d插件添加以 RSS 订阅插件为例。首先安装 hexo-generator-feed，在 blog 文件夹下执行：12## rss插件npm install hexo-generator-feed --save安装成功后，修改 blog 文件夹中的配置文件 _config.yml：1234# Extensions## Plugins: https://hexo.io/plugins/plugin:- hexo-generator-feed #RSS订阅最后，修改当前主题文件夹中的配置文件 _config.yml，添加 RSS 订阅链接即可：12subnav: rss: "/atom.xml"修改完成后，执行123hexo cleanhexo ghexo d将会在页面中看到 RSS 图标。注意事项1、提交至远程仓库时可能会出现错误。 原因可能是因为没有将 SSH Key 添加到 GitHub 中。 查看当前用户主目录下的 .ssh 文件夹中（ windows 是 C:\Users\&lt;username&gt;\.ssh）是否有id_rsa（私钥）和id_rsa.pub（公钥）这两个文件，若没有，则执行1ssh-keygen -t rsa -C "youremail@example.com" 在 GitHub 中添加 SSH Key 的具体方法为：点击 GitHub 用户头像下的 Settings，选中 SSH and GPG keys，点击 New SSH key，将id_rsa.pub中的内容复制粘贴到 Key文本框中。2、Hexo 生成和部署命令都执行失败。 原因可能是修改配置文件 _config.yml 出错。 将修改的配置文件 _config.yml 复原试试。3、Hexo 部署之后网页没变化。可能需要执行1hexo clean 清除缓存文件 ( db.json ) 和已生成的静态文件 ( public )。在某些情况（尤其是更换主题后），如果发现对站点的更改无论如何也不生效，可能需要运行该命令。后记 以后就在这上面写 blog 了，顺便把以前写的一些文档也放上来。参考资料[1] 利用github+hexo搭建自己的博客（http://blog.csdn.net/u012150360/article/category/6765461）[2] Hexo官方文档（https://hexo.io/zh-cn/）[3] GITHUB+HEXO博客轻松更换主题外观（http://www.jianshu.com/nb/10649566）[4] Hexo—正确添加RSS订阅（http://hanhailong.com/tags/Hexo%E4%B8%BB%E9%A2%98/）]]></content>
      <categories>
        <category>建站小记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>posts/4a17b156.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new post1$ hexo new "My New Post"More info: WritingRun server1$ hexo serverMore info: ServerGenerate static files1$ hexo generateMore info: GeneratingDeploy to remote sites1$ hexo deployMore info: Deployment]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
